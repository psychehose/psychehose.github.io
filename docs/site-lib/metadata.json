{"createdTime":1754545597828,"shownInTree":["algorithm/lecture/bfs.html","algorithm/lecture/dfs.html","algorithm/lecture/그리디-알고리즘.html","algorithm/leetcode/3.-longest-substring-without-repeating-characters.html","algorithm/leetcode/21.-merge-two-sorted-lists.html","algorithm/leetcode/55.-jump-game.html","algorithm/leetcode/62.-unique-paths.html","algorithm/leetcode/70.-climbing-stair.html","algorithm/leetcode/78.-subsets.html","algorithm/leetcode/141.-linked-list-cycle.html","algorithm/leetcode/143.-reorder-list.html","algorithm/leetcode/152.-maximum-product-subarray.html","algorithm/leetcode/198.-house-robber.html","algorithm/leetcode/200.-number-of-islands.html","algorithm/leetcode/206.-reverse-linked-list.html","algorithm/leetcode/217.-contains-duplicate.html","algorithm/leetcode/271.-encode-and-decode-strings.html","algorithm/leetcode/424.-longest-repeating-character-replacement.html","algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html","algorithm/study/dp.html","algorithm/study/heap-&-우선순위-큐.html","algorithm/study/two-pointer.html","algorithm/study/누적합-알고리즘.html","algorithm/study/문제유형.html","algorithm/study/이분탐색-&-파라메트릭-서치.html","algorithm/study/코딩테스트를-위한-암기.html","android/wifi-util-class.html","android/인앱-결제.html","ble/1.-ble-개요.html","ble/2.-ble-프로토콜-스택.html","ble/3.-ble-att,-gatt.html","ble/4.-ble-디바이스-연결.html","cpp/basic/0.-c,-c++-컴파일-과정.html","cpp/basic/1.-참조와-포인터.html","cpp/basic/2.-생성자.html","cpp/basic/3.-overloading.html","cpp/basic/4.-상속.html","cpp/basic/5.-다중-상속.html","cpp/basic/6.-파일-입출력.html","cpp/build-system/cmake.html","cpp/build-system/pic.html","cpp/concurrency/1.-thread.html","cpp/concurrency/2.-mutex,-deadlock.html","cpp/concurrency/3.-memory-order,-atomic.html","cpp/concurrency/4.-future,-async,-promise.html","cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html","cpp/concurrency/6.-threadpool.html","cpp/concurrency/7.-event-system.html","cpp/etc/c++-static-const-초기화.html","cpp/etc/const-위치-헷갈리는-점-정리.html","cpp/etc/rvo.html","cpp/etc/리소스-임베딩-by-compile.html","cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html","cpp/etc/유리수-클래스-구현.html","cpp/etc/전역변수와-정적변수의-공통점과-차이점.html","cpp/lib/fmt.html","cpp/lib/google-test.html","cpp/modern/1.-rvalue-rvalue-참조.html","cpp/modern/2.-move,-레퍼런스-겹침-규칙.html","cpp/modern/3.-raii,-unique-ptr.html","cpp/modern/4.-shared,-weak-ptr.html","cpp/modern/5.-callable-etc..html","cpp/modern/6.-uniform-initializer.html","cpp/modern/7.-random,-chrono-library.html","cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html","cpp/platform/sfml과-visitor-pattern.html","cpp/template/1.-명시적-템플릿-인스터스화.html","cpp/quiz.html","cs/자료구조/avl-트리.html","cs/자료구조/b+-tree.html","cs/자료구조/binary-search-tree.html","cs/자료구조/deque.html","cs/자료구조/hash-table.html","cs/자료구조/red-black-tree.html","cs/자료구조/tree.html","cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html","cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html","cs/07.-캐시-지역성.html","cs/08.-메모리-단편화.html","cs/09.-c++-메모리-구조.html","cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html","cs/12.-new,-delete와-malloc,-free의-차이점.html","cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html","cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html","cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html","cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html","cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html","cs/18.-priority_queue의-내부-구현과-사용법.html","cs/20.-map과-unordered_map-중-선택-기준.html","cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html","cs/23.-lvalue와-rvalue의-차이점.html","cs/24.-move-constructor와-move-assignment의-필요성.html","cs/25.-auto-키워드의-장단점.html","cs/26.-람다함수의-캡처-방식들과-사용법.html","cs/28.-메모리-누수를-탐지하는-방법.html","cs/29.-스레드와-프로세스의-차이점.html","cs/30.-c++에서-스레드-동기화-방법들.html","cs/31.-뮤텍스와-세마포어의-차이점.html","cs/33.-레이스-컨디션에-대해-설명해주세요.html","cs/34.-포인터와-참조의-차이점.html","cs/35.-가상-메모리는-무엇인가.html","cs/36.-static-키워드.html","cs/context-switching.html","cs/deadlock.html","cs/floating-point.html","cs/pseudo-random-(의사-난수).html","cs/리틀-앤디언과-빅-앤디언.html","cs/캐시-전략.html","csharp/linq.html","docker/1.-basic.html","docker/2.-도커-컨테이너-환경-구축.html","flutter/0.-setup.html","flutter/animation.html","flutter/appbar.html","flutter/build-context.html","flutter/gridview.html","flutter/scaffold-vs-builder.html","flutter/statefulwidget-생명주기.html","flutter/tickerproviderstatemixin.html","graphics/etc/golf-simulator-using-sfml.html","graphics/etc/sfml.html","graphics/metal/0.-metal-basic.html","graphics/metal/depth-buffer.html","graphics/metal/metal-rendering-pipeline.html","graphics/metal/shadow-map.html","graphics/metal/uniform-buffer.html","graphics/opengl/01.기본/01.-기본.html","graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html","graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html","graphics/opengl/01.기본/04.-컬러-기초이론.html","graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html","graphics/opengl/01.기본/06.-rgba-컬러-모델.html","graphics/opengl/02.응용/01.-그래픽스-파이프라인.html","graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html","graphics/opengl/02.응용/03.-gpu-내부-구조.html","graphics/opengl/02.응용/04.-glsl.html","graphics/opengl/02.응용/05.-shader-programming-코드-분석.html","graphics/opengl/02.응용/06.-재사용가능한-코드.html","graphics/opengl/02.응용/07.-glsl-자료형.html","graphics/opengl/02.응용/08.-uniform-variable.html","graphics/opengl/02.응용/09.-glsl-디버그-함수들.html","graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html","graphics/rasterizer/0.-목표에-대해서.html","graphics/rasterizer/1.-브레젠험-직선-알고리즘.html","graphics/unreal-engine/basic.html","graphics/unreal-engine/material.html","graphics/unreal-engine/rim-light와-fresnel-노드.html","graphics/이론/modeling.html","graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html","graphics/이론/vsync-(수직-동기화).html","graphics/이론/동차-좌표계와-원근-분할.html","graphics/이론/렌더링-파이프라인-이론.html","graphics/이론/변환행렬.html","graphics/이론/컴퓨터-그래픽스-기초와-수학.html","hose/develop.html","hose/내가-블로그를-시작한-이유.html","images/3colorchannel.png","images/3colorchannel.html","images/aggregate.png","images/aggregate.html","images/allpublic.png","images/allpublic.html","images/bfs_1.png","images/bfs_1.html","images/bfs_2.png","images/bfs_2.html","images/bi_linear_interpolation.png","images/bi_linear_interpolation.html","images/ble_configuration.png","images/ble_configuration.html","images/ble_host_controller.png","images/ble_host_controller.html","images/ble-attribute-table.png","images/ble-attribute-table.html","images/ble-conn-fig-1.png","images/ble-conn-fig-1.html","images/ble-conn-fig-2.png","images/ble-conn-fig-2.html","images/ble-conn-fig-3.png","images/ble-conn-fig-3.html","images/ble-connection.png","images/ble-connection.html","images/ble-connection-1.png","images/ble-connection-1.html","images/ble-data-exchange.png","images/ble-data-exchange.html","images/ble-gatt-structure.png","images/ble-gatt-structure.html","images/ble-l2cap.png","images/ble-l2cap.html","images/ble-link-layer.png","images/ble-link-layer.html","images/blendspace.png","images/blendspace.html","images/bpgi_onbeginplay.png","images/bpgi_onbeginplay.html","images/broadcastip_address.png","images/broadcastip_address.html","images/build_process.png","images/build_process.html","images/bw_grayscale.png","images/bw_grayscale.html","images/change_scheme.png","images/change_scheme.html","images/cmake_setting.png","images/cmake_setting.html","images/cmy_model.png","images/cmy_model.html","images/collectpso.png","images/collectpso.html","images/color_image.png","images/color_image.html","images/color_vs_grayscale.png","images/color_vs_grayscale.html","images/common_ui_plugin.png","images/common_ui_plugin.html","images/compared_ext_trigger.png","images/compared_ext_trigger.html","images/concurrent.png","images/concurrent.html","images/cpp_1.png","images/cpp_1.html","images/cpp_2.png","images/cpp_2.html","images/cpp_3.png","images/cpp_3.html","images/cpp_4.png","images/cpp_4.html","images/cpp_5.png","images/cpp_5.html","images/cpp_6.png","images/cpp_6.html","images/cpp_7.png","images/cpp_7.html","images/cpp_8.png","images/cpp_8.html","images/cpp_9.png","images/cpp_9.html","images/cpp_10.png","images/cpp_10.html","images/cpp_11.png","images/cpp_11.html","images/cpp_12.png","images/cpp_12.html","images/cpp_13.png","images/cpp_13.html","images/cpp_14.png","images/cpp_14.html","images/cpp_memory_struct.png","images/cpp_memory_struct.html","images/data_transfer_struct.png","images/data_transfer_struct.html","images/datahandle_row_result.png","images/datahandle_row_result.html","images/debugging_failure.png","images/debugging_failure.html","images/debugging_success.png","images/debugging_success.html","images/dfs_1.png","images/dfs_1.html","images/dfs_2.png","images/dfs_2.html","images/ebtnode_result_aborted.png","images/ebtnode_result_aborted.html","images/ebtnode_result_failed.png","images/ebtnode_result_failed.html","images/ebtnode_result_inprogress.png","images/ebtnode_result_inprogress.html","images/ebtnode_result_type.png","images/ebtnode_result_type.html","images/executable_file_structure.png","images/executable_file_structure.html","images/export_shader_code.png","images/export_shader_code.html","images/fatframework_path.png","images/fatframework_path.html","images/foldering_as_is.png","images/foldering_as_is.html","images/foldering_to_be.png","images/foldering_to_be.html","images/fragment_shader.png","images/fragment_shader.html","images/fragment_shader_execute.png","images/fragment_shader_execute.html","images/framework_path.png","images/framework_path.html","images/fresnel.png","images/fresnel.html","images/func_1.png","images/func_1.html","images/gameflowchart.png","images/gameflowchart.html","images/gl_error_flag.png","images/gl_error_flag.html","images/glew32_install_error.png","images/glew32_install_error.html","images/glsl_debugging_1.png","images/glsl_debugging_1.html","images/glsl_debugging2.png","images/glsl_debugging2.html","images/glvertexattribpointer.png","images/glvertexattribpointer.html","images/gpu_structure.png","images/gpu_structure.html","images/graphic_pipeline.png","images/graphic_pipeline.html","images/greedy_1.png","images/greedy_1.html","images/greedy_2.png","images/greedy_2.html","images/greedy_3.png","images/greedy_3.html","images/greedy_4.png","images/greedy_4.html","images/grey_to_color_using_ai.png","images/grey_to_color_using_ai.html","images/hostapp_file.png","images/hostapp_file.html","images/immutable_mutable.png","images/immutable_mutable.html","images/inc_support.png","images/inc_support.html","images/initializer_list_char.png","images/initializer_list_char.html","images/insight_after.png","images/insight_after.html","images/insight_before.png","images/insight_before.html","images/ip4v_header.png","images/ip4v_header.html","images/layout_qualifier.png","images/layout_qualifier.html","images/linear_interpolation.png","images/linear_interpolation.html","images/math_func.png","images/math_func.html","images/matrix_row_prior.png","images/matrix_row_prior.html","images/metal_rendering_pipeline.png","images/metal_rendering_pipeline.html","images/nativizedassets.png","images/nativizedassets.html","images/navigation.png","images/navigation.html","images/object_file_header.png","images/object_file_header.html","images/opengl_shader_program_process.png","images/opengl_shader_program_process.html","images/packet.png","images/packet.html","images/paralle_processing.png","images/paralle_processing.html","images/primitive_assembly_rasterization.png","images/primitive_assembly_rasterization.html","images/printf.png","images/printf.html","images/prog_debugging.png","images/prog_debugging.html","images/programmable_pipeline.png","images/programmable_pipeline.html","images/pso.png","images/pso.html","images/pso_data.png","images/pso_data.html","images/rasterization_mean.png","images/rasterization_mean.html","images/register_vec.png","images/register_vec.html","images/removedinternal.png","images/removedinternal.html","images/rgb_cmy_conversion.png","images/rgb_cmy_conversion.html","images/rgb_color_model.png","images/rgb_color_model.html","images/robot_maze.png","images/robot_maze.html","images/sandbox_error.png","images/sandbox_error.html","images/serial.png","images/serial.html","images/shader_program_structure.png","images/shader_program_structure.html","images/simulator_device_error.png","images/simulator_device_error.html","images/slate_arcitecture_1.png","images/slate_arcitecture_1.html","images/slate_arcitecture_2.png","images/slate_arcitecture_2.html","images/slate_arcitecture_3.png","images/slate_arcitecture_3.html","images/slate_arcitecture_4.png","images/slate_arcitecture_4.html","images/slate_overview_1.png","images/slate_overview_1.html","images/slate_overview_2.png","images/slate_overview_2.html","images/sphere-indexing-screenshot.png","images/sphere-indexing-screenshot.html","images/subnetmask.png","images/subnetmask.html","images/subset_graph.png","images/subset_graph.html","images/symbol_find_result.png","images/symbol_find_result.html","images/symbol_result.png","images/symbol_result.html","images/type_structure.png","images/type_structure.html","images/u2_soundtype.png","images/u2_soundtype.html","images/use_vertex_attirbute_arrays.png","images/use_vertex_attirbute_arrays.html","images/usermode_kernalmode.png","images/usermode_kernalmode.html","images/using_uniform.png","images/using_uniform.html","images/var_error.jpg","images/var_error.html","images/vertex_shader.png","images/vertex_shader.html","images/vertext_shader_parallel.png","images/vertext_shader_parallel.html","images/vtableoperation.png","images/vtableoperation.html","images/wbp_ui_transition.png","images/wbp_ui_transition.html","images/whoami.png","images/whoami.html","infra/helix-core-workflow.html","infra/helix-core,-helix-swarm-구성.html","infra/jenkins-설치-및-구성.html","infra/jenkins-안드로이드-패키징.html","infra/p4-extension,-p4-triggers.html","infra/perforce-label.html","infra/perforce-명령어.html","infra/swarm-teams.html","interview_practice/c++.html","interview_practice/ios-(1).html","interview_practice/platform-sdk-(1).html","interview_practice/platform-sdk-(2).html","interview_practice/qt.html","ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html","ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html","ios/fat-framework.html","ios/lazy-sequence.html","ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html","ios/network-timeout-unittest.html","ios/objective-c.html","ios/orientation.html","ios/photokit을-다뤄보자-(이론편).html","ios/photokit을-다뤄보자-(커스텀-코드편).html","ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html","ios/scalable-application-설계부터-구현까지-(1)-tuist.html","ios/swift,-objective-c-interoperability.html","ios/swift에서-다형성을-달성하는-방법.html","ios/tuist-기본적인-사용법.html","ios/tuist에서-ribs-fetch하기.-(carthage).html","ios/ui-update-cycle.html","ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html","ios/wwdc-2023-parameter-pack.html","ios/단위테스트와-product_module_name.html","ios/동기,-비동기.html","ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html","network/01.-network.html","network/02.-l2.html","network/03.-l3.html","network/04.-패킷의-생성과-전달.html","network/05.-계층별-데이터-단위.html","network/06.-tcp-ip-송수신-구조.html","network/07.-ipv4-header-형식.html","network/08.-서브넷-마스크와-cidr.html","network/09.-broadcast-ip-주소-&-loopback-주소.html","network/10.-ttl과-단편화.html","network/11.-인터넷-자동-설정-dhcp.html","network/12.-arp.html","network/13.-ping과-rtt.html","network/14.-tcp와-udp-개요.html","network/15.-tcp-연결-과정.html","network/16.-tcp-연결-종료-과정.html","network/17.-dns.html","network/18.-http.html","opencv/video-capture.html","physics/physx.html","physics/untitled.html","qt/opengl/opengl-sphere-그리기.html","qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html","qt/opengl/qt-opengl-in-macos.html","qt/opengl/qt-opengl-코드.html","qt/qt-quick-3d-기본-개념-정리.html","qt/자주-사용하는-단축키.html","robotics/ros-2-핵심-통신-개념.html","robotics/ros2-명령어.html","rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html","rust/cargo.html","rust/rust-기초-control,-연습-문제.html","rust/rust-기초-data-type.html","rust/rust-기초-function.html","rust/rust-기초-variable.html","rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html","tip/git.html","tip/linux-명령어.html","tip/mcp-setting.html","tip/tip.html","tip/vscode-clang++-설정.html","tip/비트-다루기.html","tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html","ue/network-프레임워크/02.html","ue/network-프레임워크/03.-커넥션과-오너십.html","ue/agde와-ue연동.html","ue/audio_stream_caching.html","ue/blendspace와-blendspace1d-차이점.html","ue/bool-vs-uint8.html","ue/build-system.html","ue/console_command-등록-하는-법.html","ue/content-cooking-&-pak-&-chunk.html","ue/datatable_asset_ref.html","ue/enum-vs-enum-class.html","ue/etriggerevent.html","ue/fgenricerror.html","ue/fiosview-inserttext-objc_msgsend.html","ue/ftp-manager.html","ue/get_audiotrackinfo_umg.html","ue/insight.html","ue/invalidation-box.html","ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html","ue/media-framework.html","ue/navigation-system.html","ue/physx-ios-빌드.html","ue/pso-(pipeline-state-object)-수집.html","ue/slate-architecture.html","ue/slate-overview.html","ue/slate-widget-examples.html","ue/sounds-개념.html","ue/sounds-개선.html","ue/ue4-source-ios-debugging-on-macos.html","ue/ue4.27-ios-background-앱-크래쉬.html","ue/ugameplaystatics.html","ue/ui-애니메이션.html","ue/umg-클래스에-delegate-추가하기.html","ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html","ue/upl.html","ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html","ue/아틀라스.html","ue/언리얼-패키징-관련-error.html","ue/언리얼엔진에서의-lamda.html","ue/월드의-생명주기.html","unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html","unity/14.-interact-action-events.html","unity/15.-selected-counter-visual-&-singleton-pattern.html","unity/16.-kitchen-object,-scriptable-object.html","unity/17.-kitchen-object-parent.html","unity/18.-player-pick-up,-csharp-interfaces.html","unity/19.-container-counter와-상속.html","unity/20.-player-pick-up-&-drop-object.html","unity/21.-cutting-counter,-interact-alternate.html","unity/22.-cutting-recipe-so.html","unity/23.-cutting-progress,-world-canvas.html","unity/24.-look-at-camera.html","unity/25.-trash-counter.html","unity/26.-stove-counter.html","unity/27.-plates-counter.html","unity/28.-plate-pick-up-objects.html","unity/glow-effect-만들기.html","unity/캐릭터-움직임과-time.deltatime.html","index.html"],"attachments":["images/3colorchannel.png","images/aggregate.png","images/allpublic.png","images/bfs_1.png","images/bfs_2.png","images/bi_linear_interpolation.png","images/ble_configuration.png","images/ble_host_controller.png","images/ble-attribute-table.png","images/ble-conn-fig-1.png","images/ble-conn-fig-2.png","images/ble-conn-fig-3.png","images/ble-connection.png","images/ble-connection-1.png","images/ble-data-exchange.png","images/ble-gatt-structure.png","images/ble-l2cap.png","images/ble-link-layer.png","images/blendspace.png","images/bpgi_onbeginplay.png","images/broadcastip_address.png","images/build_process.png","images/bw_grayscale.png","images/change_scheme.png","images/cmake_setting.png","images/cmy_model.png","images/collectpso.png","images/color_image.png","images/color_vs_grayscale.png","images/common_ui_plugin.png","images/compared_ext_trigger.png","images/concurrent.png","images/cpp_1.png","images/cpp_2.png","images/cpp_3.png","images/cpp_4.png","images/cpp_5.png","images/cpp_6.png","images/cpp_7.png","images/cpp_8.png","images/cpp_9.png","images/cpp_10.png","images/cpp_11.png","images/cpp_12.png","images/cpp_13.png","images/cpp_14.png","images/cpp_memory_struct.png","images/data_transfer_struct.png","images/datahandle_row_result.png","images/debugging_failure.png","images/debugging_success.png","images/dfs_1.png","images/dfs_2.png","images/ebtnode_result_aborted.png","images/ebtnode_result_failed.png","images/ebtnode_result_inprogress.png","images/ebtnode_result_type.png","images/executable_file_structure.png","images/export_shader_code.png","images/fatframework_path.png","images/foldering_as_is.png","images/foldering_to_be.png","images/fragment_shader.png","images/fragment_shader_execute.png","images/framework_path.png","images/fresnel.png","images/func_1.png","images/gameflowchart.png","images/gl_error_flag.png","images/glew32_install_error.png","images/glsl_debugging_1.png","images/glsl_debugging2.png","images/glvertexattribpointer.png","images/gpu_structure.png","images/graphic_pipeline.png","images/greedy_1.png","images/greedy_2.png","images/greedy_3.png","images/greedy_4.png","images/grey_to_color_using_ai.png","images/hostapp_file.png","images/immutable_mutable.png","images/inc_support.png","images/initializer_list_char.png","images/insight_after.png","images/insight_before.png","images/ip4v_header.png","images/layout_qualifier.png","images/linear_interpolation.png","images/math_func.png","images/matrix_row_prior.png","images/metal_rendering_pipeline.png","images/nativizedassets.png","images/navigation.png","images/object_file_header.png","images/opengl_shader_program_process.png","images/packet.png","images/paralle_processing.png","images/primitive_assembly_rasterization.png","images/printf.png","images/prog_debugging.png","images/programmable_pipeline.png","images/pso.png","images/pso_data.png","images/rasterization_mean.png","images/register_vec.png","images/removedinternal.png","images/rgb_cmy_conversion.png","images/rgb_color_model.png","images/robot_maze.png","images/sandbox_error.png","images/serial.png","images/shader_program_structure.png","images/simulator_device_error.png","images/slate_arcitecture_1.png","images/slate_arcitecture_2.png","images/slate_arcitecture_3.png","images/slate_arcitecture_4.png","images/slate_overview_1.png","images/slate_overview_2.png","images/sphere-indexing-screenshot.png","images/subnetmask.png","images/subset_graph.png","images/symbol_find_result.png","images/symbol_result.png","images/type_structure.png","images/u2_soundtype.png","images/use_vertex_attirbute_arrays.png","images/usermode_kernalmode.png","images/using_uniform.png","images/var_error.jpg","images/vertex_shader.png","images/vertext_shader_parallel.png","images/vtableoperation.png","images/wbp_ui_transition.png","images/whoami.png","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/obsidian.css","site-lib/styles/other-plugins.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","site-lib/rss.xml"],"allFiles":["images/vtableoperation.png","images/vtableoperation.html","images/cpp_memory_struct.png","images/cpp_memory_struct.html","graphics/이론/vsync-(수직-동기화).html","flutter/scaffold-vs-builder.html","flutter/statefulwidget-생명주기.html","flutter/tickerproviderstatemixin.html","flutter/0.-setup.html","flutter/animation.html","flutter/appbar.html","flutter/build-context.html","flutter/gridview.html","interview_practice/ios-(1).html","cs/자료구조/hash-table.html","cs/자료구조/red-black-tree.html","cs/자료구조/tree.html","cs/캐시-전략.html","interview_practice/c++.html","cs/자료구조/avl-트리.html","cs/자료구조/b+-tree.html","cs/자료구조/binary-search-tree.html","cs/자료구조/deque.html","cs/36.-static-키워드.html","cs/리틀-앤디언과-빅-앤디언.html","cs/33.-레이스-컨디션에-대해-설명해주세요.html","cs/34.-포인터와-참조의-차이점.html","cs/35.-가상-메모리는-무엇인가.html","cs/28.-메모리-누수를-탐지하는-방법.html","cs/29.-스레드와-프로세스의-차이점.html","cs/30.-c++에서-스레드-동기화-방법들.html","cs/31.-뮤텍스와-세마포어의-차이점.html","cs/23.-lvalue와-rvalue의-차이점.html","cs/24.-move-constructor와-move-assignment의-필요성.html","cs/25.-auto-키워드의-장단점.html","cs/26.-람다함수의-캡처-방식들과-사용법.html","cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html","cs/18.-priority_queue의-내부-구현과-사용법.html","cs/20.-map과-unordered_map-중-선택-기준.html","cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html","cs/12.-new,-delete와-malloc,-free의-차이점.html","cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html","cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html","cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html","cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html","cs/07.-캐시-지역성.html","cs/08.-메모리-단편화.html","cs/09.-c++-메모리-구조.html","cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html","cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html","cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html","cpp/quiz.html","graphics/unreal-engine/basic.html","graphics/이론/동차-좌표계와-원근-분할.html","images/fresnel.png","images/fresnel.html","graphics/unreal-engine/material.html","graphics/unreal-engine/rim-light와-fresnel-노드.html","graphics/metal/uniform-buffer.html","graphics/metal/0.-metal-basic.html","graphics/metal/metal-rendering-pipeline.html","graphics/rasterizer/1.-브레젠험-직선-알고리즘.html","graphics/rasterizer/0.-목표에-대해서.html","graphics/etc/golf-simulator-using-sfml.html","graphics/이론/변환행렬.html","graphics/이론/렌더링-파이프라인-이론.html","interview_practice/qt.html","cpp/template/1.-명시적-템플릿-인스터스화.html","interview_practice/platform-sdk-(2).html","interview_practice/platform-sdk-(1).html","cpp/etc/rvo.html","graphics/metal/depth-buffer.html","ios/ui-update-cycle.html","graphics/metal/shadow-map.html","graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html","physics/untitled.html","ue/upl.html","android/인앱-결제.html","index.html","algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html","hose/develop.html","robotics/ros-2-핵심-통신-개념.html","qt/자주-사용하는-단축키.html","cpp/etc/리소스-임베딩-by-compile.html","graphics/opengl/02.응용/09.-glsl-디버그-함수들.html","graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html","graphics/opengl/02.응용/03.-gpu-내부-구조.html","graphics/opengl/02.응용/04.-glsl.html","graphics/opengl/02.응용/05.-shader-programming-코드-분석.html","graphics/opengl/02.응용/06.-재사용가능한-코드.html","graphics/opengl/02.응용/07.-glsl-자료형.html","graphics/opengl/02.응용/08.-uniform-variable.html","graphics/opengl/02.응용/01.-그래픽스-파이프라인.html","graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html","qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html","qt/opengl/qt-opengl-in-macos.html","qt/opengl/qt-opengl-코드.html","tip/mcp-setting.html","qt/opengl/opengl-sphere-그리기.html","qt/qt-quick-3d-기본-개념-정리.html","cpp/etc/c++-static-const-초기화.html","images/sphere-indexing-screenshot.png","images/sphere-indexing-screenshot.html","cs/floating-point.html","cs/context-switching.html","cs/deadlock.html","cpp/etc/전역변수와-정적변수의-공통점과-차이점.html","cpp/etc/const-위치-헷갈리는-점-정리.html","cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html","cs/pseudo-random-(의사-난수).html","cpp/etc/유리수-클래스-구현.html","algorithm/study/문제유형.html","algorithm/study/코딩테스트를-위한-암기.html","cpp/build-system/cmake.html","opencv/video-capture.html","algorithm/leetcode/21.-merge-two-sorted-lists.html","algorithm/leetcode/206.-reverse-linked-list.html","algorithm/leetcode/141.-linked-list-cycle.html","algorithm/leetcode/143.-reorder-list.html","robotics/ros2-명령어.html","cpp/build-system/pic.html","docker/1.-basic.html","docker/2.-도커-컨테이너-환경-구축.html","tip/linux-명령어.html","tip/tip.html","android/wifi-util-class.html","ios/scalable-application-설계부터-구현까지-(1)-tuist.html","cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html","infra/perforce-label.html","tip/vscode-clang++-설정.html","cpp/modern/4.-shared,-weak-ptr.html","cpp/concurrency/7.-event-system.html","algorithm/leetcode/152.-maximum-product-subarray.html","cpp/basic/2.-생성자.html","cpp/basic/3.-overloading.html","cpp/basic/4.-상속.html","cpp/basic/5.-다중-상속.html","cpp/basic/6.-파일-입출력.html","cpp/concurrency/1.-thread.html","cpp/concurrency/2.-mutex,-deadlock.html","cpp/concurrency/3.-memory-order,-atomic.html","cpp/concurrency/4.-future,-async,-promise.html","cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html","cpp/concurrency/6.-threadpool.html","cpp/modern/7.-random,-chrono-library.html","cpp/modern/1.-rvalue-rvalue-참조.html","cpp/modern/2.-move,-레퍼런스-겹침-규칙.html","cpp/modern/3.-raii,-unique-ptr.html","cpp/modern/5.-callable-etc..html","cpp/modern/6.-uniform-initializer.html","images/initializer_list_char.png","images/initializer_list_char.html","cpp/lib/fmt.html","cpp/lib/google-test.html","infra/helix-core,-helix-swarm-구성.html","infra/perforce-명령어.html","tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html","ue/slate-architecture.html","ue/fgenricerror.html","ue/언리얼-패키징-관련-error.html","ue/ue4.27-ios-background-앱-크래쉬.html","ue/fiosview-inserttext-objc_msgsend.html","cpp/basic/1.-참조와-포인터.html","cpp/basic/0.-c,-c++-컴파일-과정.html","algorithm/leetcode/424.-longest-repeating-character-replacement.html","algorithm/leetcode/271.-encode-and-decode-strings.html","algorithm/leetcode/217.-contains-duplicate.html","algorithm/leetcode/200.-number-of-islands.html","algorithm/leetcode/198.-house-robber.html","algorithm/leetcode/78.-subsets.html","algorithm/leetcode/70.-climbing-stair.html","algorithm/leetcode/62.-unique-paths.html","algorithm/leetcode/55.-jump-game.html","algorithm/leetcode/3.-longest-substring-without-repeating-characters.html","algorithm/lecture/그리디-알고리즘.html","algorithm/lecture/dfs.html","algorithm/lecture/bfs.html","ble/4.-ble-디바이스-연결.html","ble/3.-ble-att,-gatt.html","ble/2.-ble-프로토콜-스택.html","ble/1.-ble-개요.html","infra/p4-extension,-p4-triggers.html","infra/swarm-teams.html","tip/git.html","infra/jenkins-설치-및-구성.html","infra/jenkins-안드로이드-패키징.html","images/compared_ext_trigger.png","images/compared_ext_trigger.html","ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html","images/robot_maze.png","images/robot_maze.html","cpp/platform/sfml과-visitor-pattern.html","graphics/etc/sfml.html","graphics/이론/modeling.html","graphics/이론/컴퓨터-그래픽스-기초와-수학.html","csharp/linq.html","unity/28.-plate-pick-up-objects.html","unity/27.-plates-counter.html","unity/26.-stove-counter.html","unity/25.-trash-counter.html","unity/24.-look-at-camera.html","unity/23.-cutting-progress,-world-canvas.html","unity/22.-cutting-recipe-so.html","unity/21.-cutting-counter,-interact-alternate.html","unity/20.-player-pick-up-&-drop-object.html","unity/19.-container-counter와-상속.html","unity/18.-player-pick-up,-csharp-interfaces.html","unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html","unity/14.-interact-action-events.html","unity/15.-selected-counter-visual-&-singleton-pattern.html","unity/16.-kitchen-object,-scriptable-object.html","unity/17.-kitchen-object-parent.html","unity/캐릭터-움직임과-time.deltatime.html","unity/glow-effect-만들기.html","rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html","tip/비트-다루기.html","rust/rust-기초-control,-연습-문제.html","rust/rust-기초-function.html","rust/rust-기초-data-type.html","rust/rust-기초-variable.html","rust/cargo.html","rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html","ios/단위테스트와-product_module_name.html","ios/wwdc-2023-parameter-pack.html","ios/swift에서-다형성을-달성하는-방법.html","ios/lazy-sequence.html","ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html","ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html","ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html","ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html","ios/photokit을-다뤄보자-(커스텀-코드편).html","ios/photokit을-다뤄보자-(이론편).html","ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html","ios/tuist-기본적인-사용법.html","ios/tuist에서-ribs-fetch하기.-(carthage).html","hose/내가-블로그를-시작한-이유.html","ue/agde와-ue연동.html","ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html","ue/etriggerevent.html","ue/blendspace와-blendspace1d-차이점.html","ue/월드의-생명주기.html","ue/ftp-manager.html","ue/sounds-개선.html","infra/helix-core-workflow.html","ue/ue4-source-ios-debugging-on-macos.html","ue/sounds-개념.html","ue/pso-(pipeline-state-object)-수집.html","ue/media-framework.html","ue/insight.html","ue/get_audiotrackinfo_umg.html","ue/datatable_asset_ref.html","ue/content-cooking-&-pak-&-chunk.html","ue/console_command-등록-하는-법.html","physics/physx.html","ios/fat-framework.html","algorithm/study/two-pointer.html","algorithm/study/heap-&-우선순위-큐.html","algorithm/study/dp.html","images/cpp_14.png","images/cpp_14.html","images/cpp_13.png","images/cpp_13.html","images/cpp_12.png","images/cpp_12.html","images/cpp_11.png","images/cpp_11.html","images/cpp_10.png","images/cpp_10.html","network/18.-http.html","network/17.-dns.html","images/metal_rendering_pipeline.png","images/metal_rendering_pipeline.html","images/insight_before.png","images/insight_before.html","images/insight_after.png","images/insight_after.html","images/vertext_shader_parallel.png","images/vertext_shader_parallel.html","images/vertex_shader.png","images/vertex_shader.html","images/using_uniform.png","images/using_uniform.html","images/use_vertex_attirbute_arrays.png","images/use_vertex_attirbute_arrays.html","images/type_structure.png","images/type_structure.html","images/shader_program_structure.png","images/shader_program_structure.html","images/rasterization_mean.png","images/rasterization_mean.html","images/register_vec.png","images/register_vec.html","images/programmable_pipeline.png","images/programmable_pipeline.html","images/prog_debugging.png","images/prog_debugging.html","images/primitive_assembly_rasterization.png","images/primitive_assembly_rasterization.html","images/opengl_shader_program_process.png","images/opengl_shader_program_process.html","images/paralle_processing.png","images/paralle_processing.html","images/matrix_row_prior.png","images/matrix_row_prior.html","images/linear_interpolation.png","images/linear_interpolation.html","images/math_func.png","images/math_func.html","images/layout_qualifier.png","images/layout_qualifier.html","images/glsl_debugging_1.png","images/glsl_debugging_1.html","images/gpu_structure.png","images/gpu_structure.html","images/glsl_debugging2.png","images/glsl_debugging2.html","images/gl_error_flag.png","images/gl_error_flag.html","images/glvertexattribpointer.png","images/glvertexattribpointer.html","images/fragment_shader_execute.png","images/fragment_shader_execute.html","images/func_1.png","images/func_1.html","images/fragment_shader.png","images/fragment_shader.html","images/export_shader_code.png","images/export_shader_code.html","images/debugging_failure.png","images/debugging_failure.html","images/debugging_success.png","images/debugging_success.html","images/bi_linear_interpolation.png","images/bi_linear_interpolation.html","ue/audio_stream_caching.html","ue/언리얼엔진에서의-lamda.html","images/broadcastip_address.png","images/broadcastip_address.html","images/ip4v_header.png","images/ip4v_header.html","images/subnetmask.png","images/subnetmask.html","network/16.-tcp-연결-종료-과정.html","network/07.-ipv4-header-형식.html","network/08.-서브넷-마스크와-cidr.html","network/09.-broadcast-ip-주소-&-loopback-주소.html","network/10.-ttl과-단편화.html","network/11.-인터넷-자동-설정-dhcp.html","network/12.-arp.html","network/13.-ping과-rtt.html","network/14.-tcp와-udp-개요.html","network/15.-tcp-연결-과정.html","images/u2_soundtype.png","images/u2_soundtype.html","images/foldering_to_be.png","images/foldering_to_be.html","images/graphic_pipeline.png","images/graphic_pipeline.html","graphics/opengl/01.기본/01.-기본.html","graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html","graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html","graphics/opengl/01.기본/04.-컬러-기초이론.html","graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html","graphics/opengl/01.기본/06.-rgba-컬러-모델.html","images/var_error.jpg","images/var_error.html","images/pso.png","images/pso.html","images/foldering_as_is.png","images/foldering_as_is.html","ue/network-프레임워크/02.html","ue/network-프레임워크/03.-커넥션과-오너십.html","images/grey_to_color_using_ai.png","images/grey_to_color_using_ai.html","images/rgb_cmy_conversion.png","images/rgb_cmy_conversion.html","images/rgb_color_model.png","images/rgb_color_model.html","images/color_vs_grayscale.png","images/color_vs_grayscale.html","images/color_image.png","images/color_image.html","images/bw_grayscale.png","images/bw_grayscale.html","images/cmy_model.png","images/cmy_model.html","images/3colorchannel.png","images/3colorchannel.html","ue/ugameplaystatics.html","ue/umg-클래스에-delegate-추가하기.html","images/datahandle_row_result.png","images/datahandle_row_result.html","images/usermode_kernalmode.png","images/usermode_kernalmode.html","images/packet.png","images/packet.html","images/data_transfer_struct.png","images/data_transfer_struct.html","network/02.-l2.html","network/03.-l3.html","network/04.-패킷의-생성과-전달.html","network/05.-계층별-데이터-단위.html","network/06.-tcp-ip-송수신-구조.html","images/bpgi_onbeginplay.png","images/bpgi_onbeginplay.html","images/wbp_ui_transition.png","images/wbp_ui_transition.html","network/01.-network.html","images/common_ui_plugin.png","images/common_ui_plugin.html","ue/ui-애니메이션.html","images/inc_support.png","images/inc_support.html","images/whoami.png","images/whoami.html","algorithm/study/이분탐색-&-파라메트릭-서치.html","algorithm/study/누적합-알고리즘.html","images/pso_data.png","images/pso_data.html","images/collectpso.png","images/collectpso.html","images/bfs_2.png","images/bfs_2.html","images/bfs_1.png","images/bfs_1.html","images/dfs_2.png","images/dfs_2.html","images/dfs_1.png","images/dfs_1.html","images/subset_graph.png","images/subset_graph.html","images/greedy_4.png","images/greedy_4.html","images/greedy_3.png","images/greedy_3.html","images/greedy_2.png","images/greedy_2.html","images/greedy_1.png","images/greedy_1.html","images/cpp_9.png","images/cpp_9.html","images/cpp_8.png","images/cpp_8.html","images/cpp_7.png","images/cpp_7.html","images/cpp_6.png","images/cpp_6.html","images/cpp_5.png","images/cpp_5.html","images/cpp_4.png","images/cpp_4.html","images/cpp_3.png","images/cpp_3.html","ue/invalidation-box.html","images/cpp_2.png","images/cpp_2.html","images/cpp_1.png","images/cpp_1.html","ue/bool-vs-uint8.html","ue/enum-vs-enum-class.html","images/ble_configuration.png","images/ble_configuration.html","ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html","images/glew32_install_error.png","images/glew32_install_error.html","images/serial.png","images/serial.html","ios/동기,-비동기.html","images/concurrent.png","images/concurrent.html","ios/orientation.html","images/allpublic.png","images/allpublic.html","images/immutable_mutable.png","images/immutable_mutable.html","images/removedinternal.png","images/removedinternal.html","ios/network-timeout-unittest.html","ios/objective-c.html","ios/swift,-objective-c-interoperability.html","images/framework_path.png","images/framework_path.html","images/hostapp_file.png","images/hostapp_file.html","images/sandbox_error.png","images/sandbox_error.html","images/simulator_device_error.png","images/simulator_device_error.html","images/fatframework_path.png","images/fatframework_path.html","images/aggregate.png","images/aggregate.html","images/slate_arcitecture_4.png","images/slate_arcitecture_4.html","images/slate_overview_1.png","images/slate_overview_1.html","images/slate_overview_2.png","images/slate_overview_2.html","images/slate_arcitecture_3.png","images/slate_arcitecture_3.html","images/slate_arcitecture_1.png","images/slate_arcitecture_1.html","images/slate_arcitecture_2.png","images/slate_arcitecture_2.html","ue/slate-overview.html","ue/slate-widget-examples.html","ue/navigation-system.html","ue/physx-ios-빌드.html","ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html","ue/아틀라스.html","images/symbol_find_result.png","images/symbol_find_result.html","images/symbol_result.png","images/symbol_result.html","images/cmake_setting.png","images/cmake_setting.html","images/change_scheme.png","images/change_scheme.html","images/nativizedassets.png","images/nativizedassets.html","images/object_file_header.png","images/object_file_header.html","images/printf.png","images/printf.html","ue/build-system.html","images/executable_file_structure.png","images/executable_file_structure.html","images/build_process.png","images/build_process.html","images/ebtnode_result_inprogress.png","images/ebtnode_result_inprogress.html","images/ebtnode_result_type.png","images/ebtnode_result_type.html","images/ebtnode_result_failed.png","images/ebtnode_result_failed.html","images/ebtnode_result_aborted.png","images/ebtnode_result_aborted.html","images/navigation.png","images/navigation.html","images/gameflowchart.png","images/gameflowchart.html","images/blendspace.png","images/blendspace.html","images/ble-gatt-structure.png","images/ble-gatt-structure.html","images/ble-l2cap.png","images/ble-l2cap.html","images/ble-link-layer.png","images/ble-link-layer.html","images/ble-connection.png","images/ble-connection.html","images/ble-connection-1.png","images/ble-connection-1.html","images/ble-data-exchange.png","images/ble-data-exchange.html","images/ble-attribute-table.png","images/ble-attribute-table.html","images/ble-conn-fig-1.png","images/ble-conn-fig-1.html","images/ble-conn-fig-2.png","images/ble-conn-fig-2.html","images/ble-conn-fig-3.png","images/ble-conn-fig-3.html","images/ble_host_controller.png","images/ble_host_controller.html","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/obsidian.css","site-lib/styles/other-plugins.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"algorithm/lecture/bfs.html":{"title":"BFS","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a>\n너비 우선 탐색\n가까운 노드부터 우선적으로 탐색\n큐 자료구조\n<br><img alt=\"BFS_1.png\" src=\"images/bfs_1.png\" target=\"_self\"><br><img alt=\"BFS_2.png\" src=\"images/bfs_2.png\" target=\"_self\">\n#include &lt;bits/stdc++.h&gt; using namespace std; bool visited[9];\nvector&lt;int&gt; graph[9]; // BFS 함수 정의\nvoid bfs(int start) { queue&lt;int&gt; q; q.push(start); // 현재 노드를 방문 처리 visited[start] = true; // 큐가 빌 때까지 반복 while(!q.empty()) { // 큐에서 하나의 원소를 뽑아 출력 int x = q.front(); q.pop(); cout &lt;&lt; x &lt;&lt; ' '; // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입 for(int i = 0; i &lt; graph[x].size(); i++) { int y = graph[x][i]; if(!visited[y]) { q.push(y); visited[y] = true; } } }\n} int main(void) { // 노드 1에 연결된 노드 정보 저장 graph[1].push_back(2); graph[1].push_back(3); graph[1].push_back(8); // 노드 2에 연결된 노드 정보 저장 graph[2].push_back(1); graph[2].push_back(7); // 노드 3에 연결된 노드 정보 저장 graph[3].push_back(1); graph[3].push_back(4); graph[3].push_back(5); // 노드 4에 연결된 노드 정보 저장 graph[4].push_back(3); graph[4].push_back(5); // 노드 5에 연결된 노드 정보 저장 graph[5].push_back(3); graph[5].push_back(4); // 노드 6에 연결된 노드 정보 저장 graph[6].push_back(7); // 노드 7에 연결된 노드 정보 저장 graph[7].push_back(2); graph[7].push_back(6); graph[7].push_back(8); // 노드 8에 연결된 노드 정보 저장 graph[8].push_back(1); graph[8].push_back(7); bfs(1);\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo"],"author":"","coverImageURL":"images/bfs_1.png","fullURL":"algorithm/lecture/bfs.html","pathToRoot":"../..","attachments":["images/bfs_1.html","images/bfs_2.html"],"createdTime":1719764451038,"modifiedTime":1737702291698,"sourceSize":1827,"sourcePath":"Algorithm/Lecture/BFS.md","exportPath":"algorithm/lecture/bfs.html","showInTree":true,"treeOrder":2,"backlinks":[],"type":"markdown"},"algorithm/lecture/dfs.html":{"title":"DFS","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a>\n스택 또는 재귀 이용\n<br><img alt=\"DFS_1.png\" src=\"images/dfs_1.png\" target=\"_self\"><br><img alt=\"DFS_2.png\" src=\"images/dfs_2.png\" target=\"_self\">#include &lt;bits/stdc++.h&gt; using namespace std; bool visited[9];\nvector&lt;int&gt; graph[9]; void dfs(int x) { visited[x] = true; cout &lt;&lt; x &lt;&lt; ' '; for(int i = 0; i &lt; graph[x].size(); i++) { int y = graph[x][i]; if (!visited[y] ) dfs(y); }\n} int main(void) { graph[1].push_back(2); graph[1].push_back(3); graph[1].push_back(8); // 노드 2에 연결된 노드 정보 저장 graph[2].push_back(1); graph[2].push_back(7); // 노드 3에 연결된 노드 정보 저장 graph[3].push_back(1); graph[3].push_back(4); graph[3].push_back(5); // 노드 4에 연결된 노드 정보 저장 graph[4].push_back(3); graph[4].push_back(5); // 노드 5에 연결된 노드 정보 저장 graph[5].push_back(3); graph[5].push_back(4); // 노드 6에 연결된 노드 정보 저장 graph[6].push_back(7); // 노드 7에 연결된 노드 정보 저장 graph[7].push_back(2); graph[7].push_back(6); graph[7].push_back(8); // 노드 8에 연결된 노드 정보 저장 graph[8].push_back(1); graph[8].push_back(7); // dfs(1); return 0;\n} ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo"],"author":"","coverImageURL":"images/dfs_1.png","fullURL":"algorithm/lecture/dfs.html","pathToRoot":"../..","attachments":["images/dfs_1.html","images/dfs_2.html"],"createdTime":1719763455545,"modifiedTime":1737702293259,"sourceSize":1256,"sourcePath":"Algorithm/Lecture/DFS.md","exportPath":"algorithm/lecture/dfs.html","showInTree":true,"treeOrder":3,"backlinks":[],"type":"markdown"},"algorithm/lecture/그리디-알고리즘.html":{"title":"그리디 알고리즘","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a>\n현재 상황에서 지금 당장 좋은 것만 고르는 방법\n문제 1.<br>\n<img alt=\"greedy_1.png\" src=\"images/greedy_1.png\" target=\"_self\">#include &lt;bits/stdc++.h&gt; using namespace std; int n = 1260;\nint cnt; int coinTypes[4] = {500, 100, 50, 10}; int main()\n{ for (int i = 0; i &lt; 4; ++i) { cnt += n / coinTypes[i]; n % = coinTypes[i]; } cout &lt;&lt; cnt &lt;&lt; '\\n';\n} 문제 2. <br><img alt=\"greedy_2.png\" src=\"images/greedy_2.png\" target=\"_self\">2 이상의 수로 나누는 것이 1을 빼는 것보다 수를 더 많이 줄일 수 있음 -&gt; 그리디#include &lt;bits/stdc++.h&gt; using namespace std; int n,k;\nint result; int main()\n{ cin &gt;&gt; n &gt;&gt; k; while (true) { // n이 k로 나누어 떨어지는 수가 될 때까지 빼기 int target = (n/k) * k; result += (n - target); n = target; // n이 k보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출 if (n &lt; k) break; result++; n /= k; } // 마지막으로 남은 수에 대하여 1씩 빼기 result += (n-1); cout &lt;&lt; result &lt;&lt;'\\n';\n}\n문제 3.<br><img alt=\"greedy_3.png\" src=\"images/greedy_3.png\" target=\"_self\">Mine: 0이나 1을 만났을 때 더하기 나머지 곱하기#include &lt;bits/stdc++.h&gt; using namespace std; string str; int main()\n{ cin &gt;&gt; str; long long result = str[0]-'0'; for (int i = 1; i &lt; str.size(); i++) { int num = str[i] - '0'; if (num &lt; = 1 || result &lt;= 1) result += num; else result *= num; } cout &lt;&lt; result &lt;&lt; '\\n';\n} 문제 4.<br><img alt=\"greedy_4.png\" src=\"images/greedy_4.png\" target=\"_self\">예시: n = 5, 공포도 : 2 3 1 2 2오름차순 정렬하고 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면 그룹 결성 그룹1: 1, 2, 3\n그룹2: 2 2#include &lt;bits/stdc++.h&gt; using namespace std; int n;\nvector&lt;int&gt; arr; int main()\n{ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; arr.push_back(x); } sort(arr.begin(), arr.end()); int result = 0; int cnt = 0; for(int i =0; i &lt; n; i++) { cnt += 1; if( cnt &gt;= arr[i]) { result +=1; cnt = 0; } } cout &lt;&lt; result &lt;&lt; '\\n';\n} ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo"],"author":"","coverImageURL":"images/greedy_1.png","fullURL":"algorithm/lecture/그리디-알고리즘.html","pathToRoot":"../..","attachments":["images/greedy_1.html","images/greedy_2.html","images/greedy_3.html","images/greedy_4.html"],"createdTime":1719241549696,"modifiedTime":1737702294443,"sourceSize":2002,"sourcePath":"Algorithm/Lecture/그리디 알고리즘.md","exportPath":"algorithm/lecture/그리디-알고리즘.html","showInTree":true,"treeOrder":4,"backlinks":[],"type":"markdown"},"algorithm/leetcode/3.-longest-substring-without-repeating-characters.html":{"title":"3. Longest Substring Without Repeating Characters","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a>Given a string&nbsp;s, find the length of the&nbsp;longest&nbsp;substring&nbsp;without repeating characters.Example 1:Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.Example 2:Input: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.Example 3:Input: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.Constraints:\n0 &lt;= s.length &lt;= 5 * 104\ns&nbsp;consists of English letters, digits, symbols and spaces.\n내 답시간복잡도 - find, erase = 공간복잡도 class Solution {\npublic: int lengthOfLongestSubstring(string s) { size_t result = 0; string sub_s; for (size_t i = 0; i &lt; s.size(); ++i) { if (auto p = sub_s.find(s[i]); p != string::npos) { // find result = max(result, sub_s.size()); sub_s.erase(0,p + 1); } sub_s += s[i]; } return max(result, sub_s.size()); }\n};\nneetcode 답Sliding window using set시간복잡도 공간복잡도 class Solution {\npublic: int lengthOfLongestSubstring(string s) { unordered_set&lt;char&gt; charSet; int l = 0; int res = 0; for (int r = 0; r &lt; s.size(); r++) { while (charSet.find(s[r]) != charSet.end()) { charSet.erase(s[l]); l++; } charSet.insert(s[r]); res = max(res, r - l + 1); } return res; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/3.-longest-substring-without-repeating-characters.html","pathToRoot":"../..","attachments":[],"createdTime":1736861505493,"modifiedTime":1737702301768,"sourceSize":1758,"sourcePath":"Algorithm/LeetCode/3. Longest Substring Without Repeating Characters.md","exportPath":"algorithm/leetcode/3.-longest-substring-without-repeating-characters.html","showInTree":true,"treeOrder":6,"backlinks":[],"type":"markdown"},"algorithm/leetcode/21.-merge-two-sorted-lists.html":{"title":"21. Merge Two Sorted Lists","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:easy\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#easy\">#easy</a> class Solution {\npublic: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* curr = new ListNode(); ListNode* res = curr; while (list1 != nullptr || list2 != nullptr) { if (list1 == nullptr) { curr-&gt;next = list2; break; } if (list2 == nullptr) { curr-&gt;next = list1; break; } int val1 = list1-&gt;val; int val2 = list2-&gt;val; if (val1 &gt;= val2) { ListNode* temp = new ListNode(val2); curr-&gt;next = temp; list2 = list2-&gt;next; } else { ListNode* temp = new ListNode(val1); curr-&gt;next = temp; list1 = list1-&gt;next; } curr = curr-&gt;next; } return res-&gt;next; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:easy"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/21.-merge-two-sorted-lists.html","pathToRoot":"../..","attachments":[],"createdTime":1741189701487,"modifiedTime":1741189701487,"sourceSize":935,"sourcePath":"Algorithm/LeetCode/21. Merge Two Sorted Lists.md","exportPath":"algorithm/leetcode/21.-merge-two-sorted-lists.html","showInTree":true,"treeOrder":7,"backlinks":[],"type":"markdown"},"algorithm/leetcode/55.-jump-game.html":{"title":"55. Jump Game","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> You are given an integer array&nbsp;nums. You are initially positioned at the array's&nbsp;first index, and each element in the array represents your maximum jump length at that position.Return&nbsp;true&nbsp;if you can reach the last index, or&nbsp;false&nbsp;otherwise.Example 1:Input: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.나는 visited 배열과 queue를 이용해서 bfs로 풀었다.핵심 로직은 순회하면서 pop할 아이템을 pair(최대 점프할 수 있는 수, 현재 인덱스)로 설정하고\n현재 인덱스 == 마지막 인덱스 or 현재 인덱스 + 최대 점프할 수 있는 수 &gt;= 마지막 인덱스 인 경우\ntrue를 리턴 했다.시간복잡도는 최대 ) 를 가질 수 있다.class Solution {\npublic: bool canJump(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) { return true; } vector&lt;bool&gt; visited(nums.size(), false); // max, cur size queue&lt;pair&lt;int, int&gt;&gt; q; q.push({nums[0], 0}); visited[0] = true; while (!q.empty()) { int max = q.front().first; int cur = q.front().second; q.pop(); if (max == 0) continue; if (cur == nums.size() - 1 || cur + max &gt;= nums.size() - 1) return true; for (int i = cur + 1; i &lt; cur + max + 1; ++i) { if (!visited[i]) { q.push({nums[i], i}); visited[i] = true; } } } return false; }\n}; \b이 문제는 그리디로 푸는 게 더 합리적이다.class Solution {\npublic: bool canJump(vector&lt;int&gt;&amp; nums) { int goal = nums.size() - 1; for (int i = nums.size() - 1; i &gt;= 0; --i) { if (i + nums[i] &gt;= goal) goal = i; } return goal == 0; }\n};\n\b순회를 반대로 하여 i + nums[i]와 goal을 비교하면 된다. i + nums[i]이 더 크다면 goal에 도달할 수 있다는 것이기 때문에 goal을 업데이트 할 수 있다. 순회가 다 끝났을 때 goal == 0인 경우 true이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/55.-jump-game.html","pathToRoot":"../..","attachments":[],"createdTime":1736697355570,"modifiedTime":1737702320255,"sourceSize":2478,"sourcePath":"Algorithm/LeetCode/55. Jump Game.md","exportPath":"algorithm/leetcode/55.-jump-game.html","showInTree":true,"treeOrder":8,"backlinks":[],"type":"markdown"},"algorithm/leetcode/62.-unique-paths.html":{"title":"62. Unique Paths","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> There is a robot on an&nbsp;m x n&nbsp;grid. The robot is initially located at the&nbsp;top-left corner&nbsp;(i.e.,&nbsp;grid[0][0]). The robot tries to move to the&nbsp;bottom-right corner&nbsp;(i.e.,&nbsp;grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers&nbsp;m&nbsp;and&nbsp;n, return&nbsp;the number of possible unique paths that the robot can take to reach the bottom-right corner.The test cases are generated so that the answer will be less than or equal to&nbsp;2 * 109.Example 1:<br><img alt=\"robot_maze.png\" src=\"images/robot_maze.png\" target=\"_self\">Input: m = 3, n = 7\nOutput: 28Example 2:Input: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner 1. Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right\n3. Down -&gt; Right -&gt; Down#include &lt;vector&gt; class Solution {\npublic: int uniquePaths(int m, int n) { // dp 초기화 std::vector&lt;std::vector&lt;int&gt;&gt; dp(m, std::vector&lt;int&gt;(n,1)); for (std::vector&lt;std::vector&lt;int&gt;&gt;::size_type r = 1; r &lt; dp.size(); ++r) { for (std::vector&lt;int&gt;::size_type c = 1; c &lt; dp[r].size(); ++c) { dp[r][c] = dp[r-1][c] + dp[r][c-1]; } } return dp[m-1][n-1]; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"images/robot_maze.png","fullURL":"algorithm/leetcode/62.-unique-paths.html","pathToRoot":"../..","attachments":["images/robot_maze.html"],"createdTime":1736064680155,"modifiedTime":1737702331785,"sourceSize":1322,"sourcePath":"Algorithm/LeetCode/62. Unique Paths.md","exportPath":"algorithm/leetcode/62.-unique-paths.html","showInTree":true,"treeOrder":9,"backlinks":[],"type":"markdown"},"algorithm/leetcode/70.-climbing-stair.html":{"title":"70. Climbing Stair","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:easy\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#easy\">#easy</a>You are climbing a staircase. It takes&nbsp;n&nbsp;steps to reach the top.Each time you can either climb&nbsp;1&nbsp;or&nbsp;2&nbsp;steps. In how many distinct ways can you climb to the top?Example 1:Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1 step + 1 step\n2 steps\nExample 2:Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1 step + 1 step + 1 step\n1 step + 2 steps\n2 steps + 1 step\nConstraints:\n1 &lt;= n &lt;= 45\n점화식으로 해결class Solution {\npublic: int climbStairs(int n) { if (n == 1) return 1; std::vector&lt;int&gt; dp { 1, 2 }; dp.reserve(n); for (int i = 2; i &lt; n; ++i) { dp.push_back(dp[i-1] + dp[i-2]); } return *(dp.end() - 1); }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Easy","level":4,"id":"Easy_0"}],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:easy"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/70.-climbing-stair.html","pathToRoot":"../..","attachments":[],"createdTime":1735919172876,"modifiedTime":1737702359498,"sourceSize":875,"sourcePath":"Algorithm/LeetCode/70. Climbing Stair.md","exportPath":"algorithm/leetcode/70.-climbing-stair.html","showInTree":true,"treeOrder":10,"backlinks":[],"type":"markdown"},"algorithm/leetcode/78.-subsets.html":{"title":"78. Subsets","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> Given an integer array&nbsp;nums&nbsp;of&nbsp;unique&nbsp;elements, return&nbsp;all possible&nbsp;subsets&nbsp;(the power set).The solution set&nbsp;must not&nbsp;contain duplicate subsets. Return the solution in&nbsp;any order.Constraints:\n1 &lt;= nums.length &lt;= 10\n-10 &lt;= nums[i] &lt;= 10\nAll the numbers of&nbsp;nums&nbsp;are&nbsp;unique.\n<br><img alt=\"subset_graph.png\" src=\"images/subset_graph.png\" target=\"_self\">class Solution {\npublic: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; curr; vector&lt;vector&lt;int&gt;&gt; result; dfs(nums, 0, curr, result); return result; } private: void dfs( vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; curr, vector&lt;vector&lt;int&gt;&gt;&amp; result) { result.push_back(curr); for(int i = start; i &lt; nums.size(); i++) { curr.push_back(nums[i]); dfs(nums, i+1, curr, result); curr.pop_back(); } }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Solution","level":4,"id":"Solution_0"}],"links":["?query=tag:algo","?query=tag:medium"],"author":"","coverImageURL":"images/subset_graph.png","fullURL":"algorithm/leetcode/78.-subsets.html","pathToRoot":"../..","attachments":["images/subset_graph.html"],"createdTime":1719241549696,"modifiedTime":1737702373256,"sourceSize":980,"sourcePath":"Algorithm/LeetCode/78. Subsets.md","exportPath":"algorithm/leetcode/78.-subsets.html","showInTree":true,"treeOrder":11,"backlinks":[],"type":"markdown"},"algorithm/leetcode/141.-linked-list-cycle.html":{"title":"141. Linked List Cycle","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:easy\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#easy\">#easy</a> class Solution {\npublic: bool hasCycle(ListNode *head) { ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) { return true; } } return false; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:easy"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/141.-linked-list-cycle.html","pathToRoot":"../..","attachments":[],"createdTime":1741189701486,"modifiedTime":1741189701486,"sourceSize":386,"sourcePath":"Algorithm/LeetCode/141. Linked List Cycle.md","exportPath":"algorithm/leetcode/141.-linked-list-cycle.html","showInTree":true,"treeOrder":12,"backlinks":[],"type":"markdown"},"algorithm/leetcode/143.-reorder-list.html":{"title":"143. Reorder List","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> class Solution {\npublic: void reorderList(ListNode* head) { if (!head || !head-&gt;next || !head-&gt;next-&gt;next) { return; } ListNode* slow = head; ListNode* fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } ListNode* mid = slow-&gt;next; slow-&gt;next = nullptr; ListNode* prev = nullptr; ListNode* curr = mid; while(curr != nullptr) { ListNode* next = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = next; } ListNode* secondHalf = prev; ListNode* first = head; ListNode* second = secondHalf; while(second) { ListNode* firstNext = first-&gt;next; ListNode* secondNext = second-&gt;next; first-&gt;next = second; second-&gt;next = firstNext; first = firstNext; second = secondNext; } }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/143.-reorder-list.html","pathToRoot":"../..","attachments":[],"createdTime":1741189701486,"modifiedTime":1741189701486,"sourceSize":1064,"sourcePath":"Algorithm/LeetCode/143. Reorder List.md","exportPath":"algorithm/leetcode/143.-reorder-list.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"markdown"},"algorithm/leetcode/152.-maximum-product-subarray.html":{"title":"152. Maximum Product Subarray","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> Given an integer array&nbsp;nums, find a&nbsp;subarray&nbsp;that has the largest product, and return&nbsp;the product.The test cases are generated so that the answer will fit in a&nbsp;32-bit&nbsp;integer.Example 1:Input: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.Example 2:Input: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.Constraints:\n1 &lt;= nums.length &lt;= 2 * 104\n-10 &lt;= nums[i] &lt;= 10\nThe product of any subarray of&nbsp;nums&nbsp;is&nbsp;guaranteed&nbsp;to fit in a&nbsp;32-bit&nbsp;integer.\n#include &lt;algorithm&gt;\n#include &lt;vector&gt; using namespace std; class Solution {\npublic: int maxProduct(vector&lt;int&gt; &amp;nums) { int res = *std::max_element(nums.begin(), nums.end()); int curMin = 1; int curMax = 1; for (auto n : nums) { if (n == 0) { curMin = 1; curMax = 1; continue; } int tempMax = curMax * n; int tempMin = curMin * n; curMax = max(tempMin, tempMax); curMax = max(curMax, n); curMin = min(tempMin, tempMax); curMin = min(curMin, n); res = max(curMax, res); } return res; }\n};\nvector를 순회한다.\n0을 제외한 아이템은 곱해서 min, max를 구한다.\n0인 경우는 min max를 1로 초기화 한다. (다음 아이템 반영)\nexample. [2. -5, -2]iter = 2\nmin: 2, max: 2, n = 2 iter = -5\nmin: -10, max: -10, n = -5\n최종: min: -10, max: -5 iter = -2\nmin: 10, max: 20, n = -2\n최종: min: -2, max: 20 result = 20.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:medium","?query=tag:blind75"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/152.-maximum-product-subarray.html","pathToRoot":"../..","attachments":[],"createdTime":1737458669761,"modifiedTime":1738476474319,"sourceSize":1622,"sourcePath":"Algorithm/LeetCode/152. Maximum Product Subarray.md","exportPath":"algorithm/leetcode/152.-maximum-product-subarray.html","showInTree":true,"treeOrder":14,"backlinks":[],"type":"markdown"},"algorithm/leetcode/198.-house-robber.html":{"title":"198. House Robber","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and&nbsp;it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array&nbsp;nums&nbsp;representing the amount of money of each house, return&nbsp;the maximum amount of money you can rob tonight&nbsp;without alerting the police.Example 1:Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.Example 2:Input: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.Constraints:\n1 &lt;= nums.length &lt;= 100\n0 &lt;= nums[i] &lt;= 400\n순회를 할 때 이 원소를 더할 것이냐, 더하지 않을 것이냐로 결정 -&gt; 하위 문제로 분할할 수 있음.rob[n]은 n까지의 최대값으로 정의\nrob[n] = max(rob[n-2] + arr[n], rob[n-1])\nclass Solution {\npublic: int rob(vector&lt;int&gt;&amp; nums) { int rob1 = 0; int rob2 = 0; for (int num : nums) { int temp = std::max(rob1 + num, rob2); rob1 = rob2; rob2 = temp; } return rob2; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/198.-house-robber.html","pathToRoot":"../..","attachments":[],"createdTime":1736174638171,"modifiedTime":1737702392885,"sourceSize":1496,"sourcePath":"Algorithm/LeetCode/198. House Robber.md","exportPath":"algorithm/leetcode/198.-house-robber.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"markdown"},"algorithm/leetcode/200.-number-of-islands.html":{"title":"200. Number of Islands","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> Given an&nbsp;m x n&nbsp;2D binary grid&nbsp;grid&nbsp;which represents a map of&nbsp;'1's (land) and&nbsp;'0's (water), return&nbsp;the number of islands.An&nbsp;island&nbsp;is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.Example 1:Input: grid = [\n[\"1\",\"1\",\"1\",\"1\",\"0\"],\n[\"1\",\"1\",\"0\",\"1\",\"0\"],\n[\"1\",\"1\",\"0\",\"0\",\"0\"],\n[\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1Example 2:Input: grid = [\n[\"1\",\"1\",\"0\",\"0\",\"0\"],\n[\"1\",\"1\",\"0\",\"0\",\"0\"],\n[\"0\",\"0\",\"1\",\"0\",\"0\"],\n[\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3Constraints:\nm == grid.length\nn == grid[i].length\n1 &lt;= m, n &lt;= 300\ngrid[i][j]&nbsp;is&nbsp;'0'&nbsp;or&nbsp;'1'.\n#include &lt;vector&gt;\n#include &lt;queue&gt; using namespace std; class Solution {\npublic: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { vector&lt;vector&lt;bool&gt;&gt; m(grid.size(), vector&lt;bool&gt;(grid[0].size(), false)); vector&lt;int&gt; dr = {-1, 1, 0, 0}; vector&lt;int&gt; dc = {0, 0 , -1, 1}; int result = 0; for (int i = 0; i &lt; grid.size(); ++i) { for (int j = 0; j &lt; grid[0].size(); ++j) { if (grid[i][j] == '1' &amp;&amp; m[i][j] == false) { queue&lt;pair&lt;int, int&gt;&gt; q; q.push({i,j}); m[i][j] = true; while (!q.empty()) { int r = q.front().first; int c = q.front().second; q.pop(); for (int k = 0; k &lt; 4; ++k) { int new_r = dr[k] + r; int new_c = dc[k] + c; if (new_r &gt;= 0 &amp;&amp; new_r &lt; grid.size() &amp;&amp; new_c &gt;= 0 &amp;&amp; new_c &lt; grid[0].size() &amp;&amp; m[new_r][new_c] == false) { m[new_r][new_c] = true; if (grid[new_r][new_c] == '1') { q.push({new_r, new_c}); } } } } ++result; } } } return result; }\n};\nclass Solution {\npublic: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { if (grid.empty() || grid[0].empty()) return 0; int rows = grid.size(); int cols = grid[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(cols, false)); static constexpr array&lt;pair&lt;int, int&gt;, 4&gt; d = { {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} }; auto bfs = [&amp;](int row, int col) { queue&lt;pair&lt;int, int&gt;&gt; q; q.push({row, col}); visited[row][col] = true; while (!q.empty()) { auto [r, c] = q.front(); q.pop(); for (const auto&amp; [dr, dc] : d) { int nr = r + dr; int nc = c+ dc; if (nr &gt;= 0 &amp;&amp; nr &lt; grid.size() &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; grid[0].size() &amp;&amp; !visited[nr][nc] &amp;&amp; grid[nr][nc] == '1') { visited[nr][nc] = true; q.push({nr, nc}); } } } }; int result = 0; for (int i = 0; i &lt; rows; ++i) { for (int j = 0; j &lt; cols; ++j) { if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) { bfs(i,j); ++result; } } } return result; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/200.-number-of-islands.html","pathToRoot":"../..","attachments":[],"createdTime":1736697355570,"modifiedTime":1737702401027,"sourceSize":3707,"sourcePath":"Algorithm/LeetCode/200. Number of Islands.md","exportPath":"algorithm/leetcode/200.-number-of-islands.html","showInTree":true,"treeOrder":16,"backlinks":[],"type":"markdown"},"algorithm/leetcode/206.-reverse-linked-list.html":{"title":"206. Reverse Linked List","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:easy\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#easy\">#easy</a>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */\nclass Solution {\npublic: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while(curr != nullptr) { ListNode* next = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = next; } return prev; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:blind75","?query=tag:easy"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/206.-reverse-linked-list.html","pathToRoot":"../..","attachments":[],"createdTime":1741189701486,"modifiedTime":1741189701487,"sourceSize":632,"sourcePath":"Algorithm/LeetCode/206. Reverse Linked List.md","exportPath":"algorithm/leetcode/206.-reverse-linked-list.html","showInTree":true,"treeOrder":17,"backlinks":[],"type":"markdown"},"algorithm/leetcode/217.-contains-duplicate.html":{"title":"217. Contains Duplicate","icon":"","description":"<a href=\".?query=tag:alog\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#alog\">#alog</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> Given an integer array&nbsp;nums, return&nbsp;true&nbsp;if any value appears&nbsp;at least twice&nbsp;in the array, and return&nbsp;false&nbsp;if every element is distinct.Example 1:Input: nums = [1,2,3,1]\nOutput: trueExample 2:Input: nums = [1,2,3,4]\nOutput: falseExample 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: trueConstraints:\n1 &lt;= nums.length &lt;= 105\n-109&nbsp;&lt;= nums[i] &lt;= 109 class Solution {\npublic: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { std::set&lt;int&gt; s(nums.begin(), nums.end()); return s.size() != nums.size(); }\n}; ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:alog","?query=tag:blind75","?query=tag:medium"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/217.-contains-duplicate.html","pathToRoot":"../..","attachments":[],"createdTime":1719241549696,"modifiedTime":1737702408185,"sourceSize":658,"sourcePath":"Algorithm/LeetCode/217. Contains Duplicate.md","exportPath":"algorithm/leetcode/217.-contains-duplicate.html","showInTree":true,"treeOrder":18,"backlinks":[],"type":"markdown"},"algorithm/leetcode/271.-encode-and-decode-strings.html":{"title":"271. Encode and Decode Strings","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.Please implement&nbsp;encode&nbsp;and&nbsp;decodeExample 1:Input: [\"neet\",\"code\",\"love\",\"you\"] Output:[\"neet\",\"code\",\"love\",\"you\"]\nExample 2:Input: [\"we\",\"say\",\":\",\"yes\"] Output: [\"we\",\"say\",\":\",\"yes\"]\nConstraints:\n0 &lt;= strs.length &lt; 100\n0 &lt;= strs[i].length &lt; 200\nstrs[i]&nbsp;contains only UTF-8 characters.\n이 문제는 인코딩과 디코딩을 디자인하는 문제다. 평소에 푸는 PS와 좀 다른 스타일의 문제였다. 특징은 시간 복잡도는 이여야 하고, 공간 복잡도는 이여야 한다. 그래서 저장하는 멤버변수를 사용할 수 없다. #include &lt;vector&gt;\nusing namespace std; class Solution {\npublic: string encode(vector&lt;string&gt;&amp; strs) { string res; for (const auto&amp; c : strs) { res += to_string(c.size()) + \"#\" + c; } return res; } vector&lt;string&gt; decode(string s) { vector&lt;string&gt; res; int i = 0; while(i &lt; s.size()) { int j = i; while(s[j] != '#') { ++j; } int len = stoi(s.substr(i, j-i)); string sub = s.substr(j+1, len); res.push_back(sub); i = j + len + 1; } return res; }\n}; stoi(), substr 사용 방법을 숙지할 수 있었다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:medium","?query=tag:blind75"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/271.-encode-and-decode-strings.html","pathToRoot":"../..","attachments":[],"createdTime":1737280427455,"modifiedTime":1737702411256,"sourceSize":1553,"sourcePath":"Algorithm/LeetCode/271. Encode and Decode Strings.md","exportPath":"algorithm/leetcode/271.-encode-and-decode-strings.html","showInTree":true,"treeOrder":19,"backlinks":[],"type":"markdown"},"algorithm/leetcode/424.-longest-repeating-character-replacement.html":{"title":"424. Longest Repeating Character Replacement","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:medium\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#medium\">#medium</a> <a href=\".?query=tag:blind75\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#blind75\">#blind75</a> You are given a string&nbsp;s&nbsp;and an integer&nbsp;k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most&nbsp;k&nbsp;times.Return&nbsp;the length of the longest substring containing the same letter you can get after performing the above operations.Example 1:Input: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.Example 2:Input: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.Constraints:\n1 &lt;= s.length &lt;= 105\ns&nbsp;consists of only uppercase English letters.\n0 &lt;= k &lt;= s.length\n못풀었다. 문제를 봤을 때 슬라이딩 윈도우일 것 같긴 했는데 조건을 생각하지 못했다.window size - max_count &gt; k 를 생각했어야 했다. 이걸 떠올리지 못한 이유가 무엇일까라고 생각해봤을 때, 빈도수 관리를 떠올리지 못해서 그런가 싶다.max_count 최적화에 대한 문제가 있는데 이해하면 간단하지만 이해가 쉽지 않았다. 이해를 힘들게 했는데 댓글을 보니 저렇게 생각하면 더 쉽게 이해할 수 있었을 것 같다.For those who are struggling to understand the optimisation with maxf, here is how i understood it: For a substring to be valid, we need window_length - maxf &lt;= k. Here, maxf is the frequency of the most common character in the current window. The difference window_length - maxf tells us how many characters we'd need to change to make the whole window the same character. The biggest valid substring we can get is of size maxf + k. So, the larger maxf is, the better. If maxf doesn't change or goes down, our potential best answer doesn't change. We don't need to update maxf in this case. On the other hand, if maxf goes up, it means we've found a character in the current window that appears more often than in previous windows. This means we might be able to get a longer valid substring, so we update maxf. Hope this helps! And thank you neetcode for the wonderful video as always.\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\nusing namespace std; class Solution {\npublic: int characterReplacement(string s, int k) { unordered_map&lt;char, int&gt; countmap; int res = 0; int l = 0; for (int r = 0; r &lt; s.size(); ++r) { countmap[s[r]] = 1 + countmap[s[r]]; while((r - l + 1) - most_frequent(countmap) &gt; k) { countmap[s[l]] = countmap[s[l]] - 1; l += 1; } res = max(res, r - l + 1); } } int characterReplacement_opt(string s, int k) { unordered_map&lt;char, int&gt; countmap; int l = 0; int max_len = 0; int max_count = 0; for (int r = 0; r &lt; s.size(); ++r) { countmap[s[r]] = countmap[s[r]] + 1; max_count = max(max_count, countmap[s[r]]); while((r - l + 1) - max_count &gt; k) { countmap[s[l]] = countmap[s[l]] - 1; l += 1; } max_len = max(max_len, r-l+1); } return max_len; } int most_frequent(unordered_map&lt;char, int&gt;&amp; m) { int frequent = 0; for (auto&amp; [k, v] : m) { frequent = max(frequent, v); } }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:algo","?query=tag:medium","?query=tag:blind75"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/424.-longest-repeating-character-replacement.html","pathToRoot":"../..","attachments":[],"createdTime":1736945531620,"modifiedTime":1737702414822,"sourceSize":3596,"sourcePath":"Algorithm/LeetCode/424. Longest Repeating Character Replacement.md","exportPath":"algorithm/leetcode/424.-longest-repeating-character-replacement.html","showInTree":true,"treeOrder":20,"backlinks":[],"type":"markdown"},"algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html":{"title":"3405. Count the Number of Arrays with K Matching Adjacent Elements","icon":"","description":"<a href=\".?query=tag:algo\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#algo\">#algo</a> <a href=\".?query=tag:hard\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#hard\">#hard</a>2단계로 접근해야 문제를 쉽게(?) 풀 수 있음. 한번에 하려고 하면 무슨 말인지 이해가 안가서 2단계로 나눠야함.조건 Exactly k indices i (where 1 &lt;= i &lt; n) satisfy the condition arr[i-1] == arr[i]\n를 만족하려면 경계가 있어야함. 사이즈가 n이라면 공간은 n-1개가 있고 이 n-1개의 공간에 막대기를 놓는걸로 생각할 수 있음.k가 작아지면 그룹 개수는 커진다. (연속된 수가 없이 잘려야 하므로) k가 커지면 그룹 개수는 작아진다. (연속된 수 그룹이 있으니)만약 n = 6, k = 3 이라면 공간은 n-1 = 5개가 있고, 막대기는 n-k-1 (6-3-1) 즉 공간이 3개가 됨.\nxx | yy | xx\nxxx | y | x 등등\n만약 n = 6이고, k = 2라면 막대기를 n-k-1 (6-2-1)개 즉 공간은 4개\nxx | yy | x | y 등등\n막대기의 개수는 n-k-1핵심 원리는 그룹 길이와 매치 개수의 관계를 생각하면 된다.길이 1: [a] → 0개 매치 길이 2: [a,a] → 1개 매치 길이 3: [a,a,a] → 2개 매치 길이 4: [a,a,a,a] → 3개 매치\n전체 매치 개수(k) = n - 그룹 개수그룹 개수 = n - k\n막대기 개수는 n-k-1그러면 총 n-1개의 공간에서 n-k-1개의 막대기를 놓는 경우의 수를 구하는 것이기 때문에 조합!조합식 C(n-1, n-k-1)인데 조합의 대칭성을 이용해 C(n-1, k)를 구할 수 있음 (C(n,r) = C(n, n-r)과 같음)\nxx에는 1 ~ m 까지의 숫자 선택 가능 (m option)\nyy에는 앞에 들어간 수(xx) 제외하고 선택 가능 (m-1 option)\nxx에는 앞에 들어간 수(yy) 제외하고 선택 가능 (m-1 option)\n그럼 답은? C(n-1, k) m (m - 1) * (m-1)일반화 하면 답은 C(n-1, k) m (m-1)^(n-k-1)하지만 C(n-1, k) m (m-1)^(n-k-1)는 매우 큼. 그래서 나머지 연산을 통해서 리턴을 해야함.{C(n-1, k) m (m-1)^(n-k-1) } % MOD는 분배법칙에 의하여{C(n-1, k) m (m-1)^(n-k-1) } % MOD = { (C(n-1,k) % MOD) × (m % MOD) × (pow((m-1), n-k-1) % MOD) } % MOD가 성립함.나머지 연산은 곱셈에 대한 분배 법칙이 성립하기 때문이다.따라서 일단 값을 구해보자 C(n-1, k) * MOD\nm * MOD\npow(m-1, n-k-1) % MOD\n2번은 그냥 값이 나오고, 3번은 pow(m-1, n-k-1)을 구해야 하는데 그냥 무턱대고 pow를 하면 값을 초과해버린다.double pow(double x, double y);\nfloat powf(float x, float y);\nlong double powl(long double x, long double y);\n그래서 만들어줘야한다. 비트 연산을 해서 계속 MOD를 통해서 overflow를 방지해야한다. long long power(long long base, long long exp) { long long result = 1; base %= MOD; while (exp &gt; 0) { if (exp &amp; 1) result = (result * base) % MOD; base = (base * base) % MOD; exp &gt;&gt;= 1; } return result; }\n그러면 2번과 3번은 해결한거고 문제는 조합에 모듈러 연산을 적용 하는것이다.모듈러 연산은 나눗셈에 대해서 분배법칙이 성립하지 않는다. 따라서 나눗셈을 곱셈으로 바꿔줘야한다. Modular Inverse (모듈러 역원)을 이용해서 변형할 수 있다.Modular Inverse란? b⁻¹는 (b × b⁻¹) % MOD = 1이 되는 수다.MOD = 7일 때, 3의 역원은?\n3 × ? ≡ 1 (mod 7)\n3 × 5 = 15 ≡ 1 (mod 7)\n따라서 3⁻¹ = 5\n이 모듈러 역원을 구하는 방법이 페르마 소정리다.p가 소수일 때: a⁻¹ ≡ a^(p-2) (mod p)\n조합을 구하는 방법 C(n ,r) = n! / (r! * (n-r)!)이다.\b분모와 분자를 따로 구한 후에 분모에 Modular 역원을 구해주면 된다.그러면 1번 식도 구할 수 있게 된다.최종적으로 1번 * 2번 * 3번 * MOD 를 해주면 된다. 그리고 값이 초과할 것 같은 곳에서도 MOD 처리를 한다.class Solution {\npublic: static const long long MOD = 1e9 + 7; long long factorial(int n) { long long result = 1; for (int i = 2; i &lt;= n; i++) { result *= i; } return result; } long long combination(int n, int r) { if (r &gt; n || r &lt; 0) return 0; return factorial(n) / (factorial(r) * factorial(n - r)); } // pow는 long long을 초과함. 그래서 long long을 리턴하는 pow를 제작해야함. long long power(long long base, long long exp) { long long result = 1; while (exp &gt; 0) { if (exp &amp; 1) result = (result * base) % MOD; base = (base * base) % MOD; exp &gt;&gt;= 1; } return result; } long long modInverse(long long a) { return power(a, MOD - 2); } long long combination2(long long n, long long r) { if (r &gt; n || r &lt; 0) return 0; if (r == 0 || r == n) return 1; long long numerator = 1; long long denominator = 1; for (long long i = 0; i &lt; r; i++) { numerator = (numerator * (n - i)) % MOD; denominator = (denominator * (i + 1)) % MOD; } return (numerator * modInverse(denominator)) % MOD; } int countGoodArrays(int n, int m, int k) { /* Exactly k indices i (where 1 &lt;= i &lt; n) satisfy the condition arr[i - 1] == arr[i] 를 만족하려면 경계가 있어야함. 사이즈가 n이라면 공간은 n-1개가 있고, 이 n-1개의 공간에 막대기를 놓는걸로 생각할 수 있음. 1. 그룹 나누기 k가 작아지면 그룹 개수는 커진다. (연속된 수가 없이 잘려야 하므로) k가 커지면 그룹 개수는 작아진다. (연속된 수 그룹이 있으니) if n = 6, k = 3 이라면 공간은 n-1 = 5개가 있고, 막대기는 n-k-1 (6-3-1) 즉 공간이 3개가 됨. xx | yy | xx xxx | y | x 등등 if n = 6이고, k = 2라면 막대기를 n-k-1 (6-2-1)개 즉 공간은 4개 xx | yy | x | y 막대기의 개수는 n-k-1 즉 조합식 C(n-1, n-k-1)인데 조합의 대칭성을 이용해 C(n-1, k)를 구할 수 있음 그럼 xx | yy | xx가 있다고 생각할 때 2. 값을 할당하기 xx에는 1 ~ m 까지의 숫자 선택 가능 (m option) yy에는 앞에 들어간 수(xx) 제외하고 선택 가능 (m-1 option) xx에는 앞에 들어간 수(yy) 제외하고 선택 가능 (m-1 option) 그럼 답은? C(n-1, k) * m * (m - 1) * (m-1) 일반화 한다면? n-k-1 개의 막대기는 n-k개의 그룹 n-k개의 그룹 -&gt; 처음은 m개 그 이후는 m-1개 이게 총 갯수 C(n-1, k) * m * (m-1)^(n-k-1) {C(n-1, k) * m * (m-1)^(n-k-1) } % MOD 분배법칙에 의하여 { (C(n-1,k) % MOD) × (m % MOD) × (pow((m-1), n-k-1) % MOD) } % MOD */ long long comb = combination2(n-1, k) % MOD; long long m_mod = m % MOD; long long power_mod = power(m-1, n-k-1) % MOD; return (comb * m_mod % MOD) * power_mod % MOD; }\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1단계 - 그룹 나누기","level":4,"id":"1단계_-_그룹_나누기_0"},{"heading":"2단계 - 값을 할당하기","level":4,"id":"2단계_-_값을_할당하기_0"},{"heading":"source code","level":4,"id":"source_code_0"}],"links":["?query=tag:algo","?query=tag:hard"],"author":"","coverImageURL":"","fullURL":"algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html","pathToRoot":"../..","attachments":[],"createdTime":1750168435995,"modifiedTime":1750171108266,"sourceSize":7393,"sourcePath":"Algorithm/LeetCode/3405. Count the Number of Arrays with K Matching Adjacent Elements.md","exportPath":"algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html","showInTree":true,"treeOrder":21,"backlinks":[],"type":"markdown"},"algorithm/study/dp.html":{"title":"DP","icon":"","description":"\nTop down -&gt; 재귀\nBottom up -&gt; 배열 작은 상황을 이용해서 큰 상황을 구할 때 dp[n]을 잘 정의하는 것\n관계식, 점화식 잘 세우기\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"dp 문제 푸는 Tip","level":4,"id":"dp_문제_푸는_Tip_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/dp.html","pathToRoot":"../..","attachments":[],"createdTime":1724571717940,"modifiedTime":1735553971555,"sourceSize":202,"sourcePath":"Algorithm/Study/DP.md","exportPath":"algorithm/study/dp.html","showInTree":true,"treeOrder":23,"backlinks":[],"type":"markdown"},"algorithm/study/heap-&-우선순위-큐.html":{"title":"Heap & 우선순위 큐","icon":"","description":"완전 이진 트리의 일종으로 두가지 조건 충족\n완전 이진 트리\n최대 힙 (부모 노드값 &gt; 자식 노드값) , 최소 힙 (부모 노드 값 &lt; 자식 노드값)\n우선순위 큐는 각 요소가 우선순위를 가지고 있으며, 우선순위가 높은 요소가 먼저 나가는 특수한 큐\n힙을 사용하여 효율적으로 구현 가능\n삽입 - 새로운 요소를 힙의 마지막에 추가한 후 힙 정렬\n삭제 - 힙의 루트 요소를 제거 하고 마지막 요소를 루트로 이동시킨 후 힙 정렬 삽입: O(log n)\n삭제 (Olog n)\n탐색 (루트 요소 확인): O(1)\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; heap = {10, 20, 30, 5, 15}; // 힙으로 변환 std::make_heap(heap.begin(), heap.end()); std::cout &lt;&lt; \"Initial max-heap: \"; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; // 힙에 요소 추가 heap.push_back(99); std::push_heap(heap.begin(), heap.end()); std::cout &lt;&lt; \"After adding an element: \"; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; // 힙에서 최대 요소 제거 std::pop_heap(heap.begin(), heap.end()); heap.pop_back(); std::cout &lt;&lt; \"After removing the max element: \"; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; return 0;\n}\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt; int main() { std::priority_queue&lt;int&gt; pq; // 아래처럼 생성하면 최소힙 // std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; min_pq; // 요소 삽입 pq.push(10); pq.push(20); pq.push(30); pq.push(5); pq.push(15); std::cout &lt;&lt; \"Priority queue elements: \"; while (!pq.empty()) { std::cout &lt;&lt; pq.top() &lt;&lt; \" \"; pq.pop(); } std::cout &lt;&lt; std::endl; return 0;\n}\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt; struct Task { int priority; std::string description; // 커스텀 비교 함수 (작은 값이 높은 우선순위) bool operator&lt;(const Task&amp; other) const { return priority &gt; other.priority; }\n}; int main() { std::priority_queue&lt;Task&gt; taskQueue; // 요소 삽입 taskQueue.push({1, \"Low priority task\"}); taskQueue.push({3, \"High priority task\"}); taskQueue.push({2, \"Medium priority task\"}); std::cout &lt;&lt; \"Tasks in priority order: \"; while (!taskQueue.empty()) { Task t = taskQueue.top(); std::cout &lt;&lt; \"(\" &lt;&lt; t.priority &lt;&lt; \", \" &lt;&lt; t.description &lt;&lt; \") \"; taskQueue.pop(); } std::cout &lt;&lt; std::endl; return 0;\n}\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt; class MaxHeap {\nprivate: std::vector&lt;int&gt; heap; void heapifyUp(int index) { while (index &gt; 0) { int parent = (index - 1) / 2; if (heap[index] &gt; heap[parent]) { std::swap(heap[index], heap[parent]); index = parent; } else { break; } } } void heapifyDown(int index) { int size = heap.size(); while (index * 2 + 1 &lt; size) { int left = index * 2 + 1; int right = index * 2 + 2; int largerChild = left; if (right &lt; size &amp;&amp; heap[right] &gt; heap[left]) { largerChild = right; } if (heap[index] &lt; heap[largerChild]) { std::swap(heap[index], heap[largerChild]); index = largerChild; } else { break; } } } public: void insert(int value) { heap.push_back(value); heapifyUp(heap.size() - 1); } int extractMax() { if (heap.empty()) { throw std::runtime_error(\"Heap is empty\"); } int maxValue = heap[0]; heap[0] = heap.back(); heap.pop_back(); heapifyDown(0); return maxValue; } void printHeap() { for (int value : heap) { std::cout &lt;&lt; value &lt;&lt; \" \"; } std::cout &lt;&lt; std::endl; } void preorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; \" \"; // 왼쪽 자식 노드 방문 preorderTraversal(2 * index + 1); // 오른쪽 자식 노드 방문 preorderTraversal(2 * index + 2); } void inorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 왼쪽 자식 노드 방문 inorderTraversal(2 * index + 1); // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; \" \"; // 오른쪽 자식 노드 방문 inorderTraversal(2 * index + 2); } void postorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 왼쪽 자식 노드 방문 postorderTraversal(2 * index + 1); // 오른쪽 자식 노드 방문 postorderTraversal(2 * index + 2); // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; \" \"; }\n}; int main() { MaxHeap heap; heap.insert(10); heap.insert(20); heap.insert(30); heap.insert(5); heap.insert(15); std::cout &lt;&lt; \"Heap elements: \"; heap.printHeap(); std::cout &lt;&lt; \"Preorder traversal: \"; heap.preorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"Inorder traversal: \"; heap.inorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"Postorder traversal: \"; heap.postorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; \"Extracted max: \" &lt;&lt; heap.extractMax() &lt;&lt; std::endl; std::cout &lt;&lt; \"Heap after extraction: \"; heap.printHeap(); return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Heap &amp; 우선순위 큐","level":1,"id":"Heap_&_우선순위_큐_0"},{"heading":"힙 Heap","level":2,"id":"힙_Heap_0"},{"heading":"우선순위 큐 Priority Queue","level":2,"id":"우선순위_큐_Priority_Queue_0"},{"heading":"STL 이용한 힙 &amp; 우선순위 큐 구현","level":4,"id":"STL_이용한_힙_&_우선순위_큐_구현_0"},{"heading":"우선순위 큐","level":5,"id":"우선순위_큐_0"},{"heading":"배열을 이용한 힙 구현","level":3,"id":"배열을_이용한_힙_구현_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/heap-&-우선순위-큐.html","pathToRoot":"../..","attachments":[],"createdTime":1720440755344,"modifiedTime":1735553976765,"sourceSize":6124,"sourcePath":"Algorithm/Study/Heap & 우선순위 큐.md","exportPath":"algorithm/study/heap-&-우선순위-큐.html","showInTree":true,"treeOrder":24,"backlinks":[],"type":"markdown"},"algorithm/study/two-pointer.html":{"title":"Two Pointer","icon":"","description":"\n두 개의 포인터를 사용하여 배열을 순회하면서 문제를 해결\n주로 배열이나 리스트와 같은 선형 자료구조를 다룰 때 사용\n시간 복잡도 O(n^2) -&gt; O(n)\n예시\n정렬된 배열에서 두 수의 합이 특정 값이 되는 쌍 찾기\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt; std::vector&lt;std::pair&lt;int, int&gt;&gt; findAllPairsWithSum(const std::vector&lt;int&gt;&amp; arr, int targetSum) { std::vector&lt;std::pair&lt;int, int&gt;&gt; result; int left = 0; int right = arr.size() - 1; while (left &lt; right) { int currentSum = arr[left] + arr[right]; if (currentSum == targetSum) { result.push_back({arr[left], arr[right]}); // 중복 원소 건너뛰기 while (left &lt; right &amp;&amp; arr[left] == arr[left + 1]) left++; while (left &lt; right &amp;&amp; arr[right] == arr[right - 1]) right--; left++; right--; } else if (currentSum &lt; targetSum) { left++; } else { right--; } } return result;\n} int main() { std::vector&lt;int&gt; sortedArray = {1, 2, 3, 4, 5, 5, 6, 7, 8, 9}; int target = 10; auto pairs = findAllPairsWithSum(sortedArray, target); if (!pairs.empty()) { std::cout &lt;&lt; \"합이 \" &lt;&lt; target &lt;&lt; \"인 모든 쌍:\" &lt;&lt; std::endl; for (const auto&amp; pair : pairs) { std::cout &lt;&lt; pair.first &lt;&lt; \", \" &lt;&lt; pair.second &lt;&lt; std::endl; } } else { std::cout &lt;&lt; \"합이 \" &lt;&lt; target &lt;&lt; \"인 쌍을 찾지 못했습니다.\" &lt;&lt; std::endl; } return 0;\n} 배열에서 중복 요소 제거\n#include &lt;iostream&gt;\n#include &lt;vector&gt; int removeDuplicates(std::vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int writePointer = 1; for (int readPointer = 1; readPointer &lt; nums.size(); readPointer++) { if (nums[readPointer] != nums[writePointer - 1]) { nums[writePointer] = nums[readPointer]; writePointer++; } } return writePointer;\n} int main() { std::vector&lt;int&gt; nums = {1, 1, 2, 2, 3, 4, 4, 5}; int newLength = removeDuplicates(nums); std::cout &lt;&lt; \"새로운 배열 길이: \" &lt;&lt; newLength &lt;&lt; std::endl; std::cout &lt;&lt; \"중복이 제거된 배열: \"; for (int i = 0; i &lt; newLength; i++) { std::cout &lt;&lt; nums[i] &lt;&lt; \" \"; } std::cout &lt;&lt; std::endl; return 0;\n} writePointer: 고유한 요소를 쓸 위치를 가리킴\nreadPointer: 배열을 순회하며 각 요소를 확인 readPointer가 새로운 요소를 발견하면, 그 요소를 writePointer 위치에 씀\n미리 readPointer가 들여다보고 중복여부 파악 후 쓸 지 결정 부분 배열의 합이 특정 값이 되는 구간 찾기 (정렬되어 있어야함)\n#include &lt;iostream&gt;\n#include &lt;vector&gt; std::pair&lt;int, int&gt; findSubarrayWithSum(const std::vector&lt;int&gt;&amp; nums, int targetSum) { int left = 0, right = 0; int currentSum = 0; while (right &lt; nums.size()) { currentSum += nums[right]; while (currentSum &gt; targetSum &amp;&amp; left &lt; right) { currentSum -= nums[left]; left++; } if (currentSum == targetSum) { return {left, right}; } right++; } return {-1, -1}; // 합이 targetSum인 부분 배열을 찾지 못한 경우\n} int main() { std::vector&lt;int&gt; nums = {1, 4, 20, 3, 10, 5}; int targetSum = 33; auto result = findSubarrayWithSum(nums, targetSum); if (result.first != -1) { std::cout &lt;&lt; \"합이 \" &lt;&lt; targetSum &lt;&lt; \"인 부분 배열을 찾았습니다: \"; std::cout &lt;&lt; \"인덱스 \" &lt;&lt; result.first &lt;&lt; \"부터 \" &lt;&lt; result.second &lt;&lt; \"까지\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"합이 \" &lt;&lt; targetSum &lt;&lt; \"인 부분 배열을 찾지 못했습니다.\" &lt;&lt; std::endl; } return 0;\n} left: 부분 배열의 시작을 가리킴.\nright: 부분 배열의 끝을 가리킴 현재 부분 배열의 합이 목표값보다 크면 left를 오른쪽으로 이동시켜 합을 줄이고, 작으면 right를 오른쪽으로 이동시켜 합을 늘림 펠린드롬\n#include &lt;iostream&gt;\n#include &lt;string&gt; bool isPalindrome(const std::string&amp; s) { int left = 0; int right = s.length() - 1; while (left &lt; right) { if (s[left] != s[right]) { return false; } left++; right--; } return true;\n} int main() { std::string str1 = \"racecar\"; std::string str2 = \"hello\"; std::cout &lt;&lt; str1 &lt;&lt; \" 은 팰린드롬\" &lt;&lt; (isPalindrome(str1) ? \"입니다.\" : \"이 아닙니다.\") &lt;&lt; std::endl; std::cout &lt;&lt; str2 &lt;&lt; \" 은 팰린드롬\" &lt;&lt; (isPalindrome(str2) ? \"입니다.\" : \"이 아닙니다.\") &lt;&lt; std::endl; return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Two Pointer","level":3,"id":"Two_Pointer_1"}],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/two-pointer.html","pathToRoot":"../..","attachments":[],"createdTime":1724571717940,"modifiedTime":1735554000945,"sourceSize":4954,"sourcePath":"Algorithm/Study/Two Pointer.md","exportPath":"algorithm/study/two-pointer.html","showInTree":true,"treeOrder":25,"backlinks":[],"type":"markdown"},"algorithm/study/누적합-알고리즘.html":{"title":"누적합 알고리즘","icon":"","description":"누적합(prefix sum) 알고리즘은 배열의 부분합을 빠르게 계산하는 데 사용되는 기법\n주어진 배열의 각 위치까지의 원소들의 합을 미리 계산해 놓는 방식\n원본 배열: A[1], A[2], ..., A[n]\n누적합 배열: S[i] = A[1] + A[2] + ... + A[i]\n시간 복잡도 전처리: O(n)\n구간 합 쿼리: O(1) 특정 구간 [L, R]의 합을 S[R] - S[L-1]로 O(1) 시간에 계산 가능\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/누적합-알고리즘.html","pathToRoot":"../..","attachments":[],"createdTime":1722252321633,"modifiedTime":1722252599292,"sourceSize":444,"sourcePath":"Algorithm/Study/누적합 알고리즘.md","exportPath":"algorithm/study/누적합-알고리즘.html","showInTree":true,"treeOrder":26,"backlinks":[],"type":"markdown"},"algorithm/study/문제유형.html":{"title":"문제유형","icon":"","description":"\n<a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/two-sum/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/two-sum/\" target=\"_self\">LeetCode #1: Two Sum</a> (Easy) 핵심 개념: 해시맵 활용\n목표 시간: 15분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_self\">LeetCode #121: Best Time to Buy and Sell Stock</a> (Easy) 핵심 개념: 한 번 순회, 최소값 갱신\n목표 시간: 15분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/3sum/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/3sum/\" target=\"_self\">LeetCode #15: 3Sum</a> (Medium) 핵심 개념: 투 포인터 기법\n목표 시간: 25분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/contains-duplicate/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/contains-duplicate/\" target=\"_self\">LeetCode #217: Contains Duplicate</a> (Easy) 핵심 개념: 해시셋 활용\n목표 시간: 10분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/valid-anagram/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/valid-anagram/\" target=\"_self\">LeetCode #242: Valid Anagram</a> (Easy) 핵심 개념: 빈도수 세기\n목표 시간: 15분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/group-anagrams/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/group-anagrams/\" target=\"_self\">LeetCode #49: Group Anagrams</a> (Medium) 핵심 개념: 해시맵으로 그룹화\n목표 시간: 20분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/flood-fill/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/flood-fill/\" target=\"_self\">LeetCode #733: Flood Fill</a> (Easy) 핵심 개념: DFS 기본\n목표 시간: 20분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/number-of-islands/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/number-of-islands/\" target=\"_self\">LeetCode #200: Number of Islands</a> (Medium) 핵심 개념: DFS/BFS 응용\n목표 시간: 25분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/rotting-oranges/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/rotting-oranges/\" target=\"_self\">LeetCode #994: Rotting Oranges</a> (Medium) 핵심 개념: BFS 응용, 레벨 순회\n목표 시간: 30분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/binary-search/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/binary-search/\" target=\"_self\">LeetCode #704: Binary Search</a> (Easy) 핵심 개념: 기본 이진 탐색\n목표 시간: 10분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/search-insert-position/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/search-insert-position/\" target=\"_self\">LeetCode #35: Search Insert Position</a> (Easy) 핵심 개념: 이진 탐색 변형\n목표 시간: 15분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/\" target=\"_self\">LeetCode #33: Search in Rotated Sorted Array</a> (Medium) 핵심 개념: 이진 탐색 응용\n목표 시간: 25분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/climbing-stairs/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/climbing-stairs/\" target=\"_self\">LeetCode #70: Climbing Stairs</a> (Easy) 핵심 개념: 기본 DP, 피보나치 수열\n목표 시간: 15분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/maximum-subarray/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/maximum-subarray/\" target=\"_self\">LeetCode #53: Maximum Subarray</a> (Easy) 핵심 개념: 카데인 알고리즘, 1D DP\n목표 시간: 20분 <br><a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/coin-change/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/coin-change/\" target=\"_self\">LeetCode #322: Coin Change</a> (Medium) 핵심 개념: 1D DP 응용\n목표 시간: 25분 // 그래프 탐색 (DFS) - 재귀\nvoid dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int rows, int cols) { if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || grid[i][j] == 0) { return; } grid[i][j] = 0; // 방문 표시 // 4방향 탐색 dfs(grid, i+1, j, rows, cols); dfs(grid, i-1, j, rows, cols); dfs(grid, i, j+1, rows, cols); dfs(grid, i, j-1, rows, cols);\n} // 그래프 탐색 (BFS)\nvoid bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int rows, int cols) { queue&lt;pair&lt;int, int&gt;&gt; q; q.push({i, j}); grid[i][j] = 0; // 방문 표시 vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; while (!q.empty()) { auto [r, c] = q.front(); q.pop(); for (auto [dr, dc] : dirs) { int nr = r + dr, nc = c + dc; if (nr &gt;= 0 &amp;&amp; nr &lt; rows &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; cols &amp;&amp; grid[nr][nc] == 1) { q.push({nr, nc}); grid[nr][nc] = 0; // 방문 표시 } } }\n} // 이진 탐색\nint binarySearch(vector&lt;int&gt;&amp; nums, int target) { int left = 0, right = nums.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; // 찾지 못함\n} // 투 포인터\nvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; map; for (int i = 0; i &lt; nums.size(); i++) { int complement = target - nums[i]; if (map.count(complement)) { return {map[complement], i}; } map[nums[i]] = i; } return {};\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"배열/문자열 조작","level":3,"id":"배열/문자열_조작_0"},{"heading":"해시 테이블 활용","level":3,"id":"해시_테이블_활용_0"},{"heading":"DFS/BFS 그래프 탐색","level":3,"id":"DFS/BFS_그래프_탐색_0"},{"heading":"이진 탐색/투 포인터","level":3,"id":"이진_탐색/투_포인터_0"},{"heading":"동적 프로그래밍 기초","level":3,"id":"동적_프로그래밍_기초_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/문제유형.html","pathToRoot":"../..","attachments":[],"createdTime":1742565162943,"modifiedTime":1742617487893,"sourceSize":4387,"sourcePath":"Algorithm/Study/문제유형.md","exportPath":"algorithm/study/문제유형.html","showInTree":true,"treeOrder":27,"backlinks":[],"type":"markdown"},"algorithm/study/이분탐색-&-파라메트릭-서치.html":{"title":"이분탐색 & 파라메트릭 서치","icon":"","description":"이분 탐색(Binary Search)은 정렬된 배열에서 특정 값을 찾는 효율적인 알고리즘\n시간 복잡도는 O(log n)으로, 선형 검색보다 훨씬 빠릅니다.이분 탐색의 기본 원리는 다음과 같습니다:\n배열의 중간 원소를 선택\n중간 원소와 찾고자 하는 값을 비교\n찾고자 하는 값이 중간 원소보다 작으면 왼쪽 부분 배열을 탐색하고, 크면 오른쪽 부분 배열을 탐색\n찾고자 하는 값을 찾을 때까지 또는 더 이상 탐색할 수 없을 때까지 이 과정을 반복\n#include &lt;iostream&gt;\n#include &lt;vector&gt; int binarySearch(const std::vector&lt;int&gt;&amp; arr, int target) { int left = 0; int right = arr.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; // 타겟을 찾았을 때 인덱스 반환 } else if (arr[mid] &lt; target) { left = mid + 1; // 오른쪽 부분 배열 탐색 } else { right = mid - 1; // 왼쪽 부분 배열 탐색 } } return -1; // 타겟을 찾지 못했을 때\n} int main() { std::vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11, 13, 15}; int target = 7; int result = binarySearch(arr, target); if (result != -1) { std::cout &lt;&lt; \"타겟 \" &lt;&lt; target &lt;&lt; \"은 인덱스 \" &lt;&lt; result &lt;&lt; \"에 있습니다.\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"타겟 \" &lt;&lt; target &lt;&lt; \"을 찾을 수 없습니다.\" &lt;&lt; std::endl; } return 0;\n}\n파라메트릭 서치(Parametric Search)는 최적화 문제를 해결하는 알고리즘 기법입니다. 주로 이분 탐색(Binary Search)을 응용하여 연속적인 값에 대한 결정 문제를 해결하는 데 사용됩니다.파라메트릭 서치의 주요 특징:\n최적화 문제를 결정 문제로 변환: \"최댓값을 찾아라\" 같은 최적화 문제를 \"이 값이 가능한가?\" 같은 결정 문제로 바꿉니다.\n이분 탐색 활용: 가능한 해의 범위를 이분 탐색으로 좁혀가며 최적해를 찾습니다.\n연속적인 값에 적용: 정수뿐만 아니라 실수 값에 대해서도 사용할 수 있습니다.\n효율성: O(log N) 시간 복잡도로 최적해를 찾을 수 있습니다.\n파라메트릭 서치의 일반적인 절차:\n문제의 답이 될 수 있는 범위를 정합니다.\n그 범위의 중간값에 대해 결정 문제를 해결합니다.\n결과에 따라 탐색 범위를 반으로 줄입니다.\n원하는 정확도에 도달할 때까지 2-3 과정을 반복합니다.\n파라메트릭 서치는 다양한 최적화 문제에 적용할 수 있습니다. 예를 들어, 특정 조건을 만족하는 최대 또는 최소값을 찾는 문제, 이진 탐색으로 해결할 수 있는 결정 문제 등에 활용됩니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"이분탐색 &amp; 파라메트릭 서치","level":1,"id":"이분탐색_&_파라메트릭_서치_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/이분탐색-&-파라메트릭-서치.html","pathToRoot":"../..","attachments":[],"createdTime":1722252335588,"modifiedTime":1722253810939,"sourceSize":2877,"sourcePath":"Algorithm/Study/이분탐색 & 파라메트릭 서치.md","exportPath":"algorithm/study/이분탐색-&-파라메트릭-서치.html","showInTree":true,"treeOrder":28,"backlinks":[],"type":"markdown"},"algorithm/study/코딩테스트를-위한-암기.html":{"title":"코딩테스트를 위한 암기","icon":"","description":"코딩테스트 때 cpp reference를 제공해주는 몰라서 헷갈리는 거 간단하게 메모sort(A.begin(), A.end(), [](int a, int b) { return a &lt; b;}); //오름차순\nsort(B.begin(), B.end(), [](int a, int b) { return a &gt; b;}); // 내림차순 std::partial_sort(start, middle, end) // 일부 정렬\n// 전체에서 가장 작은 애들만 순서대로 저장하고 나머지 위치는 상관없이 저장\nstd::partial_sort(vec.begin(), vec.begin() + 3, vec.end()); //제거 // first부터 last 사이에 있는 원소 지움\nIterator erase(Iterator first, Iterator last);\n// 3인 걸 지워라\nvec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());\n// 조건인걸 지워라 - std::remove_if(vec.begin(), vec.end(), 람다) find, find_if도 erase 같음 // 0 을 10 개 가지는 벡터 생성\nstd::vector&lt;int&gt; vec(10, 0); // Ten zeros로 외우자!!\nstd::stack&lt;type&gt; stk; // stack은 그냥 이렇게 초기화 컨테이너로 초기화 하는 방법은 굳이? stk.push();\nstk.pop(); // return void;\nstk.top();\nstk.empty();\nstk.size(); // 길이 return size_t\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"알고리즘 헤더","level":3,"id":"알고리즘_헤더_0"},{"heading":"vector","level":3,"id":"vector_0"},{"heading":"stack","level":3,"id":"stack_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"algorithm/study/코딩테스트를-위한-암기.html","pathToRoot":"../..","attachments":[],"createdTime":1742305069535,"modifiedTime":1742306811370,"sourceSize":1172,"sourcePath":"Algorithm/Study/코딩테스트를 위한 암기.md","exportPath":"algorithm/study/코딩테스트를-위한-암기.html","showInTree":true,"treeOrder":29,"backlinks":[],"type":"markdown"},"android/wifi-util-class.html":{"title":"Wifi Util Class","icon":"","description":"\nAndroid 10부터 도입된 WifiNetworkSpecifier를 이용한 Wifi는 보통 Ephemeral임.\n안드로이드 OS는 네트워크로 인터넷이 안될 것 같다고 판단하면 우선순위 낮춤 -&gt; 이 네트워크를 기본 라우트로 삼지 않게 됨 기본 라우트가 아니면 OS는 패킷을 LTE나 기존 Wi-fi 쪽으로 보내려고 시도\n즉 에페메럴 Wifi로는 도달 불가능 -&gt; TCP 연결 실패\nbindProcessToNetwork(network)를 통해서 앱 전체 프로세스가 내보내는 트래픽은 네트워크로 보내도록 설정 -&gt; TCP 연결 성공소켓 단위 바인딩 (bindSocket)을 이용하면 다른 통신은 기존 네트워크를 그대로 쓰면서, 특정 소켓은에페메럴 Wi-fi를 이용할 수 있음","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Ephemeral Wifi","level":4,"id":"Ephemeral_Wifi_0"},{"heading":"기본 라우트가 아니면 TCP 연결이 실패하는 이유","level":4,"id":"기본_라우트가_아니면_TCP_연결이_실패하는_이유_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"android/wifi-util-class.html","pathToRoot":"..","attachments":[],"createdTime":1739278204978,"modifiedTime":1739281293005,"sourceSize":850,"sourcePath":"Android/Wifi Util Class.md","exportPath":"android/wifi-util-class.html","showInTree":true,"treeOrder":31,"backlinks":[],"type":"markdown"},"android/인앱-결제.html":{"title":"인앱 결제","icon":"","description":"안드로이드 인앱결제 플로우 구글 결제 서비스 연결 - Start Connection 연결 확인 - IsReady 상품 조회 - QuerySkuDetail 구매시작 - LaunchBillingFlow 구매 후 처리 AcknowledgePurchase - Google에 구매 승인 통지\nConsume - 소모성 아이템 소비 처리 상태확인 - QueryPurchases 보통 플로우는 아래처럼 되어야 함.1. [클라이언트] StartConnection() → Google Play 연결\n2. [클라이언트] QuerySkuDetails() → 상품 정보 조회 3. [클라이언트] LaunchBillingFlow() → 사용자 결제 진행\n4. [클라이언트] AcknowledgePurchase() → Google에 구매 확인 --- 여기서 백엔드 개입 ---\n5. [클라이언트→백엔드] 구매 토큰을 백엔드로 전송\n6. [백엔드→Google] 구매 토큰 검증 (Google Play Developer API)\n7. [백엔드] 아이템 지급 + DB에 기록\n8. [백엔드→클라이언트] 지급 완료 응답 --- 소모성 아이템인 경우만 ---\n9. [클라이언트] Consume() → Google Play에서 소비 처리\nConsume을 해야 사용자가 재구매가 가능함. Consume을 클라이언트에서 호출 하지 않으면 재구매가 불가능하게 됨.안드로이드 클라이언트에서 발생 가능성 있는 에러 (PlayStore API Error 참고)AndroidBillingResponseCode\n{ // 성공 Ok = 0, // 사용자 관련 에러 UserCancelled = 1, // 사용자가 취소/뒤로가기 // 서비스 관련 에러 ServiceUnavailable = 2, // 네트워크 연결 끊김 BillingUnavailable = 3, // Billing API 버전 미지원 ServiceTimeout = 97, // Google Play 응답 시간 초과 ServiceDisconnected = 99, // Play Store 서비스 연결 끊김 // 상품 관련 에러 ItemUnavailable = 4, // 상품을 구매할 수 없음 ItemAlreadyOwned = 7, // 이미 소유한 아이템 ItemNotOwned = 8, // 소유하지 않은 아이템 소비 시도 // 개발자 에러 DeveloperError = 5, // 잘못된 API 인자 전달 // 기타 에러 Error = 6, // 일반적인 fatal error FeatureNotSupported = 98 // 현재 기기에서 미지원 기능\n};\n백엔드 연동 관련 추가될 수 있는 에러들// 백엔드 연동 관련 추가 에러 코드\nBackendBillingError\n{ // 백엔드 통신 에러 BackendConnectionFailed = 200, // 백엔드 서버 연결 실패 BackendTimeout = 201, // 백엔드 응답 시간 초과 BackendAuthFailed = 202, // 백엔드 인증 실패 // 구매 검증 에러 PurchaseVerificationFailed = 210, // 구매 토큰 검증 실패 DuplicatePurchase = 211, // 중복 구매 시도 InvalidPurchaseToken = 212, // 유효하지 않은 구매 토큰 // 아이템 지급 에러 ItemDeliveryFailed = 220, // 아이템 지급 실패 InsufficientInventory = 221, // 재고 부족 UserAccountNotFound = 222, // 사용자 계정 없음 // 소비 처리 에러 ConsumeTimingError = 230, // 잘못된 시점의 소비 시도 ConsumeRetryExceeded = 231, // 소비 재시도 횟수 초과\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"발생할 수 있는 에러","level":4,"id":"발생할_수_있는_에러_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"android/인앱-결제.html","pathToRoot":"..","attachments":[],"createdTime":1751291017364,"modifiedTime":1751291017364,"sourceSize":3344,"sourcePath":"Android/인앱 결제.md","exportPath":"android/인앱-결제.html","showInTree":true,"treeOrder":32,"backlinks":[],"type":"markdown"},"ble/1.-ble-개요.html":{"title":"1. BLE 개요","icon":"","description":"<a href=\".?query=tag:bluetooth\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#bluetooth\">#bluetooth</a>Bluetooth Low Energy (BLE)\nWPAN 기술의 일종\nBluetooth 4.0부터 저전력 프로토콜 지원\nBluetooth 5.0부터 확장 기능 제공\nBD/EDR과의 차이점\nBD/EDR은 데이터 전송 속도와 연속성에 초점 BLE는 전력 소모를 줄이는 것에 초점\nBLE는 대량의 정보를 빠르게 전송하는 것보다 소량의 정보를 주기적으로 또는 간헐적으로 보내는 시스템에 적합한 기술응용 분야 - 헬스케어, 무선 센서 네트워크","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:bluetooth"],"author":"","coverImageURL":"","fullURL":"ble/1.-ble-개요.html","pathToRoot":"..","attachments":[],"createdTime":1710855209731,"modifiedTime":1737702241699,"sourceSize":520,"sourcePath":"BLE/1. BLE 개요.md","exportPath":"ble/1.-ble-개요.html","showInTree":true,"treeOrder":34,"backlinks":[],"type":"markdown"},"ble/2.-ble-프로토콜-스택.html":{"title":"2. BLE 프로토콜 스택","icon":"","description":"<a href=\".?query=tag:bluetooth\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#bluetooth\">#bluetooth</a>BLE stack은 BLE 디바이스의 구조를 나타냄.블루투스 표준에서 정의하고 있는 LE 모드로 동작하는 디바이스가 갖춰야 하는 기능들을 포함하고 있다.<br><img alt=\"ble_host_controller.png\" src=\"images/ble_host_controller.png\" target=\"_self\">스택은 Host와 Controller로 구성 되어 있음 (Host는 아이폰, Controller는 애플워치, 에어팟 등등)\n신호를 송수신하기 위한 하드웨어로 구성\n2.4 GHZ ISM 주파수 대역에서 동작\nGFSK, FHSS 방식으로 데이터 송수신\n주파수 영역 일부를 40개의 구간으로 나누어 신호를 주고 받음 - 각 구간을 채널이라고 함 PHY와 직접적으로 상호 작용하는 레이어\n하드웨어와 소프트웨어 사이에서 동작함\n하드웨어와 연결되어 BLE 디바이스 간의 연결을 직접적으로 관리\n암호, 연결 상태 및 채널 업데이트 등의 역할 수행\n<br><img alt=\"images/ble-link-layer.png\" src=\"images/ble-link-layer.png\" target=\"_self\">!BLE 디바이스는 LL에서 하나의 상태로 동작함\nStandby\nAdvertising\nScanning\nInitiating\nConnected\n<br><img alt=\"ble-connection 1.png\" src=\"images/ble-connection-1.png\" target=\"_self\">두 개의 BLE 디바이스가 연결을 할 때의 동작 모습이러한 BLE 연결 과정은 GAP에 의해 관리됨\nHost와 Controller가 분리되어 있는 경우 두 모듈 사이의 상호작용을 담당 상위 레이어 (GATT / GAP) 하위 레이어 사이의 상호작용 담당\nBLE 패킷에 데이터를 포함하거나, 추출하는 역할\n// 상위 레이어와 하위 레이어는 BLE 패킷으로 데이터를 송수신 함<br><img alt=\"images/ble-l2cap.png\" src=\"images/ble-l2cap.png\" target=\"_self\">\nSecurity Manager는 자주 연결하는 디바이스 (Peer) 사이의 보안 코드 (Key)를 관리 배포하는 역할 서버와 클라이언트 사이의 데이터 교환에 대한 규칙\n데이터 교환의 주체\n정보를 가지고 있는 Device를 GATT server\n요청하는 디바이스를 GATT client 연결 및 Advertising 동작을 관리하는 최상위 레이어\n각 디바이스의 LL 상태를 결정\n서로 다른 BLE 디바이스 사이의 상호 작용을 관리하는 모듈\nGAP는 동작 상태 중 하나를 가짐 Broadcaster\nObserver\nPeripheral\nCentral\nPeripheral (주변기기 - 에어팟과 같은)로 동작하는 디바이스는 LL에서 Advertising 상태를 유지함 일반적으로 Advertising에서 디바이스 이름과 간단한 정보만을 송신한다. 그리고 이러한 Peripheral 디바이스를 Scanning 해서 연결까지 가능한 디바이스를 Central(중앙장치)로서 동작하는 디바이스라고 함.Peripheral 디바이스가 연결 과정 없이 Advertising 동작을 수행하는 경우 이러한 디바이스를 Broadcater라고 한다. 이 때 이름 이외에도 실질적인 데이터를 실어서 전송 이러한 장치를 비콘이라고 부름역시 Central 디바이스가 연결 과정 없이 Scanning 동작만을 수행할 때 Observer라고 일컫고 일반적으로 Advertising 패킷 내의 데이터를 타겟으로 하므로 비콘 신호를 수신할 때 사용한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Physical Layer (PHY)","level":2,"id":"Physical_Layer_(PHY)_0"},{"heading":"Link Layer (LL)","level":2,"id":"Link_Layer_(LL)_0"},{"heading":"Host - Controller Interface (HCI)","level":2,"id":"Host_-_Controller_Interface_(HCI)_0"},{"heading":"Logical Link Control and Adaptation Protocol (L2CAP)","level":2,"id":"Logical_Link_Control_and_Adaptation_Protocol_(L2CAP)_0"},{"heading":"SM","level":2,"id":"SM_0"},{"heading":"Attribute Protocol (ATT)","level":2,"id":"Attribute_Protocol_(ATT)_0"},{"heading":"Generic Access Profile (GAP)","level":2,"id":"Generic_Access_Profile_(GAP)_0"},{"heading":"GAP 동작","level":5,"id":"GAP_동작_0"}],"links":["?query=tag:bluetooth"],"author":"","coverImageURL":"images/ble_host_controller.png","fullURL":"ble/2.-ble-프로토콜-스택.html","pathToRoot":"..","attachments":["images/ble_host_controller.html","images/ble-link-layer.html","images/ble-connection-1.html","images/ble-l2cap.html"],"createdTime":1710855209731,"modifiedTime":1737702244630,"sourceSize":3286,"sourcePath":"BLE/2. BLE 프로토콜 스택.md","exportPath":"ble/2.-ble-프로토콜-스택.html","showInTree":true,"treeOrder":35,"backlinks":[],"type":"markdown"},"ble/3.-ble-att,-gatt.html":{"title":"3. BLE ATT, GATT","icon":"","description":"<a href=\".?query=tag:bluetooth\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#bluetooth\">#bluetooth</a>ATT는 서버와 클라이언트 사이의 데이터 교환에 대한 규칙이다. 데이터 교환은 ATT를 기반으로 이뤄지고 각각의 데이터 구조는 GATT에 의해 정의 된다.GATT에 의해 정의되는 데이터 구조는 Service와 Characteristic으로 표현된다.<br><img alt=\"images/ble-gatt-structure.png\" src=\"images/ble-gatt-structure.png\" target=\"_self\">Service는 characteristic의 집합이고 데이터들은 Characteristic에 의해 정의된다.이러한 Service와 Characteristic은 attribute 라는 최소 데이터 유닛에 의해 정의된다. 이러한 attribute에 대한 것들은 attribute table 내에 저장된다.attribute는 type (uuid), handle, permission에 대한 정보를 포함<br><img alt=\"images/ble-attribute-table.png\" src=\"images/ble-attribute-table.png\" target=\"_self\">각 행은 하나의 attribute를 나타냄handle은 attribute의 주소 값에 해당\npermission에 service 또는 characteristic의 접근 권한에 대한 정보 저장\nUUID는 고유 식별자<br><img alt=\"images/ble-data-exchange.png\" src=\"images/ble-data-exchange.png\" target=\"_self\">데이터를 가지고 있는 디바이스가 GATT Server\n요청하는 쪽이 GATT client","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"GATT","level":5,"id":"GATT_0"}],"links":["?query=tag:bluetooth"],"author":"","coverImageURL":"images/ble-gatt-structure.png","fullURL":"ble/3.-ble-att,-gatt.html","pathToRoot":"..","attachments":["images/ble-gatt-structure.html","images/ble-attribute-table.html","images/ble-data-exchange.html"],"createdTime":1710855209732,"modifiedTime":1737702245694,"sourceSize":1077,"sourcePath":"BLE/3. BLE ATT, GATT.md","exportPath":"ble/3.-ble-att,-gatt.html","showInTree":true,"treeOrder":36,"backlinks":[],"type":"markdown"},"ble/4.-ble-디바이스-연결.html":{"title":"4. BLE 디바이스 연결","icon":"","description":"<a href=\".?query=tag:bluetooth\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#bluetooth\">#bluetooth</a>GAP periphral로 동작하는 디바이스에서 advertising 함 Device Name, Mac Address, TxPower 등과 같은 간단한 정보를 GAP Central로 동작하는 근처 BLE 디바이스에 알리는 동작이다.PHY의 40개 채널 중 3개 (37 ~ 39)를 이용하고 각 채널은 2.4 GHz 대역 중에서도 Wifi 간섭이 가장 적을 것을 예상되는 주파수를 중심 주파수로 가짐<br><img alt=\"images/ble-conn-fig-1.png\" src=\"images/ble-conn-fig-1.png\" target=\"_self\">GAP Central로 동작하는 디바이스는 BLE 무선 연결을 위해 근처에 연결 가능한 디바이스가 있는지 찾는다. 즉 근처에 Advertising 하고 있는 디바이스를 탐색하는 작업이다. Scanning도 advertising 채널(37 ~ 39) 에 대해 수행한다.<br><img alt=\"images/ble-conn-fig-2.png\" src=\"images/ble-conn-fig-2.png\" target=\"_self\">peripheral 디바이스는 한 번에 3개의 채널을 advertising 하고 central 디바이스는 일정 간격으로 하나의 채널을 scanning 한다.주요 scanning parameter는 scan interval, scan window가 있다.\nscan interval은 scanning 시작시간 사이의 간격을 정의한다.scan window는 한 채널에서 실제로 scanning 하는 구간을 정의한다.advertising 채널과 scanning 채널이 일치하는 경우에만&nbsp;Scanner&nbsp;에서 advertising 데이터를 수신할 수 있으며, advertising 시간은 수 ms 인 반면&nbsp;Scanner&nbsp;에서는 수십에서 수백 ms 동안 scanning 동작을 수행한다. 따라서,&nbsp;Scanner&nbsp;에서는 기본적으로&nbsp;Advertiser&nbsp;에 비해 보다 많은 양의 전류를 소비하게 된다.<br><img alt=\"images/ble-conn-fig-3.png\" src=\"images/ble-conn-fig-3.png\" target=\"_self\">peripheral 디바이스에서 advertising 직후 해당 채널의 신호를 수신하는 시간을 갖는다. peripheral 디바이스에서 advertising 주기와 scanning 주기가 겹치는 시점에 채널을 통해서 central 디바이스의 연결 요청 신호 (CREQ: connection request)를 수신하게 되면 무선 연결이 시작된다. 무선 연결이 시작되고나서 먼저 본격적인 데이터 교환 전에 하드웨어 단에서 필요한 파라미터를 포함한 연결 파라미터를 주고 받는다. 또 이 시점에 연결 주기, 타임아웃 시간 등을 정보를 주고 받고 이 파라미터는 대부분 central 디바이스가 결정한다.\n다만 peripheral 디바이스도 연결 파라미터를 제안할 수 있다. 제안할 수 있는 항목은 아래와 같다.\nminimum connection interval\nmaximum connection interval\nslave latency\nconnection supervision timeout\nadvertising 채널을 제외한 37개 채널을 이용해 FHSS 방식으로 데이터를 주고 받는다.연결파라미터에 대한 추가connection interval은 BLE 패킷을 주고 받는 시간 간격이다.\nconnection supervision timeout은 BLE 디바이스가 연결된 상태에서 얼마 동안 패킷을 교환하지 못할 때 연결을 끊을 것일지 판단하는 값이다.slave latency BLE 디바이스가 무선을 연결된 상태에서의 패킷 교환 주기는 최대 4초이다. 그런데 slava latency 파라미터를 사용하면 연결 주기를 늘릴 수 있다. 무선 연결을 유지하기 위해 교환하는 더미 패킷을 몇 번까지 무시할 것인지 결정하는 파라미터이다.예를 들면 Slave latency 를 이용하면&nbsp;GAP peripheral&nbsp;디바이스에 전송할 유효한 데이터가 없는 경우,&nbsp;GAP central&nbsp;디바이스에 더미 패킷을 전송하는 과정을 건너뛸 수 있고, 따라서 불필요한 전력 소모를 줄일 수 있게 된다. 만약 connection interval 값을 4 secs 로 설정하고, slave latency 를 2 로 설정하는 경우, 유효한 데이터가 없는 상황에서는&nbsp;GAP peripheral&nbsp;디바이스의 더미 패킷 전송을 두 번 스킵할 수 있으므로 연결 주기가 12 secs 정도가 되는 셈이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Advertising","level":4,"id":"Advertising_0"},{"heading":"Scanning","level":4,"id":"Scanning_0"},{"heading":"Connection","level":4,"id":"Connection_0"}],"links":["?query=tag:bluetooth"],"author":"","coverImageURL":"images/ble-conn-fig-1.png","fullURL":"ble/4.-ble-디바이스-연결.html","pathToRoot":"..","attachments":["images/ble-conn-fig-1.html","images/ble-conn-fig-2.html","images/ble-conn-fig-3.html"],"createdTime":1710855209732,"modifiedTime":1737702259925,"sourceSize":3855,"sourcePath":"BLE/4. BLE 디바이스 연결.md","exportPath":"ble/4.-ble-디바이스-연결.html","showInTree":true,"treeOrder":37,"backlinks":[],"type":"markdown"},"cpp/basic/0.-c,-c++-컴파일-과정.html":{"title":"0. c, c++ 컴파일 과정","icon":"","description":"<img alt=\"build_process.png\" src=\"images/build_process.png\" target=\"_self\">\n전처리 과정\n소스 코드 파일 (.c / .cpp)를 전처리된 파일 *.i로 변환한다. Header file Inclusion - #include를 actual content로 대체한 후에 소스코드에 삽입한다.\nMacro Expansion - #define PI 3.14를 확인하고 PI를 3.14로 치환한다.\nComments Removal - 주석을 삭제한다. 컴파일 과정\n컴파일러를 통해 전처리된 파일 *.i를 어셈블리어 파일 .*s로 변환한다. 이 과정에서 언어의 문법 검사를 수행하고 Static한 Section에 대한 메모리 할당을 이뤄진다. 그리고 코드 최적화를 수행하고 코드를 생성한다.\n어셈블리어 과정\n어셈블러를 통해 어셈블리어 파일(*.s)을 오브젝트 파일 (*.o)로 변환한다. 오브젝트 파일은 어셈블된 코드를 소스코드와 긱어 코드의 중간 형태로 저장하고 표현하는데 사용되는 파일 형식이다. 이러한 오브젝트 파일은 실행파일에 결합하는 링커에 대한 입력 역할을 한다.<br><img alt=\"object_file_header.png\" src=\"images/object_file_header.png\" target=\"_self\">Object File Header: 일반적으로 아키텍처, 섹션의 크기, entry point에 대한 정보가 들어있다.Text Section: 변환된 기계어로 이뤄진 코드가 들어 있다.Data Section: 프로그램에서 사용되는 초기화된 / 되지 않은 데이터가 들어있다. (전역변수 / static 변수)Symbol Table Section: &nbsp;변수 및 함수 이름과 같이 코드에 사용된 기호에 대한 정보가 포함됩니다. 이 정보는 연결 및 디버깅에 필수적입니다.Relocation Information Section: 이 정보는 프로그램이 최종 실행 파일을 형성하기 위해 다른 개체 파일과 연결될 때 코드의 주소를 조정해야 하는 방법을 지정합니다. 이는 기호에 대한 참조가 올바르게 해석되도록 보장합니다. 링킹 전까지 심볼의 위치를 확정할 수 없으므로 심볼의 위치가 확정 나면 바꿔야 할 내용을 적어놓은 부분입니다.Debugging Information Section: 디버깅에 필요한 정보가 있는 부분입니다.심볼(Symbol)은&nbsp;함수나 변수를 식별할 때 사용하는 이름으로&nbsp;심볼 테이블(Symbol Table)&nbsp;안에는 오브젝트 파일에서 참조되고 있는 심볼 정보(이름과 데이터의 주소 등)를 가지고 있다.이때 오브젝트 파일의 심볼 테이블에는 해당 오브젝트 파일의 심볼 정보만 가지고 있어야 하기 때문에&nbsp;다른 파일에서 참조되고 있는 심볼 정보의 경우 심볼 테이블에 저장할 수 없다.<br><img alt=\"printf.png\" src=\"images/printf.png\" target=\"_self\">이 소스 코드 파일을 컴파일하여 하나의 오브젝트 파일을 생성할 수 있다.\n하지만, 이 오브젝트 파일은 독립적으로 실행할 수가 없다. 왜냐하면 이 소스코드에서 printf 함수를 구현한 내용이 없기 때문이다. 전처리 과정을 통해 include &lt;stdio.h&gt;로부터 printf()의 원형은 복사했지만 구현한 내용은 포함되어 있지 않다.\nSymbol Table에는 자신의 심볼 정보만 가지고 있지 외부에서 참조하는 printf에 대한 심볼 정보는 가지고 있지 않다.이 오브젝트 파일을 실행하기 위해서 printf 함수를 구현한 libc.a와 연결시키는 작업이 필요하다. 이러한 연결 과정을 링킹이라고 한다. 링킹 이후에 심볼의 위치가 확정되고 이 위치들은 Relocation Information Section에 저장된다.참고: 개체 파일 형식은 플랫폼마다 다릅니다.\nELF(Executable and Linkable Format):&nbsp;Linux를 포함한 Unix 계열 시스템\nMach-O(Mach Object):&nbsp;macOS 및 iOS\nCOFF(Common Object File Format):&nbsp;이전 Windows PE(Portable Executable):&nbsp;최신 Windows 시스템 링킹\n프로그램에서 사용되는 모든 Object 파일과 라이브러리를 실행파일로 결합하는 과정이다. 이 과정을 통해 다양한 소스파일에서 참조되는 모든 함수와 변수가 올바르게 링크된다.링커는 한 Object 파일에서 참조하는 Symbol을 다른 Object 파일의 Symbol 정의와 일치시켜 확인한다. 만약 Symbol을 찾을 수 없다면 Link Error가 발생한다. (Symbol Resolution)그리고 Object 파일의 데이터의 주소나 코드의 메모리 참조 주소를 조정하여 알맞게 배치한다.\n각 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소가 실행 파일에서의 주소와 다르므로 알맞게 수정한다. (오브젝트 파일의 Relocation Information Section의 존재 이유)\n이 과정을 Relocation 이라고 한다.링킹을 하기 전 오브젝트 파일을&nbsp;재배치 가능한 오브젝트 파일(Relocatable Object File)이라 부르고 링킹을 통해 만들어지는 오브젝트 파일을&nbsp;실행 가능한 오브젝트 파일(Executable Object File)이라 부른다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/build_process.png","fullURL":"cpp/basic/0.-c,-c++-컴파일-과정.html","pathToRoot":"../..","attachments":["images/build_process.html","images/object_file_header.html","images/printf.html"],"createdTime":1737701652291,"modifiedTime":1737702579388,"sourceSize":4915,"sourcePath":"CPP/Basic/0. c, c++ 컴파일 과정.md","exportPath":"cpp/basic/0.-c,-c++-컴파일-과정.html","showInTree":true,"treeOrder":40,"backlinks":[],"type":"markdown"},"cpp/basic/1.-참조와-포인터.html":{"title":"1. 참조와 포인터","icon":"","description":"\n성능 같음\n포인터는 원본 전달을 확실히 알려줌.\n참조는 표현적으로 원본을 넘겨주는 지 아닌지 애매함예시: PrintInfo(&amp;info) - 포인터 vs PrintInfo(info) - 참조참조에서 마음대로 고치는 부분은 const를 사용하면 해서 읽기용으로 만들 수 있음.물론 포인터도 const 사용 가능*을 기준으로 앞뒤에 따라 의미가 달라짐. 변경앞인 경우\nvoid (const PrintInfo StatInfo info) {} -&gt; 주소값을 타고 가는 데이터 변경 불가능\ninfo-&gt;hp = 100; // 에러\n뒤인 경우:\nvoid (PrintInfo StatInfo* const info) { } -&gt; 주소값 자체 변경 불가능\ninfo = other_info; // 불가능 참조 타입은 참조하는 대상이 없으면 안됨 nullptr 개념 없음, 포인터는 nullptr 가능\nint age = 29;\nconst int* pt = &amp;age; *pt += 1; // 불가능 age += 1; // age는 const가 아니므로 가능 cout &lt;&lt; age &lt;&lt; endl; // 가능\nconst float g_earth = 9.80;\nconst float* pe = &amp;g_earth; // 불가능 - pm을 이용해 g_moon의 값을 변경한다면 const라는 것이 무의미해지기 때문에\n// c++은 const 변수의 주소를 const가 아닌 일반 포인터에 대입하는 것을 금지함.\nconst float g_moon = 1.63;\nfloat* pm = &amp;g_moon; 포인터를 지시하는 포인터를 사용할 때 복잡해짐\nconst가 아닌 포인터를 const 포인터에 대입하는 것은 간접 지시인 경우에만 가능(?)int age = 29;\nint* pd = &amp;age;\n// 간접지시? 왜 간접지시냐면 pt는 결국 age를 가리키는 거랑 마찬가지이기 뗴문ㅇㅇ\nconst int* pt = pd; //( 이거 가능?) // age++ 가능\n// *pd +=1 가능\n// *pt += 1는 불가능!\n위의 예에서 보다시피 간접지시에서 const와 const가 아닌 것을 섞어쓰는 것은 매우 non - safe임.const int **pt2;\nint* p1;\nconst int n = 13; pp2 = &amp;p1; // 사실 안됨, 근데 된다고 가정\n*pp2 = &amp;n; // const끼리니까 간접지시로 p1이 n을 가리키게 한다. *p1 = 10; // const n을 변경하게 만든다.? const 무효 const가 아닌 포인터를 const 포인터에 대입하는 것은 한다리만 건너는 간접지시인 경우에만 가능. 노트는 무슨 말이야 젠장..Note. 데이터형 자체가 포인터가 아니라면 const 데이터의 주소이든, const가 아닌 데이터의 주소이든 const를 지시하는 포인터(한다리 건너는 간접지시?) 에 모두 대입할 수 있다.\nint n = 1; const int* p1 = &amp;n;\nint* p2 = &amp;n; const int* p3 = p2; // 이게 안됨.\nint* n2 = 2;\nconst int* p4 = &amp;n2;\nint* p5 = p4; // 여기서 안됨 // 이것도 안됨\nconst int x = 5;\nint* ptr = &amp;x; ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"포인터에 const 사용하기","level":3,"id":"포인터에_const_사용하기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/basic/1.-참조와-포인터.html","pathToRoot":"../..","attachments":[],"createdTime":1710855209736,"modifiedTime":1737702735019,"sourceSize":2798,"sourcePath":"CPP/Basic/1. 참조와 포인터.md","exportPath":"cpp/basic/1.-참조와-포인터.html","showInTree":true,"treeOrder":41,"backlinks":[],"type":"markdown"},"cpp/basic/2.-생성자.html":{"title":"2. 생성자","icon":"","description":"class Employee { std::string name; int age; std::string position; // 직책 (이름) int rank; // 순위 (값이 클 수록 높은 순위) public: Employee(std::string name, int age, std::string position, int rank) : name(name), age(age), position(position), rank(rank) {} // 복사 생성자 Employee(const Employee&amp; employee) { name = employee.name; age = employee.age; position = employee.position; rank = employee.rank; } // 디폴트 생성자 Employee() {} void print_info() { std::cout &lt;&lt; name &lt;&lt; \" (\" &lt;&lt; position &lt;&lt; \" , \" &lt;&lt; age &lt;&lt; \") ==&gt; \" &lt;&lt; calculate_pay() &lt;&lt; \"만원\" &lt;&lt; std::endl; } int calculate_pay() { return 200 + rank * 50; }\n}; Q1. b와 c의 메모리주소는 a와 비교하면 어떻게 되어있는가?\nEmployee* a = new Employee(); // 객체 a 생성 (디폴트 생성자 호출) Employee* b = new Employee(*a); // 객체 b 생성 (복사 생성자 호출)\nEmployee* c = a; b는 복사생성자를 호출했기 때문에 a와 b의 메모리 주소는 다르다. 그러나 c는 a의 주소값을 대입했기 때문에 메모리 주소가 같다.Q2. 두 생성자의 차이점은 무엇인가?Employee(std::string name, int age, std::string position, int rank) : name(name), age(age), position(position), rank(rank) {} // 생성자 본문에서 초기화하는 생성자 Employee(std::string name, int age, std::string position, int rank) { this-&gt;name = name; this-&gt;age = age; this-&gt;position = position; this-&gt;rank = rank; }\n첫번째 생성자는 멤버 변수가 생성될 때 해당하는 값으로 초기화 하고 두번째 생성자는 멤버 변수가 기본 생성자로 한 번 초기화된 후 다시 값이 대입된다. 그래서 비효율적이다.아래 코드에서 \"복사 생성\"은 몇번 호출 되는가\nclass A { int x; public: A(int c) : x(c) {} A(const A&amp; a) { x = a.x; std::cout &lt;&lt; \"복사 생성\" &lt;&lt; std::endl; }\n}; class B { A a; public: B(int c) : a(c) {} B(const B&amp; b) : a(b.a) {} A get_A() { A temp(a); return temp; }\n}; int main() { B b(10); std::cout &lt;&lt; \"---------\" &lt;&lt; std::endl; A a1 = b.get_A();\n}\nCopy Elision(복사 생략) 중 Return Optimization왜냐하면 어떤 함수가 함수 내에서 생성한 객체를 리턴 한다면, 굳이 그걸 그냥 사용하면 되지 이를 복사 생성을 또할 필요가 없기 때문\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제 1.","level":4,"id":"문제_1._0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/basic/2.-생성자.html","pathToRoot":"../..","attachments":[],"createdTime":1718520040497,"modifiedTime":1738470398378,"sourceSize":2644,"sourcePath":"CPP/Basic/2. 생성자.md","exportPath":"cpp/basic/2.-생성자.html","showInTree":true,"treeOrder":42,"backlinks":[],"type":"markdown"},"cpp/basic/3.-overloading.html":{"title":"3. Overloading","icon":"","description":"#include &lt;iostream&gt; class Complex { private: double real, img; double get_number(const char* str, int from, int to) const; public: Complex(double real, double** img) : real(real), img(img) { } Complex(const Complex&amp; c) { real = c.real; img = c.img ; } Complex(const char* str); Complex operator+(const Complex&amp; c) const; Complex operator-(const Complex&amp; c) const; Complex operator*(const Complex&amp; c) const; Complex operator/(const Complex&amp; c) const; Complex&amp; operator=(const Complex&amp; c); Complex&amp; operator+=(const Complex&amp; c); Complex&amp; operator-=(const Complex&amp; c); Complex&amp; operator=(const Complex&amp; c); Complex&amp; operator/=(const Complex&amp; c); void println() { std::cout &lt;&lt; \"( \" &lt;&lt; real &lt;&lt; \" , \" &lt;&lt; img &lt;&lt; \" ) \" &lt;&lt; std::endl; } }; Complex Complex::operator+(const Complex&amp; c) const { Complex temp(real + c.real, img + c.img); return temp;\n} Complex Complex::operator-(const Complex&amp; c) const { Complex temp(real - c.real, img - c.img); return temp;\n} Complex Complex::operator*(const Complex&amp; c) const { Complex temp(real * c.real - img * c.img, real * c.img + img * c.real); return temp;\n} Complex Complex::operator/(const Complex&amp; c) const { Complex temp( (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img), (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img)); return temp;\n} Complex&amp; Complex::operator=(const Complex&amp; c) { real = c.real; img = c.img; return *this; } Complex&amp; Complex::operator+=(const Complex&amp; c) { (*this) = (*this) + c; return *this; } Complex&amp; Complex::operator-=(const Complex&amp; c) { (*this) = (*this) - c; return *this; } Complex&amp; Complex::operator*=(const Complex&amp; c) { (*this) = (*this) * c; return *this; } Complex&amp; Complex::operator/=(const Complex&amp; c) { (*this) = (*this) / c; return *this; } Complex::Complex(const char* str) { int begin = 0, end = strlen(str); img = 0.0; real = 0.0; // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다. int pos_i = -1; for (int i = 0; i != end; i++) { if (str[i] == 'i') { pos_i = i; break; } } // 만일 'i' 가 없다면 이 수는 실수 뿐이다. if (pos_i == -1) { real = get_number(str, begin, end - 1); return; } // 만일 'i' 가 있다면, 실수부와 허수부를 나누어서 처리하면 된다. real = get_number(str, begin, pos_i - 1); img = get_number(str, pos_i + 1, end - 1); if (pos_i &gt;= 1 &amp;&amp; str[pos_i - 1] == '-') img *= -1.0;\n} double Complex::get_number(const char *str, int from, int to) const { bool minus = false; if (from &gt; to) return 0; if (str[from] == '-') minus = true; if (str[from] == '-' || str[from] == '+') from++; double** num = 0.0; double** decimal = 1.0; bool integer_part = true; for (int i = from; i &lt;= to; i++) { if (isdigit(str[i]) &amp;&amp; integer_part) { num *= 10.0; num += (str[i] - '0'); } else if (str[i] == '.') integer_part = false; else if (isdigit(str[i]) &amp;&amp; !integer_part) { decimal /= 10.0; num += ((str[i] - '0') * decimal); } else // 그 이외의 이상한 문자들이 올 경우 break; } if (minus) num *= -1.0; return num;\n}\nint main() { Complex a(0, 0); a = a + \"-1.1 + i3.923\"; a.println(); a = a - \"1.2 -i1.823\"; a.println(); a = a * \"2.3+i22\"; a.println(); a = a / \"-12+i55\"; a.println(); } Complex a = b + c + b;를 고려 했을 때 (b.plus(c)).plus(b) 가 되므로 -&gt; (b + c) + (b + c)가 되어버림\n그래서 사칙연산에는 주소값을 리턴하지 않는다.전자는 복사생성자, 후자는 생성 후 대입연산자 여기에서는 얕은 복사가 일어난다.Complex operator+(const char* str) const;\nComplex operator-(const char* str) const;\nComplex operator*(const char* str) const;\nComplex operator/(const char* str) const; Complex Complex::operator+(const char* str) const { Complex temp(str); return (*this) + temp;\n} Complex Complex::operator-(const char* str) const { Complex temp(str); return (*this) - temp;\n} Complex Complex::operator*(const char* str) const { Complex temp(str); return (*this) * temp;\n} Complex Complex::operator/(const char* str) const { Complex temp(str); return (*this) - temp;\n}\n컴파일러는 문자열 리터럴로부터&nbsp;const Complex&nbsp;타입의 객체를 새롭게 생성할 수 있다.a = a + \"-1.1 + i3.923\"; 를 a = a.operator+(\"-1.1 + i3.923\")로\n그리고 이것을 a = a.operator+(Complex(\"-1.1 + i3.923\")); 변환할 수 있다.그러나 a = \"-1.1 + i3.923\" + a;는 컴파일 실패한다. 변환할 수 없는 형태이기 때문이다.friend 키워드는 클래스 내부에서 다른 클래스나 함수를 friend로 정의할 수 있음.friend로 정의 되면 원래 클래스의 private로 정의된 변수, 함수들에 접근 가능lass A { private: void private_func() {} int private_num; // B 는 A 의 친구! friend class B; // func 은 A 의 친구! friend void func();\n}; class B { public: void b() { A a; // 비록 private 함수의 필드들이지만 친구이기 때문에 접근 가능하다. a.private_func(); a.private_num = 2; }\n}; void func() { A a; // 비록 private 함수의 필드들이지만 위와 마찬가지로 친구이기 때문에 접근 // 가능하다. a.private_func(); a.private_num = 2;\n} int main() {} <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Q1. 연산자 오버로딩에서 왜 리턴 값이 Complex&amp;가 아닌 Complex일까?","level":4,"id":"Q1._연산자_오버로딩에서_왜_리턴_값이_Complex&가_아닌_Complex일까?_0"},{"heading":"Q2. Some_Class a = b; 와 Some_Class a, a = b;의 차이점은?","level":4,"id":"Q2._Some_Class_a_=_b;_와_Some_Class_a,_a_=_b;의_차이점은?_0"},{"heading":"Q3. 아래 함수가 없어도 a = a + \"-1.1 + i3.923\";  는 컴파일 된다. 이유는?","level":4,"id":"Q3._아래_함수가_없어도_a_=_a_+_\"-1.1_+_i3.923\";_는_컴파일_된다._이유는?_0"},{"heading":"friend 키워드","level":3,"id":"friend_키워드_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/basic/3.-overloading.html","pathToRoot":"../..","attachments":[],"createdTime":1718520040497,"modifiedTime":1738470395424,"sourceSize":5972,"sourcePath":"CPP/Basic/3. Overloading.md","exportPath":"cpp/basic/3.-overloading.html","showInTree":true,"treeOrder":43,"backlinks":[],"type":"markdown"},"cpp/basic/4.-상속.html":{"title":"4. 상속","icon":"","description":"\n#include &lt;iostream&gt;\n#include &lt;string&gt; class Base { std::string s; public: Base() : s(\"기반\") { std::cout &lt;&lt; \"기반 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nclass Derived : public Base { std::string s; public: Derived() : s(\"파생\"), Base() { std::cout &lt;&lt; \"파생 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nint main() { Base p; Derived c; std::cout &lt;&lt; \"=== 포인터 버전 ===\" &lt;&lt; std::endl; Base* p_c = &amp;c; p_c-&gt;what(); return 0;\n}\n기반 클래스\n기반 클래스\n파생 클래스\n=== 포인터 버전 ===\n기반\n<img alt=\"cpp_1.png\" src=\"images/cpp_1.png\" target=\"_self\">위처럼 파생클래스에서 기반클래스로 캐스팅 하는 것은 업 캐스팅\n#include &lt;iostream&gt;\n#include &lt;string&gt; class Base { std::string s; public: Base() : s(\"기반\") { std::cout &lt;&lt; \"기반 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nclass Derived : public Base { std::string s; public: Derived() : s(\"파생\"), Base() { std::cout &lt;&lt; \"파생 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nint main() { Base p; Derived c; std::cout &lt;&lt; \"=== 포인터 버전 ===\" &lt;&lt; std::endl; Derived* p_p = &amp;p; p_p-&gt;what(); return 0;\n}\nerror C2440: 'initializing' : cannot convert from 'Base *' to 'Derived *'\n<br><img alt=\"cpp_2.png\" src=\"images/cpp_2.png\" target=\"_self\">위처럼 다운 캐스팅은 컴파일러 에러를 내뱉음 -&gt; 다운 캐스팅은 매우 위험한 행동임.그럼 아래와 같은 경우는 어떨까?#include &lt;iostream&gt;\n#include &lt;string&gt; class Base { std::string s; public: Base() : s(\"기반\") { std::cout &lt;&lt; \"기반 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nclass Derived : public Base { std::string s; public: Derived() : s(\"파생\"), Base() { std::cout &lt;&lt; \"파생 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nint main() { Base p; Derived c; std::cout &lt;&lt; \"=== 포인터 버전 ===\" &lt;&lt; std::endl; Base* p_p = &amp;c; Derived* p_c = p_p; p_c-&gt;what(); return 0;\n}\n위의 다운캐스팅 경우와 똑같이 에러가 발생함. 다만 우리는 실제 p_p가 Derived c를 가리킨다는 것을 알고 있기 때문에 강제로 static_cast를 이용해서 다운캐스팅을 할 수 있다. Derived* p_c = static_cast&lt;Derived*&gt;(p_p);\n이를 실행하면 어떻게 될까.clang++ 로 빌드한 결과 실행은 된다. (책에서는 안된다고 적혀있긴 한다.)상속관계에서 캐스팅 하는 것은 dynamic_cast를 사용하면 된다.Derived* p_c = dyanmic_cast&lt;Derived*&gt;(p_p);\n그러나 아래와 같은 에러가 발생한다.error: 'Base' is not polymorphic Derived* p_c = dynamic_cast&lt;Derived*&gt;(p_p);\n왜 에러가 발생할까?downcasting 을 dynamic_cast 를 통해 시도할때, compile time 에서 에러가 나오는 경우는 Base class 가 \"polymorphic\" 하지 않을 경우(즉, 가상함수가 없을 경우) 에 한정됩니다. 그 외의 경우는, 컴파일 타임에서 에러를 내지 않고 대신 nullptr 값을 리턴합니다. 또한, 레퍼런스 타입으로 캐스팅하려 할 경우는 bad_cast 를 throw 하게 됩니다. dynamic_cast 를 이용한 다운캐스팅시, 컴파일타임에 에러가 검출#include &lt;iostream&gt; class Base { public: Base() { std::cout &lt;&lt; \"기반 클래스\" &lt;&lt; std::endl; } virtual void what() { std::cout &lt;&lt; \"기반 클래스의 what()\" &lt;&lt; std::endl; }\n};\nclass Derived : public Base { public: Derived() : Base() { std::cout &lt;&lt; \"파생 클래스\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; \"파생 클래스의 what()\" &lt;&lt; std::endl; }\n};\nint main() { Base p; Derived c; Base* p_c = &amp;c; Base* p_p = &amp;p; std::cout &lt;&lt; \" == 실제 객체는 Base == \" &lt;&lt; std::endl; p_p-&gt;what(); std::cout &lt;&lt; \" == 실제 객체는 Derived == \" &lt;&lt; std::endl; p_c-&gt;what(); return 0;\n}\n위에서 공부한 것에 의하면,\bp_c는 업캐스팅, p_p는 그냥 포인터 가르키기이므로 아래와 같이 결과가 출력되어야 함.기반 클래스\n기반 클래스\n파생 클래스\n== 실제 객체는 Base ==\n기반 클래스의 what()\n== 실제 객체는 Derived == 파생 클래스의 what()\n근데 실제 결과는 기반 클래스\n기반 클래스\n파생 클래스 == 실제 객체는 Base == 기반 클래스의 what() == 실제 객체는 Derived == 파생 클래스의 what()\nvirtual 키워드 사용 때문에 이런 일이 발생하는 것임 어떻게 이런 일이 발생하는 것이냐면아래 코드 실행시에 p_c-&gt;what();\n컴퓨터(런타임) 입장에서\"흠, p_c 는 Base 포인터니까 Base 의 what() 을 실행해야지\"\n\"어 근데 what 이 virtual 이네?\" \"잠깐. 이거 실제 Base 객체 맞어? 아니네 Derived 객체네\"\n\"그럼 Derived 의 what 을 실행해야지\"\np_p-&gt;what();\n\"흠, p_c 는 Base 포인터니까 Base 의 what() 을 실행해야지\"\n\"어 근데 what 이 virtual 이네?\" \"잠깐. 이거 실제 Base 객체 맞어? 어 맞네.\"\n\"Base 의 what 을 실행하자\"\n이렇게 컴파일 시에 어떤 함수가 실행될 지 정해지지 않고 런타임 시에 정해지는 일을 가리켜서&nbsp;동적 바인딩(dynamic binding)&nbsp;이라고 부름!-&gt; virtual를 붙이면 동적바인딩이겠네 어떤 함수를 실행할 지 모르니까// i 는 사용자로부터 입력받는 변수\nif (i == 1) { p_p = &amp;c;\n} else { p_p = &amp;p;\n}\np_p-&gt;what();\n다음과 같은 코드는 정적 바인딩임. 컴파일 타임에서 어떤 함수가 실행될 지 정해지니까 #include &lt;iostream&gt; class Base {\npublic: void display() { std::cout &lt;&lt; \"Display Base\" &lt;&lt; std::endl; }\n}; class Derived : public Base {\npublic: void display() { std::cout &lt;&lt; \"Display Derived\" &lt;&lt; std::endl; }\n};\nint main() { Base base; Derived derived; base.display(); // 정적 바인딩, Base::display() 호출 derived.display(); // 정적 바인딩, Derived::display() 호출 return 0;\n}\nC++ 11 에서는 파생 클래스에서 기반 클래스의 가상 함수를 오버라이드 하는 경우,&nbsp;override&nbsp;키워드를 통해서 명시적으로 나타낼 수 있음그렇다면 프로그램 내부적으로&nbsp;virtual&nbsp;함수들은 어떻게 처리될까요? 즉, 이 포인터가 어떠한 객체를 가리키는지 어떻게 알 수 있을까요? (난이도 : 上)Answerc++에서 virtual 함수는 동적 바인딩(dynamic binding) 또는 런타임 바인딩(run-time binding)을 통해 처리됩니다. 이는 실행 시간에 호출될 함수가 결정되는 방식입니다. 이를 위해 C++는 가상 함수 테이블(Virtual Table, vtable)과 가상 함수 포인터(Virtual Table Pointer, vptr)를 사용합니다.가상 함수 테이블(vtable)과 가상 함수 포인터(vptr)1. 가상 함수 테이블(vtable) • 가상 함수 테이블은 클래스마다 존재하는 함수 포인터 테이블입니다.\n• 클래스에 가상 함수가 정의되면, 컴파일러는 해당 가상 함수를 가리키는 포인터를 가상 함수 테이블에 저장합니다.\n2. 가상 함수 포인터(vptr) • 가상 함수 포인터는 객체마다 존재합니다.\n• 이 포인터는 객체가 속한 클래스의 가상 함수 테이블을 가리킵니다.\n• 객체가 생성될 때, 이 포인터는 해당 객체의 클래스에 맞는 가상 함수 테이블을 가리키도록 초기화됩니다.\n동작 원리\n객체 생성 시\n• 객체가 생성되면, 객체의 vptr은 해당 클래스의 vtable을 가리키도록 설정됩니다.\n가상 함수 호출 시\n• 가상 함수가 호출될 때, 객체의 vptr을 통해 vtable에 접근합니다.\n• vtable에서 적절한 함수 포인터를 찾아 해당 함수를 호출합니다.\n#include &lt;iostream&gt; class Base {\npublic: virtual void show() { std::cout &lt;&lt; \"Base class\" &lt;&lt; std::endl; }\n}; class Derived : public Base {\npublic: void show() override { std::cout &lt;&lt; \"Derived class\" &lt;&lt; std::endl; }\n}; void display(Base* obj) { obj-&gt;show(); // 동적 바인딩을 통해 적절한 함수 호출\n} int main() { Base base; Derived derived; display(&amp;base); // \"Base class\" display(&amp;derived); // \"Derived class\" return 0;\n} Base* b = new Derived(); b-&gt;show(); // Derived show b-&gt;display(); // Derived display\nvtable 구성\n• Base vtable:• Base::show\n• Base::display\n• Derived vtable:• Derived::show (Base의 show 함수 재정의)\n• Derived::display (Base의 display 함수 재정의)\nvptr 초기화• Base 포인터가 Derived 객체를 가리킬 때, Derived 객체의 vptr은 Derived 클래스의 vtable을 가리킵니다.\n• 따라서 b-&gt;show()와 b-&gt;display() 호출 시 Derived 클래스의 가상 함수 테이블을 참조하여 각각 Derived::show와 Derived::display가 호출됩니다.\n상속 시에 Base 클래스 소멸자를 가상함수로 만들어야 됨#include &lt;iostream&gt; class Parent { public: Parent() { std::cout &lt;&lt; \"Parent 생성자 호출\" &lt;&lt; std::endl; } ~Parent() { std::cout &lt;&lt; \"Parent 소멸자 호출\" &lt;&lt; std::endl; }\n};\nclass Child : public Parent { public: Child() : Parent() { std::cout &lt;&lt; \"Child 생성자 호출\" &lt;&lt; std::endl; } ~Child() { std::cout &lt;&lt; \"Child 소멸자 호출\" &lt;&lt; std::endl; }\n};\nint main() { std::cout &lt;&lt; \"--- 평범한 Child 만들었을 때 ---\" &lt;&lt; std::endl; { Child c; } std::cout &lt;&lt; \"--- Parent 포인터로 Child 가리켰을 때 ---\" &lt;&lt; std::endl; { Parent *p = new Child(); delete p; }\n}\n--- 평범한 Child 만들었을 때 ---\nParent 생성자 호출\nChild 생성자 호출\nChild 소멸자 호출\nParent 소멸자 호출\n--- Parent 포인터로 Child 가리켰을 때 ---\nParent 생성자 호출\nChild 생성자 호출\nParent 소멸자 호출\ndelete p&nbsp;를 하더라도,&nbsp;p&nbsp;가 가리키는 것은&nbsp;Parent&nbsp;객체가 아닌&nbsp;Child&nbsp;객체 이기 때문에, Child&nbsp;객체가 소멸되는 것과 같은 순서로 생성자와 소멸자들이 호출되어야만 합니다. 그런데 실제로는,&nbsp;Child&nbsp;소멸자가 호출되지 않습니다. 캐스팅한 타입 Parent만을 해제하고 있음.위의 코드에서 Parent 클래스의 소멸자를 가상함수로 만든다면 우리가 원하는대로 동작할것임. Child 소멸자를 호출하게 됨 그렇다며 왜 Parent 소멸자가 호출 되는 것일까?Child&nbsp;소멸자가 '알아서'&nbsp;Parent&nbsp;의 소멸자도 호출함(Child&nbsp;는 자신이&nbsp;Parent&nbsp;를 상속받는다는 것을 알고 있습니다).반면에&nbsp;Parent&nbsp;소멸자를 먼저 호출하게 되면,&nbsp;Parent&nbsp;는&nbsp;Child&nbsp;가 있는지 없는지 모르므로,&nbsp;Child&nbsp;소멸자를 호출해줄 수 없습니다 (Parent 는 자신이 누구에서 상속해주는지 알 수 없지요).이와 같은 연유로,상속될 여지가 있는&nbsp;Base&nbsp;클래스들은 (위 경우&nbsp;Parent) 반드시 소멸자를&nbsp;virtual&nbsp;로 만들어주어야 나중에 문제가 발생할 여지가 없게 됩니다.#include &lt;iostream&gt; class A { public: virtual void show() { std::cout &lt;&lt; \"Parent !\" &lt;&lt; std::endl; }\n};\nclass B : public A { public: void show() override { std::cout &lt;&lt; \"Child!\" &lt;&lt; std::endl; }\n}; void test(A&amp; a) { a.show(); }\nint main() { A a; B b; test(a); test(b); return 0;\n}\n가상함수는 약간의 오버헤드가 발생class Parent { public: virtual void func1(); virtual void func2();\n};\nclass Child : public Parent { public: virtual void func1(); void func3();\n};\n<br><img alt=\"cpp_3.png\" src=\"images/cpp_3.png\" target=\"_self\">Parent* p = Parent();\np-&gt;func1(); p&nbsp;가&nbsp;Parent&nbsp;를 가리키는 포인터 이니까,&nbsp;func1()&nbsp;의 정의를&nbsp;Parent&nbsp;클래스에서 찾아봐야겠다.\nfunc1()&nbsp;이 가상함수네? 그렇다면&nbsp;func1()&nbsp;을 직접 실행하는게 아니라, 가상 함수 테이블에서&nbsp;func1()&nbsp;에 해당하는 함수를 실행해야겠다.\nParent* c = Child();\nc-&gt;func1();\np&nbsp;가 실제로는&nbsp;Child&nbsp;객체를 가리키고 있으므로,&nbsp;Child&nbsp;객체의 가상 함수 테이블을 참조하여,&nbsp;Child::func1()&nbsp;을 호출두 단계에 걸쳐서 함수를 호출함 -&gt; 약간의 오버헤드#include &lt;iostream&gt; class Animal { public: Animal() {} virtual ~Animal() {} virtual void speak() = 0; // 순수 가상함수\n}; class Dog : public Animal { public: Dog() : Animal() {} void speak() override { std::cout &lt;&lt; \"왈왈\" &lt;&lt; std::endl; }\n}; class Cat : public Animal { public: Cat() : Animal() {} void speak() override { std::cout &lt;&lt; \"야옹야옹\" &lt;&lt; std::endl; }\n}; int main() { Animal* dog = new Dog(); Animal* cat = new Cat(); dog-&gt;speak(); cat-&gt;speak();\n}\n가상 함수에&nbsp;= 0;&nbsp;을 붙여서, 반드시 오버라이딩 되도록 만든 함수를 완전한 가상 함수라 해서,&nbsp;순수 가상 함수(pure virtual function)라고 부름Dataview (inline field '0;'): Error: -- PARSING FAILED -------------------------------------------------- &gt; 1 | 0; | ^ Expected one of the following: '(', '*' or '/' or '%', '+' or '-', '.', '&gt;=' or '&lt;=' or '!=' or '=' or '&gt;' or '&lt;', '[', 'and' or 'or', EOF\n순수 가상 함수는 본체가 없음 -&gt; 함수 호출 불가 -&gt; 순수 가상함수를 담고 있는 객체는 생성 불가능 (추상클래스를 가르키는 포인터는 생성가능)인스턴스화를 하기 위해서는 상속 받는 클래스를 만들고 순수 가상함수를 모두 오버라이드 해야함순수 가상함수를 하나 이상 포함하고 있는 클래스 -&gt; 추상 클래스Animal a; // 스택할당 - 불가능\na.speak(); Animal* dog = new Dog();\nAnimal* cat = new Cat(); dog-&gt;speak();\ncat-&gt;speak(); #include &lt;iostream&gt; class A { public: int a; A() { std::cout &lt;&lt; \"A 생성자 호출\" &lt;&lt; std::endl; }\n}; class B { public: int b; B() { std::cout &lt;&lt; \"B 생성자 호출\" &lt;&lt; std::endl; }\n}; class C : public B, public A { public: int c; C() : A(), B() { std::cout &lt;&lt; \"C 생성자 호출\" &lt;&lt; std::endl; }\n};\nint main() { C c; }\n상속 순서에 따라서 생성자 호출B 생성자 호출\nA 생성자 호출\nC 생성자 호출\n다중 상속시 주의할 점base 클래스의 함수나 변수가 동일한 이름인 경우 문제가 발생 (다이아몬드 상속)class A { public: int a;\n}; class B { public: int a;\n}; class C : public B, public A { public: int c;\n}; int main() { C c; c.a = 3;\n}\nerror C2385: ambiguous access of 'a'\n1&gt; could be the 'a' in base 'B'\n1&gt; or could be the 'a' in base 'A' 다이아몬드 상속class Human { // ...\n};\nclass HandsomeHuman : public Human { // ...\n};\nclass SmartHuman : public Human { // ...\n};\nclass Me : public HandsomeHuman, public SmartHuman { // ...\n};\n<br><img alt=\"cpp_4.png\" src=\"images/cpp_4.png\" target=\"_self\">만약 Human에 name이라는 변수가 있다면 상속을 받은 HandsomeHuman, SmartHuman에도 name이라는 변수가 있는 것Me는 두 클래스를 상속 받으니 name 변수가 중복되는 문제 발생해결할 수 있는 방법class Human { public: // ...\n};\nclass HandsomeHuman : public virtual Human { // ...\n};\nclass SmartHuman : public virtual Human { // ...\n};\nclass Me : public HandsomeHuman, public SmartHuman { // ...\n};\n이러한 형태로&nbsp;Human&nbsp;을&nbsp;virtual&nbsp;로 상속 받는다면,&nbsp;Me&nbsp;에서 다중 상속 시에도, 컴파일러가 언제나&nbsp;Human&nbsp;을 한 번만 포함하도록 지정할 수 있게 됩니다. 참고로, 가상 상속 시에,&nbsp;Me&nbsp;의 생성자에서&nbsp;HandsomeHuman&nbsp;과&nbsp;SmartHuman&nbsp;의 생성자를 호출함은 당연하고 Human&nbsp;의 생성자 또한 호출해주어야만 합니다.최상단 base의 생성자를 호출한다는 것이 특이\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"virtual 키워드","level":4,"id":"virtual_키워드_0"},{"heading":"overrided","level":4,"id":"overrided_0"},{"heading":"문제","level":4,"id":"문제_0"},{"heading":"소멸자","level":3,"id":"소멸자_0"},{"heading":"문제","level":4,"id":"문제_1"},{"heading":"모든 함수를 가상함수로 선언하기?","level":3,"id":"모든_함수를_가상함수로_선언하기?_0"},{"heading":"순수 가상함수와 추상 클래스","level":3,"id":"순수_가상함수와_추상_클래스_0"},{"heading":"다중상속","level":3,"id":"다중상속_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"images/cpp_1.png","fullURL":"cpp/basic/4.-상속.html","pathToRoot":"../..","attachments":["images/cpp_1.html","images/cpp_2.html","images/cpp_3.html","images/cpp_4.html"],"createdTime":1719322122419,"modifiedTime":1738470391965,"sourceSize":16194,"sourcePath":"CPP/Basic/4. 상속.md","exportPath":"cpp/basic/4.-상속.html","showInTree":true,"treeOrder":44,"backlinks":[],"type":"markdown"},"cpp/basic/5.-다중-상속.html":{"title":"5. 다중 상속","icon":"","description":"예를 들어서 여러분이&nbsp;차량(Vehicle)&nbsp;에 관련한 클래스를 생성한다고 해봅시다. 차량의 종류로는 땅에서 다니는 차, 물에서 다니는 차, 하늘에서 다니는 차, 우주에서 다니는 차들이 있다고 해봅시다. (차 라고 하기 보다는 운송 수단이 좀 더 적절한 표현이겠네요..)또한, 이 차량들은 각기 다른 동력원들을 사용하는데, 휘발유를 사용할 수 도 있고, 풍력으로 갈 수 도 있고 원자력으로 갈 수도 있고, 페달을 밟아서 갈 수 도 있습니다.이러한 차량들을 클래스로 나타내기 위해서, 다중 상속을 활용할 수 있지만 그 전에, 아래와 같은 질문들에 대한 대답을 생각해봅시다.\nLandVehicle&nbsp;을 가리키는&nbsp;Vehicle&amp;&nbsp;레퍼런스를 필요로 할까? 다시 말해,&nbsp;Vehicle&nbsp;레퍼런스가 실제로는&nbsp;LandVehicle&nbsp;을 참조하고 있다면,&nbsp;Vehicle&nbsp;의 멤버 함수를 호출하였을 때, LandVehicle 의 멤버 함수가 오버라이드 되서 호출되기를 바라나요? GasPoweredVehicle&nbsp;의 경우도 마찬가지 입니다. 만일&nbsp;Vehicle&nbsp;레퍼런스가 실제로는&nbsp;GasPoweredVehicle&nbsp;을 참조하고 있을 때,&nbsp;Vehicle&nbsp;레퍼런스의 멤버함수를 호출한다면,&nbsp;GasPoweredVehicle&nbsp;의 멤버 함수가 오버라이드 되서 호출되기를 원하나요? 만일 두 개의 질문에 대한 대답이 모두&nbsp;예&nbsp;라면 다중 상속을 사용하는 것이 좋을 것입니다. 하지만 그 전에, 몇 가지 고려할 점이 더 있습니다. 만약에 이 차량이 작동하는 환경이&nbsp;𝑁N&nbsp;개가 있고 (땅, 물, 하늘, 우주 등등), 동력원의 종류가&nbsp;𝑀M&nbsp;개가 있다고 해봅시다.이를 위해서, 크게 3 가지 방법으로 이러한 클래스를 디자인 할 수 있습니다. 바로 브리지 패턴 (bridge pattern), 중첩된 일반화 방식 (nested generalization), 다중 상속 입니다. 각각의 방식에는 모두 장단점이 있습니다. 브리지 패턴의 경우 차량을 나타내는 한 가지 카테고리를 아예 멤버 포인터로 만들어버립니다. 예를 들어서&nbsp;Vehicle&nbsp;클래스의 파생 클래스로&nbsp;LandVehicle,&nbsp;SpaceVehicle&nbsp;클래스들이 있고,&nbsp;Vehicle&nbsp;클래스의 멤버 변수로 어떤 엔진을 사용하는지 가리키는&nbsp;Engine*&nbsp;멤버 변수가 있습니다. 이&nbsp;Engine&nbsp;은&nbsp;GasPowered,&nbsp;NuclearPowered&nbsp;와 같은&nbsp;Engine&nbsp;의 파생 클래스들의 객체들을 가리키게 됩니다. 그리고 런타임 시에 사용자가&nbsp;Engine&nbsp;을 적절히 설정해주면 됩니다. 이 경우 동력원 이나 환경을 하나 추가하더라도 클래스를 1 개만 더 만들면 됩니다. 즉, 총&nbsp;𝑁+𝑀N+M&nbsp;개의 클래스만 생성하면 된다는 뜻입니다. 하지만 오버라이딩 가지수가&nbsp;𝑁+𝑀N+M&nbsp;개 뿐이므로 최대&nbsp;𝑁+𝑀N+M&nbsp;개 알고리즘 밖에 사용할 수 없습니다. 만일 여러분이&nbsp;𝑁×𝑀N×M&nbsp;개의 모든 상황에 대한 섬세한 제어가 필요하다면 브리지 패턴을 사용하지 않는 것이 좋습니다. 또한, 컴파일 타임 타입 체크를 적절히 활용할 수 없다는 문제가 있습니다. 예를 들어서&nbsp;Engine&nbsp;이 페달이고 작동 환경이 우주라면, 애초에 해당 객체를 생성할 수 없어야 하지만 이를 컴파일 타임에서 강제할 방법이 없고 런타임에서나 확인할 수 있게 됩니다. 뿐만 아니라, 우주에서 작동하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 있지만 (SpaceVehicle&nbsp;클래스), 작동 환경에 관계 없이 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 는 없습니다. 중첩된 일반화&nbsp;방식을 사용하게 된다면, 한 가지 계층을 먼저 골라서 파생 클래스들을 생성합니다. 예를 들어서&nbsp;Vehicle&nbsp;클래스의 파생 클래스들로&nbsp;LandVehicle,&nbsp;WaterVehicle, 등등이 있겠지요. 그 후에, 각각의 클래스들의 대해 다른 계층에 해당하는 파생 클래스들을 더 생성합니다. 예컨대&nbsp;LandVehicle&nbsp;의 경우 동력원으로 휘발유를 사용한다면&nbsp;GasPoweredLandVehicle, 원자력을 사용한다면&nbsp;NuclearPoweredLandVehicle&nbsp;클래스를 생성할 수 있겠지요.\n따라서 최대&nbsp;𝑁×𝑀N×M&nbsp;가지의 파생 클래스들을 생성할 수 있게 됩니다. 따라서 브릿지 패턴에 비해서 좀 더 섬세한 제어를 할 수 있게 됩니다. 왜냐하면 오버라이딩 가지수가&nbsp;𝑁+𝑀N+M&nbsp;이 아닌&nbsp;𝑁×𝑀N×M&nbsp;이 되기 때문이지요. 하지만 동력원을 하나 더 추가하게 된다면 최대&nbsp;𝑁N&nbsp;개의 파생 클래스를 더 만들어야 합니다. 뿐만 아니라 앞서 브릿지 패턴에서 나왔던 문제 - 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 없다가 여전히 있습니다. 따라서 만약에 휘발유를 사용하는 차량들에서 공통적으로 사용되는 코드가 있다면 매 번 새로 작성해줘야만 합니다. 다중 상속을 이용하게 된다면, 브리지 패턴 처럼 각 카테고리에 해당하는 파생 클래스들을 만들게 되지만, 그 대신&nbsp;Engine*&nbsp;멤버 변수를 없애고 동력원과 환경에 해당하는 클래스를 상속받는 파생 클래스들을 최대&nbsp;𝑁×𝑀N×M&nbsp;개 만들게 됩니다. 예를 들어서 휘발유를 사용하며 지상에서 다니는 차량을 나타내는&nbsp;GasPoweredLandVehicle&nbsp;클래스의 경우&nbsp;GasPoweredEngine&nbsp;과&nbsp;LandVehicle&nbsp;두 개의 클래스를 상속받겠지요.\n따라서 이 방식을 통해서 브리지 패턴에서 불가능 하였던 섬세한 제어를 수행할 수 있을 뿐더러, 말도 안되는 조합을 (예컨대&nbsp;PedalPoweredSpaceVehicle) 컴파일 타입에서 확인할 수 있습니다 (애초에 정의 자체를 안하면 되니까요!). 또한 이전에 두 방식에서 발생하였던&nbsp;휘발유를 사용하는 모든 차량을 가리킬 수 없다&nbsp;문제를 해결할 수 있습니다. 왜냐하면 이제&nbsp;GasPoweredEngine&nbsp;을 통해서 휘발유를 사용하는 모든 차량을 가리킬 수 있기 때문이지요. <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"다중 상속은 언제 사용해야 할까?","level":3,"id":"다중_상속은_언제_사용해야_할까?_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/basic/5.-다중-상속.html","pathToRoot":"../..","attachments":[],"createdTime":1718520040498,"modifiedTime":1738470386639,"sourceSize":6417,"sourcePath":"CPP/Basic/5. 다중 상속.md","exportPath":"cpp/basic/5.-다중-상속.html","showInTree":true,"treeOrder":45,"backlinks":[],"type":"markdown"},"cpp/basic/6.-파일-입출력.html":{"title":"6. 파일 입출력","icon":"","description":"<img alt=\"cpp_5.png\" src=\"images/cpp_5.png\" target=\"_self\">ios_base - 스트림의 입출력 형식 관련 데이터 처리ios - 스트림 버퍼 초기화, 입출력 작업 상태 처리\n스트림버퍼: 데이터를 내보내거나 받아들이기 전에 임시로 저장하는 곳\n사용자가 1byte씩 쓰거나 읽는다고 할 때 실제 프로그램은 1byte씩 읽는게 아님 -&gt; 하드디스크에 쓰거나 읽을 때 시간이 오래걸리기 때문에 한 뭉터기로 쓰거나 읽어옴\nistream - 실제로 입력을 수행하는 클래스operator&gt;&gt;는 모든 공백문자(띄어쓰기, 엔터, 탭)을 입력시에 무시함\n#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { std::string s; while (true) { std::cin &gt;&gt; s; std::cout &lt;&lt; \"word : \" &lt;&lt; s &lt;&lt; std::endl; }\n}\nthis is a long sentence\nword : this\nword : is\nword : a\nword : long\nword : sentence\nABCD EFGH IJKL\nword : ABCD\nword : EFGH\nword : IJKL\n주의할 점// 주의할 점\n#include &lt;iostream&gt;\nusing namespace std;\nint main() { int t; while (true) { std::cin &gt;&gt; t; std::cout &lt;&lt; \"입력 :: \" &lt;&lt; t &lt;&lt; std::endl; if (t == 0) break; }\n}\n3\n입력 :: 3\n4\n입력 :: 4\n5\n입력 :: 5\n6\n입력 :: 6\n7\n입력 :: 7\n숫자만 입력시에 잘 동작함. 그러나 문자('c\\n')를 입력한다면 기괴환 무한루프 결과가 나옴.<br><img alt=\"cpp_6.png\" src=\"images/cpp_6.png\" target=\"_self\">ios 클래스에서 스트림 상태를 관리하는 플래그가 4개가 정의되어 있음\ngoodbit: 스트림에 입출력 작업이 가능할 때\nbadbit: 스트림에 복구 불가능한 오류 발생시\neofbit: 입력 작업시에&nbsp;EOF 도달시\nfailbit: 스트림에 복구 가능한 오류 발생시\n'c\\n'을 입력하는 경우 타입에 맞지 않는 값이기 때문에 failbit가 켜짐. 그리고 입력값을 받지 않고 리턴함. 그러나 스트림에 'c\\n'이 남아있는데 이를 처리하지 않는다는 것 -&gt; 무한루프// 해결 방안\n#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { int t; while (std::cin &gt;&gt; t) { std::cout &lt;&lt; \"입력 :: \" &lt;&lt; t &lt;&lt; std::endl; if (t == 0) break; }\n}\nwhilecin &gt;&gt; t로 인해서 무한루프에 빠지지 않고 제대로 처리됨.이게 어떻게 처리되는 지를 이해하기 위해서는 ios에 정의되어 있는 함수 operator void*() const;에 대해 알아야함.operator void*() const;\n이 함수는&nbsp;ios 객체를&nbsp;void*&nbsp;로 변환함. 이 떄 Null 포인터가 아닌 값을 반환하기 위해서는 failbit와 badbit가 모두 off인 경우임.즉 정상적으로 입출력 작업을 수행할 수 있는 경우임.코드로 돌아가서 문자 's'를 입력 한다면 failbit가 켜지게 됨\nstd::cin &gt;&gt; t를 후에 cin이 리턴되는데 null 포인터를 리턴하게 되어서 루프를 돌지 않게 됨.문제를 해결한 상태지만 입력을 계속 진행할 수 없음. cin에 failbit가 켜져있기 때문임. 그래서 \b플래그를 초기화 해야함#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { int t; while (true) { std::cin &gt;&gt; t; std::cout &lt;&lt; \"입력 :: \" &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; \"제대로 입력해주세요\" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 std::cin.ignore(100, '\\n'); // 개행문자가 나올 때 까지 무시한다 } if (t == 1) break; }\n}\nfail()함수는 ios에 정의되어 있고 failbit || badbit가 true인 경우 true를 리턴함.clear()도 ios에 정의되어 있고 인자를 주지 않으면 플래그를 goodbit로 초기화함 따라서 fail 상태 초기화할 수 있음.ignore() istream에 정의되어 있고 최대 첫번째 인자(100)만큼 두번째 인자('\\n')이 나올 때까지 버퍼에서 무시함.ios_base 클래스에서 스트림 입출력 형식 바꾸기 가능: 10진수 -&gt; 16진수로 처리#include &lt;string&gt;\n#include &lt;iostream&gt; int main() { int t; while (true) { std::cin.setf(std::ios_base::hex, std::ios_base::basefield); std::cin &gt;&gt; t; std::cout &lt;&lt; \"입력 :: \" &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; \"제대로 입력해주세요\" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 // std::cin.ignore(100,'n');//개행문자가 나올 때까지 // 무시한다 } if (t == 0) break; }\n}\n위의 코드는 16진수로 입력받기 -&gt; 10진수로 출력std::cin.setfhex, ios_base::basefieldsetf의 버전은 2가지임.인자를 1개 받는 경우와 위의 경우처럼 2개를 받는 것1개를 받는 경우: 하나의 인자를 받는 setf는 새로운 포맷 플래그를 설정하고, 기존 플래그와 병합합니다.\n이 경우, std::ios::hex 플래그를 설정하여 이후의 입력을 16진수로 처리합니다. 이전에 설정된 다른 플래그는 유지되며, 새로운 플래그와 병합됩니다.2개를 받는 경우\n두 개의 인자를 받는 setf는 첫 번째 인자로 전달된 플래그를 설정하고, 두 번째 인자로 전달된 마스크에 해당하는 플래그를 클리어(지움)합니다.이 경우, std::ios::hex 플래그를 설정하면서, std::ios::basefield에 해당하는 플래그 ios::dec, std::ios::oct, std::ios::hex는 모두 클리어합니다. 즉, std::ios::hex만 남게 됩니다.위의 방법말고 16진수로 입력을 조작하는 방법은 조작자를 사용하는 것// 조작자의 사용\n#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { int t; while (true) { std::cin &gt;&gt; std::hex &gt;&gt; t; std::cout &lt;&lt; \"입력 :: \" &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; \"제대로 입력해주세요\" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 std::cin.ignore(100, 'n'); //개행문자가 나올 때까지 무시한다 } if (t == 0) break; }\n}\nstd::cin &gt;&gt; hex &gt;&gt; t; hex가 cin에서 수를 받는 방식을 바꿈 여기에서 hex는 함수고 조작자라고 부름. 그 전의 경우 hex는 이름은 같지만 형식플래그고 ios_base::hex 정의되어 있는 상수 '값'임.그러나 조작자 hex는 ios_base객체를 레퍼런스로 받고 다시 그 객체를 리턴하도록 정의된 함수임.std::ios_base&amp; hex(std::ios_base&amp; str);\noperator&gt;&gt; 중에서도 위 함수를 인자로 가지도록 오버로딩 되어 있음istream&amp; operator&gt;&gt;(ios_base&amp; (*pf)(ios_base&amp;));\n조작자를 사용하면 입력 형식을 쉽게 바꿀 수 있음. endl\b는 출력을 관장하는 ostream에 정의되어 있는 조작자임. 한줄 개행문자를 출력하는 것말고 버퍼를 flush 역할을 수행함.기본적으로 문자 1개를 내보낸다고 화면에 바로 출력하는 것이 아니라 버퍼에 모은 다음에 버퍼에 어느정도 쌓이면 출력하게 되지만 flush()는 버퍼에 데이터가 얼마나 쌓여있든지 바로 출력을 해줌.c++에 streambuf 클래스가 있음 streambuf 클래스는 스트림에 대한 가장 기본적인 제어를 담당<br><img alt=\"cpp_7.png\" src=\"images/cpp_7.png\" target=\"_self\">\n(streambuf 클래스에서 스트림을 어떤 식으로 추상화하고 있는지 나타내는 그림)streambuf 클래스는 스트림의 상태를 나타내기 위해서 세 개의 포인터 정의\n버퍼의 시작 부분을 가르키는 시작 포인터\n다음으로 읽을 문자를 가르키고 있는 포인터(스트림 위치 지정자)\n버퍼의 끝 부분을 가르키는 끝 포인터\nstreambuf 클래스는 입력 버퍼와 출력 버퍼를 구분해서 get area, put area라 부름. 이를 각각 가르키는 포인터도 g, p를 붙여서 표현입력 객체 cin.rdbuf()를 호출하면 cin 객체가 수행하고 있던 streambuf 객체를 가르키는 포인터를 리턴하게 됨. cin 객체는 istream 객체이므로 오직 입력만을 수행하고 있음. 따라서 streambuf 객체에는 get area만 있음snextc() 함수는 스트림 위치 지정자를 한 칸 전진한 해당 문자를 엿봄.(읽는 것이 아님)peek의 결과가 왜 'w'일까?<br><img alt=\"cpp_8.png\" src=\"images/cpp_8.png\" target=\"_self\"><br><img alt=\"cpp_9.png\" src=\"images/cpp_9.png\" target=\"_self\">streambuf&nbsp;에는&nbsp;snextc&nbsp;함수 말고도 수 많은 함수들이 정의되어있음.\nC++ 입출력 라이브러리는 스트림 버퍼도 추상화해서 클래스로 만들었다는 것을 기억하기cin은 스트림버퍼에서 공백을 기준으로 가져옴#include &lt;iostream&gt;\n#include &lt;string&gt; int main()\n{ std::string s; std::cin &gt;&gt; s; std::cout &lt;&lt; \"1: \" &lt;&lt; s &lt;&lt; std::endl; // std::cin &gt;&gt; s; std::cout &lt;&lt; \"2: \" &lt;&lt; s &lt;&lt; std::endl; return 0; }\nQ) 입력값으로 hello world 를 입력했을 때 std::cin &gt;&gt; s 를 주석처리한 경우와 아닌 경우 결과는?주석처리 하지 않은 경우 1: hello\n2: world 주석처리한 경우 1: hello\n2: hello #include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in(\"test.txt\"); std::string s; if (in.is_open()) { // 위치 지정자를 파일 끝으로 옮긴다. in.seekg(0, std::ios::end); // 그리고 그 위치를 읽는다. (파일의 크기) int size = in.tellg(); // 그 크기의 문자열을 할당한다. s.resize(size); // 위치 지정자를 다시 파일 맨 앞으로 옮긴다. in.seekg(0, std::ios::beg); // 파일 전체 내용을 읽어서 문자열에 저장한다. // read의 파라미터: 저장할 객체, 버퍼 사이즈 in.read(&amp;s[0], size); std::cout &lt;&lt; s &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"파일을 찾을 수 없습니다!\" &lt;&lt; std::endl; } return 0;\n}\n// getline 으로 읽어들이기\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in(\"test.txt\"); char buf[100]; if (!in.is_open()) { std::cout &lt;&lt; \"파일을 찾을 수 없습니다!\" &lt;&lt; std::endl; return 0; } // getline 함수는 개행 문자 (혹은 지정한 문자) 가 나오기 전에 지정한 버퍼의 크기가 다 차게 된다면 `failbit` 를 켜게 됨 while (in) { in.getline(buf, 100); // in.getline(buf, 100, '.')로 하면 .나올 때까지 읽음 // 기본적으로 '\\n' std::cout &lt;&lt; buf &lt;&lt; std::endl; } return 0;\n}\nin.getline: ifstream에 정의된 getline은 buffer를 입력해줘야 함. 버퍼의 크기를 너무 작게 만든다면 정상적으로 데이터를 받을 수 없음.이러한 한계점을 극복하기 위해서 std::string::getline을 이용string::getline은 첫번째 인자를 istream(인풋 파일 스트림만을 의미하는 것 아님. 전체)\n두번째 인자는 저장할 스트링 객체#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in(\"test.txt\"); if (!in.is_open()) { std::cout &lt;&lt; \"파일을 찾을 수 없습니다!\" &lt;&lt; std::endl; return 0; } std::string s; while (in) { getline(in, s); std::cout &lt;&lt; s &lt;&lt; std::endl; } return 0;\n}\n한 가지 주의할 사항으로&nbsp;`while`&nbsp;문 조건으로&nbsp;절대&nbsp;`in.eof()`&nbsp;를 사용하면 안됩니다. 이러한 코드를 사용했다면 99 퍼센트의 확률로 잘못된 코드 입니다. 왜냐하면&nbsp;[eof]&nbsp;함수는 파일 위치 지시자가 파일에 끝에 도달한&nbsp;이후&nbsp;에&nbsp;`true`&nbsp;를 리턴하기 때문입니다. 예를 들어서&nbsp;`while`&nbsp;문 안에서 파일을 쭈르륵 읽다가 파일 끝(EOF) 바로 직전까지 읽었다고 해봅시다. 그렇다면 아직 EOF 를 읽지 않았으므로&nbsp;`in.eof()`&nbsp;는 참인 상태일 것입니다. 그 상태에서 예컨대&nbsp;`in &gt;&gt; data`&nbsp;를 하게 된다면&nbsp;`data`&nbsp;에는 아무것도 들어가지 않게 됩니다. 즉 초기화가 되지 않은 상태로 남아있는 것입니다! 다시 말해&nbsp;`in.eof()`&nbsp;는&nbsp;`while`&nbsp;문 안에서&nbsp;파일 읽기가 안전하다 라는 것을 보장하지 않습니다. 정확한 사용법은 그냥&nbsp;`while(in)`&nbsp;처럼 스트림 객체 자체를 전달하는 것입니다. 앞에서도 말했듯이&nbsp;[istream]&nbsp;객체는 다음 읽기가 안전할 때만&nbsp;`true`&nbsp;로 캐스팅됩니다.\nofstream을 이용해서 파일을 쓸 수 있음.#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt; int main() { // 파일 쓰기 준비 std::ofstream out(\"test.txt\"); std::string s; if (out.is_open()) { out &lt;&lt; \"이걸 쓰자~~\"; } return 0;\n}\n다만 out에 특별한 설정이 없다면 딱 저대로 텍스트 파일이 생성됨 (기존의 파일 내용 없어짐) 만약 덧붙이고 싶다면 std::ios::app 옵션을 사용한다.std::ofstream out(\"test.txt\", std::ios::app);\nout 객체를 생성할 때 옵션은 몇가지 더 있음\nios::binary\nios::app\nios::ate - 자동으로 파일 끝에서 부터 읽기와 쓰기를 실시합니다. (즉 파일을 열 때 위치 지정자가 파일 끝을 가리키고 있게 됨\nios::trunc - 파일 스트림을 열면 기존에 있던 내용들이 모두 지워짐. 기본적으로&nbsp;ofstream&nbsp;객체를 생성할 때 이와 같은 설정으로 만들어짐\nios::app 과 ios::ate는 비슷하지만 중요한 차이가 있음.ios::app은 원본 내용 무조건 보장, ios::ate는 기존 파일의 내용을 보존X#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; class Human { std::string name; int age; public: Human(const std::string&amp; name, int age) : name(name), age(age) {} std::string get_info() { return \"Name :: \" + name + \" / Age :: \" + std::to_string(age); } friend std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; o, Human&amp; h);\n}; std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; o, Human&amp; h) { o &lt;&lt; h.get_info(); return o;\n}\nint main() { // 파일 쓰기 준비 std::ofstream out(\"test.txt\"); Human h(\"이재범\", 60); out &lt;&lt; h &lt;&lt; std::endl; return 0;\n}\n#include &lt;iostream&gt;\n#include &lt;sstream&gt; int main() { std::istringstream ss(\"123\"); int x; ss &gt;&gt; x; std::cout &lt;&lt; \"입력 받은 데이터 :: \" &lt;&lt; x &lt;&lt; std::endl; return 0;\n}\nsstream에 std::istringstream이 정의되어 있음 -&gt; 마치 문자열을 하나의 스트림이라고 생각하게 하는 가상화 장치std::istringstream ss(\"123\"); // 입력스트림 생성 (입력받은 것같음)\n활용 어케하냐#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt; double to_number(std::string s) { std::istringstream ss(s); double x; ss &gt;&gt; x; return x;\n} std::string to_str(int x) { std::ostringstream ss; ss &lt;&lt; x; return ss.str();\n} int main() { std::cout &lt;&lt; \"변환:: 1 + 2 = \" &lt;&lt; to_number(\"1\") + to_number(\"2\") &lt;&lt; std::endl; std::cout &lt;&lt; \"문자열로 변환:: 1 + 2 = \" &lt;&lt; to_str(1 + 2) &lt;&lt; std::endl; return 0;\n} <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"형식 플래그(format <code>flag)</code> 와 조작자 (Manipulator)","level":3,"id":"형식_플래그(format_`flag)`_와_조작자_(Manipulator)_0"},{"heading":"스트림 버퍼에 관해","level":3,"id":"스트림_버퍼에_관해_0"},{"heading":"복습 문제","level":5,"id":"복습_문제_0"},{"heading":"읽기 (read)","level":2,"id":"읽기_(read)_0"},{"heading":"파일 전체 읽기","level":3,"id":"파일_전체_읽기_0"},{"heading":"파일 전체를 한 줄씩 읽기","level":3,"id":"파일_전체를_한_줄씩_읽기_0"},{"heading":"쓰기","level":3,"id":"쓰기_0"},{"heading":"std::ofstream 연산자 오버로딩 하기","level":3,"id":"stdofstream_연산자_오버로딩_하기_0"},{"heading":"문자열 스트림 std::stringstream","level":3,"id":"문자열_스트림_stdstringstream_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"images/cpp_5.png","fullURL":"cpp/basic/6.-파일-입출력.html","pathToRoot":"../..","attachments":["images/cpp_5.html","images/cpp_6.html","images/cpp_7.html","images/cpp_8.html","images/cpp_9.html"],"createdTime":1718520118477,"modifiedTime":1738470383466,"sourceSize":15389,"sourcePath":"CPP/Basic/6. 파일 입출력.md","exportPath":"cpp/basic/6.-파일-입출력.html","showInTree":true,"treeOrder":46,"backlinks":[],"type":"markdown"},"cpp/build-system/cmake.html":{"title":"CMake","icon":"","description":"\bCMake는 빌드파일을 생성하는 프로그램이다. CMake를 통해 빌드 파일을 생성하고 빌드 프로그램 (Make, Visual Studio, Xcode etc..)을 이용해 프로젝트를 빌드할 수 있다.그리고 CMake 명령은 타겟을 정의하는 것과 타겟의 속성을 지정하는 명령어로 구성된다.\nadd_executable (&lt;실행 파일 이름&gt; &lt;소스1&gt; &lt;소스2&gt; ... &lt;소스들&gt;)\ntarget_compile_options(&lt;실행 파일 이름&gt; PUBLIC &lt;컴파일 옵션1&gt; &lt;컴파일 옵션2&gt; ...) Ex: `target_compile_options(program PUBLIC -Wall -Werror)\nPUBLIC: PRIVATE: target_include_directories(program {PUBLIC or PRIVATE or INTERFACE} ${CMAKE_SOURCE_DIR}/includes) 헤더 파일 탐색 경로 추가 add_library (&lt;라이브러리 이름&gt; [STATIC | SHARED | MODULE ] &lt;소스 1&gt; &lt;소스 2&gt; ...) STATIC: 정적\nSHARED: 동적\nMODULE: 동적링크 X, dlopen 같은 함수로 런타임에 불러올 수 있는 라이브러리 $ mkdir build &amp;&amp; cd build\n$ cmake .. # \broot CMakeList.txt 경로를 지정해야함\n$ brew install ninja\n$ cmake .. -G Ninja\n$ cmake --build .\n.vscode/settings.json{ // 이거는 직접 라이브러리 include path 추가 //\"clangd.fallbackFlags\": [ //\"-I/opt/homebrew/Cellar/opencv/4.11.0_1/include/opencv4\", //\"-I/opt/homebrew/Cellar/opencv/4.11.0_1/include\" //], \"clangd.arguments\": [ \"--compile-commands-dir=${workspaceFolder}\", \"--background-index\", \"--clang-tidy\" ]\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"필수 문법","level":3,"id":"필수_문법_0"},{"heading":"빌드 파일 생성하는 방법","level":4,"id":"빌드_파일_생성하는_방법_0"},{"heading":"Ninja 설치","level":4,"id":"Ninja_설치_0"},{"heading":"Ninja","level":4,"id":"Ninja_0"},{"heading":"visual studio code에서 clangd와 cmake 컴파일 설정 맞추기","level":4,"id":"visual_studio_code에서_clangd와_cmake_컴파일_설정_맞추기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/build-system/cmake.html","pathToRoot":"../..","attachments":[],"createdTime":1742132450645,"modifiedTime":1742132450645,"sourceSize":1697,"sourcePath":"CPP/Build System/CMake.md","exportPath":"cpp/build-system/cmake.html","showInTree":true,"treeOrder":48,"backlinks":[],"type":"markdown"},"cpp/build-system/pic.html":{"title":"PIC","icon":"","description":"PIC는 Position Independent Code의 준말로 실행파일이 메모리의 어느 위치에 상관 없이 올바르게 실행될 수 있도록 컴파일된 코드다.리눅스에서 C++을 컴파일 했을 때 아래와 유사한 에러가 발생했다.relocation R_X86_64_PC32 against symbol ... can not be used when making a shared object\nCMAKE_POSITION_INDEPENDENT_CODE ON 를 이용해서 해결했다. 왜 이게 해결법일까?공유 라이브러리가 프로그램에 로드될 때 운영체제는 이 라이브러리를 메모리의 어느 위치에 로드할 지 실행 시점에 결정한다. 그래서 메모리 위치는 랜덤이다. 그리고 현대적인 운영체제는 보안 강화를 위해 ASLR(Address Space Layout Randomization)이라는 기술을 사용한다. 이 기술은 프로그램과 라이브러리의 메모리 로드 위치를 의도적으로 무작위화 한다.PIC 옵션 켜지 않으면 위치 종속적 코드(Position Dependent Code)가 되어버려서 아래 유사하게 동작할 것이다. 만약 아래 코드가 메모리의 다른 위치 로드하게 되면 크래쉬가 발생할 것이다.// 위치 종속적 코드의 예시 (가상의 어셈블리와 유사한 형태)\nfunction_a: // 이 함수가 메모리 주소 0x10000에 있다고 가정 ... CALL 0x10500 // function_b의 절대 주소를 하드코딩 ... function_b: // 이 함수는 항상 메모리 주소 0x10500에 있어야 함 ...\nPIC 옵션을 켜면// 위치 독립적 코드의 예시\nfunction_a: // 이 함수가 어디에 위치하든 상관없음 ... CALL PC+500 // 현재 프로그램 카운터(PC)로부터의 상대적 오프셋 ... function_b: // function_a로부터 항상 500바이트 떨어진 위치에 있음 ...\n함수 호출을 상대적인 거리 (offset)으로 하기 때문에 코드가 메모리 위치에 상관 없이 제대로 동작할 수 있다.즉 PIC 옵션은 메모리 매핑의 불확실성 속에서 코드가 올바르게 동작할 수 있게 된다. 운영체제가 라이브러리를 메모리의 어디에 배치하든 상관없이 코드는 자신의 위치와 다른 코드 조각들의 상대적 위치 관계를 이용하여 올바르게 실행된다.Linux에서는 공유 라이브러리 (so)를 빌드할 때 명시적으로 PIC 설정이 필요하다.\nMac에서는 기본적으로 공유 라이브러리(dylib)를 빌드할 때 -fPIC 옵션이 기본 적용된다.크로스플랫폼 타겟으로 하는 CMake 프로젝트에서는 Root CMakeLists.txt에서 PIC 설정을 하는 것이 좋다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"PIC를 넣지 않으면 문제가 되는 이유","level":4,"id":"PIC를_넣지_않으면_문제가_되는_이유_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/build-system/pic.html","pathToRoot":"../..","attachments":[],"createdTime":1740931213902,"modifiedTime":1740931213902,"sourceSize":2715,"sourcePath":"CPP/Build System/PIC.md","exportPath":"cpp/build-system/pic.html","showInTree":true,"treeOrder":49,"backlinks":[],"type":"markdown"},"cpp/concurrency/1.-thread.html":{"title":"1. thread","icon":"","description":"프로세스끼리 메모리 공유하지 않음.쓰레드: 프로그램 내에서 동시에 실행될 수 있는 작은 실행 단위임쓰레드는 같은 프로세스 내에 있으면 같은 메모리 공유#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing std::thread; void func1() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; \"쓰레드 1 작동중! \\n\"; }\n} void func2() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; \"쓰레드 2 작동중! \\n\"; }\n} void func3() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; \"쓰레드 3 작동중! \\n\"; }\n}\nint main() { thread t1(func1); thread t2(func2); thread t3(func3); t1.join(); t2.join(); t3.join();\n}\njoin은 쓰레드들이 실행을 종료하면 리턴하는 함수\ndetatch는 해당 쓰레드를 실행 시킨 후,&nbsp;잊어버리는 것&nbsp;이라 생각하시면 됩니다. 대신 쓰레드는 알아서 백그라운드에서 돌아감#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\nusing std::thread;\nusing std::vector; void worker(vector&lt;int&gt;::iterator start, vector&lt;int&gt;::iterator end, int* result) { int sum = 0; for (auto itr = start; itr &lt; end; ++itr) { sum += *itr; } *result = sum; // 쓰레드의 id 를 구한다. thread::id this_id = std::this_thread::get_id(); printf(\"쓰레드 %x 에서 %d 부터 %d 까지 계산한 결과 : %d \\n\", this_id, *start, *(end - 1), sum);\n} int main() { vector&lt;int&gt; data(10000); for (int i = 0; i &lt; 10000; i++) { data[i] = i; } // 각 쓰레드에서 계산된 부분 합들을 저장하는 벡터 vector&lt;int&gt; partial_sums(4); vector&lt;thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(thread(worker, data.begin() + i * 2500, data.begin() + (i + 1) * 2500, &amp;partial_sums[i])); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } int total = 0; for (int i = 0; i &lt; 4; i++) { total += partial_sums[i]; } std::cout &lt;&lt; \"전체 합 : \" &lt;&lt; total &lt;&lt; std::endl;\n}\nworker에서 std::cout 대신에 printf를 사용한 이유한 번 여러분이 컴퓨터라고 생각하고 위&nbsp;std::cout&nbsp;명령을 실행한다고 생각해보세요. 만약에&nbsp;std::cout &lt;&lt; \"쓰레드 \"&nbsp;까지 딱 실행했는데 운영체제가 갑자기 다른 쓰레드를 실행시키면 어떨까요? 그렇다면 화면에는&nbsp;쓰레드&nbsp;만 딱 나오고 그 뒤로 다른 쓰레드의 메세지가 표시될 것입니다.따라서 위와 같이&nbsp;std::cout&nbsp;의&nbsp;&lt;&lt;&nbsp;를 실행하는 과정 중간 중간에 계속 실행되는 쓰레드들이 바뀌면서 결과적으로 메세지가 뒤섞여서 나타나게 됩니다.std::cout&nbsp;의 경우&nbsp;std::cout &lt;&lt; A;&nbsp;를 하게 된다면 A 의 내용이 출력되는 동안 중간에 다른 쓰레드가 내용을 출력할 수 없게&nbsp;보장을 해줍니다 (그 사이에 컨텍스트 스위치가 되더라도 말이지요). 하지만&nbsp;std::cout &lt;&lt; A &lt;&lt; B;&nbsp;를 하게 되면&nbsp;A&nbsp;를 출력한 이후에&nbsp;B&nbsp;를 출력하기 전에 다른 쓰레드가 내용을 출력할 수 있습니다.반면에&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/35\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/35\" target=\"_self\">printf</a>&nbsp;는 조금 다릅니다.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/35\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/35\" target=\"_self\">printf</a>&nbsp;는&nbsp;\"...\"&nbsp;안에 있는 문자열을 출력할 때, 컨텍스트 스위치가 되더라도 다른 쓰레드들이 그 사이에 메세지를 집어넣지 못하게 막습니다. (자세한 내용은 여기&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads\" target=\"_self\">참고</a>)따라서, 방해받지 않고 전체 메세지를 제대로 출력할 수 있게 해줍니다.#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\nusing std::thread;\nusing std::vector; void worker(int&amp; counter) { for (int i = 0; i &lt; 10000; i++) { counter += 1; }\n} int main() { int counter = 0; vector&lt;thread&gt; workers; for (int i = 0; i &lt; 4; i++) { // 레퍼런스로 전달하려면 ref 함수로 감싸야 한다 (지난 강좌 bind 함수 참조) workers.push_back(thread(worker, std::ref(counter))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; \"Counter 최종 값 : \" &lt;&lt; counter &lt;&lt; std::endl;\n}\n흠 결과가 조금 이상하네요? 분명히 각 쓰레드에서 10000 씩 더했기 때문에 정상적인 상황이였다면 40000 이 출력되어야 했을 것입니다. 그런데, 모든 쓰레드들이 종료되고 최종적으로&nbsp;Counter&nbsp;에 써진 값은 10000 이 되었습니다 -&gt; 레이스 컨디션\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"c++에서 쓰레드 생성하는 방법","level":4,"id":"c++에서_쓰레드_생성하는_방법_0"},{"heading":"쓰레드에 인자 전달하기","level":3,"id":"쓰레드에_인자_전달하기_0"},{"heading":"메모리를 같이 접근한다면?","level":3,"id":"메모리를_같이_접근한다면?_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/concurrency/1.-thread.html","pathToRoot":"../..","attachments":[],"createdTime":1735206576299,"modifiedTime":1738470378986,"sourceSize":4745,"sourcePath":"CPP/Concurrency/1. thread.md","exportPath":"cpp/concurrency/1.-thread.html","showInTree":true,"treeOrder":51,"backlinks":[],"type":"markdown"},"cpp/concurrency/2.-mutex,-deadlock.html":{"title":"2. Mutex, deadlock","icon":"","description":"한 쓰레드에서만 위 코드를 실행시키기\nrace condition을 방지하기 위함#include &lt;iostream&gt;\n#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요\n#include &lt;thread&gt;\n#include &lt;vector&gt; void worker(int&amp; result, std::mutex&amp; m) { for (int i = 0; i &lt; 10000; i++) { m.lock(); result += 1; m.unlock(); }\n} int main() { int counter = 0; std::mutex m; // 우리의 mutex 객체 std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, std::ref(counter), std::ref(m))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; \"Counter 최종 값 : \" &lt;&lt; counter &lt;&lt; std::endl;\n}\nm.lock();\nresult += 1;\nm.unlock();\nm.lock()&nbsp;은&nbsp;뮤텍스&nbsp;m&nbsp;을 내가 쓰게 달라!&nbsp;라고 이야기 하는 것입니다. 이 때 중요한 사실은,&nbsp;한 번에 한 쓰레드에서만&nbsp;m&nbsp;의 사용 권한을 갖는다는 것입니다. 그렇다면, 다른 쓰레드에서&nbsp;m.lock()&nbsp;을 하였다면 어떻게될까요? 이는&nbsp;m&nbsp;을 소유한 쓰레드가&nbsp;m.unlock()&nbsp;을 통해&nbsp;m&nbsp;을 반환할 때 까지 무한정 기다리게 됩니다.m.unlock을 만약 하지 않는다면 다른 쓰레드에서 무한정 기다림 -&gt; 데드락위와 같은 문제를 해결하기 위해서는 취득한 뮤텍스는 사용이 끝나면 반드시 반환을 해야 합니다. 하지만 코드 길이가 길어지게 된다면 반환하는 것을 까먹을 수 있기 마련입니다.곰곰히 생각해보면 이전에 비슷한 문제를 해결한 기억이 있습니다.&nbsp;unique_ptr&nbsp;를 왜 도입을 하였는지 생각을 해보자면, 메모리를 할당 하였으면 사용 후에 반드시 해제를 해야 하므로, 아예 이 과정을&nbsp;unique_ptr&nbsp;의 소멸자에서 처리하도록 했었습니다.뮤텍스도 마찬가지로 사용 후 해제 패턴을 따르기 때문에 동일하게 소멸자에서 처리#include &lt;iostream&gt;\n#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요\n#include &lt;thread&gt;\n#include &lt;vector&gt; void worker(int&amp; result, std::mutex&amp; m) { for (int i = 0; i &lt; 10000; i++) { // lock 생성 시에 m.lock() 을 실행한다고 보면 된다. std::lock_guard&lt;std::mutex&gt; lock(m); result += 1; // scope 를 빠져 나가면 lock 이 소멸되면서 // m 을 알아서 unlock 한다. }\n} int main() { int counter = 0; std::mutex m; // 우리의 mutex 객체 std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, std::ref(counter), std::ref(m))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; \"Counter 최종 값 : \" &lt;&lt; counter &lt;&lt; std::endl;\n}\n데드락을 방지하기 위해서 한 쓰레드에 우선권을 주면, 다른 쓰레드만 일하고 남은 쓰레드는 일하지 않는 경우가 생김 -&gt; Starvation이 생길 가능성이 있음.#include &lt;iostream&gt;\n#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요\n#include &lt;thread&gt; void worker1(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { m1.lock(); m2.lock(); std::cout &lt;&lt; \"Worker1 Hi! \" &lt;&lt; i &lt;&lt; std::endl; m2.unlock(); m1.unlock(); }\n} void worker2(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { while (true) { m2.lock(); // m1 이 이미 lock 되어 있다면 \"야 차 빼\" 를 수행하게 된다. if (!m1.try_lock()) { m2.unlock(); continue; } std::cout &lt;&lt; \"Worker2 Hi! \" &lt;&lt; i &lt;&lt; std::endl; m1.unlock(); m2.unlock(); break; } }\n} int main() { std::mutex m1, m2; // 우리의 mutex 객체 std::thread t1(worker1, std::ref(m1), std::ref(m2)); std::thread t2(worker2, std::ref(m1), std::ref(m2)); t1.join(); t2.join(); std::cout &lt;&lt; \"끝!\" &lt;&lt; std::endl;\n}\nworker 1에 우선권을 줬음.#include &lt;iostream&gt;\n#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요\n#include &lt;thread&gt; void worker1(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { m1.lock(); m2.lock(); std::cout &lt;&lt; \"Worker1 Hi! \" &lt;&lt; i &lt;&lt; std::endl; m2.unlock(); m1.unlock(); }\n} void worker2(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { while (true) { m2.lock(); // m1 이 이미 lock 되어 있다면 \"야 차 빼\" 를 수행하게 된다. if (!m1.try_lock()) { m2.unlock(); continue; } std::cout &lt;&lt; \"Worker2 Hi! \" &lt;&lt; i &lt;&lt; std::endl; m1.unlock(); m2.unlock(); break; } }\n} int main() { std::mutex m1, m2; // 우리의 mutex 객체 std::thread t1(worker1, std::ref(m1), std::ref(m2)); std::thread t2(worker2, std::ref(m1), std::ref(m2)); t1.join(); t2.join(); std::cout &lt;&lt; \"끝!\" &lt;&lt; std::endl;\n}\n데드락을 해결하는건 매우매우 복잡하고 완벽하지 않음. 그래서, 데드락 상황이 발생하지 않게 잘 설계하는 것이 중요데드락 상황을 피하기 위해 다음과 같은 가이드라인을 제시모든 쓰레드들이 최대 1 개의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;만을 소유한다면 (일반적인 경우에) 데드락 상황이 발생하는 것을 피할 수 있습니다. 또한 대부분의 디자인에서는 1 개의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;으로도 충분합니다. 만일 여러개의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;을 필요로 한다면&nbsp;정말 필요로 하는지&nbsp;를 되물어보는 것이 좋습니다.<br>사실 이 가이드라인 역시 위에서 말한 내용과 자연스럽게 따라오는 것이긴 한데, 유저 코드에서&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;을 소유할 수 도 있기에 중첩된&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;을 얻는 것을 피하려면&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;소유시 유저 코드를 호출하는 것을 지양해야 합니다.<br>만일 여러개의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">Lock</a>&nbsp;들을 획득해야 할 상황이 온다면,&nbsp;반드시 이 Lock 들을 정해진 순서로 획득해야 합니다. 우리가 앞선 예제에서 데드락이 발생했던 이유 역시,&nbsp;worker1&nbsp;에서는&nbsp;m1, m2&nbsp;순으로&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">lock</a>&nbsp;을 하였지만&nbsp;worker2&nbsp;에서는&nbsp;m2, m1&nbsp;순으로&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">lock</a>&nbsp;을 하였기 때문이지요. 만일&nbsp;worker2&nbsp;에서 역시&nbsp;m1, m2&nbsp;순으로&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">lock</a>&nbsp;을 하였다면 데드락은 발생하지 않았을 것입니다.\n#include &lt;chrono&gt; // std::chrono::miliseconds\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; void producer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int index) { for (int i = 0; i &lt; 5; i++) { // 웹사이트를 다운로드 하는데 걸리는 시간이라 생각하면 된다. // 각 쓰레드 별로 다운로드 하는데 걸리는 시간이 다르다. std::this_thread::sleep_for(std::chrono::milliseconds(100 * index)); std::string content = \"웹사이트 : \" + std::to_string(i) + \" from thread(\" + std::to_string(index) + \")\\n\"; // data 는 쓰레드 사이에서 공유되므로 critical section 에 넣어야 한다. m-&gt;lock(); downloaded_pages-&gt;push(content); m-&gt;unlock(); }\n} void consumer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int* num_processed) { // 전체 처리하는 페이지 개수가 5 * 5 = 25 개. while (*num_processed &lt; 25) { m-&gt;lock(); // 만일 현재 다운로드한 페이지가 없다면 다시 대기. if (downloaded_pages-&gt;empty()) { m-&gt;unlock(); // (Quiz) 여기서 unlock 을 안한다면 어떻게 될까요? // 10 밀리초 뒤에 다시 확인한다. std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; } // 맨 앞의 페이지를 읽고 대기 목록에서 제거한다. std::string content = downloaded_pages-&gt;front(); downloaded_pages-&gt;pop(); (*num_processed)++; m-&gt;unlock(); // content 를 처리한다. std::cout &lt;&lt; content; std::this_thread::sleep_for(std::chrono::milliseconds(80)); }\n} int main() { // 현재 다운로드한 페이지들 리스트로, 아직 처리되지 않은 것들이다. std::queue&lt;std::string&gt; downloaded_pages; std::mutex m; std::vector&lt;std::thread&gt; producers; for (int i = 0; i &lt; 5; i++) { producers.push_back(std::thread(producer, &amp;downloaded_pages, &amp;m, i + 1)); } int num_processed = 0; std::vector&lt;std::thread&gt; consumers; for (int i = 0; i &lt; 3; i++) { consumers.push_back( std::thread(consumer, &amp;downloaded_pages, &amp;m, &amp;num_processed)); } for (int i = 0; i &lt; 5; i++) { producers[i].join(); } for (int i = 0; i &lt; 3; i++) { consumers[i].join(); }\n}\n먼저&nbsp;producer&nbsp;쓰레드에서는 웹사이트에서 페이지를 계속 다운로드 하는 역할을 하게 됩니다. 이 때, 다운로드한 페이지들을&nbsp;downloaded_pages&nbsp;라는 큐에 저장<br>\n<img alt=\"cpp_13.png\" src=\"images/cpp_13.png\" target=\"_self\">그리고 다운 받은 웹사이트 내용이&nbsp;content&nbsp;라고 생각해봅시다.그렇다면, 이제 다운 받은 페이지를 작업 큐에 집어 넣어야 합니다. 이 때 주의할 점으로,&nbsp;producer&nbsp;쓰레드가 1 개가 아니라 5 개나 있다는 점입니다. 따라서&nbsp;downloaded_pages&nbsp;에 접근하는 쓰레드들 사이에&nbsp;race condition&nbsp;이 발생할 수 있습니다.이를 방지 하기 위해서 뮤텍스&nbsp;m&nbsp;으로 해당 코드를 감싸서 문제가 발생하지 않게 해줍니다.먼저&nbsp;consumer&nbsp;쓰레드의 입장에서는&nbsp;언제 일이 올지 알 수 없습니다. 따라서&nbsp;downloaded_pages&nbsp;가 비어있지 않을 때 까지 계속&nbsp;while&nbsp;루프를 돌아야겠지요. 한 가지 문제는 컴퓨터 CPU 의 속도에 비해 웹사이트 정보가 큐에 추가되는 속도는 매우 느리다는 점입니다.우리의&nbsp;producer&nbsp;의 경우 대충 100ms 마다 웹사이트 정보를 큐에 추가하게 되는데, 이 시간 동안&nbsp;downloaded_pages-&gt;empty()&nbsp;이 문장을 수십 만 번 호출할 수 있을 것입니다. 이는 상당한 CPU 자원의 낭비가 아닐 수 없지요. 그래서 empty인 경우 10 밀리 세컨드 후에 다시 실행 (continue;) <br>정상 작동함..근데 consumer가 10밀리 세컨드마다 downloaded_pages에 할일이 있는 지 확인하고 있으면 하고 없으면 기다리는 형태라서 비효율임 매 번 언제 올지 모르는 데이터를 확인하기 위해 지속적으로&nbsp;mutex&nbsp;를&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/lock\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/lock\" target=\"_self\">lock</a>&nbsp;하고, 큐를 확인해야 하기 때문어떻게 개선할까?consumer는 그냥 재워놓고 producer에서 할 일이 온다면 그때 consumer를 깨우자.위와 같은 상황에서 쓰레드들을 10 밀리초 마다 재웠다 깨웠다 할 수 밖에 없었던 이유는&nbsp;어떠 어떠한 조건을 만족할 때 까지 자라!&nbsp;라는 명령을 내릴 수 없었기 때문입니다.위 경우&nbsp;downloaded_pages&nbsp;가&nbsp;empty()&nbsp;가 참이 아닐 때 까지 자라&nbsp;라는 명령을 내리고 싶었겠지요.#include &lt;chrono&gt; // std::chrono::miliseconds\n#include &lt;condition_variable&gt; // std::condition_variable\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; void producer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int index, std::condition_variable* cv) { for (int i = 0; i &lt; 5; i++) { // 웹사이트를 다운로드 하는데 걸리는 시간이라 생각하면 된다. // 각 쓰레드 별로 다운로드 하는데 걸리는 시간이 다르다. std::this_thread::sleep_for(std::chrono::milliseconds(100 * index)); std::string content = \"웹사이트 : \" + std::to_string(i) + \" from thread(\" + std::to_string(index) + \")\\n\"; // data 는 쓰레드 사이에서 공유되므로 critical section 에 넣어야 한다. m-&gt;lock(); downloaded_pages-&gt;push(content); m-&gt;unlock(); // consumer 에게 content 가 준비되었음을 알린다. cv-&gt;notify_one(); }\n} void consumer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int* num_processed, std::condition_variable* cv) { while (*num_processed &lt; 25) { std::unique_lock&lt;std::mutex&gt; lk(*m); cv-&gt;wait( lk, [&amp;] { return !downloaded_pages-&gt;empty() || *num_processed == 25; }); if (*num_processed == 25) { lk.unlock(); return; } // 맨 앞의 페이지를 읽고 대기 목록에서 제거한다. std::string content = downloaded_pages-&gt;front(); downloaded_pages-&gt;pop(); (*num_processed)++; lk.unlock(); // content 를 처리한다. std::cout &lt;&lt; content; std::this_thread::sleep_for(std::chrono::milliseconds(80)); }\n} int main() { // 현재 다운로드한 페이지들 리스트로, 아직 처리되지 않은 것들이다. std::queue&lt;std::string&gt; downloaded_pages; std::mutex m; std::condition_variable cv; std::vector&lt;std::thread&gt; producers; for (int i = 0; i &lt; 5; i++) { producers.push_back( std::thread(producer, &amp;downloaded_pages, &amp;m, i + 1, &amp;cv)); } int num_processed = 0; std::vector&lt;std::thread&gt; consumers; for (int i = 0; i &lt; 3; i++) { consumers.push_back( std::thread(consumer, &amp;downloaded_pages, &amp;m, &amp;num_processed, &amp;cv)); } for (int i = 0; i &lt; 5; i++) { producers[i].join(); } // 나머지 자고 있는 쓰레드들을 모두 깨운다. cv.notify_all(); for (int i = 0; i &lt; 3; i++) { consumers[i].join(); }\n}\nstd::unique_lock&lt;std::mutex&gt; lk(*m); cv-&gt;wait(lk, [&amp;] { return !downloaded_pages-&gt;empty() || *num_processed == 25; });\n<br>condition_variable&nbsp;의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/wait-fwait\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/wait-fwait\" target=\"_self\">wait</a>&nbsp;함수에 어떤 조건이 참이 될 때 까지 기다릴지 해당 조건을 인자로 여러 쓰레드에서 같은 객체의 값을 수정한다면 Race Condition 이 발생합니다. 이를 해결하기 위해서는 여러가지 방법이 있지만, 한 가지 방법으로 뮤텍스를 사용하는 방법이 있습니다. 뮤텍스는 한 번에 한 쓰레드에서만 획득할 수 있습니다. 획득한 뮤텍스는&nbsp;반드시&nbsp;반환해야 합니다.&nbsp;lock_guard&nbsp;나&nbsp;unique_lock&nbsp;등을 이용하면 뮤텍스의 획득-반환을 손쉽게 처리할 수 있습니다. 뮤텍스를 사용할 때 데드락이 발생하지 않도록 주의해야 합니다. 데드락을 디버깅하는 것은 매우 어렵습니다.&nbsp;condition_variable&nbsp;을 사용하면 생산자-소비자 패턴을 쉽게 구현할 수 있습니다.\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"데드락 (deadlock) &amp; Starvation (기아)","level":3,"id":"데드락_(deadlock)_&_Starvation_(기아)_0"},{"heading":"중첩된 Lock 을 사용하는 것을 피해라","level":4,"id":"중첩된_Lock_을_사용하는_것을_피해라_0"},{"heading":"Lock 을 소유하고 있을 때 유저 코드를 호출하는 것을 피해라","level":4,"id":"Lock_을_소유하고_있을_때_유저_코드를_호출하는_것을_피해라_0"},{"heading":"Lock 들을 언제나 정해진 순서로 획득해라","level":4,"id":"Lock_들을_언제나_정해진_순서로_획득해라_0"},{"heading":"생산자(Producer) 와 소비자(Consumer) 패턴","level":3,"id":"생산자(Producer)_와_소비자(Consumer)_패턴_0"},{"heading":"condition_variable","level":3,"id":"condition_variable_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"images/cpp_13.png","fullURL":"cpp/concurrency/2.-mutex,-deadlock.html","pathToRoot":"../..","attachments":["images/cpp_13.html"],"createdTime":1735209156958,"modifiedTime":1738470375860,"sourceSize":15232,"sourcePath":"CPP/Concurrency/2. Mutex, deadlock.md","exportPath":"cpp/concurrency/2.-mutex,-deadlock.html","showInTree":true,"treeOrder":52,"backlinks":[],"type":"markdown"},"cpp/concurrency/3.-memory-order,-atomic.html":{"title":"3. memory order, atomic","icon":"","description":"CPU 와 컴퓨터 메모리인 RAM 은 물리적으로 떨어져 있습니다. 따라서 CPU 가 메모리에서 데이터를 읽어 오기 위해서는 꽤 많은 시간이 걸립니다. 실제로, 인텔의 i7-6700 CPU 의 경우 최소 42 사이클 정도 걸린다고 보시면 됩니다. CPU 에서 덧셈 한 번을 1 사이클에 끝낼 수 있는데, 메모리에서 데이터 오는 것을 기다리느라, 42 번 덧셈을 연산할 시간을 놓치게 되는 것CPU 에서 연산을 수행하는 부분이랑 거의 붙어 있다 싶이 해서, 읽기 / 쓰기 속도가 매우 빠르다는 점입니다.\nCPU 에서 가장 많이 접근하는 메모리 영역은 L1 캐시에 가져다 놓게 되고, 그 다음으로, 자주 접근하는 부분은 L2, 마지막으로 L3 캐시 순임CPU 가 특정한 주소에 있는 데이터에 접근하려 한다면, 일단 캐시에 있는지 확인한 후, 캐시에 있다면 해당 값을 읽고, 없다면 메모리 까지 갔다 오는 방식으로 진행됩니다. 이렇게 캐시에 있는 데이터를 다시 요청해서 시간을 절약하는 것을&nbsp;Cache hit&nbsp;이라과 하며 반대로 캐시에 요청한 데이터가 없어서 메모리 까지 갔다 오는 것을&nbsp;Cache miss&nbsp;라고 부릅니다.&nbsp;CPU 가 어떻게 어느 영역의 메모리에 자주 접근할 지 어떻게 아는 것일까요? 답은&nbsp;알 수 없다&nbsp;입니다. 따라서 보통 CPU 에서 캐시가 작동하는 방식은 다음과 같습니다.&nbsp;\n메모리를 읽으면 일단 캐시에 저장해놓는다.\n만일 캐시가 다 찼다면 특정한 방식에 따라 처리한다. (LRU: Least Recently Used)\n예를 들어서 캐시 크기가 1 KB 밖에 안되고 LRU 방식을 사용하는 CPU 가 있다고 했을 때 첫 번째 코드가 더 빠르게 작동할까요? 아니면 두 번째 코드가 더 빨리 작동할까요? 두 코드는 동일한 연산을 수행합니다.for (int i = 0; i &lt; 10000; i++) { for (int j = 0; j &lt; 10000; j++) { s += data[j]; }\n}\nfor (int j = 0; j &lt; 10000; j++) { for (int i = 0; i &lt; 10000; i++) { s += data[j]; }\n}\n답은 두 번째 방식입니다. 왜냐하면 첫 번째 경우에서&nbsp;data[0]&nbsp;를 접근하는 것을 생각해봅시다. 일단 첫 번째 루프에서&nbsp;data[0]&nbsp;는 캐시에 들어가게 됩니다. 하지만, CPU 캐시가 매우 작기 때문에&nbsp;j = 256&nbsp;이 되었을 때&nbsp;data[0]&nbsp;는 캐시에서 사라지게 되지요 (1KB = 1024 byte = int 256 개).따라서&nbsp;i = 1&nbsp;인 루프에서&nbsp;data[0]&nbsp;에 다시 접근했을 때 이미&nbsp;data[0]&nbsp;는 캐시에서 사라진 이후기에 Cache Miss 가 발생하게 됩니다. 따지고 보면&nbsp;data&nbsp;원소의 모든 접근이 Cache Miss 가 되서 느리겠지요.반면에 후자의 경우&nbsp;data[0]&nbsp;을&nbsp;10000&nbsp;번 연속으로 접근하므로, 처음에 접근할 때 빼고 나머지&nbsp;9999&nbsp;번 접근이 Cache hit 이 되어서 빠르게 덧셈을 수행할 수 있게 됩니다.컴파일러는 지 알아서 명령어 재배치를 함.이와 같이, 한 작업 (세탁 - 건조 - 개기) 이 끝나기 전에, 다음 작업을 시작하는 방식으로 동시에 여러 개의 작업을 동시에 실행하는 것을&nbsp;파이프라이닝(pipelining)&nbsp;이라고 합니다.\nCPU 에서 명령어를 실행할 때 여러 단계를 거치게 됩니다. 명령어를 읽어야 하고 (fetch), 읽은 명령어가 무엇 인지 해석해야 하고 (decode), 해석된 명령어를 실행하고 (execute), 마지막으로 결과를 써야 하지요 (write).따라서, 컴파일러는 우리가 어떠한 최대한 CPU 의 파이프라인을 효율적으로 활용할 수 있도록 명령어를 재배치함.그리고 CPU도 캐시에 따라 실행 순서를 변경할 수 있음.명령어 순서도 뒤죽 박죽 바꾸고 심지어 CPU 에서도 명령어들을 제대로 된 순서로 실행하지 않는다면, 도대체 무엇을 믿을 수 있을까?C++ 의 모든 객체들은&nbsp;수정 순서(modification order)&nbsp;라는 것을 정의\nC++ 에서 보장하는 사실은, 원자적 연산을 할 경우에 모든 쓰레드에서 같은 객체에 대해서 동일한 수정&nbsp;순서&nbsp;를 관찰할 수 있다는 사실입니다.같은 시간에 변수&nbsp;a&nbsp;의 값을 관찰했다고 해서 굳이&nbsp;모든 쓰레드들이 동일한 값을 관찰할 필요는 없다 라는 점원자적 연산이란, CPU 가 명령어 1 개로 처리하는 명령으로, 중간에 다른 쓰레드가 끼어들 여지가 전혀 없는 연산\nC++ 에서는 몇몇 타입들에 원자적인 연산을 쉽게 할 수 있도록 여러가지 도구들을 지원하고 있습니다. 또한 이러한 원자적 연산들은 올바른 연산을 위해 굳이 뮤텍스가 필요하지 않습니다! 즉 속도가 더 빠름#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; void worker(std::atomic&lt;int&gt;&amp; counter) { for (int i = 0; i &lt; 10000; i++) { counter++; }\n} int main() { std::atomic&lt;int&gt; counter(0); std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, ref(counter))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; \"Counter 최종 값 : \" &lt;&lt; counter &lt;&lt; std::endl;\n}\n어셈블리를 까보면lock add DWORD PTR [rdi], 1\n이런 부분이 나오는데, x86 컴파일러가 알고 있었기 때문에 사용가능한거.CPU에 따라 사용 못할 수도 있음. 이러한 연산이 가능한지 확인하는 방법std::atomic&lt;int&gt; x;\nstd::cout &lt;&lt; \"is lock free ? : \" &lt;&lt; boolalpha &lt;&lt; x.is_lock_free() &lt;&lt; std::endl;\natomic&nbsp;객체들의 경우 원자적 연산 시에 메모리에 접근할 때 어떠한 방식으로 접근하는지 지정할 수 있습니다.가장&nbsp;느슨한&nbsp;조건입니다. 다시 말해,&nbsp;memory_order_relaxed&nbsp;방식으로 메모리에서 읽거나 쓸 경우, 주위의 다른 메모리 접근들과 순서가 바뀌어도 무방#include &lt;atomic&gt;\n#include &lt;cstdio&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\nusing std::memory_order_relaxed; void t1(std::atomic&lt;int&gt;* a, std::atomic&lt;int&gt;* b) { b-&gt;store(1, memory_order_relaxed); // b = 1 (쓰기) int x = a-&gt;load(memory_order_relaxed); // x = a (읽기) printf(\"x : %d \\n\", x);\n} void t2(std::atomic&lt;int&gt;* a, std::atomic&lt;int&gt;* b) { a-&gt;store(1, memory_order_relaxed); // a = 1 (쓰기) int y = b-&gt;load(memory_order_relaxed); // y = b (읽기) printf(\"y : %d \\n\", y);\n} int main() { std::vector&lt;std::thread&gt; threads; std::atomic&lt;int&gt; a(0); std::atomic&lt;int&gt; b(0); threads.push_back(std::thread(t1, &amp;a, &amp;b)); threads.push_back(std::thread(t2, &amp;a, &amp;b)); for (int i = 0; i &lt; 2; i++) { threads[i].join(); }\n}\nx : 1 y : 0 or x : 0 y : 1 or y : 1 x : 1 이 경우는 가능할까?\nx : 0 y : 0 x : 0\ny : 0위 명령어들이 순서대로 실행된다면 이는 불가능 하다는 사실을 알 수 있습니다.\n하지만, 메모리 연산들 사이에서 어떠한 제약조건도 없다고 하였습니다. 다시 말해 서로 다른 변수의&nbsp;relaxed&nbsp;메모리 연산은 CPU 마음대로 재배치 할 수 있습니다 (단일 쓰레드 관점에서 결과가 동일하다면)..emory_order_relaxed&nbsp;는 CPU 에서 메모리 연산 순서에 관련해서 무한한 자유를 주는 것과 같습니다. 덕분에 CPU 에서 매우 빠른 속도로 실행할 수 있게됩니다.#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; void producer(std::atomic&lt;bool&gt;* is_ready, int* data) { *data = 10; is_ready-&gt;store(true, std::memory_order_release);\n} void consumer(std::atomic&lt;bool&gt;* is_ready, int* data) { // data 가 준비될 때 까지 기다린다. while (!is_ready-&gt;load(std::memory_order_acquire)) { } std::cout &lt;&lt; \"Data : \" &lt;&lt; *data &lt;&lt; std::endl;\n} int main() { std::vector&lt;std::thread&gt; threads; std::atomic&lt;bool&gt; is_ready(false); int data = 0; threads.push_back(std::thread(producer, &amp;is_ready, &amp;data)); threads.push_back(std::thread(consumer, &amp;is_ready, &amp;data)); for (int i = 0; i &lt; 2; i++) { threads[i].join(); }\n}\ndata&nbsp;에 0 이 들어가는 일 불가능!memory_order_release&nbsp;는&nbsp;해당 명령 이전의 모든 메모리 명령들이 해당 명령 이후로 재배치 되는 것을 금지\n또한, 만약에 같은 변수를&nbsp;memory_order_acquire&nbsp;으로 읽는 쓰레드가 있다면,&nbsp;memory_order_release&nbsp;이전에 오는 모든 메모리 명령들이 해당 쓰레드에 의해서&nbsp;관찰&nbsp;될 수 있어야 합니다.쉽게 말해&nbsp;is_ready-&gt;storememory_order_release;&nbsp;밑으로&nbsp;*data = 10&nbsp;이 올 수 없게 됩니다. 또한&nbsp;is_ready&nbsp;가&nbsp;true&nbsp;가 된다면,&nbsp;memory_order_acquire&nbsp;로&nbsp;is_ready&nbsp;를 읽는 쓰레드에서&nbsp;data&nbsp;의 값을 확인했을 때&nbsp;10&nbsp;임을 관찰할 수 있어야하죠.memory_order_acquire&nbsp;의 경우,&nbsp;release&nbsp;와는 반대로&nbsp;해당 명령 뒤에 오는 모든 메모리 명령들이 해당 명령 위로 재배치 되는 것을 금지&nbsp;합니다.이와 같이 두 개의 다른 쓰레드들이 같은 변수의&nbsp;release&nbsp;와&nbsp;acquire&nbsp;를 통해서&nbsp;동기화 (synchronize)&nbsp;를 수행하는 것을 볼 수 있습니다.memory_order_acq_rel&nbsp;은 이름에서도 알 수 있듯이,&nbsp;acquire&nbsp;와&nbsp;release&nbsp;를 모두 수행하는 것입니다. 이는, 읽기와 쓰기를 모두 수행하는 명령들, 예를 들어서&nbsp;fetch_add&nbsp;와 같은 함수에서 사용될 수 있습니다.memory_order_seq_cst&nbsp;는 메모리 명령의&nbsp;순차적 일관성(sequential consistency)&nbsp;을 보장해줍니다.순차적 일관성이란, 메모리 명령 재배치도 없고, 모든 쓰레드에서 모든 시점에 동일한 값을 관찰할 수 있는, 여러분이 생각하는 그대로 CPU 가 작동하는 방식#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt; std::atomic&lt;bool&gt; x(false);\nstd::atomic&lt;bool&gt; y(false);\nstd::atomic&lt;int&gt; z(0); void write_x() { x.store(true, std::memory_order_release); } void write_y() { y.store(true, std::memory_order_release); } void read_x_then_y() { while (!x.load(std::memory_order_acquire)) { } if (y.load(std::memory_order_acquire)) { ++z; }\n} void read_y_then_x() { while (!y.load(std::memory_order_acquire)) { } if (x.load(std::memory_order_acquire)) { ++z; }\n} int main() { thread a(write_x); thread b(write_y); thread c(read_x_then_y); thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); std::cout &lt;&lt; \"z : \" &lt;&lt; z &lt;&lt; std::endl;\n}\n실행결과\nz : 0\nor\nz : 1\nor\nz : 2\n왜 0이 나올 수 있을까?memory_order_seq_cst&nbsp;를 사용하게 된다면, 해당 명령을 사용하는 메모리 연산들 끼리는 모든 쓰레드에서 동일한 연산 순서를 관찰할 수 있도록 보장#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing std::memory_order_seq_cst;\nusing std::thread; std::atomic&lt;bool&gt; x(false);\nstd::atomic&lt;bool&gt; y(false);\nstd::atomic&lt;int&gt; z(0); void write_x() { x.store(true, memory_order_seq_cst); } void write_y() { y.store(true, memory_order_seq_cst); } void read_x_then_y() { while (!x.load(memory_order_seq_cst)) { } if (y.load(memory_order_seq_cst)) { ++z; }\n} void read_y_then_x() { while (!y.load(memory_order_seq_cst)) { } if (x.load(memory_order_seq_cst)) { ++z; }\n} int main() { thread a(write_x); thread b(write_y); thread c(read_x_then_y); thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); std::cout &lt;&lt; \"z : \" &lt;&lt; z &lt;&lt; std::endl;\n}\nz : 2 or z : 1\nz&nbsp;의 값이 0 이 되는 경우는 발생X\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"메모리는 느리다","level":4,"id":"메모리는_느리다_0"},{"heading":"캐시","level":3,"id":"캐시_0"},{"heading":"컴퓨터는 사실 여러분이 시키는 대로 하지 않는다.","level":3,"id":"컴퓨터는_사실_여러분이_시키는_대로_하지_않는다._0"},{"heading":"CPU 파이프라이닝 (pipelining)","level":4,"id":"CPU_파이프라이닝_(pipelining)_0"},{"heading":"무엇을 믿어야해?","level":3,"id":"무엇을_믿어야해?_0"},{"heading":"원자성(atomicity)","level":3,"id":"원자성(atomicity)_0"},{"heading":"memory_order","level":3,"id":"memory_order_0"},{"heading":"memory_order_relexed","level":4,"id":"memory_order_relexed_0"},{"heading":"memory_order_acquire 과 memory_order_release","level":4,"id":"memory_order_acquire_과_memory_order_release_0"},{"heading":"memory_order_acq_rel","level":4,"id":"memory_order_acq_rel_0"},{"heading":"memory_order_seq_cst","level":4,"id":"memory_order_seq_cst_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/concurrency/3.-memory-order,-atomic.html","pathToRoot":"../..","attachments":[],"createdTime":1735212962377,"modifiedTime":1738470370845,"sourceSize":12235,"sourcePath":"CPP/Concurrency/3. memory order, atomic.md","exportPath":"cpp/concurrency/3.-memory-order,-atomic.html","showInTree":true,"treeOrder":53,"backlinks":[],"type":"markdown"},"cpp/concurrency/4.-future,-async,-promise.html":{"title":"4. future, async, promise","icon":"","description":"c++ 초기에는 비동기 하려면 쓰레드로 직접 했어야 했다.\nc++11 std에서 도구 제공 되기 시작.동기적 실행으로 하고 싶은 일은, 어떠한 데이터를 다른 쓰레드를 통해 처리해서 받아내는 것\n어떤 쓰레드 T 를 사용해서, 비동기적으로 값을 받아내겠다 라는 의미는,&nbsp;미래에 (future) 쓰레드 T 가 원하는 데이터를 돌려 주겠다 라는 약속 (promise) 라고 볼 수 있습니다.#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\nusing std::string; void worker(std::promise&lt;string&gt;* p) { // 약속을 이행하는 모습. 해당 결과는 future 에 들어간다. p-&gt;set_value(\"some data\");\n}\nint main() { std::promise&lt;string&gt; p; // 미래에 string 데이터를 돌려 주겠다는 약속. std::future&lt;string&gt; data = p.get_future(); std::thread t(worker, &amp;p); // 미래에 약속된 데이터를 받을 때 까지 기다린다. data.wait(); // wait 이 리턴했다는 뜻이 future 에 데이터가 준비되었다는 의미. // 참고로 wait 없이 그냥 get 해도 wait 한 것과 같다. std::cout &lt;&lt; \"받은 데이터 : \" &lt;&lt; data.get() &lt;&lt; std::endl; t.join(); }\npromise&nbsp;객체는 자신이 가지고 있는&nbsp;future&nbsp;객체에 값을 넣어주게 됩니다.\n대응되는&nbsp;future&nbsp;객체의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;함수를 통해 얻어낼 수 있습니다. 한 가지 중요한 점은&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 값을 전달하기 전 까지&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/wait-fwait\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/wait-fwait\" target=\"_self\">wait</a>&nbsp;함수가 기다린다는 점입니다.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/wait-fwait\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/wait-fwait\" target=\"_self\">wait</a>&nbsp;함수가 리턴을 하였다면&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;을 통해서&nbsp;future&nbsp;에 전달된 객체를 얻을 수 있습니다.<br>참고로 굳이&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/wait-fwait\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/wait-fwait\" target=\"_self\">wait</a>&nbsp;함수를 따로 호출할 필요는 없는데,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;함수를 바로 호출하더라도 알아서&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 객체를 전달할 때 까지 기다린다음에 리턴합니다. 참고로&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;을 호출하면&nbsp;future&nbsp;내에 있던 데이터가 이동 됩니다. 따라서&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;을 다시 호출하면 안됩니다.`future`&nbsp;에서 get 을 호출하면, 설정된 객체가&nbsp;이동&nbsp;됩니다. 따라서 절대로&nbsp;get을 두 번 호출하면 안됩니다.\n<br>그냥&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/wait-fwait\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/wait-fwait\" target=\"_self\">wait</a>&nbsp;을 하였다면&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 전달할 때 까지 기다리게 됩니다. 하지만&nbsp;wait_for&nbsp;을 사용하면, 정해진 시간 동안만 기다리고 그냥 진행할 수 있습니다.#include &lt;chrono&gt;\n#include &lt;exception&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt; void worker(std::promise&lt;void&gt;* p) { std::this_thread::sleep_for(std::chrono::seconds(10)); p-&gt;set_value();\n}\nint main() { // void 의 경우 어떠한 객체도 전달하지 않지만, future 가 set 이 되었냐 // 안되었느냐의 유무로 마치 플래그의 역할을 수행할 수 있습니다. std::promise&lt;void&gt; p; // 미래에 string 데이터를 돌려 주겠다는 약속. std::future&lt;void&gt; data = p.get_future(); std::thread t(worker, &amp;p); // 미래에 약속된 데이터를 받을 때 까지 기다린다. while (true) { std::future_status status = data.wait_for(std::chrono::seconds(1)); // 아직 준비가 안됨 if (status == std::future_status::timeout) { std::cerr &lt;&lt; \"&gt;\"; } // promise 가 future 를 설정함. else if (status == std::future_status::ready) { break; } } t.join();\n}\nfuture_status&nbsp;는 총 3 가지 상태를 가질 수 있습니다. 먼저&nbsp;future&nbsp;에 값이 설정 됬을 때 나타나는&nbsp;future_status::ready&nbsp;가 있고,&nbsp;wait_for&nbsp;에 지정한 시간이 지났지만 값이 설정되지 않아서 리턴한 경우에는&nbsp;future_status::timeout&nbsp;이 리턴됩니다.마지막으로&nbsp;future_status::deferred&nbsp;가 있는데 이는 결과값을 계산하는 함수가 채 실행되지 않았다는 의미인데, 뒤에서 좀더 자세히 다루도록 하겠습니다.<br>앞서&nbsp;future&nbsp;의 경우 딱 한 번만&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;을 할 수 있다고 하였습니다. 왜냐하면&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;을 호출하면&nbsp;future&nbsp;내부의 객체가 이동되기 때문<br>but 종종 여러 개의 다른 쓰레드에서&nbsp;future&nbsp;를&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;할 필요성이 있음#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing std::thread; void runner(std::shared_future&lt;void&gt; start) { start.get(); std::cout &lt;&lt; \"출발!\" &lt;&lt; std::endl;\n} int main() { std::promise&lt;void&gt; p; std::shared_future&lt;void&gt; start = p.get_future(); thread t1(runner, start); thread t2(runner, start); thread t3(runner, start); thread t4(runner, start); // 참고로 cerr 는 std::cout 과는 다르게 버퍼를 사용하지 않기 때문에 터미널에 // 바로 출력된다. std::cerr &lt;&lt; \"준비...\"; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cerr &lt;&lt; \"땅!\" &lt;&lt; std::endl; p.set_value(); t1.join(); t2.join(); t3.join(); t4.join();\n}\nC++ 에서는 위&nbsp;promise-future&nbsp;패턴을 비동기적 함수(정확히는 Callable - 즉 람다 함수, Functor 포함) 의 리턴값에 간단히 적용할 수 있는&nbsp;packaged_task&nbsp;라는 것을 지원<br>\n<img alt=\"cpp_14.png\" src=\"images/cpp_14.png\" target=\"_self\">#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt; int some_task(int x) { return 10 + x; } int main() { // int(int) : int 를 리턴하고 인자로 int 를 받는 함수. (std::function 참조) std::packaged_task&lt;int(int)&gt; task(some_task); std::future&lt;int&gt; start = task.get_future(); std::thread t(std::move(task), 5); std::cout &lt;&lt; \"결과값 : \" &lt;&lt; start.get() &lt;&lt; std::endl; t.join();\n}\n<br>생성된&nbsp;packaged_task&nbsp;를 쓰레드에 전달하면 됩니다. 참고로&nbsp;packaged_task&nbsp;는 복사 생성이 불가능하므로 (promise&nbsp;도 마찬가지 입니다.) 명시적으로&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/301\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/301\" target=\"_self\">move</a>&nbsp;해줘야만 합니다.<br>비동기적으로 실행된 함수의 결과값은 추후에&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;함수로 받을 수 있게 됩니다. 이와 같이&nbsp;packaged_task&nbsp;를 사용하게 된다면 쓰레드에 굳이&nbsp;promise&nbsp;를 전달하지 않아도 알아서&nbsp;packaged_task&nbsp;가 함수의 리턴값을 처리해줘서 매우 편리 -&gt; some_task 함수에 set_value() 같은 거 없음std::async&nbsp;에 어떤 함수를 전달한다면, 아예 쓰레드를 알아서 만들어서 해당 함수를 비동기적으로 실행하고, 그 결과값을&nbsp;future&nbsp;에 전달즉 thread 만들 필요 없음parallel&nbsp;함수는 1 부터 1000 까지의 덧셈을 총 2 개의 쓰레드에서 실행한다고 보면 됩니다. 1 부터 500 까지의 합은,&nbsp;async&nbsp;를 통해 생성된 새로운 쓰레드에서 더하게 되고, 나머지 501 부터 1000 까지의 합은 원래의 쓰레드에서 처리하게 되죠.#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; // std::accumulate 와 동일\nint sum(const std::vector&lt;int&gt;&amp; v, int start, int end) { int total = 0; for (int i = start; i &lt; end; ++i) { total += v[i]; } return total;\n} int parallel_sum(const std::vector&lt;int&gt;&amp; v) { // lower_half_future 는 1 ~ 500 까지 비동기적으로 더함 // 참고로 람다 함수를 사용하면 좀 더 깔끔하게 표현할 수 도 있다. // --&gt; std::async([&amp;v]() { return sum(v, 0, v.size() / 2); }); std::future&lt;int&gt; lower_half_future = std::async(std::launch::async, sum, cref(v), 0, v.size() / 2); // upper_half 는 501 부터 1000 까지 더함 int upper_half = sum(v, v.size() / 2, v.size()); return lower_half_future.get() + upper_half;\n} int main() { std::vector&lt;int&gt; v; v.reserve(1000); for (int i = 0; i &lt; 1000; ++i) { v.push_back(i + 1); } std::cout &lt;&lt; \"1 부터 1000 까지의 합 : \" &lt;&lt; parallel_sum(v) &lt;&lt; std::endl;\n}\nasync&nbsp;함수는 인자로 받은 함수를 비동기적으로 실행한 후에, 해당 결과값을 보관할&nbsp;future&nbsp;를 리턴합니다. 첫 번째 인자로는 어떠한 형태로 실행할지를 전달하는데 두 가지 값이 가능합니다.\nstd::launch::async&nbsp;: 바로 쓰레드를 생성해서 인자로 전달된 함수를 실행한다. <br>std::launch::deferred&nbsp;:&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;함수가 호출되었을 때 실행한다. (새로운 쓰레드를 생성하지 않음) <br>즉&nbsp;launch::async&nbsp;옵션을 주면 바로 그 자리에서 쓰레드를 생성해서 실행하게 되고,&nbsp;launch::deferred&nbsp;옵션을 주면,&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/191\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/191\" target=\"_self\">get</a>&nbsp;을 하였을 때 비로소 (동기적으로) 실행하게 됩니다. 다시 말해, 해당 함수를 굳이 바로 당장 비동기적으로 실행할 필요가 없다면&nbsp;deferred&nbsp;옵션을 주면 됩니다.\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"동기 (synchronous) 와 비동기 (asynchronous) 실행","level":3,"id":"동기_(synchronous)_와_비동기_(asynchronous)_실행_0"},{"heading":"std::promise 와 std::future","level":3,"id":"stdpromise_와_stdfuture_0"},{"heading":"wait_for","level":4,"id":"wait_for_0"},{"heading":"shared_future","level":3,"id":"shared_future_0"},{"heading":"packaged_task","level":3,"id":"packaged_task_0"},{"heading":"std::async","level":3,"id":"stdasync_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"images/cpp_14.png","fullURL":"cpp/concurrency/4.-future,-async,-promise.html","pathToRoot":"../..","attachments":["images/cpp_14.html"],"createdTime":1735219967281,"modifiedTime":1738470366963,"sourceSize":9339,"sourcePath":"CPP/Concurrency/4. future, async, promise.md","exportPath":"cpp/concurrency/4.-future,-async,-promise.html","showInTree":true,"treeOrder":54,"backlinks":[],"type":"markdown"},"cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html":{"title":"5. 비동기, promise & future, callback, async, ThreadPool","icon":"","description":"\n개념: \"나중에 끝날 작업을 시작하고, 다른 일을 하는 것\"\n일종의 프로그래밍 패러다임\nPromise &amp; Future, Callback은 비동기를 구현하는 서로 다른 방식\n// 상황: 오래 걸리는 파일 읽기 작업 // 1. Promise/Future 방식\nstd::future&lt;string&gt; readFile(string path) { return std::async([path]() { // 파일 읽기 return content; });\n} // 사용\nauto future = readFile(\"data.txt\");\n// 다른 작업 수행\nstring content = future.get(); // 필요할 때 결과를 가져옴 // 2. Callback 방식\nvoid readFile(string path, function&lt;void(string)&gt; callback) { std::thread([path, callback]() { // 파일 읽기 callback(content); // 완료되면 callback 호출 }).detach();\n} // 사용\nreadFile(\"data.txt\", [](string content) { // 여기서 결과 처리\n}); 결과 처리 방식 Promise/Future: 결과가 필요한 시점에 우리가 직접 가져옴 (get)\nCallback: 결과가 준비되면 자동으로 호출 코드 구조 Promise/Future: 선형적\nCallback: 중첩될 수록 복잡 예외처리\n// Promise/Future\ntry { auto result = future.get();\n} catch (exception&amp; e) { // 에러 처리\n} // Callback\nreadFile(\"data.txt\", [](string content) { /* 성공 처리 */ }, [](error_code e) { /* 에러 처리 */ }\n); Promise/Future 선호 상황 결과를 특정 시점에 확실히 필요로 할 때\n여러 비동기 작업의 결과를 한번에 모아야 할 때\n예외 처리가 중요할 때 Callback 선호 상황 이벤트 기반 프로그래밍\nGUI 프로그래밍\n결과를 즉시 처리해야 할 때 std::async는 C++11에서 도입된 고수준 비동기 실행 도구. 쓰레드 생성과 관리를 자동으로 처리해주는 편리한 함수// 기본적인 async 사용\nstd::future&lt;int&gt; result = std::async([]() { return 42; // 비동기로 실행될 작업\n});\n[async의 장점]\n쓰레드 관리 자동화 직접 std::thread를 생성/관리할 필요가 없습니다\n리소스 정리가 자동으로 이루어집니다. 예외 처리 용이\ntry { auto future = std::async([]() { throw std::runtime_error(\"에러 발생!\"); }); future.get(); // 예외가 여기서 캐치됩니다\n} catch (const std::exception&amp; e) { std::cout &lt;&lt; \"에러: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n}\nstdasync vs ThreadPool std::async 간단한 비동기 작업에 적합\n시스템이 쓰레드 관리\n작업량이 적을 때 사용 ThreadPool 많은 작업을 효율적으로 처리\n쓰레드 재사용으로 성능 향상\n대규모 작업에 적합 <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5. 비동기, promise &amp; future, callback, async, ThreadPool","level":1,"id":"5._비동기,_promise_&_future,_callback,_async,_ThreadPool_0"},{"heading":"비동기","level":3,"id":"비동기_0"},{"heading":"Promise &amp; Future, Callback의 차이점","level":3,"id":"Promise_&_Future,_Callback의_차이점_0"},{"heading":"언제 사용해야하는가","level":4,"id":"언제_사용해야하는가_0"},{"heading":"async는 뭐야","level":3,"id":"async는_뭐야_0"},{"heading":"async vs Thread Pool","level":3,"id":"async_vs_Thread_Pool_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html","pathToRoot":"../..","attachments":[],"createdTime":1735453051496,"modifiedTime":1738470362844,"sourceSize":2929,"sourcePath":"CPP/Concurrency/5. 비동기, promise & future, callback, async, ThreadPool.md","exportPath":"cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html","showInTree":true,"treeOrder":55,"backlinks":[],"type":"markdown"},"cpp/concurrency/6.-threadpool.html":{"title":"6. ThreadPool","icon":"","description":"#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;cstdio&gt;\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; namespace ThreadPool {\nclass ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); // job 을 추가한다. void EnqueueJob(std::function&lt;void()&gt; job); private: // 총 Worker 쓰레드의 개수. size_t num_threads_; // Worker 쓰레드를 보관하는 벡터. std::vector&lt;std::thread&gt; worker_threads_; // 할일들을 보관하는 job 큐. std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 위의 job 큐를 위한 cv 와 m. std::condition_variable cv_job_q_; std::mutex m_job_q_; // 모든 쓰레드 종료 bool stop_all; // Worker 쓰레드 void WorkerThread();\n}; ThreadPool::ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_all(false) { worker_threads_.reserve(num_threads_); for (size_t i = 0; i &lt; num_threads_; ++i) { worker_threads_.emplace_back([this]() { this-&gt;WorkerThread(); }); }\n} void ThreadPool::WorkerThread() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(m_job_q_); cv_job_q_.wait(lock, [this]() { return !this-&gt;jobs_.empty() || stop_all; }); if (stop_all &amp;&amp; this-&gt;jobs_.empty()) { return; } // 맨 앞의 job 을 뺀다. std::function&lt;void()&gt; job = std::move(jobs_.front()); jobs_.pop(); lock.unlock(); // 해당 job 을 수행한다 :) job(); }\n} ThreadPool::~ThreadPool() { stop_all = true; cv_job_q_.notify_all(); for (auto&amp; t : worker_threads_) { t.join(); }\n} void ThreadPool::EnqueueJob(std::function&lt;void()&gt; job) { if (stop_all) { throw std::runtime_error(\"ThreadPool 사용 중지됨\"); } { std::lock_guard&lt;std::mutex&gt; lock(m_job_q_); jobs_.push(std::move(job)); } cv_job_q_.notify_one();\n} } // namespace ThreadPool void work(int t, int id) { printf(\"%d start \\n\", id); std::this_thread::sleep_for(std::chrono::seconds(t)); printf(\"%d end after %ds\\n\", id, t);\n} int main() { ThreadPool::ThreadPool pool(3); for (int i = 0; i &lt; 10; i++) { pool.EnqueueJob([i]() { work(i % 3 + 1, i); }); }\n}\n한계: 우리가 전달한 함수가 어떠한 값을 리턴할 때 입니다. 물론 그 함수에 포인터로 리턴값을 저장할 변수를 전달하면 되기는 합니다. 하지만, 기존의&nbsp;future&nbsp;처럼 그 값이 설정될 때 까지 기다리는 것은 불가능따라서 더 나은 구조로는&nbsp;EnqueueJob&nbsp;함수가 임의의 형태의 함수를 받고, 그 함수의 리턴값을 보관하는&nbsp;future&nbsp;를 리턴#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;cstdio&gt;\n#include &lt;functional&gt;\n#include &lt;future&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; namespace ThreadPool {\nclass ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); // job 을 추가한다. template &lt;class F, class... Args&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; EnqueueJob( F f, Args... args); private: // 총 Worker 쓰레드의 개수. size_t num_threads_; // Worker 쓰레드를 보관하는 벡터. std::vector&lt;std::thread&gt; worker_threads_; // 할일들을 보관하는 job 큐. std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 위의 job 큐를 위한 cv 와 m. std::condition_variable cv_job_q_; std::mutex m_job_q_; // 모든 쓰레드 종료 bool stop_all; // Worker 쓰레드 void WorkerThread();\n}; ThreadPool::ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_all(false) { worker_threads_.reserve(num_threads_); for (size_t i = 0; i &lt; num_threads_; ++i) { worker_threads_.emplace_back([this]() { this-&gt;WorkerThread(); }); }\n} void ThreadPool::WorkerThread() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(m_job_q_); cv_job_q_.wait(lock, [this]() { return !this-&gt;jobs_.empty() || stop_all; }); if (stop_all &amp;&amp; this-&gt;jobs_.empty()) { return; } // 맨 앞의 job 을 뺀다. std::function&lt;void()&gt; job = std::move(jobs_.front()); jobs_.pop(); lock.unlock(); // 해당 job 을 수행한다 :) job(); }\n} ThreadPool::~ThreadPool() { stop_all = true; cv_job_q_.notify_all(); for (auto&amp; t : worker_threads_) { t.join(); }\n} template &lt;class F, class... Args&gt;\nstd::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; ThreadPool::EnqueueJob( F f, Args... args) { if (stop_all) { throw std::runtime_error(\"ThreadPool 사용 중지됨\"); } using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto job = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(std::bind(f, args...)); std::future&lt;return_type&gt; job_result_future = job-&gt;get_future(); { std::lock_guard&lt;std::mutex&gt; lock(m_job_q_); jobs_.push([job]() { (*job)(); }); } cv_job_q_.notify_one(); return job_result_future;\n} } // namespace ThreadPool int work(int t, int id) { printf(\"%d start \\n\", id); std::this_thread::sleep_for(std::chrono::seconds(t)); printf(\"%d end after %ds\\n\", id, t); return t + id;\n} int main() { ThreadPool::ThreadPool pool(3); std::vector&lt;std::future&lt;int&gt;&gt; futures; for (int i = 0; i &lt; 10; i++) { futures.emplace_back(pool.EnqueueJob(work, i % 3 + 1, i)); } for (auto&amp; f : futures) { printf(\"result : %d \\n\", f.get()); }\n}\nEnqueueJob&nbsp;함수의 경우 인자들의 복사본을 받는다는 것 하지만 이는 불필요한 복사를 야기하므로&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/228\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/228\" target=\"_self\">완벽한 전달</a>&nbsp;패턴을 사용EnqueueJob 파라미터에서 우측값 레퍼런스로 변경, bind 함수에 forward로 인자 전달#include &lt;condition_variable&gt;\n#include &lt;cstdio&gt;\n#include &lt;functional&gt;\n#include &lt;future&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt; class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); template &lt;class F, class... Args&gt; std::future&lt;typename std::invoke_result&lt;F, Args...&gt;::type&gt; EnqueueJob( F&amp;&amp; f, Args&amp;&amp;... args) { if (stop_all) { throw std::runtime_error(\"ThreadPool is stopped\"); } using return_type = typename std::invoke_result&lt;F, Args...&gt;::type; auto job = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)); std::future&lt;return_type&gt; job_result_future = job-&gt;get_future(); jobs_.push([job]() { (*job)(); }); cv_job_q_.notify_one(); return job_result_future; } private: size_t num_threads_; std::vector&lt;std::thread&gt; worker_threads_; std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; std::condition_variable cv_job_q_; std::mutex m_job_q_; bool stop_all; void WorkerThread(); };\nThreadPool은 Thread에 일을 시키는 거야. 그러니까 Thread에 일을 시키기 위해서는 어떤 일을 할당할 지 함수를 매개변수로 넘겨 줘야해. c에서는 이걸 함수 포인터로 처리해 하지만 c++에서는 다른 방법이 있어. (1.이 부분을 좀 더 풀어서 설명하고 싶어. 지금과 같은 상황에서는 어떤 용어를 써야하지? )\n그걸 템플릿 메서드를 이용해서 F f 로 받을거야.\n우리가 넘겨줄 함수 f에는 매개변수가 들어갈수도 있어. 이 매개변수를 처리하기 위해 파라미터 팩을 이용할거야. class ... Args를 이용해서 함수 f의 매개변수의 값을 받는거지.return type은 비동기 처리를 위해서 future로 설정했어.\n(2.이 부분이 비동기 처리를 위해서 future를 사용했는 지 확실하지 않아.)\n그리고 invoke_result 함수를 통해서 함수 f의 리턴 값을 추론 할 수 있어.invoke_result를 이용해서 함수 f의 리턴 값 추론 하고 비동기 지원을 위해 future에 담아서 return 하는거지. (3.만약 future가 아니라면 어떻게 될까?)이제 함수 내용을 살펴보자stop_all 플래그가 이미 true면 runtime_error를 던져주자.리턴 타입이 너무 길어 그래서 using을 이용해서 return_type을 정의할게.이제 우리는 함수 f, f에 들어갈 파라미터 args, 그리고 함수 f의 리턴값이 준비되었어.이제 job을 만들거야. 이걸 shared_ptr로 만들자.\n(4. 왜 인지 보충 설명이 필요해) 타입은 std::packaged_task&lt;return_type()&gt;이거야. (5.return_type을 packaged_task로 감싼 이유를 알려줘. 그냥 return_type을 사용하면 안되는건지..)그리고 bind 함수를 통해서 f와, args를 결합할거야.job_result_future = job-&gt;get_future();를 해서 패키지된 task에서 future를 추출했어.<br>(6. jobs_.push(<a data-tooltip-position=\"top\" aria-label=\"\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"\" target=\"_self\">job</a> { (*job)(); });를 하는 이유가 뭘까? 이 부분은 문법적으로 이해가 잘 가지 않아.)그런 다음에 job_result_future을 리턴할거야.main에서 사용법을 보자. EnqueueJob을 하고 값을 futres에 넣을거야.\nfutures는 job_result_future를 원소로 가지고 있고 이걸 .get을 하면 그 함수 내용이 실행될거야. get을 하면 함수가 실행되니까.\nC와 C++의 함수 처리 방식 차이에 대해 설명하자면: C에서는 함수 포인터를 사용해서 콜백 함수를 전달하는데, 이는 문법이 복잡하고 타입 안전성이 떨어집니다. 반면 C++에서는 std::function이라는 개념을 사용합니다. 이것을 \"함수 객체\" 또는 \"콜러블(callable) 객체\"라고 부릅니다.\nstd::function은 일반 함수, 멤버 함수, 람다 함수 등 모든 종류의 호출 가능한 객체를 저장할 수 있어서 더 유연하고 안전합니다.\nfuture의 비동기 처리 역할: 네, 정확합니다. std::future는 비동기 작업의 결과를 나중에 가져올 수 있게 해주는 객체입니다. 쓰레드 풀에서 작업이 완료되면, 그 결과를 future를 통해 메인 쓰레드에서 받아올 수 있습니다.\nfuture를 사용하지 않았다면: 만약 future를 사용하지 않았다면: 작업의 완료 여부를 알 수 없습니다\n작업의 결과값을 받아올 방법이 없습니다\n작업이 실패했을 때 예외 처리를 할 수 없습니다\n비동기 작업의 동기화가 매우 어려워집니다 shared_ptr을 사용하는 이유: shared_ptr을 사용하는 이유는 메모리 관리 때문입니다. job은 여러 쓰레드에서 공유될 수 있고, 마지막 쓰레드가 작업을 완료했을 때 자동으로 메모리가 해제되어야 합니다. shared_ptr은 이런 참조 카운팅을 자동으로 처리해줍니다.\npackaged_task를 사용하는 이유: std::packaged_task는 함수와 그 결과를 연결해주는 래퍼(wrapper)입니다. 이것을 사용하는 이유는: 함수의 실행을 지연시킬 수 있습니다\n함수의 결과를 future를 통해 받을 수 있습니다\n예외 처리를 안전하게 할 수 있습니다\n그냥 return_type만 사용하면 이런 기능들을 구현할 수 없습니다.\njobs_.push(job { (*job)(); }); 설명: 이 부분은 람다 함수를 만들어 큐에 push하는 것입니다. [job]은 람다 함수가 캡처할 변수입니다 (job을 람다 안에서 사용하기 위함)\n()는 람다 함수의 매개변수입니다 (여기서는 없음)\n{ (*job)(); }는 람다 함수의 본문입니다\n이렇게 하는 이유는 job(packaged_task)을 나중에 실행하기 위해서입니다. 실제 실행은 WorkerThread에서 이루어집니다.왜 Mutex가 필요한지// mutex가 없다면 발생할 수 있는 문제 예시\nstd::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 공유 자원 // 쓰레드 1이 작업을 추가하려고 함\njobs_.push(new_job); // 이 순간에 // 쓰레드 2가 작업을 가져가려고 함\nauto job = jobs_.front(); // 동시 접근! 데이터 손상 발생!\n왜 꼭 packaged_task를 사용해야하는 지 - 함수 실행 지연 &amp; 예외처리packaged_task는 \"작업의 패키징\"이 주 목적이고, future는 \"결과값을 받는 것\"이 주 목적// 1. std::future만 사용할 경우\nstd::future&lt;int&gt; future = std::async(작업함수);\n// 이 시점에서 작업이 이미 시작됨! // 2. std::packaged_task 사용\nstd::packaged_task&lt;int()&gt; task(작업함수);\nstd::future&lt;int&gt; future = task.get_future();\n// 이 시점에서는 작업이 시작되지 않음\n// 나중에...\ntask(); // 이 시점에 작업 시작\n[ThreadPool에서 필요한 이유]\n작업 큐잉(Queueing)class ThreadPool { std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 작업 대기열 // packaged_task를 사용하면: void addJob(std::packaged_task&lt;int()&gt; task) { jobs_.push([task = std::move(task)]() { task(); // 나중에 실행 가능 }); }\n};\n// ThreadPool이 하는 일:\n1. 작업 받기\nauto future = pool.EnqueueJob(work, args...); 2. 내부적으로는:\n- packaged_task로 작업을 감싸서\n- 큐에 저장했다가\n- worker 쓰레드가 나중에 실행 // future만 사용하면:\n- 작업이 즉시 시작되어 버림\n- 큐잉이 불가능\n- 쓰레드 풀의 의미가 없어짐\nWorkerThread()에서 job(); 할 때 실제 실행// 1. main에서:\nauto future = pool.EnqueueJob(work, 1, 2); // 2. EnqueueJob 내부:\njobs_.push([task]() { (*task)(); }); // 3. WorkerThread에서:\njob(); // 실제로 work(1, 2)가 실행되는 시점! <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[""],"author":"","coverImageURL":"","fullURL":"cpp/concurrency/6.-threadpool.html","pathToRoot":"../..","attachments":[],"createdTime":1735310618551,"modifiedTime":1738470354443,"sourceSize":13497,"sourcePath":"CPP/Concurrency/6. ThreadPool.md","exportPath":"cpp/concurrency/6.-threadpool.html","showInTree":true,"treeOrder":56,"backlinks":[],"type":"markdown"},"cpp/concurrency/7.-event-system.html":{"title":"7.  Event System","icon":"","description":"Event System 구현, 학습내용\n타입 안전한 이벤트 시스템\nstd::variant와 std::any의 활용\n함수형 프로그래밍 개념\n옵저버 패턴\nweak_ptr을 이용한 수명 관리\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"7. Event System","level":1,"id":"7._Event_System_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/concurrency/7.-event-system.html","pathToRoot":"../..","attachments":[],"createdTime":1739066946213,"modifiedTime":1739067160063,"sourceSize":207,"sourcePath":"CPP/Concurrency/7.  Event System.md","exportPath":"cpp/concurrency/7.-event-system.html","showInTree":true,"treeOrder":57,"backlinks":[],"type":"markdown"},"cpp/etc/c++-static-const-초기화.html":{"title":"C++ static const 초기화","icon":"","description":"C++17에서는 다음과 같은 방법으로 헤더 파일에서 static const 변수를 초기화할 수 있다.// header.h\n#ifndef HEADER_H\n#define HEADER_H // C++17에서는 inline 키워드를 사용하여 헤더에서 정의 가능\ninline static const int MAX_SIZE = 100;\ninline static const double PI = 3.14159; class MyClass {\npublic: // 클래스 내부의 static const static const int CLASS_CONSTANT = 200; // C++17에서는 inline을 사용하여 복잡한 타입도 가능 inline static const std::string NAME = \"MyClass\";\n};\n#endif\n// header.h\n#ifndef HEADER_H\n#define HEADER_H // constexpr을 사용하면 컴파일 타임에 값이 결정됨\nconstexpr int MAX_SIZE = 100;\nconstexpr double PI = 3.14159; class MyClass {\npublic: // 클래스 내부에서도 constexpr 사용 가능 static constexpr int CLASS_CONSTANT = 200; // C++17에서는 문자열 리터럴도 가능 static constexpr const char* NAME = \"MyClass\";\n};\n#endif\n// header.h\n#ifndef HEADER_H\n#define HEADER_H #include &lt;vector&gt;\n#include &lt;string&gt; // 복잡한 객체도 inline을 사용하면 헤더에서 초기화 가능\ninline static const std::vector&lt;int&gt; DEFAULT_VALUES = {1, 2, 3, 4, 5};\ninline static const std::string APP_NAME = \"My Application\"; #endif\nC++에서 클래스 내에서 static const 변수의 초기화는 타입에 따라 규칙이 다름\n정수형 상수 (int, char, bool, enum 등) 클래스 선언 내에서 직접 초기화 가능 class MyClass { static const int a = 3; // 가능\n}; 부동 소수점형 상수 (float, double) 클래스 선언 내에서 직접 초기화 불가능 class MyClass { static const float a = 3.0f; // 컴파일 에러\n}; C++17 이상에서는 inline 키워드 사용:\nclass MyClass { inline static const float a = 3.0f; // C++17 이상에서 가능\n}; 별도의 소스 파일(.cpp)에서 정의:\n// MyClass.h\nclass MyClass { static const float a; // 선언만\n}; // MyClass.cpp\nconst float MyClass::a = 3.0f; // 정의와 초기화 constexpr 사용 (권장):\nclass MyClass { static constexpr float a = 3.0f; // 모든 타입에 가능\n}; static const는 정수형이 아닌 타입은 별도의 소스 파일에서 정의하는 것이 필요\n단 C++17 이상에서는 inline static const 또는 static constexpr을 사용하면 헤더에서 선언 정의 동시에 가능\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"헤더 파일에서의 static const 초기화","level":2,"id":"헤더_파일에서의_static_const_초기화_0"},{"heading":"1. inline 키워드 사용 (C++17 이상)","level":3,"id":"1._inline_키워드_사용_(C++17_이상)_0"},{"heading":"2. constexpr 사용 (권장)","level":3,"id":"2._constexpr_사용_(권장)_0"},{"heading":"3. 복잡한 객체 초기화","level":3,"id":"3._복잡한_객체_초기화_0"},{"heading":"클래스 내 static const 초기화 규칙","level":2,"id":"클래스_내_static_const_초기화_규칙_0"},{"heading":"정수형과 부동소수점형의 차이","level":3,"id":"정수형과_부동소수점형의_차이_0"},{"heading":"부동소수점형 초기화 해결 방법","level":3,"id":"부동소수점형_초기화_해결_방법_0"},{"heading":"요약 및 권장사항","level":2,"id":"요약_및_권장사항_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/c++-static-const-초기화.html","pathToRoot":"../..","attachments":[],"createdTime":1743691206979,"modifiedTime":1743691206979,"sourceSize":2871,"sourcePath":"CPP/etc/C++ static const 초기화.md","exportPath":"cpp/etc/c++-static-const-초기화.html","showInTree":true,"treeOrder":59,"backlinks":[],"type":"markdown"},"cpp/etc/const-위치-헷갈리는-점-정리.html":{"title":"const 위치 헷갈리는 점 정리","icon":"","description":"C++에서 포인터와 const를 같이 사용할 때 자주 헷갈린다. 그래서 복습을 계속 한다. 목표는 const 위치에 따라 포인터 자체와 가리키는 값 중 무엇이 변경 불가능한지 암기하는 것이다.'const를 기준으로 왼쪽에 있는 것이 상수고 아무것도 없다면 오른쪽에 있는 것이 상수'\nconst int* p int const* p\nconst int* p와 int const* p는 같다. 원리만 기억하면 같다는 사실을 도출할 수 있다.\n포인터가 가르키는 값이 상수임. 포인터 자체는 변경 가능하니까 다른 주소를 가르키면 됨#include &lt;iostream&gt;\nint main() { int v = 10; int v2 = 30; const int *p = &amp;v; int const *p2 = &amp;v; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; *p2 &lt;&lt; std::endl; *p = 20; // 컴파일 실패 *p2 = 20; // 컴파일 실패 p = &amp;v2; p2 = &amp;v2; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; *p2 &lt;&lt; std::endl; return 0;\n} int* const p\nconst의 왼쪽은 *이므로 포인터 자체가 상수라는 뜻이다. 이 경우 p의 가르키는 값은 변경 가능하지만 p 자체를 변경할 수 없음.\n#include &lt;iostream&gt;\nint main() { int value1 = 10; int value2 = 20; int *const p3 = &amp;value1; *p3 = 30; // 가능: p가 가리키는 값은 변경 가능 p3 = &amp;value2; // 컴파일 에러: p 자체를 변경할 수 없음 return 0;\n} const int* const p\nint main() { int value1 = 10; int value2 = 20 const int* const p = &amp;value1; *p = 30; // 컴파일 에러: p가 가리키는 값을 변경할 수 없음 p = &amp;value2; // 컴파일 에러: p 자체를 변경할 수 없음\n} const 멤버 함수는 클래스의 상태를 변경하지 않는다는 뜻이다.즉 const 멤버 함수 내에서\n멤버 변수 값 수정 불가\nnon-const 멤버 함수 호출 불가\nthis 포인터는 const MyClass* 타입이다.\nclass MyClass {\npublic: int getValue() const { value = 10; // 컴파일 실패 return value; } private: int value; }\nconst 참조 반환은 함수가 객체의 내부 데이터에 대한 읽기 전용 접근을 제공하는 방법이다.\n아래 코드에서 const가 있는 경우에는 레퍼런스 타입으로 getText()를 하면 컴파일 에러가 발생해서 수정 할 수 있는 여지가 없다.const가 없는 경우에는 getText()에서 컴파일 에러 발생 안하고 text를 수정 가능 하므로 Hello world를 출력하게 된다.class StringContainer {\npublic: StringContainer() : text(\"Hello\") {} const std::string &amp;getText() { return text; } // 수정 가능한 참조 반환 // std::string &amp;getText() { return text; } private: std::string text;\n}; int main() { StringContainer container; std::cout &lt;&lt; container.getText() &lt;&lt; std::endl; std::string &amp;text = container.getText(); // 컴파일 에러 발생 text += \" world\"; std::cout &lt;&lt; container.getText() &lt;&lt; std::endl; return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"포인터가 가르키는 값이 상수","level":4,"id":"포인터가_가르키는_값이_상수_0"},{"heading":"포인터 자체가 상수","level":4,"id":"포인터_자체가_상수_0"},{"heading":"둘 다 상수","level":4,"id":"둘_다_상수_0"},{"heading":"클래스의 멤버 함수에서 const 사용","level":3,"id":"클래스의_멤버_함수에서_const_사용_0"},{"heading":"const 멤버 함수","level":4,"id":"const_멤버_함수_0"},{"heading":"const 참조 반환","level":4,"id":"const_참조_반환_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/const-위치-헷갈리는-점-정리.html","pathToRoot":"../..","attachments":[],"createdTime":1742746589113,"modifiedTime":1742748551725,"sourceSize":3217,"sourcePath":"CPP/etc/const 위치 헷갈리는 점 정리.md","exportPath":"cpp/etc/const-위치-헷갈리는-점-정리.html","showInTree":true,"treeOrder":60,"backlinks":[],"type":"markdown"},"cpp/etc/rvo.html":{"title":"RVO","icon":"","description":"Return Value OptimizationC++에서 함수가 객체를 반환할 때 불필요한 복사를 피하기 위한 최적화 기법이다. 일반적으로 함수가 객체를 반환하면 임시 객체가 생성되고 복사하는데 컴파일러가 이를 최적화 하는 것이다.RVO에는 두가지 종류가 있다.\nNRVO (Named Return Value Optimization)\nMyClass func() { MyClass obj; // 지역 객체 // obj 초기화 작업 return obj; // NRVO 적용 가능\n} RVO (Return Value Optimization)\nMyClass createObject() { return MyClass(); // 임시 객체 직접 반환, RVO 적용\n}\n핵심은 RVO 최적화는 개발자가 아닌 컴파일러가 하는 것이다. 개발자가 해야하는 것은 컴파일러가 RVO를 적용할 수 있도록 구조적으로 코드를 작성 해야한다.RVO가 효과적으로 작동하려면 아래 조건들이 충족 되어야 한다.\n단순하게 반환 - 복잡한 로직 피하기\n단일 경로 - 조건부 반환 최소화\n직접 반환 - 불필요한 중간 변수 제거\n참조 활용: 매개변수는 const 참조로\nmove 남용 금지: RVO를 방해할 수 있음\n성능 관점에서는 RVO가 더 확실함. 최적화는 컴파일러 재량이기 때문에 RVO가 더 확실함. RVO는 거의 모든 현대 컴파일러에서 적극 적용이 되었고, NRVO는 잘 되긴 하지만 누락 가능성도 존재함.즉!\nRVO 가능하면 RVO (더 확실한 최적화)\n복잡하면 NRVO (가독성과 유지보수성)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"NRVO vs RVO","level":4,"id":"NRVO_vs_RVO_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/rvo.html","pathToRoot":"../..","attachments":[],"createdTime":1751879420587,"modifiedTime":1751879420587,"sourceSize":1562,"sourcePath":"CPP/etc/RVO.md","exportPath":"cpp/etc/rvo.html","showInTree":true,"treeOrder":61,"backlinks":[],"type":"markdown"},"cpp/etc/리소스-임베딩-by-compile.html":{"title":"리소스 임베딩 by compile","icon":"","description":"크로스플랫폼을 타겟으로 하는 C++ 라이브러리를 개발하면서 리소스를 포함해야 하는 경우가 있다.PC 기반의 환경 (macOS, Windows, Linux 등등)에서 파일 경로를 이용해서 fopen() 으로 리소스에 접근할 수 있다. 그러나 샌드박스 환경 (Android, iOS 등)에서는 파일 시스템 접근이 제한된다. 그래서 각 플랫폼 API를 이용하는 방법으로 리소스에 접근하거나 이미지, 오디오, 텍스트 파일등의 바이너리 리소스를 C / C++ 소스코드 배열로 변환하는 리소스 임베딩 방식을 사용한다.\n리소스 파일을 바이트 배열로 변환한다.\n바이트 배열을 C++ 소스 코드 파일에 포함시킨다.\n컴파일을 할 때 이 배열이 프로그램의 바이너리에 포함된다.\n런타임에 이 배열에 접근해서 리소스를 사용한다.\n리소스 파일을 바이트 배열로 변환할 때 Python 스크립트나 bin2c, CMake의 configure_file을 사용한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"동작 방식","level":4,"id":"동작_방식_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/리소스-임베딩-by-compile.html","pathToRoot":"../..","attachments":[],"createdTime":1748530578247,"modifiedTime":1748530578247,"sourceSize":1054,"sourcePath":"CPP/etc/리소스 임베딩 by compile.md","exportPath":"cpp/etc/리소스-임베딩-by-compile.html","showInTree":true,"treeOrder":62,"backlinks":[],"type":"markdown"},"cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html":{"title":"상속 생성자, 소멸자 헷갈리는 점","icon":"","description":"파생 클래스는 기본적으로 기반 클래스의 생성자를 호출한다.\n기반클래스 생성자 -&gt; 파생클래스 생성자 -&gt; 파생클래스 소멸자 -&gt; 파생클래스 소멸자 순서다.각 클래스 타입에 맞게 생성을 하면 문제가 없으나, 다형성을 사용하기 위해서 파생클래스를 생성하고 기반클래스 포인터로 가르킬 때 파악을 잘해야한다.#include &lt;iostream&gt;\n#include &lt;string&gt; class Base { std::string s; public: Base() : s(\"Base\") { std::cout &lt;&lt; \"Base class\" &lt;&lt; std::endl; } ~Base() { std::cout &lt;&lt; \"Base class 소멸\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; } };\nclass Derived : public Base { std::string s; public: Derived() : Base(), s(\"Derived\") { std::cout &lt;&lt; \"Derived Class\" &lt;&lt; std::endl; } ~Derived() { std::cout &lt;&lt; \"Derived class 소멸\" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }\n};\nint main() { std::cout &lt;&lt; \" === Generate base class 생성 ===\" &lt;&lt; std::endl; Base p; std::cout &lt;&lt; \" === Generate Derived Class ===\" &lt;&lt; std::endl; Derived c; std::cout &lt;&lt; \"=== 포인터 버전 ===\" &lt;&lt; std::endl; Base *p_c = &amp;c; Base *p_p = &amp;p; std::cout &lt;&lt; \"== 실제 객체는 Base == \" &lt;&lt; std::endl; p_p-&gt;what(); // Base 출력 std::cout &lt;&lt; \"== 실제 객체는 Derived == \" &lt;&lt; std::endl; p_c-&gt;what(); // Base 출력 std::cout &lt;&lt; \"================= \" &lt;&lt; std::endl; { Derived c; } { Base *p_c = new Derived(); delete p_c; } std::cout &lt;&lt; \"================= 소멸자 호출 시작 =======\" &lt;&lt; std::endl; return 0;\n}\n실제 객체는 파생 클래스인데 기반 클래스 포인터로 가르키면 위처럼 Base를 출력할 것이다. 만약 다형성을 이유로 기반 클래스 포인터로 가르키고 파생 클래스의 Derived를 출력하길 원한다면 기반 클래스에 virtual 키워드를 사용하면 된다. 즉 virtual 키워드를 이용하면 기반 클래스 포인터로 가르켜도 실제 객체 (파생클래스)의 멤버 함수 실행할 수 있게 된다.그리고 또 주의할 점은 소멸자다. 객체는 파생 클래스지만 기반 클래스 포인터로 가르키고 있을 때 소멸자가 호출되면 기반 클래스의 소멸자는 호출 되지만 파생 클래스의 소멸자는 호출되지 않는다. 이 지점에서 메모리 누수가 발생한다. 이를 방지 하기 위해서는 기반 클래스의 소멸자에 virtual 키워드를 사용한다. 그러면 기반 클래스 소멸자가 호출될 때 virtual 키워드를 보고 파생 클래스의 소멸자도 호출한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"상속과 생성자와 소멸자","level":3,"id":"상속과_생성자와_소멸자_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html","pathToRoot":"../..","attachments":[],"createdTime":1742745781068,"modifiedTime":1742746401621,"sourceSize":2672,"sourcePath":"CPP/etc/상속 생성자, 소멸자 헷갈리는 점.md","exportPath":"cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html","showInTree":true,"treeOrder":63,"backlinks":[],"type":"markdown"},"cpp/etc/유리수-클래스-구현.html":{"title":"유리수 클래스 구현","icon":"","description":"기약분수로 나타내기 위해 최대공약수 (GCD)를 구하는 함수가 필요하다.\b클래스에서 연산자를 구현해서 반환할 때 약분하고 반환한다.#include &lt;iostream&gt;\n#include &lt;stdexcept&gt; class Ratio { private: static int gcd(int a, int b) { a = std::abs(a); b = std::abs(b); while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } // 기약분수 void simplify() { if (num == 0) { den = 1; return; } int divisor = gcd(num, den); num /= divisor; den /= divisor; if (den &lt; 0) { num = -num; den = -den; } } public: int num; int den; explicit Ratio(int num, int den = 1) : num(num), den(den) { if (den == 0) { throw std::invalid_argument(\"Denominator cannot be zero\"); } simplify(); } bool operator==(const Ratio &amp;other) const { return num * other.den == den * other.num; } bool operator!=(const Ratio &amp;other) const { return num * other.den != den * other.num; } bool operator&lt;(const Ratio &amp;other) const { return num * other.den &lt; den * other.num; } bool operator&gt;(const Ratio &amp;other) const { return num * other.den &gt; den * other.num; } bool operator&lt;=(const Ratio &amp;other) const { return num * other.den &lt;= den * other.num; } bool operator&gt;=(const Ratio &amp;other) const { return num * other.den &gt;= den * other.num; } Ratio operator+(const Ratio &amp;other) const { int new_num = num * other.den + den * other.num; int new_den = den * other.den; return Ratio(new_num, new_den); } Ratio operator-(const Ratio &amp;other) const { int new_num = num * other.den - den * other.num; int new_den = den * other.den; return Ratio(new_num, new_den); } Ratio operator*(const Ratio &amp;other) const { int new_num = num * other.den; int new_den = den * other.num; return Ratio(new_num, new_den); } Ratio operator/(const Ratio &amp;other) { int new_num = num * other.den; int new_den = den * other.num; if (new_num == 0) { return Ratio(0); } return Ratio(new_num, new_den); } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Ratio &amp;r) { os &lt;&lt; r.num &lt;&lt; \"/\" &lt;&lt; r.den; return os; }\n}; int main(int argc, char *argv[]) { Ratio r1(1, 2); std::cout &lt;&lt; \"r1 = \" &lt;&lt; r1 &lt;&lt; std::endl; Ratio r2(2, 4); // 1/2로 약분됨 std::cout &lt;&lt; \"r2 = \" &lt;&lt; r2 &lt;&lt; std::endl; Ratio r3 = r1 + r2; std::cout &lt;&lt; \"r1 + r2 = \" &lt;&lt; r3 &lt;&lt; std::endl; Ratio r4(3, 6); // 1/2로 약분됨 std::cout &lt;&lt; \"r4 = \" &lt;&lt; r4 &lt;&lt; std::endl; Ratio r5 = r1 * r4; std::cout &lt;&lt; \"r1 * r4 = \" &lt;&lt; r5 &lt;&lt; std::endl; Ratio r6(-2, 4); // -1/2로 약분됨 std::cout &lt;&lt; \"r6 = \" &lt;&lt; r6 &lt;&lt; std::endl; Ratio r7(4, -8); // -1/2로 약분됨 std::cout &lt;&lt; \"r7 = \" &lt;&lt; r7 &lt;&lt; std::endl; std::cout &lt;&lt; \"r1 == r2: \" &lt;&lt; (r1 == r2 ? \"true\" : \"false\") &lt;&lt; std::endl; std::cout &lt;&lt; \"r1 == r3: \" &lt;&lt; (r1 == r3 ? \"true\" : \"false\") &lt;&lt; std::endl; std::cout &lt;&lt; \"r1 != r2: \" &lt;&lt; (r1 != r2 ? \"true\" : \"false\") &lt;&lt; std::endl; std::cout &lt;&lt; \"r1 != r3: \" &lt;&lt; (r1 != r3 ? \"true\" : \"false\") &lt;&lt; std::endl; std::cout &lt;&lt; \"r1 &lt; r3: \" &lt;&lt; (r1 &lt; r3 ? \"true\" : \"false\") &lt;&lt; std::endl; return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/유리수-클래스-구현.html","pathToRoot":"../..","attachments":[],"createdTime":1742742104554,"modifiedTime":1742744544787,"sourceSize":3253,"sourcePath":"CPP/etc/유리수 클래스 구현.md","exportPath":"cpp/etc/유리수-클래스-구현.html","showInTree":true,"treeOrder":64,"backlinks":[],"type":"markdown"},"cpp/etc/전역변수와-정적변수의-공통점과-차이점.html":{"title":"전역변수와 정적변수의 공통점과 차이점","icon":"","description":"\n둘 다 프로그램이 시작될 때 생성되어 프로그램이 종료될 때까지 존재한다.\n스택이 아닌 정적 메모리 영역(데이터 영역)에 저장됨\n멀티쓰레드 환경에서 접근이 가능해서 동기화가 메커니즘이 필요하다. (race condition 발생 가능성 있음)\nC++11 이전에는 전역 변수, 정적 변수를 초기화 할 때 쓰레드 안전성이 없었으나 C++11 이후에는 초기화할 때 안전성이 있음. Scope가 가장 큰 차이점임. 전역변수는 프로그램 전체에서 접근 가능하지만, 정적 변수는 선언된 범위내에서만 접근 가능하다. (함수, 클래스, 파일)\n전역변수는 함수 외부에 선언하고 정적 변수는 static 키워드로 선언한다.\nint globalVar = 10; // 전역 변수 static int fileStaticVar = 20; // 파일 범위 정적 변수 void func() { static int localStaticVar = 30; // 함수 내 정적 변수\n} class MyClass {\npublic: static int classStaticVar; // 클래스 정적 변수\n};\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"공통점","level":3,"id":"공통점_0"},{"heading":"차이점","level":3,"id":"차이점_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/etc/전역변수와-정적변수의-공통점과-차이점.html","pathToRoot":"../..","attachments":[],"createdTime":1742748775631,"modifiedTime":1742749373299,"sourceSize":1085,"sourcePath":"CPP/etc/전역변수와 정적변수의 공통점과 차이점.md","exportPath":"cpp/etc/전역변수와-정적변수의-공통점과-차이점.html","showInTree":true,"treeOrder":65,"backlinks":[],"type":"markdown"},"cpp/lib/fmt.html":{"title":"fmt","icon":"","description":"fmt는 문자열 포매팅 라이브러리다. Python과 유사한 형식의 문법을 가지고 있어서 사용하기 간편하다. 이러한 점은 c++ 20 표준의 std::format 의 기반이 되었다. 20 이상에서는 표준을 사용하면 된다.\nPython과 유사한 형식의 문법\nstring name = \"My Name\";\nint age = 2;\nfmt::print(\"Name: {}, Age: {}\", name, age); 타입 안정성 컴파일 시점에서 포맷 문자열과 인자의 타입 불일치를 검사 fmt::format_string 다양한 포맷팅 옵션 // 숫자 포매팅\nfmt::print(\"Integer: {:d}, Float: {:.2f}\", 42, 3.14159); // 정렬과 패딩\nfmt::print(\"Left aligned: {:&lt;10}\", \"text\");\nfmt::print(\"Right aligned: {:&gt;10}\", \"text\"); // 사용자 정의 타입 지원\nstruct Point { int x, y; };\ntemplate &lt;&gt; struct fmt::formatter&lt;Point&gt; { // 사용자 정의 타입을 위한 포매팅 구현\n};\n주로 CMake를 이용해서 프로젝트에 링크 한다.include(FetchContent) FetchContent_Declare( Fmt GIT_REPOSITORY \"https://github.com/fmtlib/fmt\" GIT_TAG \"7.1.3\" ) FetchContent_MakeAvailable(Fmt) target_link_libraries(program PUBLIC fmt) 기본 문자열 포매팅 std::string name = \"psychehose\"; int age = 31; // basic formatting 순서. fmt::print(\"Name: {}, Age: {} \\n\", name, age); // by indexing fmt::print(\"{1}살을 먹은 {0}\\n\", name, age); // by name fmt::print(\"{name}은 {age}살\\n\", fmt::arg(\"name\", name), fmt::arg(\"age\", age)); fmt::print(\"{name}은 {age}살\\n\", fmt::arg(\"age\", age), fmt::arg(\"name\", name)); 이름 기반 포매팅을 할 때는 인자들의 이름을 지정 했기 때문에 순서가 바뀌어도 상관 없다.\n숫자 포매팅 int num = 42; fmt::print(\"10진수 {}\\n\", num); // 42 fmt::print(\"16진수 {:x}\\n\", num); // 2a fmt::print(\"16진수 (대문자) {:X}\\n\", num); // 2A fmt::print(\"8진수 {:o}\\n\", num); // 52 fmt::print(\"2진수 {:b}\\n\", num); // 101010 // 부동소수점 fmt::print(\"소수점 2자리: {:.2f}\\n\", 3.141592); fmt::print(\"지수 표기: {:e}\\n\", 1000000.0); fmt::print(\"자동 지수/고정: {:g}\\n\", 1000000.0); 정렬과 패딩, 최소 너비 설정\n// 왼쪽 정렬 (기본값)\nfmt::print(\"왼쪽정렬: {:&lt;10}\\n\", \"left\"); // \"left \" // 오른쪽 정렬\nfmt::print(\"오른쪽정렬: {:&gt;10}\\n\", \"right\"); // \" right\" // 가운데 정렬\nfmt::print(\"가운데정렬: {:^10}\\n\", \"center\"); // \" center \" // 사용자 지정 패딩 문자\nfmt::print(\"패딩: {:*&gt;10}\\n\", \"pad\"); // \"******pad\" // 최소 너비 지정\nfmt::print(\"{:10}\\n\", \"text\"); // \"text \" 부호\nfmt::print(\"{:+}\\n\", 42); // \"+42\"\nfmt::print(\"{:+}\\n\", -42); // \"-42\" 컨테이너 포맷팅 #include \"fmt/ranges.h\" std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\nfmt::print(\"{}\\n\", v); // [1, 2, 3, 4, 5] std::map&lt;std::string, int&gt; m = {{\"apple\", 1}, {\"banana\", 2}};\nfmt::print(\"{}\\n\", m); // {\"apple\": 1, \"banana\": 2} 날짜 / 시간 포매팅\n#include &lt;fmt/chrono.h&gt; std::time_t t = std::time(nullptr);\nfmt::print(\"현재 시간: {:%Y-%m-%d %H:%M:%S}\\n\", fmt::gmtime(t)); 문자열 변수로 저장 fmt::format\n// 문자열 반환\nstd::string result = fmt::format(\"Hello, {}!\", \"World\"); // 여러 인자 사용\nint x = 10, y = 20;\nstd::string coords = fmt::format(\"좌표: ({}, {})\", x, y);\nstd::cout &lt;&lt; coords &lt;&lt; std::endl; [fmt example github][https://github.com/psychehose/example_fmt]","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"라이브러리 링크","level":3,"id":"라이브러리_링크_0"},{"heading":"사용 예제","level":3,"id":"사용_예제_0"},{"heading":"github","level":4,"id":"github_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/lib/fmt.html","pathToRoot":"../..","attachments":[],"createdTime":1738210790687,"modifiedTime":1738229071138,"sourceSize":3710,"sourcePath":"CPP/Lib/fmt.md","exportPath":"cpp/lib/fmt.html","showInTree":true,"treeOrder":67,"backlinks":[],"type":"markdown"},"cpp/lib/google-test.html":{"title":"Google Test","icon":"","description":"EXPECT_EQ(val1, val2); // val1 == val2\nEXPECT_NE(val1, val2); // val1 != val2\nEXPECT_LT(val1, val2); // val1 &lt; val2\nEXPECT_LE(val1, val2); // val1 &lt;= val2\nEXPECT_GT(val1, val2); // val1 &gt; val2\nEXPECT_GE(val1, val2); // val1 &gt;= val2 EXPECT_TRUE(condition); // condition이 true인지\nEXPECT_FALSE(condition); // condition이 false인지 EXPECT_STREQ(str1, str2); // 문자열이 같은지\nEXPECT_STRNE(str1, str2); // 문자열이 다른지\nEXPECT_STRCASEEQ(str1, str2); // 대소문자 무시하고 같은지\nEXPECT_STRCASENE(str1, str2); // 대소문자 무시하고 다른지 EXPECT_FLOAT_EQ(val1, val2); // float 거의 같은지\nEXPECT_DOUBLE_EQ(val1, val2); // double 거의 같은지\nEXPECT_NEAR(val1, val2, abs_error); // 지정된 오차 범위 내인지\n$ ctest\n옵션 -V: verbose의 약자로, 자세한 출력을 보여달라는 옵션 테스트 실행 과정\n테스트 출력 내용\n실패한 경우 실패 원인 등 상세한 정보 -R &nbsp;Regular expression의 약자로, 정규표현식과 일치하는 이름을 가진 테스트만 실행 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/lib/google-test.html","pathToRoot":"../..","attachments":[],"createdTime":1738155816275,"modifiedTime":1738210616535,"sourceSize":1130,"sourcePath":"CPP/Lib/Google Test.md","exportPath":"cpp/lib/google-test.html","showInTree":true,"treeOrder":68,"backlinks":[],"type":"markdown"},"cpp/modern/1.-rvalue-rvalue-참조.html":{"title":"1. rvalue rvalue 참조","icon":"","description":"\nrvalue란? 메모리상의 임시 값입니다\n프로그램에서 곧 사라질 값입니다\n주소를 가질 수 없는 값입니다 int a = 5 + 3; // 여기서 5 + 3이 rvalue\nstd::string str = std::string(\"hello\"); // std::string(\"hello\")가 rvalue rvalue 참조(&amp;&amp;)란? rvalue를 참조할 수 있는 특별한 참조 타입\nC++11 // 1. 기본적인 rvalue와 참조\nint&amp;&amp; rref = 42; // 42는 rvalue, rref는 rvalue 참조\nint x = 10;\nint&amp;&amp; rref2 = x; // 컴파일 에러! x는 lvalue이므로 rvalue 참조 불가능\nint&amp;&amp; rref3 = std::move(x); // OK! std::move는 lvalue를 rvalue로 변환 // 2. 문자열 예제\nstd::string getName() { return \"John\"; // \"John\"은 임시 객체(rvalue)\n} std::string&amp;&amp; name = getName(); // 임시 객체를 rvalue 참조로 받음\n성능 최적화, 불필요한 복사 방지class BigData { int* data; size_t size;\npublic: // 이동 생성자 (rvalue 참조 사용) BigData(BigData&amp;&amp; other) noexcept { // 포인터만 복사 (매우 빠름) data = other.data; size = other.size; // 원본 무효화 other.data = nullptr; other.size = 0; }\n}; rvalue 참조 변수는 lvalue\nvoid process(int&amp;&amp; x) { int&amp;&amp; y = x; // 에러! x는 rvalue 참조지만, 그 자체는 lvalue입니다 int&amp;&amp; y = std::move(x); // OK\n} std::move는 실제로 객체 이동X\nstd::string str = \"hello\";\nstd::move(str); // 아무 일도 일어나지 않음\nstd::string str2 = std::move(str); // 여기서 실제 이동 발생 rvalue: 임시적이고 곧 사라질 값\nrvalue 참조(&amp;&amp;): 이러한 임시 값을 참조할 수 있는 방법\n주요 용도: 이동 생성자와 이동 대입 연산자 구현\n성능 최적화: 불필요한 복사를 줄이고 효율적인 리소스 이동 가능 <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"핵심 개념","level":2,"id":"핵심_개념_0"},{"heading":"왜 필요?","level":1,"id":"왜_필요?_0"},{"heading":"자주 하는 실수","level":1,"id":"자주_하는_실수_0"},{"heading":"정리","level":1,"id":"정리_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/modern/1.-rvalue-rvalue-참조.html","pathToRoot":"../..","attachments":[],"createdTime":1737701652292,"modifiedTime":1738470341586,"sourceSize":2063,"sourcePath":"CPP/Modern/1. rvalue rvalue 참조.md","exportPath":"cpp/modern/1.-rvalue-rvalue-참조.html","showInTree":true,"treeOrder":70,"backlinks":[],"type":"markdown"},"cpp/modern/2.-move,-레퍼런스-겹침-규칙.html":{"title":"2. move, 레퍼런스 겹침 규칙","icon":"","description":"lvalue는 \"주소가 있는 값\"으로 생각할 수 있음\n마치 우리가 집 주소로 찾아갈 수 있는 집처럼, 프로그램에서 다시 찾아갈 수 있는 위치를 가진 값rvalue는 \"임시 값\"으로 생각할 수 있음.\n마치 계산기로 계산한 결과 값처럼, 잠시 존재했다가 사라지는 값int x = 10; // x는 lvalue\nint y = x; // x는 lvalue\nint z = x + y; // (x + y)는 rvalue\nclass String { char* data;\npublic: // 이동 생성자 String(String&amp;&amp; other) noexcept { data = other.data; // 데이터 포인터만 가져옴 other.data = nullptr; // 원본은 무효화 } // 이동 대입 연산자 String&amp; operator=(String&amp;&amp; other) noexcept { if (this != &amp;other) { delete[] data; // 기존 데이터 해제 data = other.data; // 새 데이터 이동 other.data = nullptr; // 원본 무효화 } return *this; }\n}; // 사용 예시\nString str1(\"Hello\");\nString str2 = std::move(str1); // str1의 내용이 str2로 이동됨\n여기서 std::move는 실제로 객체를 이동시키지 않고, 단지 lvalue를 rvalue로 캐스팅하는 역할. 실제 이동은 이동 생성자나 이동 대입 연산자에서 일어남Perfect forwarding은 함수 템플릿에서 인자의 값 카테고리(lvalue/rvalue)를 그대로 유지하면서 전달하는 기능template&lt;typename T&gt;\nvoid wrapper(T&amp;&amp; param) { // 보편 참조(universal reference) foo(std::forward&lt;T&gt;(param)); // perfect forwarding\n} // 사용 예시\nstd::string str = \"hello\";\nwrapper(str); // str은 lvalue로 전달됨\nwrapper(std::string(\"world\")); // 임시 객체는 rvalue로 전달됨\nstd::forward가 하는 일을 자세히 살펴보면:\nlvalue가 전달되면 lvalue 참조로 전달\nrvalue가 전달되면 rvalue 참조로 전달\n이를 통해 얻는 이점:\n불필요한 복사를 방지할 수 있습니다\n인자의 원래 특성(lvalue/rvalue)을 그대로 보존할 수 있음\n템플릿 기반의 제네릭 코드를 효율적으로 작성할 수 있음\nclass Widget { std::vector&lt;int&gt; data;\npublic: // 생성자에서 perfect forwarding 사용 template&lt;typename... Args&gt; Widget(Args&amp;&amp;... args) : data(std::forward&lt;Args&gt;(args)...) {}\n}; // 사용 예시\nstd::vector&lt;int&gt; vec = {1, 2, 3};\nWidget w1(vec); // lvalue로 전달 - 복사 발생\nWidget w2(std::vector&lt;int&gt;{1,2,3}); // rvalue로 전달 - 이동 발생\nmove 의미론과 perfect forwarding은 현대 C++에서 성능 최적화의 핵심 요소이며, 특히 대용량 데이터를 다루는 프로그램에서 매우 중요한 역할.\n이를 통해 불필요한 복사를 줄이고 더 효율적인 코드를 작성할 수 있음\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"lvalue, rvalue","level":4,"id":"lvalue,_rvalue_0"},{"heading":"c++의 move 의미","level":4,"id":"c++의_move_의미_0"},{"heading":"Perfect Fowarding","level":4,"id":"Perfect_Fowarding_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/modern/2.-move,-레퍼런스-겹침-규칙.html","pathToRoot":"../..","attachments":[],"createdTime":1734522365540,"modifiedTime":1738470334592,"sourceSize":3039,"sourcePath":"CPP/Modern/2. move, 레퍼런스 겹침 규칙.md","exportPath":"cpp/modern/2.-move,-레퍼런스-겹침-규칙.html","showInTree":true,"treeOrder":71,"backlinks":[],"type":"markdown"},"cpp/modern/3.-raii,-unique-ptr.html":{"title":"3. RAII, unique ptr","icon":"","description":"C++ 창시자인 비야네 스트로스트룹은 C++ 에서 자원을 관리하는 방법으로 다음과 같은 디자인 패턴을 제안하였습니다. 바로 흔히&nbsp;RAII&nbsp;라 불리는&nbsp;자원의 획득은 초기화다&nbsp;- Resource Acquisition Is Initialization&nbsp;입니다. 이는 자원 관리를 스택에 할당한 객체를 통해 수행하는 것포인터는 객체가 아님. delete를 하지 않고 포인터가 유실되면 힙에 저장되어 있는 데이터는 그대로 남아있음.객체는 소멸될 떄 소멸자를 호출함.포인터 '객체' 로 만들어서 자신이 소멸 될 때 자신이 가리키고 있는 데이터도 같이&nbsp;delete&nbsp;하게 하면 됩니다. 즉, 자원 (이 경우 메모리) 관리를 스택의 객체 (포인터 객체) 를 통해 수행하게 되는 것임이러한 타입을 스마트 포인터라고 함.특정 객체에 유일한 소유권을 부여하는 포인터 객체를&nbsp;unique_ptr여기서 퀴즈!&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/301\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/301\" target=\"_self\">std::move</a>&nbsp;가 왜 필요할까요?void do_something() { std::unique_ptr&lt;A&gt; pa(new A()); std::cout &lt;&lt; \"pa : \"; pa-&gt;some(); // pb 에 소유권을 이전. std::unique_ptr&lt;A&gt; pb = std::move(pa); std::cout &lt;&lt; \"pb : \"; pb-&gt;some();\n} unique_ptr는 리소스의 독점적 소유권을 보장하기 위해 복사를 허용하지 않습니다. 즉, 복사 생성자와 복사 대입 연산자가 delete되어 있죠.\n대신 소유권을 이전하는 방법으로 이동 연산자와 이동 생성자를 사용할 수 있습니다. 이들은 rvalue 참조를 매개변수로 받도록 설계되어 있습니다.\n그런데&nbsp;pa와 같은 기존 unique_ptr은 lvalue입니다. 이동 연산자/생성자는 rvalue 참조만 받을 수 있으므로, lvalue인&nbsp;pa를 직접 전달할 수는 없습니다.\n여기서 std::move가 필요한 것입니다! move는 lvalue를 rvalue로 캐스팅해주는 역할을 합니다. 이렇게 rvalue가 된 포인터는 이동 연산자/생성자가 받을 수 있는 형태가 되어 소유권 이전이 가능해집니다.\n결국 이는 C++의 타입 시스템이 value category(lvalue/rvalue)를 통해 리소스의 소유권 이전을 안전하게 관리하는 방식이라고 볼 수 있습니다.void do_something(std::unique_ptr&lt;A&gt;&amp; ptr) { ptr-&gt;do_sth(3); } int main() { std::unique_ptr&lt;A&gt; pa(new A()); do_something(pa);\n}\nvoid do_something(A* ptr) { ptr-&gt;do_sth(3); } int main() { std::unique_ptr&lt;A&gt; pa(new A()); do_something(pa.get());\n}\n두 차이점은?첫 번째 방식 (참조로 전달):void do_something(std::unique_ptr&lt;A&gt;&amp; ptr)\n이 방식은 unique_ptr 자체를 참조로 받습니다. 이는 다음을 의미합니다:\n함수가 unique_ptr의 전체 기능에 접근할 수 있습니다. 예를 들어 reset()을 호출하거나, 다른 객체로 재할당할 수 있습니다.\n소유권 관점에서 보면, 함수가 포인터의 소유권에 영향을 미칠 수 있는 권한을 가집니다.\n함수가 unique_ptr만 받을 수 있고, 일반 포인터는 받을 수 없습니다.\n두 번째 방식 (raw 포인터로 전달):void do_something(A* ptr)\n이 방식은 get()을 통해 내부의 raw 포인터만 전달합니다:\n함수는 단순히 객체의 멤버에만 접근할 수 있습니다.\n소유권과 관련된 어떤 작업도 할 수 없습니다.\n이 함수는 더 유연합니다. unique_ptr 뿐만 아니라 shared_ptr, raw 포인터 등 다양한 소스로부터 포인터를 받을 수 있습니다.\n일반적으로 두 번째 방식이 더 선호됩니다. 그 이유는:\n함수의 의도가 더 명확합니다 - \"나는 객체를 사용만 할 뿐, 소유권은 건드리지 않겠다\"\n더 유연합니다 - 다양한 포인터 타입과 함께 사용할 수 있습니다\nSOLID 원칙 중 인터페이스 분리 원칙(Interface Segregation Principle)에 더 부합합니다 - 함수는 실제로 필요한 기능만 받습니다\n만약 함수가 정말로 포인터의 소유권을 조작해야 한다면, 그때는 첫 번째 방식을 사용하는 것이 적절할 것입니다.c++14 std::make_unique#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt; class A { int *data; public: A(int i) { std::cout &lt;&lt; \"자원을 획득함!\" &lt;&lt; std::endl; data = new int[100]; data[0] = i; } void some() { std::cout &lt;&lt; \"일반 포인터와 동일하게 사용가능!\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"자원을 해제함!\" &lt;&lt; std::endl; delete[] data; }\n}; int main() { std::vector&lt;std::unique_ptr&lt;A&gt;&gt; vec; std::unique_ptr&lt;A&gt; pa(new A(1)); vec.push_back(pa); // 에러 발생 <br>삭제된&nbsp;unique_ptr&nbsp;의 복사 생성자에 접근하였기 때문이지요. 기본적으로&nbsp;vector&nbsp;의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/185\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/185\" target=\"_self\">push_back</a>&nbsp;함수는 전달된 인자를 복사해서 집어 넣기 때문에 위와 같은 문제가 발생하게 되는 것이지요.<br>이를 방지하기 위해서는 명시적으로&nbsp;pa&nbsp;를&nbsp;vector&nbsp;안으로 이동 시켜주어야만 합니다. 즉&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://modoocode.com/185\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/185\" target=\"_self\">push_back</a>&nbsp;의 우측값 레퍼런스를 받는 버전이 오버로딩 될 수 있도록 말이지요. -&gt; move 이용int main() { std::vector&lt;std::unique_ptr&lt;A&gt;&gt; vec; std::unique_ptr&lt;A&gt; pa(new A(1)); vec.push_back(std::move(pa)); // 잘 실행됨\n}\n아니면 emplace_back 이용.먼저 perfect forwarding의 핵심을 상기해보면, 이는 함수 템플릿이 인자를 받아서 다른 함수로 전달할 때 인자의 값 카테고리(lvalue/rvalue)와 const/volatile 등의 특성을 그대로 보존하는 것입니다.emplace_back은 이 perfect forwarding을 활용해서 컨테이너 내부에서 객체를 직접 생성합니다. 기본적인 구현은 대략 이렇게 됩니다:template&lt;typename... Args&gt;\nreference emplace_back(Args&amp;&amp;... args) { // 메모리 재할당이 필요한지 확인하고 처리 // perfect forwarding을 사용해 객체를 직접 생성 construct_at(data_ + size_, std::forward&lt;Args&gt;(args)...); ++size_; return back();\n}\n여기서 중요한 점은 Args&amp;&amp;...가 forwarding reference(universal reference)로 사용되어, 어떤 타입의 인자든 받을 수 있고, std::forward를 통해 그 특성을 완벽하게 보존주의할점은 아래 코드를 조심해야함. 어떤 생성자가 호출되는 지.std::vector&lt;std::vector&lt;int&gt;&gt; v;\nv.emplace_back(100000); // 100000개의 원소를 가진 벡터를 추가하게 됨.\n이건 생성자 정의.vector(size_type count); // count개의 기본값으로 초기화된 원소\nvector(size_type count, const T&amp; value); // count개의 value로 초기화된 원소 <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"unique_ptr","level":4,"id":"unique_ptr_0"},{"heading":"unique_ptr 를 함수 인자로 전달하기","level":3,"id":"unique_ptr_를_함수_인자로_전달하기_0"},{"heading":"unique_ptr 을 쉽게 생성","level":3,"id":"unique_ptr_을_쉽게_생성_0"},{"heading":"unique_ptr 를 원소로 가지는 컨테이너","level":3,"id":"unique_ptr_를_원소로_가지는_컨테이너_0"},{"heading":"emplace_back 과 이용할 시에 주의할 점","level":3,"id":"emplace_back_과_이용할_시에_주의할_점_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/modern/3.-raii,-unique-ptr.html","pathToRoot":"../..","attachments":[],"createdTime":1737701652291,"modifiedTime":1738470330827,"sourceSize":7122,"sourcePath":"CPP/Modern/3. RAII, unique ptr.md","exportPath":"cpp/modern/3.-raii,-unique-ptr.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown"},"cpp/modern/4.-shared,-weak-ptr.html":{"title":"4. shared, weak ptr","icon":"","description":"여러 개의 스마트 포인터가 하나의 객체를 같이 소유 해야 하는 경우가 발생합니다. 예를 들어서 여러 객체에서 하나의 자원을 사용하고자 합니다. 후에 자원을 해제하기 위해서는 이 자원을 사용하는 모든 객체들이 소멸되야 하는데, 어떤 객체가 먼저 소멸되는지 알 수 없기 때문에 이 자원 역시 어느 타이밍에 해제 시켜야 할 지 알 수 없게 됩니다.특정 자원을&nbsp;몇 개의 객체에서 가리키는지를 추적한 다음에, 그 수가 0 이 되야만 비로소 해제를 시켜주는 방식의 포인터가 필요 : reference countstd::shared_ptr&lt;A&gt; p1(new A());\nstd::shared_ptr&lt;A&gt; p2(p1); // p2 역시 생성된 객체 A 를 가리킨다.\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt; class A { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; \"자원을 획득함!\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"소멸자 호출!\" &lt;&lt; std::endl; delete[] data; }\n}; int main() { std::vector&lt;std::shared_ptr&lt;A&gt;&gt; vec; vec.push_back(std::shared_ptr&lt;A&gt;(new A())); vec.push_back(std::shared_ptr&lt;A&gt;(vec[0])); vec.push_back(std::shared_ptr&lt;A&gt;(vec[1])); // 벡터의 첫번째 원소를 소멸 시킨다. std::cout &lt;&lt; \"첫 번째 소멸!\" &lt;&lt; std::endl; vec.erase(vec.begin()); // 그 다음 원소를 소멸 시킨다. std::cout &lt;&lt; \"다음 원소 소멸!\" &lt;&lt; std::endl; vec.erase(vec.begin()); // 마지막 원소 소멸 std::cout &lt;&lt; \"마지막 원소 소멸!\" &lt;&lt; std::endl; vec.erase(vec.begin()); std::cout &lt;&lt; \"프로그램 종료!\" &lt;&lt; std::endl;\n}\n자원을 획득함!\n첫 번째 소멸!\n다음 원소 소멸!\n마지막 원소 소멸!\n소멸자 호출!\n프로그램 종료!\nshared_ptr&nbsp;들은 참조 개수가 몇 개 인지 알고 있어야만 합니다. 이 경우 어떻게 하면 같은 객체를 가리키는&nbsp;shared_ptr&nbsp;끼리 동기화를 시킬 수 있을까요?처음으로 실제 객체를 가리키는&nbsp;shared_ptr&nbsp;가&nbsp;제어 블록(control block)&nbsp;을 동적으로 할당한 후,&nbsp;shared_ptr&nbsp;들이 이 제어 블록에 필요한 정보를 공유하는 방식으로 구현<img alt=\"cpp_10.png\" src=\"images/cpp_10.png\" target=\"_self\">shared_ptr&nbsp;는 복사 생성할 때 마다 해당 제어 블록의 위치만 공유하면 되고,&nbsp;shared_ptr&nbsp;가 소멸할 때 마다 제어 블록의 참조 개수를 하나 줄이고, 생성할 때 마다 하나 늘리는 방식으로 작동shared_ptr&nbsp;은 인자로 주소값이 전달된다면, 마치 자기가 해당 객체를 첫번째로 소유하는&nbsp;shared_ptr&nbsp;인 것 마냥 행동A* a = new A();\nstd::shared_ptr&lt;A&gt; pa1(a);\nstd::shared_ptr&lt;A&gt; pa2(a);\n<br><img alt=\"cpp_11.png\" src=\"images/cpp_11.png\" target=\"_self\">따라서 위와 같이 각각의 제어 블록들은, 다른 제어 블록들의 존재를 모르고 참조 개수를 1 로 설정하게 되겠지요. 만약에&nbsp;pa1&nbsp;이 소멸된다면, 참조 카운트가 0 이 되어서 자신이 가리키는 객체 A 를 소멸시켜 버립니다.&nbsp;pa2&nbsp;가 아직 가리키고 있는데도 말이지요!물론&nbsp;pa2&nbsp;의 참조 카운트는 계속 1 이기 때문에 자신이 가리키는 객체가 살아 있을 것이라 생각할 것입니다. 설사 운 좋게도&nbsp;pa2&nbsp;를 사용하지 않아도,&nbsp;pa2&nbsp;가 소멸되면 참조 개수가 0 으로 떨어지고 자신이 가리키고 있는 (이미 해제된) 객체를 소멸시키기 때문에 오류가 발생#include &lt;iostream&gt;\n#include &lt;memory&gt; class A { int* data; public: A() { data = new int[100]; std::cout &lt;&lt; \"자원을 획득함!\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"소멸자 호출!\" &lt;&lt; std::endl; delete[] data; }\n}; int main() { A* a = new A(); std::shared_ptr&lt;A&gt; pa1(a); std::shared_ptr&lt;A&gt; pa2(a); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;\n}\n자원을 획득함!\n1\n1\n소멸자 호출!\n소멸자 호출!\ntest(37272,0x11254d5c0) malloc: *** error for object 0x4000000000000000: pointer being freed was not allocated\ntest(37272,0x11254d5c0) malloc: *** set a breakpoint in malloc_error_break to debug\n[1] 37272 abort ./test\n이와 같은 상황을 방지하려면&nbsp;shared_ptr&nbsp;를 주소값을 통해서 생성하는 것을 지양해야 합니다.하지만, 어쩔 수 없는 상황도 있습니다. 바로 객체 내부에서 자기 자신을 가리키는&nbsp;shared_ptr&nbsp;를 만들 때 를 생각해봅시다.#include &lt;iostream&gt;\n#include &lt;memory&gt; class A { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; \"자원을 획득함!\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"소멸자 호출!\" &lt;&lt; std::endl; delete[] data; } std::shared_ptr&lt;A&gt; get_shared_ptr() { return std::shared_ptr&lt;A&gt;(this); }\n}; int main() { std::shared_ptr&lt;A&gt; pa1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;A&gt; pa2 = pa1-&gt;get_shared_ptr(); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;\n}\n자원을 획득함!\n1\n1\n소멸자 호출!\n소멸자 호출!\ntest(38479,0x10e0945c0) malloc: *** error for object 0x7fa1e0e02700: pointer being freed was not allocated\ntest(38479,0x10e0945c0) malloc: *** set a breakpoint in malloc_error_break to debug\n[1] 38479 abort ./test\n위와 같이 이전과 같은 이유로 오류가 발생하게 됩니다.&nbsp;get_shared_ptr&nbsp;함수에서&nbsp;shared_ptr&nbsp;을 생성할 때, 이미 자기 자신을 가리키는&nbsp;shared_ptr&nbsp;가 있다는 사실을 모른채 새로운 제어 블록을 생성하기 때문이 문제는&nbsp;enable_shared_from_this&nbsp;를 통해 깔끔하게 해결#include &lt;iostream&gt;\n#include &lt;memory&gt; class A : public std::enable_shared_from_this&lt;A&gt; { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; \"자원을 획득함!\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"소멸자 호출!\" &lt;&lt; std::endl; delete[] data; } std::shared_ptr&lt;A&gt; get_shared_ptr() { return shared_from_this(); }\n}; int main() { std::shared_ptr&lt;A&gt; pa1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;A&gt; pa2 = pa1-&gt;get_shared_ptr(); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;\n}\n근데 위의 코드는 보통 언제쯤 사용하는걸까?콜백이나 비동기 작업에서 객체의 안전한 수명 관리가 필요할 때 주로 사용한다고 함. 순환참조 문제 발생 이러한 순환 참조 문제를 해결하기 위해 나타난 것이 바로&nbsp;weak_ptr우리는 트리 구조를 지원하는 클래스를 만드려고 합니다. 트리 구조라 함은 아래와 가계도와 비슷하다고 생각하시면 됩니다.<br><img alt=\"cpp_12.png\" src=\"images/cpp_12.png\" target=\"_self\">class Node { std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children; /* 어떤 타입이 와야할까? */ parent; public: Node(){}; void AddChild(std::shared_ptr&lt;Node&gt; node) { children.push_back(node); }\n}; 만약에 일반 포인터(Node *) 로 하게 된다면, 메모리 해제를 까먹고 하지 않을 경우 혹은 예외가 발생하였을 경우 적절하게 자원을 해제하기 어렵습니다. 물론 이미 해제된 메모리를 계속 가리키고 있을 위험도 있습니다. 하지만 이를&nbsp;shared_ptr&nbsp;로 하게 된다면 앞서 본 순환 참조 문제가 생깁니다. 부모와 자식이 서로를 가리키기 때문에 참조 개수가 절대로 0 이 될 수 없습니다. 따라서, 이들 객체들은 프로그램 끝날 때 까지 절대로 소멸되지 못하고 남아있게 됩니다.\nweak_ptr&nbsp;는 일반 포인터와&nbsp;shared_ptr&nbsp;사이에 위치한 스마트 포인터로, 스마트 포인터 처럼 객체를 안전하게 참조할 수 있게 해주지만,&nbsp;shared_ptr&nbsp;와는 다르게 참조 개수를 늘리지는 않습니다. 이름 그대로&nbsp;약한&nbsp;포인터 인것이지요.따라서 설사 어떤 객체를&nbsp;weak_ptr&nbsp;가 가리키고 있다고 하더라도, 다른&nbsp;shared_ptr&nbsp;들이 가리키고 있지 않다면 이미 메모리에서 소멸되었을 것입니다.이 때문에&nbsp;weak_ptr&nbsp;자체로는 원래 객체를 참조할 수 없고, 반드시&nbsp;shared_ptr&nbsp;로 변환해서 사용해야 합니다. 이 때 가리키고 있는 객체가 이미 소멸되었다면 빈&nbsp;shared_ptr&nbsp;로 변환되고, 아닐경우 해당 객체를 가리키는&nbsp;shared_ptr&nbsp;로 변환#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt; class A { std::string s; std::weak_ptr&lt;A&gt; other; public: A(const std::string&amp; s) : s(s) { std::cout &lt;&lt; \"자원을 획득함!\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"소멸자 호출!\" &lt;&lt; std::endl; } void set_other (std::weak_ptr&lt;A&gt; o) { other = o; } void access_other() { std::shared_ptr&lt;A&gt; o = other.lock(); if (o) { std::cout &lt;&lt; \"접근 : \" &lt;&lt; o-&gt;name() &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"이미 소멸됨 ㅠ\" &lt;&lt; std::endl; } } std::string name() { return s; }\n}; int main() { std::vector&lt;std::shared_ptr&lt;A&gt;&gt; vec; vec.push_back(std::make_shared&lt;A&gt;(\"자원 1\")); vec.push_back(std::make_shared&lt;A&gt;(\"자원 2\")); vec[0]-&gt;set_other(vec[1]); vec[1]-&gt;set_other(vec[0]); // pa 와 pb 의 ref count 는 그대로다. std::cout &lt;&lt; \"vec[0] ref count : \" &lt;&lt; vec[0].use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"vec[1] ref count : \" &lt;&lt; vec[1].use_count() &lt;&lt; std::endl; // weak_ptr 로 해당 객체 접근하기 vec[0]-&gt;access_other(); // 벡터 마지막 원소 제거 (vec[1] 소멸) vec.pop_back(); vec[0]-&gt;access_other(); // 접근 실패!\n} <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"shared_ptr","level":3,"id":"shared_ptr_0"},{"heading":"shared_ptr 생성 시 주의 할 점","level":3,"id":"shared_ptr_생성_시_주의_할_점_0"},{"heading":"서로 참조하는 shared_ptr","level":3,"id":"서로_참조하는_shared_ptr_0"},{"heading":"weak_ptr","level":3,"id":"weak_ptr_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"images/cpp_10.png","fullURL":"cpp/modern/4.-shared,-weak-ptr.html","pathToRoot":"../..","attachments":["images/cpp_10.html","images/cpp_11.html","images/cpp_12.html"],"createdTime":1735107852604,"modifiedTime":1739074423015,"sourceSize":9792,"sourcePath":"CPP/Modern/4. shared, weak ptr.md","exportPath":"cpp/modern/4.-shared,-weak-ptr.html","showInTree":true,"treeOrder":73,"backlinks":[],"type":"markdown"},"cpp/modern/5.-callable-etc..html":{"title":"5. callable etc.","icon":"","description":"Callable&nbsp;이란, 이름 그대로 나타내듯이 호출(Call) 할 수 있는 모든 것을 의미C++ 에서는 이러한&nbsp;Callable&nbsp;들을 객체의 형태로 보관할 수 있는&nbsp;std::function&nbsp;이라는 클래스를 제공합니다. C 에서의 함수 포인터는 진짜 함수들만 보관할 수 있는 객체라고 볼 수 있다면 이&nbsp;std::function&nbsp;의 경우 함수 뿐만이 아니라 모든&nbsp;Callable&nbsp;들을 보관할 수 있는 객체#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; int some_func1(const std::string&amp; a) { std::cout &lt;&lt; \"Func1 호출! \" &lt;&lt; a &lt;&lt; std::endl; return 0;\n} struct S { void operator()(char c) { std::cout &lt;&lt; \"Func2 호출! \" &lt;&lt; c &lt;&lt; std::endl; }\n}; int main() { std::function&lt;int(const std::string&amp;)&gt; f1 = some_func1; std::function&lt;void(char)&gt; f2 = S(); std::function&lt;void()&gt; f3 = []() { std::cout &lt;&lt; \"Func3 호출! \" &lt;&lt; std::endl; }; f1(\"hello\"); f2('c'); f3();\n}\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; class A { int c; public: A(int c) : c(c) {} int some_func() { std::cout &lt;&lt; \"내부 데이터 : \" &lt;&lt; c &lt;&lt; std::endl; }\n}; int main() { A a(5); std::function&lt;int()&gt; f1 = a.some_func;\n}\n이건 컴파일 오류test2.cc: In function 'int main()':\ntest2.cc:17:26: error: invalid use of non-static member function 'int A::some_func()' std::function&lt;int()&gt; f1 = a.some_func; ~~^~~~~~~~~\ntest2.cc:10:9: note: declared here int some_func() { ^~~~~~~~~\nf1&nbsp;을 호출하였을 때, 함수의 입장에서 자신을 호출하는 객체가 무엇인지 알 길이 없기 때문에&nbsp;c&nbsp;를 참조 하였을 때 어떤 객체의&nbsp;c&nbsp;인지를 알 수 없겠지요. 따라서 이 경우&nbsp;f1&nbsp;에&nbsp;a&nbsp;에 관한 정보도 추가로 전달해야 합니다.사실 멤버 함수들은 구현 상 자신을 호출한 객체를 인자로 암묵적으로 받고 있었습니다.#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; class A { int c; public: A(int c) : c(c) {} int some_func() { std::cout &lt;&lt; \"비상수 함수: \" &lt;&lt; ++c &lt;&lt; std::endl; return c; } int some_const_function() const { std::cout &lt;&lt; \"상수 함수: \" &lt;&lt; c &lt;&lt; std::endl; return c; } static void st() {}\n}; int main() { A a(5); std::function&lt;int(A&amp;)&gt; f1 = &amp;A::some_func; std::function&lt;int(const A&amp;)&gt; f2 = &amp;A::some_const_function; /*\n위와 같이 원래 인자에 추가적으로 객체를 받는 인자를 전달해주면 됩니다. 이 때 상수 함수의 경우 당연히 상수 형태로 인자를 받아야 하고 (`const A&amp;`), 반면에 상수 함수가 아닌 경우 단순히 `A&amp;` 의 형태로 인자를 받으면 되겠습니다. f1(a); f2(a);\n*/\n}\nvector&nbsp;들을 가지는&nbsp;vector&nbsp;가 있을 때, 각각의&nbsp;vector&nbsp;들의 크기들을 벡터로 만들어주는 코드를 생각해봅시다.#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(b); container.push_back(d); container.push_back(a); container.push_back(c); vector&lt;int&gt; size_vec(4); std::transform(container.begin(), container.end(), size_vec.begin(), &amp;vector&lt;int&gt;::size); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; \"벡터 크기 :: \" &lt;&lt; *itr &lt;&lt; std::endl; }\n}\n위 코드를 컴파일 하면 아래와 같은 컴파일 오류왜 그럴까요? 이 역시 전달된&nbsp;size&nbsp;함수가 멤버 함수여서 발생하는 문제 입니다. 위 템플릿에&nbsp;&amp;vector&lt;int&gt;::size&nbsp;가 들어간다면 해당&nbsp;unary_op&nbsp;를 호출하는 부분은 아래와 같이 변환\n// from\nunary_op(*first1); // to로 변환됨\n&amp;vector&lt;int&gt;::size(*first); // 멤버함수의 경우\n(*first).(*&amp;vector&lt;int&gt;::size) // or\nfirst-&gt;(*&amp;vector&lt;int&gt;::size)\n// 둘중 하나로 호출해야함. c++ 규칙이니까 그래서 std::function을 이용해야함. std::function&nbsp;으로 변환해서 전달#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(a); container.push_back(b); container.push_back(c); container.push_back(d); std::function&lt;size_t(const vector&lt;int&gt;&amp;)&gt; sz_func = &amp;vector&lt;int&gt;::size; vector&lt;int&gt; size_vec(4); std::transform(container.begin(), container.end(), size_vec.begin(), sz_func); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; \"벡터 크기 :: \" &lt;&lt; *itr &lt;&lt; std::endl; }\n}\n근데 매번 function&nbsp;객체를 따로 만들어서 전달하는 것은 매우 귀찮습니다. 따라서 C++ 개발자들은 라이브러리에 위&nbsp;function&nbsp;객체를 리턴해버리는 함수를 추가#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(a); container.push_back(b); container.push_back(c); container.push_back(d); vector&lt;int&gt; size_vec(4); transform(container.begin(), container.end(), size_vec.begin(), std::mem_fn(&amp;vector&lt;int&gt;::size)); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; \"벡터 크기 :: \" &lt;&lt; *itr &lt;&lt; std::endl; }\n}\n참고로&nbsp;mem_fn&nbsp;은 그리 자주 쓰이지는 않는데, 람다 함수로도 동일한 작업을 수행할 수 있기 때문입니다. 위 코드의 경우&nbsp;mem_fnsize&nbsp;대신에&nbsp;[](const auto&amp; v){ return v.size()}&nbsp;를 전달해도 동일한 작업을 수행합니다.mem_fn&nbsp;을 사용하기 위해서는&nbsp;&lt;functional&gt;&nbsp;헤더를 추가해야 하지만 람다함수는 그냥 쓸 수 있으니 좀 더 편리한 면이 있습니다. 물론, 코드 길이 면에서는&nbsp;mem_fn&nbsp;을 사용하는 것이 좀더 깔끔한 편입니다.std::bind는 함수 객체를 생성하는 도구로, 함수의 일부 인자를 고정하거나 인자의 순서를 변경할 수 있게 해줍니다.#include &lt;functional&gt;\n#include &lt;iostream&gt; void add(int x, int y) { std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; \" = \" &lt;&lt; x + y &lt;&lt; std::endl;\n} void subtract(int x, int y) { std::cout &lt;&lt; x &lt;&lt; \" - \" &lt;&lt; y &lt;&lt; \" = \" &lt;&lt; x - y &lt;&lt; std::endl;\n}\nint main() { auto add_with_2 = std::bind(add, 2, std::placeholders::_1); add_with_2(3); // 두 번째 인자는 무시된다. add_with_2(3, 4); auto subtract_from_2 = std::bind(subtract, std::placeholders::_1, 2); auto negate = std::bind(subtract, std::placeholders::_2, std::placeholders::_1); subtract_from_2(3); // 3 - 2 를 계산한다. negate(4, 2); // 2 - 4 를 계산한다\n}\nbind를 사용할 때 레퍼런스로 넘길 때 주의 해야함.#include &lt;functional&gt;\n#include &lt;iostream&gt; struct S { int data; S(int data) : data(data) { std::cout &lt;&lt; \"일반 생성자 호출!\" &lt;&lt; std::endl; } S(const S&amp; s) { std::cout &lt;&lt; \"복사 생성자 호출!\" &lt;&lt; std::endl; data = s.data; } S(S&amp;&amp; s) { std::cout &lt;&lt; \"이동 생성자 호출!\" &lt;&lt; std::endl; data = s.data; }\n}; void do_something(S&amp; s1, const S&amp; s2) { s1.data = s2.data + 3; } int main() { S s1(1), s2(2); std::cout &lt;&lt; \"Before : \" &lt;&lt; s1.data &lt;&lt; std::endl; // s1 이 그대로 전달된 것이 아니라 s1 의 복사본이 전달됨! auto do_something_with_s1 = std::bind(do_something, s1, std::placeholders::_1); do_something_with_s1(s2); std::cout &lt;&lt; \"After :: \" &lt;&lt; s1.data &lt;&lt; std::endl;\n}\n일반 생성자 호출!\n일반 생성자 호출!\nBefore : 1\n복사 생성자 호출!\nAfter :: 1\n그 이유는 위 생성자 호출 메세지에서 확인할 수 있듯이&nbsp;bind&nbsp;함수로 인자가&nbsp;복사&nbsp;되서 전달되기 때문입니다. 따라서 이를 해결 하기 위해서는 명시적으로&nbsp;s1&nbsp;의 레퍼런스를 전달해줘야 합니다.#include &lt;functional&gt;\n#include &lt;iostream&gt; struct S { int data; S(int data) : data(data) { std::cout &lt;&lt; \"일반 생성자 호출!\" &lt;&lt; std::endl; } S(const S&amp; s) { std::cout &lt;&lt; \"복사 생성자 호출!\" &lt;&lt; std::endl; data = s.data; } S(S&amp;&amp; s) { std::cout &lt;&lt; \"이동 생성자 호출!\" &lt;&lt; std::endl; data = s.data; }\n}; void do_something(S&amp; s1, const S&amp; s2) { s1.data = s2.data + 3; } int main() { S s1(1), s2(2); std::cout &lt;&lt; \"Before : \" &lt;&lt; s1.data &lt;&lt; std::endl; // s1 이 그대로 전달된 것이 아니라 s1 의 복사본이 전달됨! auto do_something_with_s1 = std::bind(do_something, std::ref(s1), std::placeholders::_1); do_something_with_s1(s2); std::cout &lt;&lt; \"After :: \" &lt;&lt; s1.data &lt;&lt; std::endl;\n}\n일반 생성자 호출!\n일반 생성자 호출!\nBefore : 1\nAfter :: 5 <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Callable","level":3,"id":"Callable_0"},{"heading":"std::function","level":3,"id":"stdfunction_0"},{"heading":"멤버 함수를 가지는 std::function","level":3,"id":"멤버_함수를_가지는_stdfunction_0"},{"heading":"멤버 함수들을 함수 객체로 - mem_fn","level":3,"id":"멤버_함수들을_함수_객체로_-_mem_fn_0"},{"heading":"std::bind","level":3,"id":"stdbind_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/modern/5.-callable-etc..html","pathToRoot":"../..","attachments":[],"createdTime":1737701652292,"modifiedTime":1738470322442,"sourceSize":9317,"sourcePath":"CPP/Modern/5. callable etc..md","exportPath":"cpp/modern/5.-callable-etc..html","showInTree":true,"treeOrder":74,"backlinks":[],"type":"markdown"},"cpp/modern/6.-uniform-initializer.html":{"title":"6. Uniform Initializer","icon":"","description":"C++ 11에서 추가된 기능#include &lt;iostream&gt; class A { public: A() { std::cout &lt;&lt; \"A 의 생성자 호출!\" &lt;&lt; std::endl; }\n}; int main() { A a(); // 아무것도 출력되지 않음. } A a() 는 A의 객체 a를 만든 것이 아니다. 컴파일러는 A를 리턴하고 인자를 받지 않는 함수 a를 정의 하는 것으로 판단한다. ()는 함수의 인자를 정의할 때 사용되고 일반적인 객체의 생성자를 호출 할 때에도 사용되기 때문이다.그렇다면 argument가 있는 경우는 어떨까? 함수 정의로 볼 수 없기 때문에 호출 된다.#include &lt;iostream&gt; class A { public: A(int x) { std::cout &lt;&lt; \"A 의 생성자 호출!\" &lt;&lt; std::endl; }\n}; int main() { A a(3); // A의 생성자 호출! 출력\n} 이러한 불편함을 줄이기 위해서 도입된 것이 Uniform Initializer 다.#include &lt;iostream&gt; class A { public: A() { std::cout &lt;&lt; \"A 의 생성자 호출!\" &lt;&lt; std::endl; }\n}; int main() { A a{}; // A 의 생성자 호출! 프린트 됨\n} (), {} 초기화의 한가지 큰 차이점이 있다. narrow-conversion 허용 여부다.#include &lt;iostream&gt; class A { public: A(int x) { std::cout &lt;&lt; \"A 의 생성자 호출!\" &lt;&lt; std::endl; }\n}; int main() { A a(3.5); // Narrow-conversion 가능 - 3으로 출력 A b{3.5}; // Narrow-conversion 불가능 - 컴파일 실패\n} Narrow - conversion 부동 소수점 타입에서 정수 타입으로의 변환\nlong double&nbsp;에서&nbsp;double&nbsp;혹은&nbsp;float&nbsp;으로의 변환,&nbsp;double&nbsp;에서&nbsp;float&nbsp;으로의 변환\n정수 타입에서 부동 소수점 타입으로의 변환 즉 {}를 사용하면 원하지 않는 타입 캐스팅 방지해서 데이터 손실 오류를 잡아낼 수 있다.class B {\npublic: B(std::initializer_list&lt;int&gt; l) { for (auto itr = l.begin(); itr != l.end(); ++itr) { std::cout &lt;&lt; *itr &lt;&lt; std::endl; } }\n};\nint main() { B b({1, 2, 3});\n} initializer_list&nbsp;는 우리가&nbsp;{}&nbsp;를 이용해서 생성자를 호출할 때, 클래스의 생성자들 중에&nbsp;initializer_list&nbsp;를 인자로 받는 생성자가 있다면 전달된다.{}&nbsp;를 이용해서 객체를 생성할 경우 생성자 오버로딩 시에 해당 함수 Initializer list가&nbsp;최우선&nbsp;으로 고려된다는 점이다.vector에는 vector(size_type count); 형태의 생성자가 존재. 이 생성자는 count 만큼의 원소 자리를 미리 생성해놓는다.vector v{10}는 그냥 원소 1 개 짜리&nbsp;intializer_list&nbsp;라고 생각해서&nbsp;10&nbsp;을 보관하고 있는 벡터를 생성하게 된다.#include &lt;initializer_list&gt;\n#include &lt;iostream&gt; class A { public: A(int x, double y) { std::cout &lt;&lt; \"일반 생성자! \" &lt;&lt; std::endl; } A(std::initializer_list&lt;int&gt; lst) { std::cout &lt;&lt; \"초기화자 사용 생성자! \" &lt;&lt; std::endl; }\n}; int main() { A a(3, 1.5); // Good A b{3, 1.5}; // Bad!\n}\n위의 코드에서 컴파일러는 initializer_list를 받는 생성자를 최대한 이용하도록 노력한다.\n하지만 {}는 narrow conversion이 불가능하기 때문에 b에서 컴파일러 에러가 발생한다.이러한 문제가 발생하지 않으려면 initializer_list&nbsp;의 원소 타입으로 타입 변환 자체가 불가능한 경우여야만 한다. 즉 narrow conversion이라는 것이 아예 일어날 수 없는 경우다.#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt; class A { public: A(int x, double y) { std::cout &lt;&lt; \"일반 생성자! \" &lt;&lt; std::endl; } A(std::initializer_list&lt;std::string&gt; lst) { std::cout &lt;&lt; \"초기화자 사용 생성자! \" &lt;&lt; std::endl; }\n}; int main() { A a(3, 1.5); // 일반 A b{3, 1.5}; // 일반 A c{\"abc\", \"def\"}; // 초기화자\n} int&nbsp;나&nbsp;double&nbsp;이&nbsp;string&nbsp;으로 변환될 수 없기 때문에&nbsp;initializer_list&nbsp;를 받는 생성자는 아예 고려 대상에서 제외된다.만일&nbsp;{}&nbsp;를 이용해서 생성할 때 타입으로&nbsp;auto&nbsp;를 지정한다면&nbsp;initializer_list&nbsp;객체가 생성된다. auto list = {1, 2, 3}; // initializer_list&lt;int&gt;\n그런데 c++11과 c++17 차이점이 있다.auto a = {1}; // std::initializer_list&lt;int&gt;\nauto b{1}; // std::initializer_list&lt;int&gt;\nauto c = {1, 2}; // std::initializer_list&lt;int&gt;\nauto d{1, 2}; // std::initializer_list&lt;int&gt;\nC++ 11에서 b의 타입이 std::initializer_list&lt;int&gt; 로 추론된다. b의 타입이 그냥 int로 추론 되어야 한다는 것이 이치에 맞다고 판단해서인지 C++ 17에서는 수정 되었다.\nauto x = {arg1, arg2...}&nbsp;형태의 경우&nbsp;arg1,&nbsp;arg2&nbsp;... 들이 모두 같은 타입이라면&nbsp;x&nbsp;는&nbsp;std::initializer_list&lt;T&gt;&nbsp;로 추론 auto x {arg1, arg2, ...}&nbsp;형태의 경우 만일 인자가 단 1 개라면 인자의 타입으로 추론되고, 여러 개일 경우 오류를 발생\nauto a = {1}; // 첫 번째 형태이므로 std::initializer_list&lt;int&gt;\nauto b{1}; // 두 번째 형태 이므로 그냥 int\nauto c = {1, 2}; // 첫 번째 형태이므로 std::initializer_list&lt;int&gt;\nauto d{1, 2}; // 두 번째 형태 인데 인자가 2 개 이상이므로 컴파일 오류\nauto를 사용해서 문자열을 다룰 때, 주의할 점이 있다.auto list = {\"a\", \"b\", \"c\"};\n<img alt=\"initializer_list_char.png\" src=\"images/initializer_list_char.png\" target=\"_self\">list&nbsp;는&nbsp;initializer_list&lt;std::string&gt;&nbsp;이 아닌&nbsp;initializer_list&lt;const char*&gt;&nbsp;이 된다는 점이다.C++ 14에서 추가된 리터럴 연산자 활용 -&gt; initializer_list&lt;std::string&gt;&nbsp;으로 추론할 수 있다.using namespace std::string_literals;\nauto list = {\"a\"s, \"b\"s, \"c\"s}; <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a> <br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/example_uniform_initializer\" target=\"_self\">https://github.com/psychehose/example_uniform_initializer</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"균일한 초기화 (Uniform Initialization)","level":3,"id":"균일한_초기화_(Uniform_Initialization)_0"},{"heading":"초기화자 리스트 (Initializer list)","level":3,"id":"초기화자_리스트_(Initializer_list)_0"},{"heading":"Initializer list 사용시 주의할 점","level":4,"id":"Initializer_list_사용시_주의할_점_0"},{"heading":"initializer_list 와 auto","level":4,"id":"initializer_list_와_auto_0"},{"heading":"Reference","level":3,"id":"Reference_0"},{"heading":"Github","level":3,"id":"Github_0"}],"links":[],"author":"","coverImageURL":"images/initializer_list_char.png","fullURL":"cpp/modern/6.-uniform-initializer.html","pathToRoot":"../..","attachments":["images/initializer_list_char.html"],"createdTime":1738400809952,"modifiedTime":1738470293413,"sourceSize":6098,"sourcePath":"CPP/Modern/6. Uniform Initializer.md","exportPath":"cpp/modern/6.-uniform-initializer.html","showInTree":true,"treeOrder":75,"backlinks":[],"type":"markdown"},"cpp/modern/7.-random,-chrono-library.html":{"title":"7. random, chrono library","icon":"","description":"\n&lt;random&gt;&nbsp;라이브러리를 활용한 난수 생성\n&lt;chrono&gt;&nbsp;라이브러리를 활용한 시간 측정\nC언어의 srand(), rand()는 좋은 품질의 난수열을 생성 못함.\n선형 합동 생성기(LCG) 기반으로 예측 가능한 패턴 발생 주기가 RAND_MAX(보통 32767)로 제한되어 짧음\n통계적 특성이 좋지 않아 시뮬레이션/암호화에 부적합\nC언어의 srand(), rand()는 사용하지 말자.\n대신에 C++의 random을 사용하자#include &lt;iostream&gt;\n#include &lt;random&gt; int main() { // 시드값을 얻기 위한 random_device 생성. std::random_device rd; // random_device 를 통해 난수 생성 엔진을 초기화 한다. // 메르센 트위스터 알고리즘 난수 엔진 std::mt19937 gen(rd()); // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의. std::uniform_int_distribution&lt;int&gt; dis(0, 99); for (int i = 0; i &lt; 5; i++) { std::cout &lt;&lt; \"난수 : \" &lt;&lt; dis(gen) &lt;&lt; std::endl; }\n}\n이건 정규 분포#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;random&gt; int main() { std::random_device rd; std::mt19937 gen(rd()); std::normal_distribution&lt;double&gt; dist(/* 평균 = */ 0, /* 표준 편차 = */ 1); std::map&lt;int, int&gt; hist{}; for (int n = 0; n &lt; 10000; ++n) { ++hist[std::round(dist(gen))]; } for (auto p : hist) { std::cout &lt;&lt; std::setw(2) &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; std::string(p.second / 100, '*') &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; '\\n'; }\n}\n-4 1\n-3 38\n-2 ****** 638\n-1 ************************ 2407 0 ************************************** 3821 1 ************************ 2429 2 ***** 595 3 70 4 1\n&lt;chrono&gt;&nbsp;는 4가지 주요 구성요소를 가짐\nstd::chrono::duration: 시간 간격 표현\nstd::chrono::time_point: 특정 시점 표현\nstd::chrono::system_clock: 시스템 시계\nstd::chrono::steady_clock: 단조 증가 시계 (주로 시간 측정에 사용)\ntime_point들이 연산하면 duration이 됨.#include &lt;chrono&gt;\nusing namespace std::chrono; // 현재 시간 얻기\nauto now = system_clock::now(); // 시간 간격 정의\nhours h(1); // 1시간\nminutes m(30); // 30분\nseconds s(15); // 15초\nmilliseconds ms(100); // 100밀리초 // 시간 계산\nauto future = now + h + m; // 1시간 30분 후 // 시간 간격 측정\nauto start = steady_clock::now();\n// ... 작업 수행\nauto end = steady_clock::now();\nauto duration = duration_cast&lt;milliseconds&gt;(end - start); auto my_time_t = std::chrono::system_clock::to_time_t(boot);\nstd::tm* my_tm = std::gmtime(&amp;my_time_t); my_tm-&gt;tm_year;\nmy_tm-&gt;tm_mon;\nmy_tm-&gt;tm_mday;\nmy_tm-&gt;tm_hour;\nmy_tm-&gt;tm_min;\nmy_tm-&gt;tm_sec;\ntm 구조체에서 tm_year는 1900년도부터의 연도 차이를 저장하도록 설계되어 있음.\n2000년은 tm_year에 100으로 저장됨 (2000 - 1900 = 100)\n2024년은 tm_year에 124로 저장됨 (2024 - 1900 = 124)\n그래서 실제 연도를 얻으려면 항상 tm_year + 1900을 해야함\n비슷하게, tm_mon도 0부터 시작하므로(0이 1월) 실제 월을 얻으려면 tm_mon + 1을 해야함.\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://modoocode.com/135\" target=\"_self\">https://modoocode.com/135</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"목표","level":4,"id":"목표_0"},{"heading":"random","level":3,"id":"random_0"},{"heading":"chrono","level":3,"id":"chrono_0"},{"heading":"time을 뽑아내는 방법","level":4,"id":"time을_뽑아내는_방법_0"},{"heading":"Reference","level":3,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/modern/7.-random,-chrono-library.html","pathToRoot":"../..","attachments":[],"createdTime":1737554201126,"modifiedTime":1738470350209,"sourceSize":3357,"sourcePath":"CPP/Modern/7. random, chrono library.md","exportPath":"cpp/modern/7.-random,-chrono-library.html","showInTree":true,"treeOrder":76,"backlinks":[],"type":"markdown"},"cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html":{"title":"C++ 프로젝트에서 JNI를 이용해서 Android 호출","icon":"","description":"C++ 기반의 프로젝트에서 안드로이드 함수를 사용 해야하는 경우가 있다. 안드로이드 게임을 타겟으로 하는 언리얼 엔진 프로젝트가 예시이다.어떻게 하면 C++ 프로젝트에서 안드로이드 개발자가 정의한 함수를 호출할 수 있을까? JNI를 이용하면 된다. JNI는 Java Native Interface의 준말로 안드로이드 앱(자바/코틀린)과 네이티브 코드(C/C++) 사이를 연결해주는 인터페이스다. C++ 기반 코드에서 JNIEnv*라는 환경 포인터를 이용하여, 자바 클래스를 찾고 메서드를 호출하거나, 자바 타입과 C++ 타입 간 데이터를 변환할 수 있다.C++ 코드베이스에서 JNI를 이용해서 Android 플랫폼 코드를 호출 하기 위해서 먼저 안드로이드 라이브러리를 빌드 해야한다. \baar은 Android Archive package의 준말이다. 자바 코드만 포함할 수 있는jar과 다르게 aar은 안드로이드 리소스 파일(레이아웃 등)과 매니페스트 파일과 C++ Library를 포함하수 있다. 안드로이드 스튜디오를 이용해서 Java / Kotlin으로 로직을 작성한다. AGP 버전, gradle 버전, 안드로이드 필수 라이브러리 호환성 체크 gradle을 이용해서 안드로이드 라이브러리(aar) 빌드 $ ./gradlew --version # gradle 버전\n$ ./gradlew :AndroidUtil:assembleRelease # build/output 폴더로 라이브러리 빌드\n언리얼엔진과 안드로이드 라이브러리 파일(aar)을 통합하기 위해서는 JNI를 이용 해야 한다. 프로젝트에 바로 추가하는 것보다 플러그인에 추가하는 것이 낫다.\n플러그인 모듈을 만들고 $(PluginDir)/../..Resource/Library/Android에 빌드한 aar을 넣는다.\nPluginDir에 {Module_Name}_UPL.xml을 생성한다.\n{Module_Name}_UPL.xml 작성 PrivateDependencyModuleNames.Add(\"Launch\"); 필수 Launch 모듈에 언리얼 JNI 헬퍼 함수들이 구현되어 있음. // MyModule.Build.cs\nusing UnrealBuildTool;\nusing System.IO;\npublic class MyModule : ModuleRules\n{ public MyModule(ReadOnlyTargetRules Target) : base(Target) { // ... // string PluginPath = Utils.MakePathRelativeTo(ModuleDirectory, Target.RelativeEnginePath) if (Target.Platform == UnrealTargetPlatform.Android) { // ... // PrivateDependencyModuleNames.Add(\"Launch\"); AdditionalPropertiesForReceipt.Add(\"AndroidPlugin\", Path.Combine(PluginPath), \"MyModule_UPL.xml\") } }\n} UPL을 작성한다. 안드로이드 패키징을 할 때 aar 파일을 안드로이드 앱에 복사함\n복사한 aar을 dependency로 설정함\nGameActivity에 aar에 있는 package를 import 함\n안드로이드 매니페스트 업데이트 (권한) &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!-- Copyright (c) 2024 Hose --&gt; &lt;root xmlns:android=\"[http://schemas.android.com/apk/res/android\"&gt; &lt;init&gt; &lt;log text=\"Android UPL initialization\" /&gt; &lt;/init&gt; &lt;prebuildCopies&gt; &lt;copyFile src=\"$S(PluginDir)/../../Resources/Library/Android/AndroidUtil-release.aar\" dst=\"$S(BuildDir)/gradle/app/libs/AndroidUtil-release.aar\" /&gt; &lt;log text=\"Copy Success\" /&gt; &lt;/prebuildCopies&gt; &lt;!-- 프로젝트의 빌드 스크립트 자체를 구성하는 데 필요한 종속성을 정의 gradle version 지정\n--&gt; &lt;buildscriptGradleAdditions&gt; &lt;insert&gt; dependencies { classpath 'com.android.tools.build:gradle:7.4.2' } &lt;/insert&gt; &lt;/buildscriptGradleAdditions&gt; &lt;!-- 앱의 종속성을 정의\n--&gt; &lt;buildGradleAdditions&gt; &lt;insert&gt; dependencies { implementation files('libs/AndroidUtil-release.aar') } &lt;/insert&gt; &lt;/buildGradleAdditions&gt; &lt;!-- GameActivity에서 네이티브 메서드를 인식하도록 설정 --&gt; &lt;gameActivityImportAdditions&gt; &lt;insert&gt; import com.psychehose.androidutil.network.NativeNetworkManager; &lt;/insert&gt; &lt;/gameActivityImportAdditions&gt; &lt;gradleProperties&gt; &lt;insert&gt; android.useAndroidX=true android.enableJetifier=true &lt;/insert&gt; &lt;/gradleProperties&gt; &lt;proguardAdditions&gt; &lt;insert&gt; &lt;/insert&gt; &lt;/proguardAdditions&gt; &lt;androidManifestUpdate&gt; &lt;addPermission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; &lt;addPermission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;addPermission android:name=\"android.permission.CHANGE_WIFI_STATE\"/&gt; &lt;addPermission android:name=\"android.permission.CHANGE_NETWORK_STATE\"/&gt; &lt;addPermission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt; &lt;addPermission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt; &lt;addPermission android:name=\"android.permission.NEARBY_WIFI_DEVICES\" android:usesPermissionFlags=\"neverForLocation\" android:minSdkVersion=\"33\"/&gt; &lt;/androidManifestUpdate&gt; &lt;/root&gt; 라이브러리 내에 있는 AndroidManifest.xml에서 권한 처리를 한다면 &lt;androidManifestUpdate&gt;를 생략하면 된다.안드로이드는 자바 또는 코틀린으로 구현되어 있어서 JVM 위에서 구동된다. 그래서 C++ 코드베이스에서 Java 환경을 먼저 가져오고 함수를 호출 해야한다.\nJNIEnv를 가져온다.\n실행하고자 하는 Java Class를 찾는다.\nJava Class에서 Java method를 찾는다.(jmethod에 캐싱)\nJava Class를 통해서 instance를 생성한다. (jobject에 캐싱)\njobject와 jmethod를 이용해서 호출\n아래 static 함수 signaturepublic static NativeNetworkManager getInstance(Context context) { if (instance == null) { synchronized (NativeNetworkManager.class) { if (instance == null) { instance = new NativeNetworkManager(context); } } } return instance;\n}\nprivate static native void nativeCallbackMessage(); // callback을 위한 public void helloMessage() { nativeCallbackMessage(); } UWifiManager::UWifiManager()\n{\n} UWifiManager::~UWifiManager()\n{ JNIEnv* Env = FAndroidApplication::GetJavaEnv(); Env-&gt;DeleteGlobalRef(NativeNetworkManagerObject);\n} void UWifiManager::Init()\n{ JNIEnv* Env = FAndroidApplication::GetJavaEnv(); if (Env == nullptr) { UE_LOG(LogTemp, Log, TEXT(\"Env is nullptr\")); return; } // class를 가져옴 (instance가 아님을 주의) NativeNetworkManagerClass = FAndroidApplication::FindJavaClass(\"com/psychehose/androidutil/network/NativeNetworkManager\"); if (!NativeNetworkManagerClass) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the NativeNetworkManager class.\")); return; } if (Env-&gt;ExceptionCheck()) { Env-&gt;ExceptionDescribe(); Env-&gt;ExceptionClear(); UE_LOG(LogTemp, Error, TEXT(\"Exception occurred after finding class\")); return; } // 안드로이드의 화면 - Activity jobject Context = FAndroidApplication::GetGameActivityThis(); // Static Method를 찾고 변수에 캐싱함 jmethodID alternativeMethod = Env-&gt;GetStaticMethodID(NativeNetworkManagerClass, \"getInstance\", \"(Landroid/content/Context;)Lcom/psychehose/androidutil/network/NativeNetworkManager;\"); if (!alternativeMethod) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the alternativeMethod getInstance method.\")); } if (Env-&gt;ExceptionCheck()) { Env-&gt;ExceptionDescribe(); Env-&gt;ExceptionClear(); UE_LOG(LogTemp, Error, TEXT(\"Exception occurred after finding method\")); } jmethodID NativeNetworkManagerGetInstanceMethod = FJavaWrapper::FindStaticMethod(Env, NativeNetworkManagerClass, \"getInstance\", \"(Landroid/content/Context;)Lcom/psychehose/androidutil/network/NativeNetworkManager;\", true); if (Env-&gt;ExceptionCheck()) { Env-&gt;ExceptionDescribe(); Env-&gt;ExceptionClear(); UE_LOG(LogTemp, Error, TEXT(\"Exception occurred after finding method2\")); } if (!NativeNetworkManagerGetInstanceMethod) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the getInstance method.\")); } // Static Method Call (인스턴스 필요 없음) // static 함수의 리턴값은 NativeNetworkManager 인스턴스 이건 jobject에 캐싱함 NativeNetworkManagerObject = Env-&gt;CallStaticObjectMethod(NativeNetworkManagerClass, alternativeMethod, Context); if (!NativeNetworkManagerObject) { UE_LOG(LogTemp, Error, TEXT(\"Failed to get the NativeNetworkManager object.\")); return; } // 클래스에서 찾은 함수들을 캐싱함 IsLocationPermissionGrantedMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, \"isLocationPermissionGranted\", \"()Z\", true ); if (!IsLocationPermissionGrantedMethod) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the isLocationPermissionGranted method.\")); return; } GrantLocationPermissionMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, \"grantLocationPermission\", \"()Z\", true ); if (!GrantLocationPermissionMethod) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the grantLocationPermission method.\")); return; } FetchCurrentNetworkInformationMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, \"fetchCurrentNetworkInformation\", \"()V\", true ); if (!FetchCurrentNetworkInformationMethod) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the fetchCurrentNetworkInformation method.\")); return; } ConnectWifiMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, \"connectWifi\", \"(Ljava/lang/String;Ljava/lang/String;Z)V\", true ); if (!ConnectWifiMethod) { UE_LOG(LogTemp, Error, TEXT(\"Failed to find the connectWifi method.\")); return; } HelloMessageMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, \"helloMessage\", \"()V\", true );\n} void UWifiManager::HelloMessage()\n{ JNIEnv* Env = FAndroidApplication::GetJavaEnv(); if (Env == nullptr) { UE_LOG(LogTemp, Log, TEXT(\"Env is nullptr\")); return; } // 캐싱한 object와 method로 자바 함수 호출 Env-&gt;CallVoidMethod(NativeNetworkManagerObject, HelloMessageMethod);\n} JNI_METHOD void Java_com_psychehose_androidutil_network_NativeNetworkManager_nativeCallbackMessage(JNIEnv* jenv, jobject thiz)\n{ \b// Callback은 여기를 통해서 받을 수 있다. UE_LOG(LogTemp, Log, TEXT(\"Native Callback Message\"));\n} gradle/libs.versions.toml 파일 열어서 AGP 버전 변경 gradle/wrapper/gradle-wrapper.properties 파일을 연다.\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-X.X-all.zip X.X에 버전을 지정 한다.\n./gradlew --version 버전 확인. Activity는 안드로이드 앱에서 하나의 화면을 나타내는 구성 요소\n사용자가 앱을 실행하면 화면에 보이는 인터페이스를 담당하며, 화면 전환, 사용자 입력 처리 등을 관리\n게임은 모든 화면을 다 지우니까 하나의 Activity만 유지함. 그게 바로 GameActivity\nContext는 현재 앱의 상태나 환경 정보를 제공하는 객체\n자원(리소스), 시스템 서비스, 파일 입출력, 테마, 디바이스 관련 정보 등에 접근할 때 필요\nActivity는 Context의 하위 개념이며, Activity 자신도 Context 역할\nUI를 생성하거나 변경할 때, UI 위젯이나 Dialog, Toast 등을 생성하는 데 Context가 필요\n언리얼엔진에서는 Context를 매개변수로 받는 것이 있으면 GameActivity를 넣으면 됨.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"안드로이드 라이브러리 빌드","level":3,"id":"안드로이드_라이브러리_빌드_0"},{"heading":"언리얼엔진과 통합","level":3,"id":"언리얼엔진과_통합_0"},{"heading":"C++ 코드베이스에서 Android 함수 호출","level":4,"id":"C++_코드베이스에서_Android_함수_호출_0"},{"heading":"JNI를 사용하기 위한 선행 지식","level":3,"id":"JNI를_사용하기_위한_선행_지식_0"},{"heading":"AGP 변경","level":4,"id":"AGP_변경_0"},{"heading":"gradle 버전 변경","level":4,"id":"gradle_버전_변경_0"},{"heading":"Activity란?","level":4,"id":"Activity란?_0"},{"heading":"Context란?","level":4,"id":"Context란?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html","pathToRoot":"../..","attachments":[],"createdTime":1739278009360,"modifiedTime":1739278009360,"sourceSize":11800,"sourcePath":"CPP/Platform/C++ 프로젝트에서 JNI를 이용해서 Android 호출.md","exportPath":"cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html","showInTree":true,"treeOrder":78,"backlinks":[],"type":"markdown"},"cpp/platform/sfml과-visitor-pattern.html":{"title":"SFML과 Visitor Pattern","icon":"","description":"기존의 SFML에서는 멤버 변수 sf::Event::EventType을 확인해서 각 이벤트를 처리 했었다. 내가 사용하는 3.0 버전에서는 이벤트를 visitor를 이용해서 처리 한다. Visitor 패턴은 객체 구조와 처리를 분리하는 디자인 패턴. 즉 '다른 클래스에 있는 알고리즘을 가져와서 실행할 수 있게 해주는 패턴'임 // 기존 방식 (이제 지원하지 않음)\nif (event.type == sf::Event::Closed) { window.close();\n} // Visitor 패턴 사용 (새로운 방식)\nevent.visit([&amp;window](const sf::Event::Closed&amp;) { window.close();\n}); 컴파일 타임 검사: 잘못된 이벤트 타임에 접근하는 것을 방지하고 타입 불일치 오류를 컴파일 단계에서 발견할 수 있다. 기존의 방식을 사용하면 아래처럼 런타임에서 에러를 잡을 수 있다.\n// 기존\nif (event.type == sf::Event::MouseMoved) { // 실수로 KeyPressed의 데이터를 사용하려고 하면... bool isShiftPressed = event.key.shift; // 잘못된 메모리 접근\n} // visitor\nevent.visit([](const sf::Event::MouseMoved&amp; mouse) { // mouse.position만 사용할 수 있음 // 다른 이벤트의 멤버는 접근 불가능\n}); 코드 가독성: 중첩 if문, switch문 없음. 각 이벤트 타입별 처리가 원활\n유지보수 좋음: 기존 코드 수정하지 않고 새로운 핸들러 추가가 쉬움\nsf:Event 클래스를 확인하면 클래스 내에 struct으로 각 이벤트가 정의 되어 있다. 그리고 내부 변수에 private로 m_data를 가지고 있다.\n이 m_data의 타입은 std::variant&lt;Closed, Resized, FocusLost, /*...*/ &gt; 이다.std::variant는 여러 타입 중 하나를 저장할 수 있는 type-safe union이다. 그렇다면 어떻게 SFML에서 m_data와 visit을 통해서 이벤트를 처리할까?이를 이해하기 위해 먼저 std::variant와 std::visit의 관계와 사용법에 대해 알아야만 한다.// 기본구조 // Variant: 여러 타입 중 하나를 저장할 수 있는 컨테이너\nstd::variant&lt;A, B, C&gt; data;\n// Visitor: variant에 저장된 데이터를 처리하는 방법\nauto visitor = [](const auto&amp; value) { /* 처리 로직 */ }; // 동작 방식\n// 1. variant가 데이터 저장\nstd::variant&lt;int, std::string&gt; data = 42;\n// 2. visitor가 데이터 처리\nstd::visit([](const auto&amp; value) { using T = std::decay_t&lt;decltype(value)&gt;; if constexpr (std::is_same_v&lt;T, int&gt;) { std::cout &lt;&lt; \"정수 처리: \" &lt;&lt; value &lt;&lt; std::endl; } else if constexpr (std::is_same_v&lt;T, std::string&gt;) { std::cout &lt;&lt; \"문자열 처리: \" &lt;&lt; value &lt;&lt; std::endl; }\n}, data);\nusing T = std::decay_t&lt;decltype(value)&gt; 에서 decltype(value)는 value의 정확한 타입을 추론하고 std::decay_t는 참조와 const를 제거한 순수한 타입을 얻는다. 위 코드에서 const int&amp;는 int로 변환된다.이렇게 얻은 타입 T로 컴파일 타임에 타입 체크를 수행한다.if constexpr (std::is_same_v&lt;T, int&gt;) { // int 타입일 때의 처리\n}\nelse if constexpr (std::is_same_v&lt;T, std::string&gt;) { // string 타입일 때의 처리\n}\n위의 예시와 같이std::variant 과 std::visit를 이용하면 컴파일 타임에서 안전하게 타입을 추론할 수 있고 각 타입마다 처리를 하기 용이 해진다는 장점을 알 수 있다.Window::pollEvnet() 를 호출하면 m_data가 변경된다.//SFML Event 내부 구현\ntemplate &lt;typename TEventSubtype&gt; Event::Event(const TEventSubtype&amp; eventSubtype)\n{ static_assert(isEventSubtype&lt;TEventSubtype&gt;, \"TEventSubtype must be a subtype of sf::Event\"); if constexpr (isEventSubtype&lt;TEventSubtype&gt;) m_data = eventSubtype;\n}\n// SFML Event 내부 구현\nclass Event {\npublic: // visitor 패턴을 이용한 이벤트 처리 template &lt;typename T&gt; auto visit(T&amp;&amp; visitor) const { // visitor는 람다함수 or 함수 객체 return std::visit(std::forward&lt;T&gt;(visitor), m_data); }\n};\n여기에서 Visitor 패턴의 핵심 동작이 일어난다. Event::visit 함수는 std::visit의 단순 래퍼다.\nstd::forward&lt;T&gt;를 통해 visitor (람다나 함수 객체) 를 perfect 전달한다. 따라서 m_data와 visitor를 통해서 각 이벤트에 대해서 처리를 할 수 있게 된다.void Simulator::handleEvents() {\nif (auto event = window.pollEvent()) { event-&gt;visit([this](const auto&amp; e) { using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }); }\n}\n이 코드가 실행될 때 내부적으로 아래와 같은 과정이 일어난다.\n람다 함수가 Event::visit에 전달\nEvent::visit은 람다 함수를 std::visit으로 전달\nstd::visit은 m_data에 저장된 실제 타입을 확인하고 람다를 호출 한다.\n이걸 좀 풀어서 설명하면 아래처럼 코드가 실행되는 것이다.std::visit( [this](const auto&amp; e) { // 여기서 e는 variant에 저장된 실제 타입의 참조 using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }, m_data // variant 객체 전달\n);\nstruct EventVisitor { Simulator&amp; simulator; // 참조를 저장 // 특정 이벤트용 처리기 void operator()(const sf::Event::Closed&amp; event) { simulator.window.close(); } void operator()(const sf::Event::KeyPressed&amp; event) { ... } // 다른 모든 이벤트를 처리하는 템플릿 template&lt;typename T&gt; void operator()(const T&amp; event) {}\n};\nvoid Simulator::handleEvents() { if (auto event = window.pollEvent()) { event-&gt;visit(EventVisitor{*this}); }\n} 객체를 만들고 operator()를 구현하면 객체를 함수처럼 사용할 수 있다.EventVisitor visitor; visitor(something);\n내부적으로는 위의 람다 함수의 경우와 사실 거의 같다. 람다 함수 대신에 함수 객체를 넘겨주는 것이 차이점이다. 그리고 기본적으로 std::visit은 variant에 저장된 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다\nevent-&gt;visit(EventVisitor{*this}); 호출 한다.\nEvent::visit은 std::visit에 함수 객체와, m_data를 전달한다.\nstd::visit은 m_data(variant)를 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Visitor 패턴이란?","level":3,"id":"Visitor_패턴이란?_0"},{"heading":"Visitor 패턴의 장점","level":3,"id":"Visitor_패턴의_장점_0"},{"heading":"SFML은 어떠한 방식으로 Visitor 패턴을 사용했을까?","level":3,"id":"SFML은_어떠한_방식으로_Visitor_패턴을_사용했을까?_0"},{"heading":"std::variant와 std::visit","level":4,"id":"stdvariant와_stdvisit_0"},{"heading":"SFML에서의 visit - Event::visit()","level":4,"id":"SFML에서의_visit_-_Eventvisit()_0"},{"heading":"이벤트 처리하는 방법 - 람다 함수","level":4,"id":"이벤트_처리하는_방법_-_람다_함수_0"},{"heading":"이벤트 처리하는 방법 - 함수 객체","level":4,"id":"이벤트_처리하는_방법_-_함수_객체_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/platform/sfml과-visitor-pattern.html","pathToRoot":"../..","attachments":[],"createdTime":1735918424772,"modifiedTime":1735918424773,"sourceSize":7230,"sourcePath":"CPP/Platform/SFML과 Visitor Pattern.md","exportPath":"cpp/platform/sfml과-visitor-pattern.html","showInTree":true,"treeOrder":79,"backlinks":[],"type":"markdown"},"cpp/template/1.-명시적-템플릿-인스터스화.html":{"title":"1. 명시적 템플릿 인스터스화","icon":"","description":"템플릿은 lazy instantiation 방식을 사용한다. 즉 실제로 사용되는 시점에 컴파일러가 해당 타입에 대한 코드를 생성함.// header.hpp\ntemplate&lt;typename T&gt;\nclass Container {\npublic: void add(T value); T get() const;\nprivate: T data_;\n}; // source.cpp\ntemplate&lt;typename T&gt;\nvoid Container&lt;T&gt;::add(T value) { data_ = value;\n} template&lt;typename T&gt;\nT Container&lt;T&gt;::get() const { return data_;\n}\n일반적인 템플릿 사용시에는 다음과 같은 과정이 발생함 각각의 소스 파일에서 템플릿이 사용될 때마다 컴파일러는 해당 타입에 대한 코드를 생성함 이로 인해 여러 소스 파일에서 동일한 템플릿 인스턴스가 중복 생성될 수 있습니다. Q.여러소스 파일이라는게 이 파일마다 동일한 템플릿 인스턴스가 중복 생성될 수 있다는 뜻일까? 여러 소스 파일에서 동일한 템플릿 인스턴스가 중복 생성\"된다는 것은 정확히 각각의 cpp 파일마다 동일한 템플릿 코드가 생성된다는 의미\n컴파일 시점에서는 A.cpp와 B.cpp가 각각 독립적으로 컴파일되기 때문에, 각 파일에서 Container&lt;int&gt;에 대한 코드가 따로 생성됩니다. 즉, set()과 get() 함수의 코드가 두 번 생성되는 것 링커가 중복된 인스턴스들 중 하나를 선택하여 최종 실행 파일에 포함시킵니다. Q. \b만약 A.cpp에서 Container&lt;int&gt;, Container&lt;double&gt; 사용하고 B.cpp에서 Container&lt;int&gt;, Container&lt;double&gt; 을 똑같이 사용함. 그렇게 어떻게 될까? 링커가 중복된 인스턴스들 중 하나를 선택한다는건 하나의 cpp object 파일에서 그 인스턴스를 지운다는걸까? // A.obj 파일에 생성되는 것:\n- Container&lt;int&gt;::set()\n- Container&lt;int&gt;::get()\n- Container&lt;double&gt;::set()\n- Container&lt;double&gt;::get() // B.obj 파일에 생성되는 것:\n- Container&lt;int&gt;::set()\n- Container&lt;int&gt;::get()\n- Container&lt;double&gt;::set()\n- Container&lt;double&gt;::get()\n링킹 단계:\n- 링커는 COMDAT(COMmon DATA) 섹션이라는 특별한 메커니즘을 사용함\n- 각 템플릿 인스턴스는 COMDAT 섹션에 들어감.\n- 링커는 동일한 COMDAT 섹션을 발견하면, 그 중 하나만 최종 실행 파일에 포함시킴\n- 나머지는 자동으로 무시중요한 점은, 링커가 obj 파일에서 인스턴스를 지우는 것이 아닌 최종 실행 파일을 만들 때 중복된 코드 중 하나만 선택한다는 것입니다. obj 파일들은 그대로 유지됨.명시적 템플릿 인스턴스화가 제공하는 이점template class Container&lt;int&gt;; // 명시적 인스턴스화 컴파일 시간 단축 이렇게 선언하면 컴파일러는 해당 타입에 대한 모든 멤버 함수의 코드를 이 시점에 생성한다. 다른 translation unit에서는 이미 생성된 코드를 재사용할 수 있어 전체 컴파일 시간이 단축된다. 코드 크기 최적화 여러 translation unit에서 동일한 템플릿 코드가 중복 생성되는 것을 방지할 수 있다. 특히 크기가 큰 템플릿 클래스의 경우 실행 파일 크기를 상당히 줄일 수 있다. 컴파일 오류 조기 발견 // 컴파일 시점에 오류 발견 가능\ntemplate class Container&lt;incomplete_type&gt;; // 컴파일 오류 발생 헤더에서 명시적 인스턴스화하는 경우template class MyTemplate&lt;int&gt;; // 여기서 코드 생성 장점: 간단하고 직관적\n단점: 헤더 변경시 이를 포함하는 모든 파일 재컴파일 필요\nextern + cpp에서 명시적 인스턴스화// mytemplate.hpp\nextern template class MyTemplate&lt;int&gt;; // extern -&gt; 구현 안찾음\n// mytemplate.cpp\ntemplate class MyTemplate&lt;int&gt;; // 컴파일러는 이곳에서 찾음 장점: 구현 변경시 cpp 파일만 재컴파일\n단점: 파일을 분리해야 하는 약간의 수고가 필요\n즉 extern은 기능적인 차이를 만들지는 않지만, 컴파일 성능 최적화를 위한 도구다.결론: 명시적 템플릿 인스턴스화를 사용하려면 헤더에 구현까지 하던가, 구현을 분리하려면 extern 키워드를 써라.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"\b템플릿 기본 동작","level":3,"id":"\b템플릿_기본_동작_0"},{"heading":"명시적 템플릿 인스턴스화 Explict Template Instantiation","level":2,"id":"명시적_템플릿_인스턴스화_Explict_Template_Instantiation_0"},{"heading":"extern keyword","level":4,"id":"extern_keyword_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/template/1.-명시적-템플릿-인스터스화.html","pathToRoot":"../..","attachments":[],"createdTime":1752046023827,"modifiedTime":1752046023827,"sourceSize":4419,"sourcePath":"CPP/Template/1. 명시적 템플릿 인스터스화.md","exportPath":"cpp/template/1.-명시적-템플릿-인스터스화.html","showInTree":true,"treeOrder":81,"backlinks":[],"type":"markdown"},"cpp/quiz.html":{"title":"Quiz","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cpp/quiz.html","pathToRoot":"..","attachments":[],"createdTime":1754545491055,"modifiedTime":1754545491055,"sourceSize":0,"sourcePath":"CPP/Quiz.md","exportPath":"cpp/quiz.html","showInTree":true,"treeOrder":82,"backlinks":[],"type":"markdown"},"cs/자료구조/avl-트리.html":{"title":"AVL 트리","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/avl-트리.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":0,"sourcePath":"CS/자료구조/AVL 트리.md","exportPath":"cs/자료구조/avl-트리.html","showInTree":true,"treeOrder":85,"backlinks":[],"type":"markdown"},"cs/자료구조/b+-tree.html":{"title":"B+ Tree","icon":"","description":"이진 탐색트리를 일반화한 트리\b노드 내의 key들은 오름차순으로 저장모든 leaf 노드들은 같은 레벨에 있다 -&gt; 균형 트리M: 각 노드의 최대 자녀 수M에 따라서 M차 트리각 노드의 최대 key 수 : M - 1각 노드의 최소 자녀 노드 수 : ceil(M/2) root node, leaf 노드 제외각 노드의 최소 key 수 : ceil(m/2) - 1 root node 제외삭제\n항상 leaf 노드에서 발생\n삭제 후 최소 key 수보다 적어졌다면 재조정한다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/b+-tree.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":524,"sourcePath":"CS/자료구조/B+ Tree.md","exportPath":"cs/자료구조/b+-tree.html","showInTree":true,"treeOrder":86,"backlinks":[],"type":"markdown"},"cs/자료구조/binary-search-tree.html":{"title":"Binary Search Tree","icon":"","description":"Binary Search Tree는 모든 노드 x에 대해서 왼쪽에 있는 모든 노드의 값 &lt;= x, 오른쪽에 있는 모든 노드의 값 &gt; x를 만족하는 이진트리다.이 정의에 의해서\n중위 순회시 정렬된 순서로 값을 얻을 수 있고\n이진 탐색이 가능하고\n동적 데이터에 대해서 정렬 상태를 유지할 수 있다.\nBST의 시간 복잡도는 균형 잡힌 트리에서는 탐색, 삽입, 삭제 모두 O (log n)이다. 다만 편향된 트리에서는 연결 리스트와 똑같이 탐색 O (n), 삽입 O(n) 삭제 O(n)이다. 삽입과 삭제가 O(n)인 이유는 탐색을 해야하기 때문이다. 위치를 알면 O(1)이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/binary-search-tree.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":687,"sourcePath":"CS/자료구조/Binary Search Tree.md","exportPath":"cs/자료구조/binary-search-tree.html","showInTree":true,"treeOrder":87,"backlinks":[],"type":"markdown"},"cs/자료구조/deque.html":{"title":"Deque","icon":"","description":"유튜브 보기","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/deque.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":16,"sourcePath":"CS/자료구조/Deque.md","exportPath":"cs/자료구조/deque.html","showInTree":true,"treeOrder":88,"backlinks":[],"type":"markdown"},"cs/자료구조/hash-table.html":{"title":"Hash Table","icon":"","description":"해시 테이블은 key - value를 저장하는 자료구조로 해시 함수를 이용해서 키를 인덱스로 변환한다.\n실제 value는 배열에 저장된다. 이를 통해 평균적으로 O(1) 시간에 삽입, 삭제, 검색을 수행할 수 있다.해시 테이블의 핵심 구성요소는 해시 함수와 버킷이라고 할 수 있다.\n해시 함수: 키를 배열 인덱스로 변환\n버킷 (Bucket): 실제 데이터가 저장되는 배열의 아이템\n좋은 해시 함수는 아래 조건을 충족 해야 한다.\n결정적: 같은 입력에 대해서는 같은 출력을 보장해야함\n효율성: 빠른 계산 속도\nSTL에서 해시 함수는 타입마다 구현을 달리 한다. int, long long 같은 타입들은 이미 그 자체로 hash이기 때문에 더 이상 계산을 안한다. 그래서 항등함수를 사용한다.double이나 long double 같은 타입들은 거의 그 값에 맞게 해싱하지만 정확히 항등함수는 아니다. 실제로 clang에서 llbcxx 구현체를 보면 hash 함수를 확인할 수 있다.// libcxx/include/__functional/hash.h template &lt;class _Tp&gt;\nstruct __hash_impl&lt;_Tp, __enable_if_t&lt;is_integral&lt;_Tp&gt;::value &amp;&amp; (sizeof(_Tp) &lt;= sizeof(size_t))&gt;&gt; : __unary_function&lt;_Tp, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { return static_cast&lt;size_t&gt;(__v); }\n}; template &lt;class _Tp&gt;\nstruct __hash_impl&lt;_Tp, __enable_if_t&lt;is_integral&lt;_Tp&gt;::value &amp;&amp; (sizeof(_Tp) &gt; sizeof(size_t))&gt;&gt; : __scalar_hash&lt;_Tp&gt; {};\n조건 1. __enable_if_t&lt;is_integral&lt;_Tp&gt;::value - 정수 타입인지 확인하는 type trait다.\n조건 2. sizeof(_Tp) &lt;= sizeof(size_t) - 64비트 시스템에서 size_t는 8바이트라서 8바이트 이하여야 함.Tip. 두번째 특화에서 정수형 타입이면서 8바이트를 넘는 자료형이 있을까 싶었는데 있다고 한다.// GCC / Clang에서 지원하는 확장\n__int128 big_int; // 16 byte // libcxx/include/__functional/hash.h\ntemplate &lt;class _Tp&gt;\nstruct __hash_impl&lt;_Tp, __enable_if_t&lt;is_floating_point&lt;_Tp&gt;::value&gt; &gt; : __scalar_hash&lt;_Tp&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { // -0.0 and 0.0 should return same hash if (__v == 0.0f) return 0; return __scalar_hash&lt;_Tp&gt;::operator()(__v); }\n}; // __scalar_hash 구현\ntemplate &lt;class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)&gt;\nstruct __scalar_hash; template &lt;class _Tp&gt;\nstruct __scalar_hash&lt;_Tp, 0&gt; : public __unary_function&lt;_Tp, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { union { _Tp __t; size_t __a; } __u; __u.__a = 0; __u.__t = __v; return __u.__a; }\n}; template &lt;class _Tp&gt;\nstruct __scalar_hash&lt;_Tp, 1&gt; : public __unary_function&lt;_Tp, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { union { _Tp __t; size_t __a; } __u; __u.__t = __v; return __u.__a; }\n}; template &lt;class _Tp&gt;\nstruct __scalar_hash&lt;_Tp, 2&gt; : public __unary_function&lt;_Tp, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { union { _Tp __t; struct { size_t __a; size_t __b; } __s; } __u; __u.__t = __v; return std::__hash_memory(std::addressof(__u), sizeof(__u)); }\n}; template &lt;class _Tp&gt;\nstruct __scalar_hash&lt;_Tp, 3&gt; : public __unary_function&lt;_Tp, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { union { _Tp __t; struct { size_t __a; size_t __b; size_t __c; } __s; } __u; __u.__t = __v; return std::__hash_memory(std::addressof(__u), sizeof(__u)); }\n}; template &lt;class _Tp&gt;\nstruct __scalar_hash&lt;_Tp, 4&gt; : public __unary_function&lt;_Tp, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp __v) const _NOEXCEPT { union { _Tp __t; struct { size_t __a; size_t __b; size_t __c; size_t __d; } __s; } __u; __u.__t = __v; return std::__hash_memory(std::addressof(__u), sizeof(__u)); }\n}; 부동소수점인 경우에는 __scalar_hash&lt;_Tp&gt;::operator()(__v);를 리턴한다.__scalar_hash 의 구현을 살펴보면 struct __scalar_hash&lt;_Tp, 1&gt; 이런식으로 꺽쇠 안에 숫자가 붙어 있다. 맨 위 정의에 _Tp / sizeof(size_t) 를 의미하는데 64bit 시스템에서는 size_t가 8바이트이므로 1인 경우는 double 같은 타입이다특징으로는 union을 이용해서 메모리 레이아웃을 이용해 비트 캐스팅을 이용한다.예를 들어 double = 3.14159; 면 메모리 레이아웃은\n01000000 00001001 00100001 11111001 11110000 00011011 10000110 01101110이걸 size_t로 재해석하면 -&gt; 4614256650576692846가 나온다.// Test\nint main() { std::hash&lt;double&gt; double_hasher; cout &lt;&lt; \"double hash 3.14159::\" &lt;&lt; double_hasher(3.14159) &lt;&lt; endl; return 0;\n}\n// double hash 3.14159 ::4614256650576692846\n계속해서 2,3,4인 경우는 std::__hash_memory 를 리턴하는데 hash_memory 함수는 이렇게 처리되어 있다.#if _LIBCPP_AVAILABILITY_HAS_HASH_MEMORY\n[[__gnu__::__pure__]] _LIBCPP_EXPORTED_FROM_ABI size_t __hash_memory(_LIBCPP_NOESCAPE const void*, size_t) _NOEXCEPT;\n#else\n_LIBCPP_HIDE_FROM_ABI inline size_t __hash_memory(const void* __ptr, size_t __size) _NOEXCEPT { return __murmur2_or_cityhash&lt;size_t&gt;()(__ptr, __size);\n}\n#endif\nhash_memory 함수는 주소값과, 사이즈를 파라미터로 받는다.만약 hash_memory가 라이브러리에 있다면 최적화된 플랫폼 전용 해시 함수를 사용하라는 뜻이고\n없다면 __murmur2_or_cityhash&lt;size_t&gt;를 사용하라는 뜻이다.murmurhash2는 해시 함수로, 32bit에서 주로 사용되는 함수다.\ncityhash는 해시함수로, Google에서 개발했고 64bit에 최적화 되어있다.이 두 함수중 하나를 거쳐서 size_t를 리턴하게 된다.\b\n포인터 타입도 부동소수점의 사이즈가 16 바이트를 넘어갈 때의 처리랑 유사하다. hash_memory 함수를 이용한다.template &lt;class _Tp&gt;\nstruct hash&lt;_Tp*&gt; : public __unary_function&lt;_Tp*, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(_Tp* __v) const _NOEXCEPT { union { _Tp* __t; size_t __a; } __u; __u.__t = __v; return std::__hash_memory(std::addressof(__u), sizeof(__u)); }\n}; 문자열 타입은 모두 hash.h에 구현된 것과 다르게 각 타입에 구현되어 있다.\n__do_string_hash 함수를 보면 결국 std::__hash_memory를 사용한다.위에서 쓴 것과 같이 std::__hash_memory 플랫폼 함수가 있다면 사용하고, 없다면 murmurhash2 or cityhash를 사용한다.\n// libcxx/include/ext/__hash template &lt;&gt;\nstruct hash&lt;const char*&gt; : public std::__unary_function&lt;const char*, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(const char* __c) const _NOEXCEPT { return std::__do_string_hash(__c, __c + strlen(__c)); }\n}; template &lt;&gt;\nstruct hash&lt;char*&gt; : public std::__unary_function&lt;char*, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(char* __c) const _NOEXCEPT { return std::__do_string_hash&lt;const char*&gt;(__c, __c + strlen(__c)); }\n}; // libcxx/include/__string/char_traits.h\ntemplate &lt;class _Ptr&gt;\ninline _LIBCPP_HIDE_FROM_ABI size_t __do_string_hash(_Ptr __p, _Ptr __e) { typedef typename iterator_traits&lt;_Ptr&gt;::value_type value_type; return std::__hash_memory(__p, (__e - __p) * sizeof(value_type));\n} // libcxx/include/string.h\ntemplate &lt;class _CharT, class _Allocator&gt;\nstruct __string_hash : public __unary_function&lt;basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, _Allocator&gt;, size_t&gt; { _LIBCPP_HIDE_FROM_ABI size_t operator()(const basic_string&lt;_CharT, char_traits&lt;_CharT&gt;, _Allocator&gt;&amp; __val) const _NOEXCEPT { return std::__do_string_hash(__val.data(), __val.data() + __val.size()); }\n};\n위에서와 같이 해시함수를 통과했을 때 이는 그냥 size_t이므로 무조건 유효한 인덱스가 아닐 것이다. 이를 실제 hash table 구현체에서 buckets.size()으로 나머지 연산을 하면 버킷에 맞게 들어간다. // 단순한 예\nclass hash_table {\nprivate: size_t bucket_count_; size_t compress(size_t hash_value) const { // 단순 모듈러 연산 return hash_value % bucket_count_; }\npublic: template&lt;typename Key&gt; size_t get_bucket(const Key&amp; key) const { size_t hash_val = std::hash&lt;Key&gt;{}(key); return compress(hash_val); } 해싱을 했을 때 다른 입력값이지만 같은 출력이 나오는 경우를 생각할 수 있다. 이런 경우를 해시 충돌이라고 한다. 해시 충돌을 해결하는 방법이 여러가지가 있는데 대표적인 방식은 체이닝 방식과, 오픈 어드레싱 방법이 있다. C++ STL에서는 체이닝 방식을 사용한다.체이닝 방식은 각 버킷이 연결 리스트의 헤드 포인터(시작점)를 가지고 있는 것이다. 즉 체이닝은 같은 인덱스로 가는 데이터들을 연결리스트로 묶어서 관리하는 방법을 의미한다.struct Node { string key; int value; Node* next; // 다음 노드를 가리키는 포인터\n}; // buckets\nNode* table[4]; // 포인터 배열 // 초기 상태\ntable[0] = nullptr;\ntable[1] = nullptr;\ntable[2] = nullptr;\ntable[3] = nullptr;\n정리하자면 배열의 각 칸에는 포인터가 들어가고 이 포인터는 연결리스트의 첫번째 노드를 가르킨다.\n충돌 시 같은 연결리스트에 새 노드로 추가하고, 검색 시에 해당 연결리스트를 순서대로 확인한다.오픈 어드레싱은 비어 있는 슬롯을 찾아 데이터를 저장하는 방식이다. 비어 있는 슬롯을 찾는 행위를 프로빙(프로빙)이라고 한다. 프로빙은 선형 프로빙, 쿼드러틱 프로빙 (Quardratic), 더블 해싱이 있다.선형 프로빙은 index를 1씩 증가 시켜서 비어 있는 슬롯을 찾는 것이다.쿼드러틱 프로빙은 i^2 씩 증가 시켜서 비어 있는 슬롯을 찾는다. (1, 4, 9 ...)더블 해싱은 다른 해쉬 함수를 사용해서 해싱을 한번 더 하는 것이다. hash2라고 한다면 hash(x) + 1 hash2) -&gt; hash(x) + 2 hash2 ... 이런식으로 프로빙을 하게 된다.hash table에 계속 데이터를 집어 넣어서 buckets이 모두 찬다면 buckets 사이즈를 늘려줘야 한다.buckets 사이즈를 늘리면 기존의 buckets 있는 모든 요소들을 다시 해싱 해야한다. 이 과정은 평균적으로 O(n) 시간이 소요된다.그러면 C++ STL에서 해시 테이블을 구현할 때 buckets이 꽉 차면 사이즈를 확장하고 재해싱을 할까? hash table에서 로드 팩터 (load factor)라는 변수를 두고 재해싱이 일어날지 말지를 결정한다. 로드 팩터 = 저장된 원소 수 / 배열 크기\n로드 팩터의 임계값은 보통 0.75로 알려져있지만, C++ STL에서는 1.0이다.int main() { std::unordered_map&lt;int, int&gt; map; std::cout &lt;&lt; \"기본 max_load_factor: \" &lt;&lt; map.max_load_factor() &lt;&lt; std::endl; return 0;\n}\n// 기본 max_load_factor: 1 C++ STL은 해시 충돌 해결을 체이닝을 사용하기 때문에 로드 팩터가 1.0을 넘어도 동작이 가능하다. 그리고 평균적으로 버킷의 연결리스트가 많이 길지 않기 때문에 1.0으로 설정되어 있다.해시 테이블은 빠른 검색을 특징으로 여러 분야에서 사용된다.\n캐싱시스템 (LRU Cache)\n컴파일러의 심볼 테이블\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"해시 함수","level":3,"id":"해시_함수_0"},{"heading":"정수형 타입","level":4,"id":"정수형_타입_0"},{"heading":"부동소수점 타입","level":4,"id":"부동소수점_타입_0"},{"heading":"포인터 타입","level":4,"id":"포인터_타입_0"},{"heading":"문자열 타입","level":4,"id":"문자열_타입_0"},{"heading":"해시 충돌","level":3,"id":"해시_충돌_0"},{"heading":"체이닝 방식","level":4,"id":"체이닝_방식_0"},{"heading":"오픈 어드레싱 (Open Addressing)","level":4,"id":"오픈_어드레싱_(Open_Addressing)_0"},{"heading":"재해싱과 로드 팩터","level":3,"id":"재해싱과_로드_팩터_0"},{"heading":"마무리","level":3,"id":"마무리_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/hash-table.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491064,"modifiedTime":1754545491065,"sourceSize":11941,"sourcePath":"CS/자료구조/Hash Table.md","exportPath":"cs/자료구조/hash-table.html","showInTree":true,"treeOrder":89,"backlinks":[],"type":"markdown"},"cs/자료구조/red-black-tree.html":{"title":"Red Black Tree","icon":"","description":"유튜브 보기","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/red-black-tree.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":17,"sourcePath":"CS/자료구조/Red Black Tree.md","exportPath":"cs/자료구조/red-black-tree.html","showInTree":true,"treeOrder":90,"backlinks":[],"type":"markdown"},"cs/자료구조/tree.html":{"title":"Tree","icon":"","description":"트리는 계층적 구조를 가진 비선형 자료구조다. 그래프의 특수한 형태로 사이클이 없는 무방향 그래프라고 정의할 수 있다.균형잡힌 성능을 보장함\n순서가 중요한 데이터 관리\n범위 검색이 빈번한 경우 (효율적인 탐색)\n예측 가능한 성능\n계층적 관계\n메모리 사용량 (필요할 때 붙이니까)\n계층적 데이터 표현\n파일시스템\nXML / HTML DOM\n검색과 정렬\n이진 검색 트리(BST): O(log n) 검색, 삽입, 삭제\nAVL 트리, Red-Black 트리: 균형 잡힌 BST, 최악의 경우에도 O(log n) 보장\nB-트리: 데이터베이스 인덱싱에서 사용\n우선순위 관리\n우선순위 큐\n최소/최대 힙\n문자열 처리\n트라이(Trie): 문자열 검색, 자동완성 기능\n접미사 트리: 패턴 매칭, 문자열 분석\nAI\n결정 트리: 머신러닝에서 분류 문제 set, multiset\nmap, multimap\npriority_queue\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Tree를 선택하는 보통의 이유","level":3,"id":"Tree를_선택하는_보통의_이유_0"},{"heading":"Tree의 주요 사용 사례","level":3,"id":"Tree의_주요_사용_사례_0"},{"heading":"STL에서의 Tree가 이용되는 곳","level":3,"id":"STL에서의_Tree가_이용되는_곳_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/자료구조/tree.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":1099,"sourcePath":"CS/자료구조/Tree.md","exportPath":"cs/자료구조/tree.html","showInTree":true,"treeOrder":91,"backlinks":[],"type":"markdown"},"cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html":{"title":"01. 배열과 연결리스트의 차이점과 각각의 시간복잡도","icon":"","description":"배열과 연결리스트는 둘 다 선형 자료구조지만, 메모리 저장 방식에 근본적인 차이가 있습니다.배열은 연속된 메모리 공간에 동일한 타입의 데이터를 순서대로 저장하는 구조이고 연결리스트는 노드들이 포인터로 연결되어 있어 메모리 상에서 불연속적으로 저장되는 구조입니다.// 배열의 메모리 구조\nint arr[5] = {10, 20, 30, 40, 50};\n// 메모리: [10][20][30][40][50] (연속된 주소: 1000, 1004, 1008, 1012, 1016) // 연결리스트의 메모리 구조 struct Node { int data; Node* next;\n};\n// 메모리: 노드들이 힙의 임의 위치에 산재, 포인터로 연결\n배열은 첫 번째 원소의 주소만 알면 인덱스를 통해 모든 원소에 직접 접근 가능하지만, 연결리스트는 헤드 노드부터 순차적으로 탐색해야 합니다.*는 연결리스트는 삽입/삭제할 위치의 노드를 이미 알고 있을 때 배열은 연속된 메모리에 저장되어 있어서, 한 원소에 접근할 때 주변 원소들도 함께 캐시로 로드됩니다. 따라서 순차 접근 시 캐시 히트율이 높아 성능이 우수합니다. 반면 연결리스트는 노드들이 메모리에 산재해 있어서, 다음 노드에 접근할 때마다 캐시 미스가 발생할 가능성이 높습니다.메모리 할당에서도 차이가 있습니다.\n배열은 실제 데이터만 저장하기 때문에 메모리 효율적이고\n연결리스트는 데이터와 포인터를 저장하기 때문에 추가 메모리 오버헤드가 있습니다.\n또한 연결리스트는 노드를 개별적으로 할당/해제하므로 메모리에 작은 빈 공간들이 산발적으로 생깁니다. 이는 외부 단편화를 야기해 메모리 효율성을 떨어뜨립니다. 배열은 큰 블록을 한 번에 할당하므로 이런 문제가 없습니다.배열 기반: std::vector, std::array\n연결리스트 기반: std::list","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 배열과 연결리스트의 차이점과 각각의 시간복잡도","level":1,"id":"1._배열과_연결리스트의_차이점과_각각의_시간복잡도_0"},{"heading":"시간 복잡도","level":3,"id":"시간_복잡도_0"},{"heading":"순차적 접근과 캐시 효율성","level":3,"id":"순차적_접근과_캐시_효율성_0"},{"heading":"메모리 할당 방식에서의 차이점 (메모리 외부 단편화)","level":3,"id":"메모리_할당_방식에서의_차이점_(메모리_외부_단편화)_0"},{"heading":"STL에서","level":3,"id":"STL에서_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html","pathToRoot":"..","attachments":[],"createdTime":1754545491056,"modifiedTime":1754545491056,"sourceSize":2694,"sourcePath":"CS/01. 배열과 연결리스트의 차이점과 각각의 시간복잡도.md","exportPath":"cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html","showInTree":true,"treeOrder":92,"backlinks":[],"type":"markdown"},"cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html":{"title":"05. 정렬 알고리즘들의 시간복잡도와 특징 (정리중","icon":"","description":"정렬 알고리즘은 크게 O(n²) 그룹과 O(n log n) 그룹으로 나뉩니다.버블 정렬은 인접한 요소를 비교해서 교환하는 방식으로, 구현이 가장 단순하지만 O(n²)로 느립니다. 다만 이미 정렬된 경우를 감지하면 O(n)에 끝낼 수 있고, 안정 정렬입니다.선택 정렬은 최솟값을 찾아서 앞으로 보내는 방식입니다. 항상 O(n²)이고 불안정 정렬이지만, 교환 횟수가 최소라는 특징이 있습니다.삽입 정렬은 카드를 정리하듯이 적절한 위치에 삽입하는 방식입니다. 거의 정렬된 데이터에서는 O(n)에 가까운 성능을 보여서, 작은 데이터나 부분적으로 정렬된 데이터에 효율적입니다.퀵 정렬은 피벗을 기준으로 분할 정복하는 방식입니다. 평균 O(n log n)으로 매우 빠르고 캐시 효율이 좋지만, 최악의 경우 O(n²)가 될 수 있습니다. 피벗 선택이 중요하죠.병합 정렬은 항상 O(n log n)을 보장하고 안정 정렬이지만, O(n)의 추가 메모리가 필요합니다. 외부 정렬이나 링크드리스트 정렬에 적합합니다.힙 정렬도 항상 O(n log n)이고 제자리 정렬이지만, 캐시 효율이 나빠서 실제로는 퀵 정렬보다 느린 경우가 많습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5. 정렬 알고리즘들의 시간복잡도와 특징 (정리중","level":1,"id":"5._정렬_알고리즘들의_시간복잡도와_특징_(정리중_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html","pathToRoot":"..","attachments":[],"createdTime":1754545491057,"modifiedTime":1754545491057,"sourceSize":1309,"sourcePath":"CS/05. 정렬 알고리즘들의 시간복잡도와 특징 (정리중.md","exportPath":"cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html","showInTree":true,"treeOrder":93,"backlinks":[],"type":"markdown"},"cs/07.-캐시-지역성.html":{"title":"07. 캐시 지역성","icon":"","description":"\n시간적 지역성 최근에 참조된 메모리 주소가 가까운 미래에 다시 참조될 가능성이 높다.\n예: 반복문의 카운터 변수, 자주 호출되는 함수 공간적 지역성 참조된 메모리 주소 근처의 주소들이 가까운 미래에 참조될 가능성이 높다.\n예: 배열의 순차적 접근, 구조체의 멤버 변수들 CPU Register (1 cycle) ↓\nL1 Cache (1-3 cycles) ↓\nL2 Cache (10-20 cycles) ↓\nL3 Cache (20-40 cycles) ↓\nMain Memory (100-300 cycles) ↓\nStorage (10,000+ cycles)\n캐시는 캐시 라인(Cache Line) 단위로 작동합니다. 일반적으로 64바이트 크기이며, 하나의 메모리 주소를 요청하면 해당 캐시 라인 전체가 로드됩니다. 캐시 라인은 해당 주소를 포함하는 정렬된 64바이트 블록이다.캐시 라인은 주소 정렬을 기반으로 작동함. 하위 6비트를 0으로 만들고 그 주소부터 64 byte예시// 64바이트 캐시 라인의 경우\n// 주소의 하위 6비트(64 = 2^6)를 0으로 만든 주소부터 시작 주소 0x1234 (0001 0010 0011 0100)를 요청하면:\n하위 6비트를 0으로: 0x1200 (0001 0010 0000 0000)\n캐시 라인 범위: 0x1200 ~ 0x123F (64바이트) 주소 0x1278을 요청하면:\n하위 6비트를 0으로: 0x1240\n캐시 라인 범위: 0x1240 ~ 0x127F (64바이트)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"7. 캐시 지역성","level":1,"id":"7._캐시_지역성_0"},{"heading":"종류","level":3,"id":"종류_0"},{"heading":"메모리 계층 구조와 캐시","level":3,"id":"메모리_계층_구조와_캐시_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/07.-캐시-지역성.html","pathToRoot":"..","attachments":[],"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":1441,"sourcePath":"CS/07. 캐시 지역성.md","exportPath":"cs/07.-캐시-지역성.html","showInTree":true,"treeOrder":94,"backlinks":[],"type":"markdown"},"cs/08.-메모리-단편화.html":{"title":"08. 메모리 단편화","icon":"","description":"할당된 메모리 블록 내에서 실제 사용되지 않는 공간이 발생하는 현상// 메모리 낭비 예시\nstruct Player { bool isAlive; // 1바이트 float health; // 4바이트 (3바이트 패딩) bool hasWeapon; // 1바이트 (3바이트 패딩) int score; // 4바이트\n}; // 총 16바이트, 실제 데이터 10바이트 (37.5% 낭비) Player players[10000]; // 60KB 낭비! // 최적화된 버전\nstruct OptimizedPlayer { float health; // 4바이트 int score; // 4바이트 bool isAlive; // 1바이트 bool hasWeapon; // 1바이트 // 2바이트 패딩만 필요\n}; // 총 12바이트, 실제 데이터 10바이트 (16.7% 낭비)\n할당되지 않은 메모리 공간이 작은 조각들로 흩어져서, 큰 연속된 메모리 요청을 만족할 수 없는 현상// 메모리 상태 (각 블록은 연속된 공간)\n[사용중 20바이트][빈공간 10바이트][사용중 15바이트][빈공간 8바이트][사용중 25바이트] // 12바이트 할당 요청이 들어왔을 때:\n// - 총 빈 공간: 18바이트 (10 + 8)\n// - 하지만 연속된 12바이트 공간이 없음\n// - 10바이트 블록과 8바이트 블록은 분리되어 있음\n// - 따라서 12바이트 할당 실패! // 더 극단적인 예:\n[사용][빈2][사용][빈3][사용][빈4][사용][빈5][사용][빈2]\n// 총 빈 공간: 16바이트, 하지만 6바이트도 연속 할당 불가능\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"8. 메모리 단편화","level":1,"id":"8._메모리_단편화_0"},{"heading":"내부 단편화","level":2,"id":"내부_단편화_0"},{"heading":"외부 단편화","level":2,"id":"외부_단편화_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/08.-메모리-단편화.html","pathToRoot":"..","attachments":[],"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":1538,"sourcePath":"CS/08. 메모리 단편화.md","exportPath":"cs/08.-메모리-단편화.html","showInTree":true,"treeOrder":95,"backlinks":[],"type":"markdown"},"cs/09.-c++-메모리-구조.html":{"title":"09. C++ 메모리 구조","icon":"","description":"C++의 메모리는 크게 네 영역으로 나뉩니다.텍스트 영역에는 프로그램 코드가, 데이터 영역에는 전역 변수와 정적 변수가 저장됩니다. 스택에는 지역 변수와 함수 호출 정보가, 힙에는 동적으로 할당된 메모리가 저장됩니다.텍스트 영역은 실행 가능한 기계어 코드가 저장되는 읽기 전용 구역입니다. 이 영역에는 컴파일된 함수들과 명령어들로 이루어져 있습니다. 프로그램 실행 중에 변경되지 않고 읽기 전용입니다.데이터 영역은 초기화된 데이터 구역입니다. 초기값이 있는 전역 변수와 정적 변수가 저장됩니다. 프로그램 시작 시 초기값으로 설정됩니다.BSS 영역은 초기화 되지 않은 데이터 영역입니다. 초기값이 없는 전역 변수와 정적 변수가 저장되고 실제 메모리는 프로그램 로딩 시점에 할당됩니다.힙 영역은 동적 메모리 할당을 위한 영역입니다. 낮은 주소에서 높은 방향으로 성장하고 프로그래머가 메모리를 직접 할당 / 해제를 합니다. (new / delete , malloc / free)\n특징은 런타임에 크기가 결정되고 메모리 누수 위험성이 존재합니다. 할당 / 해제 속도가 스택보다 느립니다.스택 영역은 함수 호출과 지역 변수를 저장하는 구역입니다. 높은 주소에서 낮은 주소 방향으로 성장하고 컴파일러가 자동으로 관리합니다. LIFO 구조이고 함수 종료시 자동으로 메모리를 해제합니다. 힙 영역에 비해 빠른 할당 / 해제 속도를 가지고 있습니다.<img alt=\"cpp_memory_struct.png\" src=\"images/cpp_memory_struct.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"9. C++ 메모리 구조","level":1,"id":"9._C++_메모리_구조_0"}],"links":[],"author":"","coverImageURL":"images/cpp_memory_struct.png","fullURL":"cs/09.-c++-메모리-구조.html","pathToRoot":"..","attachments":["images/cpp_memory_struct.html"],"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":1684,"sourcePath":"CS/09. C++ 메모리 구조.md","exportPath":"cs/09.-c++-메모리-구조.html","showInTree":true,"treeOrder":96,"backlinks":[],"type":"markdown"},"cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html":{"title":"10. 스택과 힙 메모리 특징과 차이점, 사용시기","icon":"","description":"스택과 힙의 가장 큰 차이는 메모리 관리 방식과 생명주기입니다.스택은 LIFO 구조로 관리되고, 함수 호출 시 자동으로 할당되고 반환 시 자동으로 해제됩니다. 스택 포인터를 조작하는 것만으로 할당/해제가 되니까 매우 빠릅니다. O(1)이죠. 하지만 크기가 제한적이고, 보통 몇 MB 정도만 사용할 수 있습니다. 스코프를 벗어나면 자동으로 소멸되기 때문에 함수 밖으로 포인터를 반환하면 안 됩니다. (new로 반환을 해서 리턴하게 되면 외부에서 수동 delete 해줘야함 안하면 누수, 아니면 스마트 포인터를 이용 이건 힙 할당은 이용하는거임)int* bad() { int x = 5; // 스택에 할당된 지역변수 return &amp;x; // &amp;x를 반환 → 대상(x)이 사라진 후 호출자에 전해짐\n} int* good() { int* p = new int(5); // 힙에 할당 return p; // p(포인터 변수)도, *p(대상)도 함수 뒤에도 유효\n}\n힙은 프로그래머가 명시적으로 할당하고 해제해야 합니다. 크기 제한이 거의 없고, 프로그램 전체에서 접근 가능합니다. 하지만 메모리 관리자가 적절한 블록을 찾아야 하므로 할당/해제가 느립니다. 또한 단편화 문제가 발생할 수 있고, 메모리 누수의 위험이 있습니다.사용 시기를 판단하는 기준은 이렇습니다. 크기를 컴파일 타임에 알 수 있고 작은 데이터는 스택을 사용합니다. 런타임에 크기가 결정되거나, 큰 데이터, 함수 스코프를 벗어나는 생명주기가 필요하면 힙을 사용합니다.예를 들어 함수 내에서만 사용하는 작은 배열은 스택에, 사용자 입력에 따라 크기가 달라지는 동적 배열은 힙에 할당합니다. RAII 객체는 스택에 두고 내부적으로 힙을 관리하게 하는 것이 일반적인 패턴입니다.스택은 높은 주소에서 낮은 주소로 성장하고, 두 개의 핵심 포인터가 관리함\n스택 포인터: 현재 스택의 맨 위 (가장 최근 데이터)\n프레임 포인터: 현재 함수의 스택 프레임 시작점\n높은 주소 (0x1000)\n┌─────────────────────┐\n│ 이전 함수의 데이터 │\n├─────────────────────┤ ← 이전 FP\n│ 매개변수 (param) │\n├─────────────────────┤\n│ 반환 주소 │\n├─────────────────────┤ ← 현재 FP (프레임 포인터)\n│ 이전 FP 저장 │\n├─────────────────────┤\n│ 지역변수 1 │\n├─────────────────────┤\n│ 지역변수 2 │\n├─────────────────────┤ ← 현재 SP (스택 포인터)\n│ (사용 가능 공간) │\n└─────────────────────┘\n낮은 주소 (0x800)\nvoid functionA(int param) { int local1 = 10; int local2 = 20; functionB();\n} void functionB() { char arr[8]; int value = 100;\n}\n주소 내용\n0x1000 │ main의 스택 프레임 │\n0x0FFC │ functionA param │\n0x0FF8 │ A의 반환 주소 │ // functionA 호출\n0x0FF4 │ 이전 FP │ // FP는 이전 프레임포인터를 가리킴 (함수 리턴이 되면 돌아가야함)\n0x0FF0 │ A의 local1 │\n0x0FEC │ A의 local2 │\n0x0FE8 │ B의 반환 주소 │ // functionB 호출\n0x0FE4 │ A의 FP 저장 │ ← 새로운 FP\n0x0FE0 │ arr[0-3] │\n0x0FDC │ arr[4-7] │\n0x0FD8 │ value = 100 │ ← SP\n함수를 호출하게 되면 반환 받을 주소를 기입하고, 다음 주소에서 FP를 저장한다. 그리고 실행을 하면서 SP를 움직인다. (로컬 변수)반환 주소는 SP 복원지점과 실행 위치인거다. 어느 반환을 받고 어느 코드로 돌아가서 계속 실행하지?의 기준이다.FP 저장은 쉽게 세이브 포인트면서 함수 경계다. FP는 연결리스트처럼 되어 있어 이전으로 재귀형태로 돌아갈 수 있다.즉 반환 주소: SP 복원과 코드 실행 재개를 위한 정보\nFP 저장: 함수 경계 표시와 이전 상태로의 세이브 포인트 malloc / new 로 데이터만큼 요청을 한다. 힙 관리자는 사용 가능한 블록을 검색하고 사용 가능한 블록을 찾는다.\n발견시에 블록을 실제 데이터 저장되는 곳과 메타데이터 저장되는 곳으로 분할한다. 메타데이터를 저장 한다\n할당된 메모리의 시작 주소를 반환한다.\n할당 알고리즘을 통해 어떤 블록을 선택할지 결정한다.\nFirst Fit - 요청된 크기보다 큰 첫 번째 자유 블록 사용\nBest Fit - 요청된 크기에 가장 가까운 자유 블록 사용\n메모리 해제 과정\n포인터 검증\n메타데이터 접근\n상태 변경 (할당 -&gt; 할당 안됨)\n인근 블록 병합\n해제 전:\n┌─ 사용중(200) ─┬─ 해제할블록(400) ─┬─ 자유(100) ─┐ 해제 후:\n┌─ 사용중(200) ─┬─────── 자유(500) ──────────────┐ ↑ 인접한 자유 블록들을 병합 자유 블록 리스트에 추가\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"스택의 기본구조","level":4,"id":"스택의_기본구조_0"},{"heading":"힙","level":4,"id":"힙_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html","pathToRoot":"..","attachments":[],"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":5626,"sourcePath":"CS/10. 스택과 힙 메모리 특징과 차이점, 사용시기.md","exportPath":"cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html","showInTree":true,"treeOrder":97,"backlinks":[],"type":"markdown"},"cs/12.-new,-delete와-malloc,-free의-차이점.html":{"title":"12.  new, delete와 malloc, free의 차이점","icon":"","description":"new/delete와 malloc/free의 가장 중요한 차이는 객체의 생명주기 관리입니다.new는 메모리 할당과 함께 생성자를 호출합니다. 객체가 제대로 초기화되어 사용 가능한 상태가 됩니다. delete는 소멸자를 호출한 후 메모리를 해제합니다. 반면 malloc은 단순히 메모리만 할당하고, free는 메모리만 해제합니다. 생성자와 소멸자가 호출되지 않아서 C++ 객체에는 사용할 수 없습니다.타입 안정성도 큰 차이입니다. new는 타입을 명시하면 자동으로 크기를 계산하고 올바른 타입의 포인터를 반환합니다. malloc은 void 포인터를 반환하므로 캐스팅이 필요하고, 크기를 직접 계산해야 합니다.에러 처리 방식도 다릅니다. new는 실패 시 bad_alloc 예외를 던지고, malloc은 NULL을 반환합니다. 따라서 new는 try-catch로, malloc은 NULL 체크로 에러를 처리합니다.또 하나 중요한 차이는 new/delete는 오버로딩이 가능하다는 점입니다. 클래스별로 또는 전역적으로 메모리 할당 방식을 커스터마이징할 수 있습니다. 메모리 풀이나 디버깅 기능을 추가할 때 유용합니다.절대 하지 말아야 할 것은 malloc으로 할당한 것을 delete로 해제하거나, new로 할당한 것을 free로 해제하는 것입니다. 정의되지 않은 동작이 발생합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"12. new, delete와 malloc, free의 차이점","level":1,"id":"12._new,_delete와_malloc,_free의_차이점_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/12.-new,-delete와-malloc,-free의-차이점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":1432,"sourcePath":"CS/12.  new, delete와 malloc, free의 차이점.md","exportPath":"cs/12.-new,-delete와-malloc,-free의-차이점.html","showInTree":true,"treeOrder":98,"backlinks":[],"type":"markdown"},"cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html":{"title":"13. 가상함수와 순수가상함수의 차이점과 vtable 동작원리","icon":"","description":"\n가상함수의 필요성과 다형성\n순수가상함수와 추상클래스\nvtable 매커니즘\n성능 고려사항\n가상함수는 파생 클래스에서 재정의할 수 있는 함수로, 런타임에 실제 객체 타입에 따라 호출될 함수가 결정됩니다. 반면 순수가상함수는 구현이 없고 파생 클래스에서 반드시 구현해야하는 인터페이스입니다.순수가상함수를 포함한 클래스는 추상클래스가 되어 인스턴스를 생성할 수 없습니다. 이는 인터페이스를 정의하고 파생 클래스가 반드시 특정 기능을 구현하도록 강제하는 설계 도구입니다.vtable의 동작 원리를 설명드리면, 컴파일러는 가상함수를 가진 각 클래스마다 vtable이라는 함수 포인터 배열을 생성합니다. 객체가 생성되면 해당 객체는 자신의 클래스 vtable을 가리키는 vptr을 갖게된다.class Base {\npublic: virtual void virtualFunc() { /* … */ } void nonVirtualFunc() { /* … */ }\n};\nclass Derived : public Base {\npublic: void virtualFunc() override { /* … */ }\n}; Base* ptr = new Derived();\nptr-&gt;virtualFunc()을 호출한다고 가정\n<img alt=\"vtableoperation.png\" src=\"images/vtableoperation.png\" target=\"_self\">예를 들어, Base* ptr = new Derived()에서 ptr-&gt;virtualFunc()를 호출하면 ptr이 가리키는 객체의 vptr을 통해 Derived 클래스의 vtable에 접근하고 해당 vtable에서 virtualFunc의 인덱스를 찾아 실제 Derived::virtualFunc()를 호출합니다. 이 과정은 두 번의 간접 참조를 거치므로 일반 함수 호출보다 약간의 오버헤드가 있습니다.그래서 성능 측면에서 고려할 때, 성능이 중요한 작은 함수는 가상함수로 만들지 않는 것이 좋습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/vtableoperation.png","fullURL":"cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html","pathToRoot":"..","attachments":["images/vtableoperation.html"],"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":1791,"sourcePath":"CS/13. 가상함수와 순수가상함수의 차이점과 vtable 동작원리.md","exportPath":"cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html","showInTree":true,"treeOrder":99,"backlinks":[],"type":"markdown"},"cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html":{"title":"14. 상속 관계에서 생성자와 소멸자의 호출순서","icon":"","description":"\n상속 관계에서의 순서\n멤버 변수와의 관계\n가상 소멸자의 중요성\n상속 관계에서 생성자는 기반 클래스로부터 파생 클래스 순으로 호출됩니다. 소멸자는 반대로 파생 클래스부터 기반 클래스 순으로 호출됩니다.멤버 변수의 초기화 순서는 클래스 선언 순서를 따릅니다. 예를 들면\nclass Base { Base() {}; ~Base() {};\n} class Member { Member() {}; ~Member() {};\n} class Derived: Base { Member _member; Derived() { } ~Derived() { }; }\n생성 순서는 Base -&gt; Member -&gt; Derived\n소멸 순서는 Derived -&gt; Member -&gt; Base입니다.가상 소멸자가 없으면 심각한 문제가 발생합니다. Base 포인터로 Derived 객체를 삭제할 때, 가상 소멸자가 없으면 Derived 소멸자가 호출되지 않아 리소스 누수가 발생합니다. 따라서 다형성을 사용하는 기반 클래스는 반드시 가상 소멸자를 가져야 합니다.상속관계에서 실무를 할 때 실수하기 좋은 지점은 생성자에서 가상함수를 호출하면 파생 클래스가 아닌 현재 클래스의 함수가 호출된다는 것입니다. 생성 중에는 객체가 아직 완전한 파생 클래스 타입이 아니기 때문입니다.#include &lt;iostream&gt; class Base { public: Base() { std::cout &lt;&lt; \"Base constructor\\n\"; virtualFunc(); } virtual ~Base() { std::cout &lt;&lt; \"Base destructor\\n\"; virtualFunc(); } virtual void virtualFunc() { std::cout &lt;&lt; \"Base::virtualFunc()\\n\"; }\n}; class Derived : public Base { public: Derived() { std::cout &lt;&lt; \"Derived constructor\\n\"; } ~Derived() override { std::cout &lt;&lt; \"Derived destructor\\n\"; } void virtualFunc() override { std::cout &lt;&lt; \"Derived::virtualFunc()\\n\"; }\n}; int main() { Base* ptr = new Derived(); ptr-&gt;virtualFunc(); return 0;\n}\nBase constructor\nBase::virtualFunc()\nDerived constructor\nDerived::virtualFunc()\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html","pathToRoot":"..","attachments":[],"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":2017,"sourcePath":"CS/14. 상속 관계에서 생성자와 소멸자의 호출순서.md","exportPath":"cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html","showInTree":true,"treeOrder":100,"backlinks":[],"type":"markdown"},"cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html":{"title":"15. 깊은 복사와 얕은 복사의 차이점과 구현 방법","icon":"","description":"\n메모리 관점에서의 차이\n문제 발생 시나리오\n올바른 구현 방법\nRule of Three / Five\n깊은 복사와 얕은 복사의 차이는 포인터가 가리키는 메모리를 어떻게 처리하느냐에 있습니다.얕은 복사는 포인터 값 자체만 복사하여 두 객체가 같은 메모리를 가리키게 됩니다. 반면 깊은 복사는 포인터가 가리키는 메모리의 내용까지 새로 할당하여 복사합니다.얕은 복사의 문제는 이중 해제와 댕글링 포인터입니다. 기본 복사 생성자는 포인터 타입은 얕은 복사를 수행하므로, 동적 메모리를 가진 객체를 복사하면 두 객체가 같은 메모리를 가리킵니다. 한 객체가 소멸되면서 메모리를 해제하면, 다른 객체는 해제된 메모리를 가리키는 댕글링 포인터가 됩니다.깊은 복사를 구현하려면 복사 생성자와 복사 대입 연산자를 명시적으로 정의해야 합니다. 복사 생성자에서는 새 메모리를 할당하고 내용을 복사합니다. 복사 대입 연산자에서는 자기 대입 검사, 기존 메모리 해제, 새 메모리 할당 및 복사의 순서를 지켜야 합니다.Rule of 3\n소멸자, 복사 생성자, 복사 대입 연산자 중 하나를 직접 정의하면, 나머지 둘도 반드시 정의하라.\n필요한 이유 클래스가 동적 메모리·파일·소켓 등 자원을 직접 관리할 때, 기본 제공 복사 연산자는 얕은 복사(shallow copy)만 수행하므로 복사된 두 객체가 같은 자원을 공유 → 한 객체가 소멸될 때 자원을 해제하면 다른 객체는 댕글링 포인터를 가짐 이중 해제(double free) 버그 발생 Rule of 5\nRule of Three에 이동 연산자 둘을 추가\nRule of 0\n가능하면 사용자 정의 특별 멤버 함수를 전혀 만들지 말라\n스마트 포인터, STL, string 같은 RAII 타입을 사용해 자원을 관리\nRule of 3, 5는 컴파일러 자동 생성에 의존 하지 말고 의도를 드러내라라는 의미임.개발자가 생성자를 정의하지 않으면 컴파일러가 자동으로 생성해줌\n기본 생성자\n복사 생성자\n복사 대입 생성자\n이동 연산자\n이동 대입 연산자\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"참고) Rule of 3, Rule of 5, Rule of 0","level":4,"id":"참고)_Rule_of_3,_Rule_of_5,_Rule_of_0_0"},{"heading":"참고) 생성자 자동 생성 규칙","level":4,"id":"참고)_생성자_자동_생성_규칙_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html","pathToRoot":"..","attachments":[],"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":3561,"sourcePath":"CS/15. 깊은 복사와 얕은 복사의 차이점과 구현 방법.md","exportPath":"cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html","showInTree":true,"treeOrder":101,"backlinks":[],"type":"markdown"},"cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html":{"title":"16. vector, list, deque의 차이점과 시간복잡도","icon":"","description":"\n내부 메모리 구조\n각 연산의 시간복잡도\n메모리 재할당 전략\n선택 기준\n세 컨테이너의 가장 중요한 차이는 메모리 레이아웃입니다.vector는 연속된 메모리 블록을 사용합니다. 이는 동적 배열로, 모든 요소가 메모리상에 연속적으로 배치되어 있어 캐시 효율성이 뛰어납니다. 랜덤 액세스가 O(1)로 가능한 이유도 단순한 포인터 연산으로 주소를 계산할 수 있기 때문입니다.list는 이중 연결 리스트로 구현됩니다. 각 노드가 데이터와 앞뒤 포인터를 가지고 있어, 메모리상에 분산되어 있습니다. 따라서 특정 위치 접근은 O(n)이지만, 위치를 알고 있다면 삽입과 삭제가 O(1)입니다.deque는 청크 단위로 관리되는 이중 종단 큐입니다. 여러 개의 고정 크기 블록을 포인터 배열로 관리하여, 양 끝에서의 삽입/삭제가 O(1)이면서도 랜덤 액세스도 O(1)로 가능합니다.메모리 재할당 측면에서 보면, vector는 용량이 부족하면 전체를 재할당하고 복사합니다. 보통 2배씩 늘립니다. deque는 새 청크만 추가하므로 기존 요소를 이동시킬 필요가 없고, 포인터는 유효하게 유지됩니다. list는 재할당 개념이 없고 각 노드를 개별 할당합니다.실무에서 선택 기준은 이렇습니다. 대부분의 경우 vector를 기본으로 사용합니다. 캐시 효율성이 좋고 메모리 오버헤드가 적기 때문입니다. 중간 삽입/삭제가 빈번하고 요소 크기가 크면 list를 고려합니다. 양 끝 삽입/삭제가 많으면서 랜덤 액세스도 필요하면 deque를 선택합니다.! 얼핏 보기에는 deque가 vector의 상위 호환 같아서 deque를 쓰는 게 나은 거 같지만 deque는 vector처럼 완전 연속 메모리가 아니라 캐시 지역성 관점에서 vector 만큼 효율이 나오지 않음.vector는 랜덤 엑세스를 할 때 base_ptr + offset으로 접근 하는 반면 deque는 '어떤 청크에 있는 지' -&gt; offset 계산으로 접근을 하기 때문에 참조와 분기를 수행해서 오버헤드가 있다.그리고 deque는 내부적으로 청크 관리를 위해서 map table이라는 구조를 사용해 메모리 오버헤드가 있다.즉 vector: 진정한 연속 메모리 → 최상의 캐시 지역성 → 가장 빠른 순차·임의 접근, 메모리 오버헤드 최소\ndeque: 세그먼트된 연속 메모리 → 캐시 미스율 ↑, 연산 상수 계수 증가, 메모리 오버헤드 ↑, 대신 양끝 삽입·삭제가 아주 안정적으로 O(1)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"참고","level":4,"id":"참고_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html","pathToRoot":"..","attachments":[],"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":2686,"sourcePath":"CS/16. vector, list, deque의 차이점과 시간복잡도.md","exportPath":"cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html","showInTree":true,"treeOrder":102,"backlinks":[],"type":"markdown"},"cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html":{"title":"17. map, unordered_map, set, unordered_set의 차이점","icon":"","description":"\n내부 구현 자료구조\n정렬 여부와 순회 순서\n시간복잡도 비교\n이 네 컨테이너는 내부 구현 방식에 따라 두 그룹으로 나뉩니다.map과 set은 Red-Black Tree로 구현되어 있습니다. 이는 자가 균형 이진 탐색 트리로, 모든 연산이 O(log n)을 보장합니다. 중요한 특징은 요소들이 항상 정렬된 상태를 유지한다는 것입니다. map은 키로, set은 값 자체로 정렬됩니다.unordered_map과 unordered_set은 해시 테이블로 구현됩니다. 평균적으로 O(1)의 접근 시간을 제공하지만, 최악의 경우 해시 충돌로 인해 O(n)이 될 수 있습니다. 요소들의 순서는 보장되지 않으며, 해시 함수와 버킷 크기에 따라 달라집니다.메모리 사용량과 캐시 효율성 측면에서, 트리 기반 컨테이너는 각 노드마다 좌우 포인터와 색상 정보를 저장해야 하므로 메모리 오버헤드가 큽니다. 해시 기반 컨테이너는 로드 팩터를 유지하기 위해 실제 요소 수보다 큰 버킷 배열을 할당하므로, 역시 메모리를 더 사용할 수 있습니다.선택 기준을 말씀드리면, 정렬된 순서가 필요하거나 범위 기반 검색을 해야 한다면 map/set을 사용합니다. 예를 들어 구간 검색이나 lower_bound, upper_bound 연산이 필요한 경우입니다. 단순히 빠른 검색, 삽입, 삭제만 필요하다면 unordered 버전이 더 효율적입니다.사용자 정의 타입을 키로 사용할 때 map,set은 Red Black Tree이므로 operator&lt; 를 정의 해야하고 unordered_map, unordered_set은 해시 테이블 기반이기 때문에 operator==를 정의 해야한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491059,"modifiedTime":1754545491060,"sourceSize":1742,"sourcePath":"CS/17. map, unordered_map, set, unordered_set의 차이점.md","exportPath":"cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html","showInTree":true,"treeOrder":103,"backlinks":[],"type":"markdown"},"cs/18.-priority_queue의-내부-구현과-사용법.html":{"title":"18. priority_queue의 내부 구현과 사용법","icon":"","description":"\n힙 자료구조의 원리\nSTL priority_queue 구현\n주요 연산과 복잡도\n실제 활용 사례\n힙에 대해서 공부할 것. (유튜브 봐야할 듯)","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/18.-priority_queue의-내부-구현과-사용법.html","pathToRoot":"..","attachments":[],"createdTime":1754545491060,"modifiedTime":1754545491060,"sourceSize":172,"sourcePath":"CS/18. priority_queue의 내부 구현과 사용법.md","exportPath":"cs/18.-priority_queue의-내부-구현과-사용법.html","showInTree":true,"treeOrder":104,"backlinks":[],"type":"markdown"},"cs/20.-map과-unordered_map-중-선택-기준.html":{"title":"20. map과 unordered_map 중 선택 기준","icon":"","description":"두 컨테이너의 선택은 요구사항과 데이터 특성에 따라 결정됩니다.unordered_map을 선택하는 경우는, 첫째로 평균적인 성능이 중요할 때입니다. 단순 키 검색, 삽입, 삭제만 필요하다면 O(1)의 unordered_map이 O(log n)의 map보다 빠릅니다. 특히 요소가 수만 개 이상일 때 차이가 명확합니다.둘째, 키의 해시 함수가 잘 정의되어 있고 충돌이 적을 때입니다. 정수, 문자열 같은 기본 타입은 표준 라이브러리의 해시 함수가 잘 동작합니다.map을 선택하는 경우는, 첫째로 정렬된 순서가 필요할 때입니다. 로그 출력, 정렬된 결과 표시, 범위 기반 검색이 필요하면 map이 필수입니다. lower_bound, upper_bound로 특정 범위의 요소를 효율적으로 찾을 수 있습니다.둘째, 최악의 경우 성능 보장이 중요할 때입니다. unordered_map은 해시 충돌 시 O(n)까지 성능이 저하될 수 있지만, map은 항상 O(log n)을 보장합니다. 실시간 시스템이나 보안이 중요한 서버에서는 이런 예측 가능성이 중요합니다.셋째, 메모리 사용이 더 예측 가능해야 할 때입니다. unordered_map은 로드 팩터 유지를 위해 실제 요소보다 많은 버킷을 할당하지만, map은 요소 수에 비례한 메모리만 사용합니다.실무 팁으로는, 캐시나 설정 관리처럼 빠른 접근이 중요하면 unordered_map을, 인덱스나 순위 시스템처럼 순서가 중요하면 map을 사용합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/20.-map과-unordered_map-중-선택-기준.html","pathToRoot":"..","attachments":[],"createdTime":1754545491060,"modifiedTime":1754545491060,"sourceSize":1579,"sourcePath":"CS/20. map과 unordered_map 중 선택 기준.md","exportPath":"cs/20.-map과-unordered_map-중-선택-기준.html","showInTree":true,"treeOrder":105,"backlinks":[],"type":"markdown"},"cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html":{"title":"21. 스마트 포인터 (unique_ptr, shared_ptr, weak_ptr)","icon":"","description":"\n각 스마트 포인터의 소유권 모델\n내부 구현 원리\n사용 시나리오와 주의점\n프로젝트 적용 사례\n스마트 포인터는 RAII 원칙을 따라 자동 메모리 관리를 제공합니다.unique_ptr은 독점 소유권을 표현합니다. 한 시점에 하나의 unique_ptr만이 객체를 소유할 수 있으며, 소유권은 move로만 이전됩니다. 오버헤드가 거의 없어 원시 포인터와 성능이 동일합니다. 소멸자에서 자동으로 delete를 호출하므로 예외 안전성을 보장합니다.shared_ptr은 공유 소유권을 표현합니다. 여러 포인터가 같은 객체를 공유합니다. 내부에 제어블록을 별도로 할당해서 참조 카운터와 커스텀 삭제자를 저장합니다. 마지막 shared_ptr이 소멸될 때 delete를 호출되고 객체가 삭제됩니다. 따라서 약간의 메모리, 성능 오버헤드가 있습니다. 주로 옵저버 패턴, 콜백 함수에서 주로 사용됩니다.weak_ptr은 순환 참조를 방지하는 포인터입니다. shared_ptr을 관찰하지만 참조 카운터를 증가시키지 않습니다.사용하려면 lock()으로 shared_ptr을 얻어야 하며, 이 과정에서 객체가 이미 삭제되었는지 확인합니다.트리 구조에서 자식 노드에서 부모 노드를 가리킬 때 weak_ptr을 사용하여 순환 참조를 방지합니다.스마트 포인터를 사용할 때 make_shared, make_unique 함수를 이용해서 할당하는 것이 좋습니다. new와 스마트 포인터 생성 사이에서 예외가 생겨도 메모리 누수를 방지합니다. make_shared 같은 경우는 객체와 제어블록을 한 번에 할당해서 메모리와 성능의 이점을 누릴 수 있습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html","pathToRoot":"..","attachments":[],"createdTime":1754545491060,"modifiedTime":1754545491060,"sourceSize":1782,"sourcePath":"CS/21. 스마트 포인터 (unique_ptr, shared_ptr, weak_ptr).md","exportPath":"cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html","showInTree":true,"treeOrder":106,"backlinks":[],"type":"markdown"},"cs/23.-lvalue와-rvalue의-차이점.html":{"title":"23. lvalue와 rvalue의 차이점","icon":"","description":"lvalue와 rvalue는 표현식의 카테고리를 나타내는 개념입니다.간단히 말하면, lvalue는 메모리 위치를 가지고 있어 주소를 취할 수 있는 표현식이고, rvalue는 임시 값으로 주소를 취할 수 없는 표현식입니다. 변수는 lvalue, 리터럴이나 임시 객체는 rvalue입니다.C++11에서 rvalue 참조가 도입되면서 이 구분이 더 중요해졌습니다. lvalue 참조는 &amp;로, rvalue 참조는 &amp;&amp;로 표현합니다. rvalue 참조는 임시 객체를 바인딩할 수 있어, 불필요한 복사를 피하고 이동 의미론을 구현할 수 있습니다.예를 들어, string s = \"hello\" 에서 s는 lvalue, \"hello\"는 rvalue입니다. string&amp;&amp; r = string(\"temp\")에서 rvalue 참조 r은 임시 string 객체를 바인딩합니다.실무에서 중요한 점은 완벽한 전달(perfect forwarding)입니다. 템플릿에서 T&amp;&amp;는 유니버설 참조(forwarding reference)로, lvalue가 들어오면 lvalue 참조로, rvalue가 들어오면 rvalue 참조로 추론됩니다. std::forward를 사용해 원래 값 카테고리를 유지하며 전달할 수 있습니다.std::move의 역할을 정확히 이해해야 합니다. move는 실제로 이동하지 않고, lvalue를 rvalue로 캐스팅만 합니다. 이를 통해 이동 생성자나 이동 대입 연산자가 호출되도록 합니다.포워딩 참조 (유니버셜 참조)의 핵심은 '템플릿에서 T&amp;&amp;가 lvalue, rvalue'를 모두 원래 카테고리를 보존해 전달할 수 있다는 것이다.일반 함수에서 rvalue의 참조는 오직 ravlue만 바인딩할 수 있다.void f(int&amp;&amp;); // f(3) 가능, f(x) 불가능\n그런데 템플릿에서는 lvalue와 rvalue를 모두 바인딩할 수 있다. 이때 T&amp;&amp;를 포워딩 참조 또는 유니버셜 참조라고 한다.template&lt;typename T&gt;\nvoid f(T&amp;&amp;); // f(3) 가능, f(x) 가능\n이게 왜 가능할까?rvalue 인자를 넘길 때 -&gt; f(3)을 가정하면f(3);\nT를 int로 추론을 하고 매개변수 타입은 int&amp;&amp;로 추론함\nint x = 0;\nf(x); T를 int&amp;로 추론하고 타입은 int&amp; &amp;&amp;로 추론함.\n참조 결합 법칙에 따라 int&amp;로 축소?\n왜 완벽한 전달이 중요할까?템플릿 관련 코드 std::make_shared, emplace_back 등은 내부에서 생성자나 다른 함수로 인자를 중계하는 경우가 많다. 이때 lvalue를 전달하면 복사 생성자를 호출하고, rvalue를 전달하면 이동 생성자를 호출해야 한다.\n그래서 원래의 카테고리를 보존해야하는데 유니버셜 참조와 std::forward가 그 역할을 해주기 때문물론 &amp;, &amp;&amp; 를 둘 다 구현해서 lvalue와 rvalue를 각각 처리할 수 있는데 이렇게 한다면 코드가 중복 되고 가변 인자 조합 폭발 (매개변수가 2개라면 ll ,lr, rl, rr 4개 경우를 처리해야함)C++ 표준은 참조의 참조를 허용하지 않기 때문에, 두 개의 참조 기호가 만나면 다음과 같은 방식으로 하나의 참조로 접는다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"참고) 포워딩 참조","level":4,"id":"참고)_포워딩_참조_0"},{"heading":"참고) 참조결합","level":4,"id":"참고)_참조결합_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/23.-lvalue와-rvalue의-차이점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":3275,"sourcePath":"CS/23. lvalue와 rvalue의 차이점.md","exportPath":"cs/23.-lvalue와-rvalue의-차이점.html","showInTree":true,"treeOrder":107,"backlinks":[],"type":"markdown"},"cs/24.-move-constructor와-move-assignment의-필요성.html":{"title":"24. move constructor와 move assignment의 필요성","icon":"","description":"이동 의미론은 C++11의 가장 중요한 개선사항 중 하나입니다.필요성은 불필요한 복사를 피하는 데 있습니다. 예를 들어 함수가 큰 vector를 반환할 때, 이전에는 전체 복사가 필요했지만, 이동 생성자를 사용하면 내부 포인터만 이동시킬 수 있습니다. 이는 O(n)에서 O(1)로 성능이 개선됩니다.#include &lt;vector&gt;\n#include &lt;iostream&gt; std::vector&lt;int&gt; make_big_vector() { // 100만 개 정수를 담는 큰 벡터 생성 std::vector&lt;int&gt; v(1'000'000, 42); std::cout &lt;&lt; \"make_big_vector: vector constructed\\n\"; return v; // C++11 이후: move 생성자, C++17 이후: (N)RVO로 완전 생략\n} int main() { // 벡터를 복사 없이(또는 이동만으로) 받아옴 → O(1) std::vector&lt;int&gt; data = make_big_vector(); std::cout &lt;&lt; \"main: vector size = \" &lt;&lt; data.size() &lt;&lt; \"\\n\"; return 0;\n}\n이동 생성자는 임시 객체로부터 리소스를 훔쳐옵니다. 원본 객체의 포인터를 가져오고, 원본은 유효하지만 불확정 상태로 만듭니다. 일반적으로 nullptr로 설정하여 소멸자에서 안전하게 처리되도록 합니다.// 개념적 구현\nMyClass(MyClass&amp;&amp; other) noexcept : data(other.data) { other.data = nullptr; // 원본을 안전한 상태로\n}\n이동 대입 연산자는 자기 대입 검사와 기존 리소스 정리가 필요합니다. swap을 사용한 구현이 일반적이며, 강한 예외 보장을 제공할 수 있습니다.NonTrivial&amp; operator=(NonTrivial&amp;&amp; other) noexcept { if (this != &amp;other) { std::swap(data, other.data); std::swap(size, other.size); std::cout &lt;&lt; \"move assign called, size=\" &lt;&lt; size &lt;&lt; \"\\n\"; } return *this; }\n주의할 점은 noexcept 지정입니다. 이동 연산이 예외를 던지지 않음을 보장하면, 컨테이너가 재할당 시 이동을 사용할 수 있습니다. noexcept가 없으면 예외안전성을 위해 복사를 사용합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"참고) 이동은 '스택 영역에 할당된 데이터와 관련이 없고, 힙 영역에 할당된 데이터와 관련된 것'","level":4,"id":"참고)_이동은_'스택_영역에_할당된_데이터와_관련이_없고,_힙_영역에_할당된_데이터와_관련된_것'_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/24.-move-constructor와-move-assignment의-필요성.html","pathToRoot":"..","attachments":[],"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":2228,"sourcePath":"CS/24. move constructor와 move assignment의 필요성.md","exportPath":"cs/24.-move-constructor와-move-assignment의-필요성.html","showInTree":true,"treeOrder":108,"backlinks":[],"type":"markdown"},"cs/25.-auto-키워드의-장단점.html":{"title":"25. auto 키워드의 장단점","icon":"","description":"auto는 컴파일 타임 타입 추론을 제공하는 키워드입니다.장점은 첫째, 코드 작성이 간결해집니다. 특히 반복자나 템플릿 타입처럼 긴 타입명을 반복하지 않아도 됩니다.두번째는 타입 불일치로 인한 잠재적 버그를 방지합니다. 예를들어 vector::size()는 size_t를 반환하는데, int로 받으면 경고나 오버플로우가 발생할 수 있습니다.단점은 첫째, 코드 가독성이 떨어질 수 있습니다. 타입이 명시되지 않아 코드를 읽는 사람이 타입을 추론해야 합니다. 물론 IDE를 사용하면 덜 불편할 순 있습니다.둘째, 의도하지 않은 타입 추론이 발생할 수 있습니다.auto x = {1};는 initializer_list&lt;int&gt;로 추론함\n그래서 가이드 라인을 잡고 사용하는 것을 권장합니다. 타입이 명확한 경우나 긴 타입(템플릿)은 auto를 사용하고 로직이 중요해 가독성이 필요한 곳에는 명시적 타입을 쓴다거나.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/25.-auto-키워드의-장단점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":1044,"sourcePath":"CS/25. auto 키워드의 장단점.md","exportPath":"cs/25.-auto-키워드의-장단점.html","showInTree":true,"treeOrder":109,"backlinks":[],"type":"markdown"},"cs/26.-람다함수의-캡처-방식들과-사용법.html":{"title":"26. 람다함수의 캡처 방식들과 사용법","icon":"","description":"람다는 익명 함수 객체를 생성하는 간결한 방법입니다.캡처 방식은 크게 값 캡처와 참조 캡처로 나뉩니다. [=]는 모든 변수를 값으로, [&amp;]는 참조로 캡처합니다. 개별 변수는 [x, &amp;y]처럼 선택적으로 캡처할 수 있습니다.값 캡처는 람다 생성 시점의 값을 복사합니다. 원본이 변경되어도 람다 내부 값은 변하지 않으며, 람다가 원본보다 오래 살아도 안전합니다. 단, 기본적으로 const이므로 수정하려면 mutable 키워드가 필요합니다.참조 캡처는 원본 변수를 직접 참조합니다. 원본 수정이 가능하지만, 원본이 소멸한 후 람다를 사용하면 댕글링 참조가 됩니다. 특히 비동기 작업이나 콜백에서 주의해야 합니다.#include &lt;iostream&gt;\n#include &lt;functional&gt; std::function&lt;void()&gt; makeCallback() { int x = 42; // 지역 변수 return [&amp;]() { // x를 참조 캡처 std::cout &lt;&lt; x &lt;&lt; \"\\n\"; };\n} // 여기서 x가 소멸 int main() { auto cb = makeCallback(); // cb 안에는 x의 참조가 저장되어 있다 cb(); // 댕글링 참조를 사용 → UB return 0;\n} C++14부터 초기화 캡처가 가능합니다. [ptr = make_unique&lt;T&gt;()]처럼 캡처 시 새 변수를 만들 수 있어, 이동 캡처를 구현할 수 있습니다.#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;functional&gt; int main() { auto ptr = std::make_unique&lt;int&gt;(100); // 이동 캡처: ptr은 람다 내부로 이동(move)되고, 외부 ptr은 빈 상태(nullptr)이 됨 auto lambda = [p = std::move(ptr)]() { std::cout &lt;&lt; *p &lt;&lt; \"\\n\"; }; // ptr이 nullptr이므로 더 이상 접근 불가 // std::cout &lt;&lt; *ptr; // 오류 lambda(); // 안전하게 100 출력 return 0;\n} 자주 사용하는 패턴은 , STL 알고리즘과 함께 사용하는 것입니다. std::sort의 비교 함수, std::find_if의 조건 함수 등을 람다로 작성하면 코드가 간결해집니다.멀티스레드 환경에서는 값 캡처를 선호합니다. 특히 this 캡처는 위험할 수 있으므로, C++17의 [*this]로 객체 전체를 값으로 캡처하는 것이 안전합니다.흔한 함정은, 루프 안에서 람다를 생성할 때 참조 캡처한 루프 변수가 모두 마지막 값을 가리키는 문제입니다. 이런 경우 값 캡처나 초기화 캡처를 사용해야 합니다.#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt; int main() { std::vector&lt;std::function&lt;void()&gt;&gt; v; for (int i = 0; i &lt; 3; ++i) { // [&amp;i]로 참조 캡처 → 모든 람다가 동일한 i(=3)를 가리킴 v.push_back([&amp;]() { std::cout &lt;&lt; i &lt;&lt; \" \"; }); } for (auto&amp; f : v) f(); // 예상: 0 1 2 // 실제: 3 3 3 std::cout &lt;&lt; \"\\n\"; return 0;\n} ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"심화: 람다랑 std::function의 차이점?","level":4,"id":"심화_람다랑_stdfunction의_차이점?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/26.-람다함수의-캡처-방식들과-사용법.html","pathToRoot":"..","attachments":[],"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":3038,"sourcePath":"CS/26. 람다함수의 캡처 방식들과 사용법.md","exportPath":"cs/26.-람다함수의-캡처-방식들과-사용법.html","showInTree":true,"treeOrder":110,"backlinks":[],"type":"markdown"},"cs/28.-메모리-누수를-탐지하는-방법.html":{"title":"28.  메모리 누수를 탐지하는 방법","icon":"","description":"\u001e\n첫째로는 정적 분석은 코드를 실행하지 않고 소스 코드 자체를 분석해서 잠재적 오류(버그), 메모리 누수 가능성, 코드 스타일 위반 등을 찾아내는 기법이다. clang-tidy와 같은 정적 분석기를 이용하는 것은 메모리 누수 탐지에 도움이 된다.두번째로는 Valgrind 같은 동적 분석 프로그램을 이용하는 것\n동작방식\n프로그램을 Valgrind 가상 머신(VM) 위에서 실행\n메모리 할당·해제, 읽기·쓰기 등을 모두 가로채서 추적\n종료 시점에 할당 후 해제되지 않은 블록(메모리 누수), 초기화되지 않은 읽기, 버퍼 오버런 등을 보고\nclang인 경우 AddressSanitizer &amp; LeakSanitizer를 이용 이것도 동적 분석 (상대적으로 가벼움) Valgrind와 중복하지 말것.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"28. 메모리 누수를 탐지하는 방법","level":1,"id":"28._메모리_누수를_탐지하는_방법_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/28.-메모리-누수를-탐지하는-방법.html","pathToRoot":"..","attachments":[],"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":838,"sourcePath":"CS/28.  메모리 누수를 탐지하는 방법.md","exportPath":"cs/28.-메모리-누수를-탐지하는-방법.html","showInTree":true,"treeOrder":111,"backlinks":[],"type":"markdown"},"cs/29.-스레드와-프로세스의-차이점.html":{"title":"29. 스레드와 프로세스의 차이점","icon":"","description":"프로세스와 스레드는 실행 단위라는 공통점이 있지만 자원 공유 방식에서 큰 차이가 있습니다.프로세스는 독립적인 실행 단위입니다. 각 프로세스는 독립된 가상 주소 공간을 가지며, 코드, 데이터, 힙, 스택 영역이 모두 분리되어 있습니다. 한 프로세스가 비정상 종료되어도 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.스레드는 프로세스 내의 실행 흐름입니다. 같은 프로세스의 스레드들은 코드, 데이터, 힙 영역을 공유하지만 각자의 스택과 레지스터를 가집니다. 이로 인해 스레드 간 통신이 빠르고 컨텍스트 스위칭 비용이 적습니다.생성과 종료 비용 면에서, 프로세스는 새로운 주소 공간 할당과 자원 복사가 필요해 무겁습니다. fork() 시스템 콜은 COW(Copy-On-Write)로 최적화되지만 여전히 오버헤드가 있습니다. 스레드는 스택 공간만 할당하면 되어 가볍습니다.통신 방식도 다릅니다. 프로세스 간 통신(IPC)은 파이프, 소켓, 공유 메모리 등 운영체제가 제공하는 메커니즘이 필요합니다. 스레드는 전역 변수나 힙 메모리를 직접 공유할 수 있어 효율적이지만, 동기화 문제가 발생합니다.실무 선택 기준은, 격리가 중요하면 프로세스를, 성능과 자원 공유가 중요하면 스레드를 선택합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"심화) COW","level":4,"id":"심화)_COW_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/29.-스레드와-프로세스의-차이점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":1510,"sourcePath":"CS/29. 스레드와 프로세스의 차이점.md","exportPath":"cs/29.-스레드와-프로세스의-차이점.html","showInTree":true,"treeOrder":112,"backlinks":[],"type":"markdown"},"cs/30.-c++에서-스레드-동기화-방법들.html":{"title":"30.  C++에서 스레드 동기화 방법들","icon":"","description":"C++11부터 표준 라이브러리에서 다양한 동기화 도구를 제공합니다.뮤텍스(mutex)는 가장 기본적인 동기화 도구입니다. 상호 배제를 보장하여 한 번에 하나의 스레드만 임계 영역에 접근할 수 있습니다. lock_guard나 unique_lock으로 RAII 패턴을 적용하면 데드락을 방지할 수 있습니다. recursive_mutex는 같은 스레드가 여러 번 잠글 수 있고, timed_mutex는 시간 제한을 설정할 수 있습니다.조건 변수(condition_variable)는 특정 조건을 기다리는 동기화입니다. 생산자-소비자 패턴에서 유용합니다. wait()는 뮤텍스를 해제하고 대기하다가, notify를 받으면 다시 뮤텍스를 획득합니다. spurious wakeup 때문에 항상 while 루프로 조건을 재확인해야 합니다.원자적 연산(atomic)은 락 없는 동기화를 제공합니다. 단순한 변수 접근이나 카운터에 효율적입니다. memory_order를 지정하여 메모리 순서를 제어할 수 있습니다. compare_exchange로 CAS(Compare-And-Swap) 연산을 수행하여 락 프리 자료구조를 구현할 수 있습니다.future/promise는 비동기 작업 결과를 전달합니다. promise가 값을 설정하면 future를 통해 다른 스레드가 받을 수 있습니다. async()는 자동으로 future를 반환하여 비동기 작업을 간단히 처리합니다.실무 팁으로는, 가능한 한 락의 범위를 최소화하고, 여러 락을 획득할 때는 항상 같은 순서로 획득하여 데드락을 방지합니다. 읽기가 많은 경우 shared_mutex(reader-writer lock)를 사용하고, 성능이 중요한 경우 lock-free 자료구조를 고려합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"30. C++에서 스레드 동기화 방법들","level":1,"id":"30._C++에서_스레드_동기화_방법들_0"},{"heading":"실제로 구현 한번 해보기","level":4,"id":"실제로_구현_한번_해보기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/30.-c++에서-스레드-동기화-방법들.html","pathToRoot":"..","attachments":[],"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":1794,"sourcePath":"CS/30.  C++에서 스레드 동기화 방법들.md","exportPath":"cs/30.-c++에서-스레드-동기화-방법들.html","showInTree":true,"treeOrder":113,"backlinks":[],"type":"markdown"},"cs/31.-뮤텍스와-세마포어의-차이점.html":{"title":"31. 뮤텍스와 세마포어의 차이점","icon":"","description":"뮤텍스와 세마포어는 동기화 목적은 같지만 사용 방식과 의미가 다릅니다.뮤텍스는 상호 배제를 위한 잠금 메커니즘입니다. 소유권 개념이 있어서, 잠근 스레드만이 해제할 수 있습니다. 이진 상태(잠김/해제)만 가지며, 한 번에 하나의 스레드만 임계 영역에 진입할 수 있습니다. 재진입 가능한 recursive_mutex도 있습니다.세마포어는 카운팅 기반의 신호 메커니즘입니다. 소유권 개념이 없어 어떤 스레드든 신호를 보낼 수 있습니다. 카운터 값만큼의 스레드가 동시에 진입할 수 있어, 리소스 풀 관리에 적합합니다. 이진 세마포어는 뮤텍스와 유사하지만 소유권이 없다는 차이가 있습니다.사용 시나리오가 다릅니다. 뮤텍스는 공유 데이터 보호에 사용합니다. 예를 들어 전역 변수나 공유 객체 접근을 직렬화합니다. 세마포어는 제한된 리소스 관리에 사용합니다. 데이터베이스 연결 풀이나 스레드 풀에서 동시 접근 수를 제한할 때 유용합니다.구현 수준의 차이도 있습니다. 뮤텍스는 보통 유저 레벨에서 빠른 경로를 제공하고, 경합 시에만 커널로 전환됩니다. 세마포어는 일반적으로 시스템 콜을 통해 구현되어 오버헤드가 더 클 수 있습니다.실무에서는 단순 상호 배제는 뮤텍스를, 생산자-소비자 패턴이나 리소스 카운팅은 세마포어를 사용합니다. C++ 표준 라이브러리는 mutex는 제공하지만 세마포어는 C++20부터 counting_semaphore로 제공됩니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/31.-뮤텍스와-세마포어의-차이점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":1680,"sourcePath":"CS/31. 뮤텍스와 세마포어의 차이점.md","exportPath":"cs/31.-뮤텍스와-세마포어의-차이점.html","showInTree":true,"treeOrder":114,"backlinks":[],"type":"markdown"},"cs/33.-레이스-컨디션에-대해-설명해주세요.html":{"title":"33. 레이스 컨디션에 대해 설명해주세요","icon":"","description":"레이스 컨디션은 여러 스레드가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 현상입니다.가장 단순한 예는 카운터 증가입니다. count++는 실제로 읽기, 증가, 쓰기의 세 단계로 이루어집니다. 두 스레드가 동시에 실행하면, 둘 다 같은 값을 읽고 증가시켜 하나의 증가분이 손실될 수 있습니다. 예를 들어 count가 10일 때 두 스레드가 동시에 증가시키면 12가 아닌 11이 될 수 있죠.레이스 컨디션이 위험한 이유는 재현이 어렵다는 점입니다. 스레드 스케줄링은 운영체제가 결정하므로, 같은 코드도 실행할 때마다 다른 결과가 나올 수 있습니다. 개발 환경에서는 문제없다가 운영 환경에서 갑자기 발생하기도 합니다. 이런 비결정적 특성 때문에 디버깅이 매우 어렵습니다.실제 프로젝트에서 자주 발생하는 패턴들이 있습니다. Check-Then-Act 패턴이 대표적인데, 조건을 확인하고 행동하는 사이에 다른 스레드가 상태를 변경할 수 있습니다. 싱글톤 패턴의 이중 체크 잠금도 메모리 재정렬 때문에 문제가 될 수 있죠. 컨테이너를 순회하면서 수정하는 것도 반복자 무효화로 크래시를 일으킬 수 있습니다.해결 방법은 적절한 동기화입니다. 가장 기본적으로는 뮤텍스를 사용하여 임계 영역을 보호합니다. 단순한 변수는 atomic 타입을 사용하면 락 없이도 안전합니다. 더 나아가 불변 객체나 thread-local storage를 활용하면 공유 자체를 피할 수 있습니다.디버깅 팁으로는, ThreadSanitizer 같은 도구를 사용하면 레이스 컨디션을 자동으로 감지할 수 있습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/33.-레이스-컨디션에-대해-설명해주세요.html","pathToRoot":"..","attachments":[],"createdTime":1754545491063,"modifiedTime":1754545491063,"sourceSize":1826,"sourcePath":"CS/33. 레이스 컨디션에 대해 설명해주세요.md","exportPath":"cs/33.-레이스-컨디션에-대해-설명해주세요.html","showInTree":true,"treeOrder":115,"backlinks":[],"type":"markdown"},"cs/34.-포인터와-참조의-차이점.html":{"title":"34. 포인터와 참조의 차이점","icon":"","description":"포인터와 참조는 둘 다 간접 참조를 제공하지만, 사용 방식과 보장사항이 다릅니다.가장 큰 차이는 재할당 가능 여부입니다. 포인터는 다른 객체를 가리키도록 변경할 수 있지만, 참조는 한 번 바인딩되면 변경할 수 없습니다. 참조에 다른 값을 대입하면 참조 대상의 값이 변경되는 거지, 참조 자체가 바뀌는 게 아닙니다.NULL 가능성도 중요한 차이입니다. 포인터는 nullptr이 될 수 있어서 항상 유효성 검사가 필요합니다. 참조는 반드시 유효한 객체를 참조해야 하므로 NULL 체크가 필요 없습니다. 이 때문에 함수 매개변수로 NULL이 될 수 없는 경우 참조를 사용하면 더 안전합니다.선택 기준을 말씀드리면, 재할당이 필요하거나 NULL이 될 수 있으면 포인터를, 항상 유효한 객체를 가리키고 재할당이 불필요하면 참조를 사용합니다. STL 컨테이너는 참조를 저장할 수 없으므로 포인터를 사용합니다.실무에서 적용하는 규칙은, 함수 매개변수는 기본적으로 const 참조를 사용하고, 소유권 이전이 필요하면 스마트 포인터를, 선택적 매개변수면 포인터를 사용합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/34.-포인터와-참조의-차이점.html","pathToRoot":"..","attachments":[],"createdTime":1754545491063,"modifiedTime":1754545491063,"sourceSize":1277,"sourcePath":"CS/34. 포인터와 참조의 차이점.md","exportPath":"cs/34.-포인터와-참조의-차이점.html","showInTree":true,"treeOrder":116,"backlinks":[],"type":"markdown"},"cs/35.-가상-메모리는-무엇인가.html":{"title":"35. 가상 메모리는 무엇인가","icon":"","description":"가상메모리는 현대 운영체제의 핵심적인 메모리 관리 기법으로, 물리적 메모리의 한계를 극복하고 효율적인 메모리 사용을 가능하게 하는 추상화 계층입니다. 본질적으로 가상메모리는 각 프로세스에게 독립적이고 연속적인 주소 공간을 제공하되, 이것이 반드시 물리 메모리와 일대일 대응되지는 않습니다.가상메모리의 핵심 원리는 주소 변환(Address Translation)입니다. 프로그램이 사용하는 가상 주소(Virtual Address)는 MMU(Memory Management Unit)를 통해 실제 물리 주소(Physical Address)로 변환됩니다. 이 과정에서 페이지 테이블(Page Table)이 핵심적인 역할을 수행하며, 각 가상 페이지가 어떤 물리 프레임에 매핑되어 있는지, 혹은 현재 메모리에 로드되어 있는지를 추적합니다.C++ 개발자 관점에서 보면, new나 malloc()으로 할당받는 메모리 주소들이 모두 가상 주소입니다. 이는 프로세스 간 메모리 보호와 격리를 제공하며, 동시에 물리 메모리보다 큰 프로그램도 실행할 수 있게 해줍니다. 또한 같은 가상 주소라도 서로 다른 프로세스에서는 완전히 다른 물리 메모리 위치를 가리킬 수 있어, 메모리 보안과 안정성을 크게 향상시킵니다.페이지 폴트는 프로세스가 현재 물리 메모리에 로드되지 않은 페이지에 접근하려 할 때 발생하는 하드웨어 예외입니다. 이는 가상메모리 시스템의 핵심 메커니즘으로, 필요에 따라 페이지를 메모리에 로드하는 지연 로딩(Lazy Loading) 방식을 구현합니다.처리 과정은 다음과 같이 진행됩니다. 먼저 CPU가 가상 주소에 접근을 시도하면, MMU가 해당 주소의 페이지 테이블 엔트리를 확인합니다. 이때 페이지가 물리 메모리에 없다면(Present bit가 0), MMU는 페이지 폴트 예외를 발생시킵니다. 이는 하드웨어 인터럽트로서, 현재 실행 중인 명령어를 중단하고 운영체제의 페이지 폴트 핸들러로 제어권을 넘깁니다.운영체제의 페이지 폴트 핸들러는 먼저 폴트의 원인을 분석합니다. 정당한 메모리 접근인지(유효한 가상 주소 범위인지, 권한이 있는지 등) 확인한 후, 해당 페이지를 디스크의 스왑 영역이나 실행 파일에서 찾습니다. 만약 물리 메모리가 부족하다면, 페이지 교체 알고리즘(LRU, FIFO 등)을 통해 기존 페이지를 디스크로 내보내 공간을 확보합니다.이후 디스크 I/O를 통해 필요한 페이지를 물리 메모리로 로드하고, 페이지 테이블을 업데이트하여 가상 주소와 새로운 물리 주소의 매핑을 설정합니다. 마지막으로 페이지 폴트를 발생시킨 원래 명령어를 다시 실행하여 정상적인 메모리 접근이 완료됩니다.TLB 미스와 페이지 폴트는 모두 메모리 접근 과정에서 발생하는 예외 상황이지만, 그 성격과 처리 방식이 근본적으로 다릅니다.TLB(Translation Lookaside Buffer)는 최근에 사용된 주소 변환 정보를 캐싱하는 하드웨어 구조입니다. TLB 미스는 요청된 가상 주소의 변환 정보가 TLB에 없을 때 발생합니다. 이는 단순히 캐시 미스의 한 형태로, 해당 페이지가 물리 메모리에는 존재하지만 TLB에 정보가 없는 상황입니다. 처리 과정은 상대적으로 간단합니다. 하드웨어(또는 운영체제)가 페이지 테이블에서 해당 변환 정보를 찾아 TLB에 로드합니다. 이 과정은 메모리 접근 몇 번으로 해결되므로 보통 수십 CPU 사이클 내에 완료됩니다.반면 페이지 폴트는 훨씬 심각한 상황입니다. 요청된 페이지가 아예 물리 메모리에 존재하지 않아서, 디스크에서 해당 페이지를 읽어와야 합니다. 디스크 I/O는 CPU 사이클에 비해 극도로 느린 작업으로, 수십만에서 수백만 사이클이 소요될 수 있습니다. 이는 TLB 미스보다 1000배 이상 느린 것입니다.성능 관점에서 보면, TLB 미스는 빈번하게 발생해도 시스템 전체 성능에 미치는 영향이 제한적입니다. 반면 페이지 폴트는 한 번 발생할 때마다 상당한 성능 저하를 일으키므로, 효율적인 메모리 사용 패턴과 적절한 페이지 교체 알고리즘이 시스템 성능에 결정적인 영향을 미칩니다. C++ 개발자로서는 지역성(Locality)을 고려한 메모리 접근 패턴을 통해 두 종류의 미스를 모두 최소화할 수 있습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"페이지 폴트 처리 과정","level":2,"id":"페이지_폴트_처리_과정_0"},{"heading":"TLB 미스와 페이지 폴트의 차이점","level":2,"id":"TLB_미스와_페이지_폴트의_차이점_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/35.-가상-메모리는-무엇인가.html","pathToRoot":"..","attachments":[],"createdTime":1754545491063,"modifiedTime":1754545491063,"sourceSize":4787,"sourcePath":"CS/35. 가상 메모리는 무엇인가.md","exportPath":"cs/35.-가상-메모리는-무엇인가.html","showInTree":true,"treeOrder":117,"backlinks":[],"type":"markdown"},"cs/36.-static-키워드.html":{"title":"36. static 키워드","icon":"","description":"전역 변수? 정적 변수?","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/36.-static-키워드.html","pathToRoot":"..","attachments":[],"createdTime":1754545491063,"modifiedTime":1754545491064,"sourceSize":29,"sourcePath":"CS/36. static 키워드.md","exportPath":"cs/36.-static-키워드.html","showInTree":true,"treeOrder":118,"backlinks":[],"type":"markdown"},"cs/context-switching.html":{"title":"Context Switching","icon":"","description":"컨텍스트 스위칭은 CPU가 하나의 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 제어를 전환하는 과정이다.이 과정에서 현재 실행 중인 프로세스의 상태(컨텍스트)를 저장하고 다음에 실행할 프로세스의 상태를 불러온다.\n시분할(Time Sharing): 여러 프로세스가 CPU 시간을 공유하기 위해 운영체제가 주기적으로 스위칭\n인터럽트(Interrupt) 발생: 하드웨어 인터럽트, 소프트웨어 인터럽트 등이 발생했을 때\nI/O 요청: 프로세스가 입출력 작업을 요청했을 때(디스크 읽기/쓰기 등)\n동기화 이벤트: 세마포어 획득 대기, 뮤텍스 락 대기 등 현재 실행 중인 프로세스의 상태를 PCB에 저장\n해당 프로세스의 PCB를 프로세스 테이블에 업데이트\n다음 실행할 프로세스의 PCB를 프로세스 테이블에서 로드\n해당 PCB의 정보를 기반으로 CPU 레지스터, 메모리 맵 등을 복원 컨텍스트 스위칭을 하면 오버헤드가 발생할 수 밖에 없다. 프로세스가 전환되면 기존의 컨텍스트를 PCB에 저장하고 프로세스를 업데이트 하고 전환된 PCB를 로드해야하기 때문이다. (CPU 시간 소비)\n프로세스는 자신만의 메모리 공간을 사용하는데 이전\b 프로세스가 사용했던 CPU 캐시는 새 프로세스에게 유용하지 않다. 즉 캐시 미스가 증가한다.\n오버헤드를 줄이기 위해서 컨텍스트 스위칭을 최적화 하는 방법이 여러가지가 있는데 스레드 사용과 배치 처리가 있다.스레드를 사용하면 프로세스를 전환하는 것보다 오버헤드가 적다.\n스레드는 프로세스보다 적은 상태 정보를 저장한다.\n같은 프로세스 내 스레드들은 메모리 공간을 공유하므로 전체 주소 공간(코 데 힙) 전환 이 필요 없다. (스택 영역은 독립적이라 변경 필요)\n스레드간 전환 시 캐시 재사용 가능성 높아짐\n배치 처리는 요청을 묶어서 한번에 처리해 컨텍스트 스위칭 횟수 자체를 줄이는 방법이다.\n시스템 콜: 여러 개의 시스템 호출을 하나로 묶어 커널 모드로의 전환 횟수 감소\nI/O 작업 최적화: 여러 I/O 작업을 한 번에 수행하여 블로킹으로 인한 컨텍스트 스위칭 감소\n자원 할당: 자원 할당/해제 과정에서 발생하는 컨텍스트 스위칭 최소화\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"컨텍스트 스위칭 발생 원인","level":4,"id":"컨텍스트_스위칭_발생_원인_0"},{"heading":"컨텍스트 스위칭 과정","level":4,"id":"컨텍스트_스위칭_과정_0"},{"heading":"오버헤드","level":4,"id":"오버헤드_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/context-switching.html","pathToRoot":"..","attachments":[],"createdTime":1742749871667,"modifiedTime":1742751866920,"sourceSize":2626,"sourcePath":"CS/Context Switching.md","exportPath":"cs/context-switching.html","showInTree":true,"treeOrder":119,"backlinks":[],"type":"markdown"},"cs/deadlock.html":{"title":"Deadlock","icon":"","description":"Deadlock (교착상태)의 4가지 필수 조건 자원은 한 번에 하나의 프로세스만 사용 해야한다. 자원이 공유되지 않고 독점적으로 사용할 수 있어야 한다. 프로세스가 이미 일부 자원을 점유한 상태라면 다른 프로세스가 사용 중인 자원을 요청하고 대기하는 상태다. 프로세스가 자원을 스스로 반납하기 전까지 다른 프로세스가 강제로 빼앗을 수 없다. 프로세스들이 순환적으로 다른 프로세스가 요구하는 자원을 가지고 있는 상황이다. 예를 들면 A는 B의 자원을 기다리고, B는 C의 자원을 기다리고, C는 A의 자원을 기다리는 경우다.데드록을 예방하려면 네가지 조건 중 최소한 하나를 제거 해야한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. Mutual Exclusion","level":4,"id":"1._Mutual_Exclusion_0"},{"heading":"2. Hold and Wait","level":4,"id":"2._Hold_and_Wait_0"},{"heading":"3. No Preemption","level":4,"id":"3._No_Preemption_0"},{"heading":"4. Circular Wait","level":4,"id":"4._Circular_Wait_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/deadlock.html","pathToRoot":"..","attachments":[],"createdTime":1742749398018,"modifiedTime":1742749767776,"sourceSize":883,"sourcePath":"CS/Deadlock.md","exportPath":"cs/deadlock.html","showInTree":true,"treeOrder":120,"backlinks":[],"type":"markdown"},"cs/floating-point.html":{"title":"Floating Point","icon":"","description":"float는 4byte = 32bit다. 32개의 비트는 아래처럼 구성되어 있다.\n1 비트: 부호비트\n8 비트: 지수부\n23 비트: 가수부 (fraction)\n\b실제 값은 (-1)^(부호) 1.가수부 2^(지수부 -127)로 계산할 수 있다.실제 값을 구할 때는 지수부를 저장할 때 127 편향값을 더하는 과정이 있어서 -127를 빼는 것임2.5 변환 과정을 보자.\n2.5를 이진법으로 나타내면 10.1\n정규화하면 1.01 * 2^1 : 여기에서 실제 지수는 1이지만 편향값 127을 더해서 128을 얻음\n32bit 표현\n1비트: 0 (양수)\n8비트: 지수부 - 128의 이진수(10000000)\n23비트: 가수부 - 01000000000000000000000 ( 01 + 빈자리 0 21개)\n결과: 0 10000000 01000000000000000000000 소수점 이하 손실\nfloat이 int의 범위를 초과할 수 있음 (clang 17 기준으로 int max로 초기화 됨)\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\nint main() { float float_a = std::numeric_limits&lt;float&gt;::max(); int int_a = 0; std::cout &lt;&lt; float_a &lt;&lt; std::endl; // 3.40282e+38 std::cout &lt;&lt; int_a &lt;&lt; std::endl; // 0 int_a = float_a; // 2147483647 std::cout &lt;&lt; int_a &lt;&lt; std::endl; return 0;\n}\n아래 코드는 애매하다. c의 값에 따라 true false가 변하니 프로그램을 예측 할 수가 없다. 이런 부작용을 줄이기 위해서는 엡실론을 사용하자.#include &lt;iostream&gt;\n#include &lt;limits&gt; int main() { float b = 0.2345; float c = 0.2345001; if (b == c) { std::cout &lt;&lt; \"b == c\" &lt;&lt; std::endl; // c가 0.23450001인 경우 } else { std::cout &lt;&lt; \"b != c\" &lt;&lt; std::endl; // c가 0.2345001인 경우 } return 0;\n}\n엡실론은 개발자가 정의 해도 되고 limits에 정의된 엡실론을 사용해도 된다. limits에 정의된 엡실론은 시스템에 맞는 적절한 엡실론 값이다. 일반적으로\b는 32비트 float의 경우 약 1.19209e-7 값을 가진다고 한다.#include &lt;iostream&gt;\n#include &lt;limits&gt; const float epsilon = 0.0000001; int main() { float b = 0.2345; float c = 0.234501; if (std::fabs(b - c) &lt; epsilon) { std::cout &lt;&lt; \"b == c\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"b != c\" &lt;&lt; std::endl; } if (std::fabs(b - c) &lt; std::numeric_limits&lt;float&gt;::epsilon()) { std::cout &lt;&lt; \"b == c\" &lt;&lt; std::endl; } else { std::cout &lt;&lt; \"b != c\" &lt;&lt; std::endl; } return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"floating point의 메모리 구조","level":4,"id":"floating_point의_메모리_구조_0"},{"heading":"int로 캐스팅할 때 발생할 수 있는 문제점","level":4,"id":"int로_캐스팅할_때_발생할_수_있는_문제점_0"},{"heading":"값을 비교 및 사칙연산을 할 때 부작용을 줄일 수 있는 방법","level":4,"id":"값을_비교_및_사칙연산을_할_때_부작용을_줄일_수_있는_방법_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/floating-point.html","pathToRoot":"..","attachments":[],"createdTime":1742708090950,"modifiedTime":1742751879138,"sourceSize":2600,"sourcePath":"CS/Floating Point.md","exportPath":"cs/floating-point.html","showInTree":true,"treeOrder":121,"backlinks":[],"type":"markdown"},"cs/pseudo-random-(의사-난수).html":{"title":"Pseudo random (의사 난수)","icon":"","description":"왜 의사 난수라고 하는가? 어떻게 하면 진짜 난수를 추출할 수 있는가?의사 난수라고 하는 이유는 \b컴퓨터 알고리즘으로 생성되는 난수는 수학적 공식에 따라 결정적으로 생성되기 때문이다. 이러한 난수 수열은 시드를 기반으로 해서 생성된다. 만약 같은 시드라면 동일한 수열이 생성된다.의사 난수의 문제점은 시드와 알고리즘을 안다면 난수 시퀀스를 예측할 수 있고 알고리즘이기 때문에 값의 bias (편향성)이 있을 수 있다.C++에서 난수를 생성하는 방법은 주로 random의 std::random_device를 사용하는 것이다. 이것은 수학적 알고리즘을 통해 생성되는 가짜 난수가 아니라 정말로 컴퓨터가 실행 되면서 마주치는 무작위적인 요소들 (예를 들어 장치 드라이버들의 noise) 을 기반으로한 진짜 난수를 제공한다.다만 이 방식은 의사난수 생성보다 느리다. 그래서 보통 시드만 '진짜 난수'로 생성하고 의사 난수 생성기를 통해 난수를 생성한다. 보통 C++ 표준 라이브러리에 포함된 메르센 트위스터(Mersenne Twister) 의사난수 생성기 std::mt19937를 사용함. #include &lt;iostream&gt;\n#include &lt;random&gt; int main(int argc, char *argv[]) { std::random_device rd; std::cout &lt;&lt; \"Entropy: \" &lt;&lt; rd.entropy() &lt;&lt; std::endl; std::mt19937 gen(rd()); std::uniform_int_distribution&lt;&gt; distrib(1, 6); for (int i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; distrib(gen); } return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"의사 난수","level":3,"id":"의사_난수_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"cs/pseudo-random-(의사-난수).html","pathToRoot":"..","attachments":[],"createdTime":1742744578859,"modifiedTime":1742745104423,"sourceSize":1604,"sourcePath":"CS/Pseudo random (의사 난수).md","exportPath":"cs/pseudo-random-(의사-난수).html","showInTree":true,"treeOrder":122,"backlinks":[],"type":"markdown"},"cs/리틀-앤디언과-빅-앤디언.html":{"title":"리틀 앤디언과 빅 앤디언","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/리틀-앤디언과-빅-앤디언.html","pathToRoot":"..","attachments":[],"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":0,"sourcePath":"CS/리틀 앤디언과 빅 앤디언.md","exportPath":"cs/리틀-앤디언과-빅-앤디언.html","showInTree":true,"treeOrder":123,"backlinks":[],"type":"markdown"},"cs/캐시-전략.html":{"title":"캐시 전략","icon":"","description":"LRU 캐시(Least Recently Used Cache)LRU 캐시는 한정된 저장 공간(capacity)을 갖는 캐시에서, 가장 오랫동안 사용되지 않은 항목을 우선적으로 제거하는 방식의 자료 구조","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"cs/캐시-전략.html","pathToRoot":"..","attachments":[],"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":215,"sourcePath":"CS/캐시 전략.md","exportPath":"cs/캐시-전략.html","showInTree":true,"treeOrder":124,"backlinks":[],"type":"markdown"},"csharp/linq.html":{"title":"LINQ","icon":"","description":"Swift에서&nbsp; map(), filter() 같은&nbsp;고차함수를 많이 사용했었어요. C#으로 처음 PS를 풀 때 map을 사용하고 싶어서 c# map function으로 구글링 했을 때&nbsp; LINQ의 Select() 메서드를 사용하라고 하더군요. 'Select이 뭐지?' 했는데 데이터베이스 시간에 SQL로 열심히 실습할 때 나오는 그 select가 동일합니다. 그럼 LINQ가 뭘까요?LINQ는 Language-Integrated Query의 준말로 C#에서 직접 쿼리 기능을 통합하는 방식을 기반으로 하는 기술 이름이에요. 일반적으로 쿼리는 특수화된 쿼리 언어로 표현되어요. 예를 들면 관계형 데이터베이스에서는 SQL, XML에서는 XQuery가 사용됩니다. 그래서 하나의 형식을 사용할 때마다 하나의 쿼리 언어를 학습할 필요가 생기는 거죠. 그래서 LINQ가 등장하게 되었어요. LINQ는 다양한 데이터 소스 및 다양한 형식에 사용할 수 있는 일관된 모델을 제공합니다. 모든 형식에서 같은 방식으로 데이터를 쿼리하고 변환할 수 있게 됩니다.&nbsp;LINQ는 쿼리군요.&nbsp; 그럼 쿼리는 무엇일까요?&nbsp;\n쿼리는 데이터 소스에서 검색할 데이터 및 반환된 데이터에 필요한 모양과 구성을 설명하는 지침 집합이다.\n쉽게 풀면 쿼리는 데이터 소스에서 데이터를 검색(추출)하는 식입니다. (쿼리를 통해 검색된 결과가 아님을 주의)C#에서 쿼리(LINQ)를 어떻게 이용할 수 있을까요?&nbsp; LINQ는 세가지 작업으로 구성됩니다!1.&nbsp; 데이터 소스 가져오기 쿼리 만들기 쿼리 실행 데이터 소스는 말 그대로 우리가 쿼리하고 싶은 데이터 모음입니다. 단 쿼리 변수의 타입이&nbsp;IEumerable 또는 IQueryable이므로 이것을 두 타입 중 하나를 컨펌해야만 합니다.&nbsp;List와 Array와 같은 컬렉션 타입은 IEnumerable을 컨펌하고 있기 때문에 데이터 소스로 사용할 수 있어요. 또 관계형 데이터 베이스나, XML과 같은 것들을 IEumerable 또는 IQueryable로 로드를 하거나 맵핑을 해서 데이터 소스로 사용할 수 있습니다.// Array int[] numbers = new int[7] { 0,1,2,3,4,5,6 }; IEumerable&lt;int&gt; numQuery = from number in numbers where (number % 2) == 0 select number;\n// LINQ to XML\n// Create a data source from an XML document.\n// using System.Xml.Linq;\nXElement contacts = XElement.Load(@\"c:\\myContactList.xml\"); IQueryable&lt;Contract&gt; contractQuery = from contract in contracts where ... select ...\n// LINQ to SQL Mapping Northwnd db = new Northwnd(@\"c:\\northwnd.mdf\"); // Query for customers in London.\nIQueryable&lt;Customer&gt; custQuery = from cust in db.Customers where cust.City == \"London\" select cust;\n이제 쿼리 변수를 만들겠습니다.쿼리 변수를 만드는 방법은 두가지가 있습니다. 쿼리 구문을 이용해서! 메서드 구문을 이용해서! 그럼 1번 2번을 두개 다 연습을 해볼게요. 연습을 하기 전에 데이터 소스를 먼저 만들어줍시다.// Teacher.cs public class Teacher\n{ public string Name { get; set; } public int ID { get; set; } public decimal Salary { get; set; } public Teacher(string name, int id, decimal salary) { Name = name; ID = id; Salary = salary; }\n} // Student.cs public class Student\n{ public string Name { get; set; } public int ID { get; set; } public List&lt;int&gt; scroes { get; set; } public Student(string name, int id, List&lt;int&gt; scroes) { Name = name; ID = id; this.scroes = scroes; }\n} // Program.cs namespace TestLINQ\n{ class Program { static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); } public static void SeedData(List&lt;Student&gt; students, List&lt;Teacher&gt; teachers) { List&lt;Student&gt; _students = new List&lt;Student&gt;() { new Student(\"김수로\", 0, new() { 90, 95,70,50, 87}), new Student(\"박혁거세\", 1, new() { 80, 45,95,80, 75}), new Student(\"이은혜\", 2, new() { 83, 63,89,93, 63}), new Student(\"이근왕\", 3, new() { 55, 77,77,31, 90}), new Student(\"선우현\", 4, new() { 100, 15,25,36, 57}), }; foreach (var s in _students) { students.Add(s); } List&lt;Teacher&gt; _teachers = new List&lt;Teacher&gt;() { new Teacher(\"김철수\", 5, 10000), new Teacher(\"이진혜\", 6, 20000), new Teacher(\"김왕심\", 7, 30000), new Teacher(\"박수빈\", 8, 40000), new Teacher(\"손을왕\", 9, 50000), }; foreach (var t in _teachers) { teachers.Add(t); } } }\n}\n혹시 SQL을 사용한 경험이 있으신가요?SQL처럼 select where from을 이용해서 쿼리 하는 방식이 쿼리 구문을 이용하는 방법입니다. SQL과 차이점이라면 순서가 반대라는 것!쿼리 구문은 아래와 같은 형식을 가집니다.\n쿼리 구문은 반드시 from절로 시작해야 함\n쿼리 구문은 반드시 select절 또는 group절로 끝나야 함.\n첫 번째 from절과 마지막 select절 또는 group절 사이에 where, orderby, join, let절과 추가 from절들이 하나 이상 들어갈 수 있음.\n첫 번째 예시는 첫번째 시험에서 90점 이상을 맞은 학생들을 검색하는 쿼리 변수를 만들게요. static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); IEnumerable&lt;Student&gt; notLessThan90 = from student in students where (student.scroes[0] &gt;= 90) select student; Console.WriteLine(\"첫번째 시험에서 90점 이상 맞은 학생들\"); foreach (Student student in notLessThan90) { Console.WriteLine(\"{0}, {1}\", student.Name, student.scroes[0]); }\n쿼리 구문을 이용하면 상당히 직관적으로 데이터를 추출할 수 있네요. 기본적인 구조는 이해하는데 문제가 없을 것 같아요.추가로 정렬을 의미하는 orderby도 한번 사용해 볼게요. Student에서 성이 이씨인 사람들을 뽑을건데 ID를 내림차순으로 정렬해보도록 하겠습니다. IEnumerable&lt;Student&gt; descendingByID = from student in students where (student.Name[0].ToString() == \"이\") orderby student.ID descending select student; Console.WriteLine(\"학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬\"); foreach (Student student in descendingByID) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); }\n되게 간단하네요.&nbsp; 마지막으로 select 대신에 group을 한번 사용해볼게요.Student 리스트에서 성으로 그룹핑을 하겠습니다. Console.WriteLine(\"학생들의 성으로 그룹화\"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstName= from student in students group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstName) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); } } Console.WriteLine(\"학생들의 성으로 내림차순으로 정렬 및 그룹화\"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescending= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescending) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); } }\n보시다시피 group을 사용하면 IGrouping을 반환해서 네스트 타입이 되네요. 일일이 타입을 적어주는 게 불편한 경우도 있죠. 그런 경우에는 암묵적 형식인 var 키워드를 사용해도 됩니다. var groupByFirstNameDescending2= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (var group in groupByFirstNameDescending2) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); } } }\n위에서 쿼리를 쿼리 구문을 이용해서 작성해 봤어요.&nbsp;쿼리 구문은 코드를 컴파일할 때 .NET CLR(공용 언어 런타임)에 대한 메서드 호출로 변환해야 합니다. 이러한 메서드 호출은&nbsp;Where,&nbsp;Select,&nbsp;GroupBy,&nbsp;Join,&nbsp;Max,&nbsp;Average&nbsp;등과 같은 표준 쿼리 연산자를 호출한다고 하네요. 따라서 우리는 쿼리 구문 대신 메서드 구문을 사용하여 연산자를 직접 호출할 수도 있어요.쿼리 구문과 메서드 구문은 의미상 동일하지만, 쿼리 구문이 더 간단하고 읽기 쉽다고 생각하는 사람이 많다고 합니다. 저도 쿼리 구문이 더 읽기가 쉬웠어요. 그러나 일부 쿼리는 메서드 호출로 표현해야 합니다. 예를 들어 필터를 하는 쿼리에서 요소 개수 또는 최댓값등을 얻으려면 메서드 호출을 사용해야 해요. 따라서 LINQ 쿼리를 작성하기 시작한 경우에도 쿼리 및 쿼리 식 자체에서 메서드 구문을 사용하는 방법을 잘 알고 있으면 유용합니다.위에서 쿼리 구문으로 작성한 쿼리를 메서드 문법으로 작성해 볼게요. // 메서드 구문 이용 Console.WriteLine(\"메서드 구문 이용해서\"); IEnumerable&lt;Student&gt; notLessThan90Method = students.Where(student =&gt; student.scroes[0] &gt;= 90); Console.WriteLine(\"첫번째 시험에서 90점 이상 맞은 학생들\"); foreach (Student student in notLessThan90Method) { Console.WriteLine(\"{0}, {1}\", student.Name, student.scroes[0]); } IEnumerable&lt;Student&gt; descendingByIDMethod = students.Where(student =&gt; student.Name[0].ToString() == \"이\").OrderByDescending(student =&gt; student.ID); // from student in students // where (student.Name[0].ToString() == \"이\") // orderby student.ID descending // select student; Console.WriteLine(\"학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬\"); foreach (Student student in descendingByIDMethod) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); } Console.WriteLine(\"학생들의 성으로 그룹화\"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameMethod = students.GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); } } Console.WriteLine(\"학생들의 성으로 내림차순으로 정렬 및 그룹화\"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescendingMethod = students.OrderByDescending(student =&gt; student.Name[0].ToString()) .GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescendingMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine(\"{0}, {1}\", student.Name, student.ID); } }\n마지막으로 Concat() 메서드를 이용해서 학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID를 추출하겠습니다. Console.WriteLine(\"학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID\"); var oddIDInTeacherAndStudent = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)); foreach (var id in oddIDInTeacherAndStudent) { Console.WriteLine(id); }\n위에서 쿼리 변수를 열심히 만들어서 출력해 봤는데요. 항상 맨 밑에 foreach가 존재합니다. 쿼리 변수는 사실 결과 데이터를 가지고 있지 않아요. 그저 명령만을 가지고 있습니다.&nbsp; 실제로 데이터를 얻기 위해서는 쿼리 실행을 해줘야 합니다. 쿼리 실행 하는 법은 foreach를 사용해서 루프를 돌게 하면 되겠습니다.즉시 실행을 하기 위해서는 Count(), Average(), Max() 등 결과를 얻기 위해 foreach를 암묵적으로 사용하는 메서드 문법을 사용하거나, ToList, ToArray 같은 것을 사용해서 결과를 바로 캐시 하는 방법을 사용하면 됩니다. var oddIDCount = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).Count(); Console.WriteLine(oddIDCount); var oddIDList = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).ToList(); Console.WriteLine(String.Join(\" \", oddIDList));\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/LINQ_Practice\" target=\"_self\">https://github.com/psychehose/LINQ_Practice</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/\" target=\"_self\">https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"LINQ?","level":4,"id":"LINQ?_0"},{"heading":"데이터 소스 가져오기","level":3,"id":"데이터_소스_가져오기_0"},{"heading":"쿼리 만들기","level":3,"id":"쿼리_만들기_0"},{"heading":"1. 쿼리 구문을 이용","level":4,"id":"1._쿼리_구문을_이용_0"},{"heading":"2. 메서드 구문을 이용","level":4,"id":"2._메서드_구문을_이용_0"},{"heading":"쿼리 실행","level":3,"id":"쿼리_실행_0"},{"heading":"GitHub","level":4,"id":"GitHub_0"},{"heading":"Ref","level":4,"id":"Ref_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"csharp/linq.html","pathToRoot":"..","attachments":[],"createdTime":1735624836303,"modifiedTime":1735624866986,"sourceSize":15206,"sourcePath":"csharp/LINQ.md","exportPath":"csharp/linq.html","showInTree":true,"treeOrder":126,"backlinks":[],"type":"markdown"},"docker/1.-basic.html":{"title":"1. basic","icon":"","description":"brew install --cask docker\ndocker -v # docker 설치 확인\ndocker search ubuntu # ubuntu 이미지 검색\ndocker pull ubuntu:22.04 #specific version\ndocker run -it ubuntu:22.04 /bin/bash # 도커 컨테이너 생성 및 시작\n# 패키지 목록 업데이트\napt update # zsh 및 git, curl 등등 필요한 도구 설치\napt install -y zsh curl git build-essential vim # Oh My Zsh 설치 (선택사항)\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\ndocker ps\ndocker ps -a # 꺼져있는 컨테이너도 조회됨.\ndocker commit [컨테이너ID] my-ubuntu:1.0 # {name}:{version}\ndocker는 exit를 입력하면 종료됨. 삭제 되는게 아닌 컨테이너가 종료됨. run: 만들면서 실행\nstart: 종료된 컨테이너 실행\n$ docker start -i {name} # 이름으로\n$ docker start -i {container_id} #id로\n처음 run할 때 --name 지정 안하면 랜덤으로 지정됨 그래서 바꿔야함docker rename {old} {new}\ndocker rm {docker_container_name}\ndocker exec -it {컨테이너_이름} bash -c \"{command}\"\n# docker exec -it {컨테이너_이름} bash -c \"cd /workspace &amp;&amp; ./build.sh -c -g Ninja\" 도커 컨테이너 종료: exit\n도커 컨테이너 유지 &amp; 터미널 세션은 종료: Ctrl + P + Ctrl + Q\n터미널 세션 다시 실행: docker exec -it {container_name} bash\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"도커 설치","level":3,"id":"도커_설치_0"},{"heading":"초기설정","level":3,"id":"초기설정_0"},{"heading":"패키지 설치 및 설정","level":3,"id":"패키지_설치_및_설정_0"},{"heading":"컨테이너 아이디 확인 (다른 터미널 세션에서)","level":3,"id":"컨테이너_아이디_확인_(다른_터미널_세션에서)_0"},{"heading":"컨테이너 커밋","level":3,"id":"컨테이너_커밋_0"},{"heading":"컨테이너 실행","level":3,"id":"컨테이너_실행_0"},{"heading":"컨테이너 이름 변경","level":3,"id":"컨테이너_이름_변경_0"},{"heading":"컨테이너 삭제","level":3,"id":"컨테이너_삭제_0"},{"heading":"호스트 터미널에서 도커 환경 실행하기","level":3,"id":"호스트_터미널에서_도커_환경_실행하기_0"},{"heading":"터미널에서 도커 컨테이너 종료","level":3,"id":"터미널에서_도커_컨테이너_종료_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"docker/1.-basic.html","pathToRoot":"..","attachments":[],"createdTime":1740931213902,"modifiedTime":1740931213902,"sourceSize":1839,"sourcePath":"docker/1. basic.md","exportPath":"docker/1.-basic.html","showInTree":true,"treeOrder":128,"backlinks":[],"type":"markdown"},"docker/2.-도커-컨테이너-환경-구축.html":{"title":"2. 도커 컨테이너 환경 구축","icon":"","description":"C++ 크로스 플랫폼 프로젝트를 컴파일 하기 위한 구축\nos: ubuntu 22.04 LTS\nlanguage: Clang++\nbuild generator: cmake\nDockerFile을 작성해서 이미지 설정을 한다.#base 22.04 LTS\nFROM ubuntu:22.04 # package install RUN apt-get update &amp;&amp; apt-get install -y \\ build-essential \\ clang \\ clang-format \\ clang-tidy \\ cmake \\ curl \\ git \\ lldb \\ ninja-build \\ pkg-config \\ tar \\ unzip \\ wget \\ libssl-dev \\ &amp;&amp; apt-get clean \\ &amp;&amp; rm -rf /var/lib/apt/lists/* # apt-get clean, rm -rf /var/lib/apt/lists/* 를 하면 패키지 파일을 설치 과정에서 다운로드된 `.deb` 패키지 파일을 제거 # 작업 디렉토리 설정 == mkdir workspace &amp;&amp; cd /workspace랑 같음\nWORKDIR /workspace # 환경 변수 설정\nENV CC=clang\nENV CXX=clang++ # Host 프로젝트 소스코드가 이 경로에 들어갈 거임. shared 폴더로 지정한다는것\n# docker run할 때 외부 폴더 (호스트의 소스코드 디렉토리)랑 연결할 수 있음\nVOLUME [\"/workspace\"] # 기본 실행 명령어 설정\nCMD [\"/bin/bash\"]\nDockerfile을 이용해서 이미지를 빌드한다.$ docker build -t {도커이미지_이름} {도커파일 경로} # t는 tag의 약자임.\n# cd {docker file path}\n# docker build -t my-docker .\n빌드된 도커이미지로 도커 컨테이너 생성docker run -it --name {container_name} -v {host_path}:/workspace {image_name} #docker run -it --name maxflight-container -v ~/Labs/MaxFlight:/workspace maxflight-dev -it: 대화형 터미널 사용\n--name maxflight-container: 컨테이너에 이름 부여 안할시에 랜덤 지정됨\n-v ~/Labs/MaxFlight:/workspace: 공유 폴더 연결 호스트의 프로젝트 디렉토리를 컨테이너의 /workspace에 마운트함. 호스트랑 폴더 sync 됨 maxflight-dev: 빌드한 도커 이미지 이름\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"docker/2.-도커-컨테이너-환경-구축.html","pathToRoot":"..","attachments":[],"createdTime":1740931213902,"modifiedTime":1740931213902,"sourceSize":1942,"sourcePath":"docker/2. 도커 컨테이너 환경 구축.md","exportPath":"docker/2.-도커-컨테이너-환경-구축.html","showInTree":true,"treeOrder":129,"backlinks":[],"type":"markdown"},"flutter/0.-setup.html":{"title":"0. setup","icon":"","description":"vscode를 이용해서 설치\n플러터 익스텐션 설치\ncommand + shift + p\nflutter 검색\nFlutter: New Project 선택\nDownload SDK 선택 후 위치는 ~/Develop으로 지정\n$ flutter doctor -v\n찾을 수 없는 명령어면 환경변수에 지정$ echo 'export PATH=$PATH:~/Develop/flutter/bin' &gt;&gt; ~/.zshrc\n그런 다음에 flutter doctor -v를 하면 플러터 개발시 필요한 도구들을 알려줌.그에 맞게 업데이트 하거나 설치를 하면 됨.나 같은 경우는 CocoaPods의 버전을 업데이트 (1.12.1 -&gt; 1.16.2)로 해줘야하고, 안드로이드 툴체인을 설치 해야한다.나는 예전에 cocoapods을 설치했을 때 homebrew를 이용해서 설치했기 때문에 homebrew를 통해서 업그레이드 했다.$ brew upgrade cocoapods\n안드로이드 툴체인은 안드로이드 스튜디오를 다운로드 하고 아래 구성요소를 설치하면 됨\nAndroid SDK Platform, API 35.0.2\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"CocoaPods update","level":4,"id":"CocoaPods_update_0"},{"heading":"Android toolchain","level":4,"id":"Android_toolchain_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/0.-setup.html","pathToRoot":"..","attachments":[],"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":1160,"sourcePath":"flutter/0. setup.md","exportPath":"flutter/0.-setup.html","showInTree":true,"treeOrder":131,"backlinks":[],"type":"markdown"},"flutter/animation.html":{"title":"Animation","icon":"","description":"\nlate AnimationController _animationController;\nlate Animation&lt;double&gt; _fadeAnimation; _animationController = AnimationController( duration: const Duration(milliseconds: 1000), vsync: this, ); _fadeAnimation = Tween&lt;double&gt;(begin: 0.0, end: 1.0).animate( CurvedAnimation(parent: _animationController, curve: Curves.easeInOut), ); _animationController.forward();\nAnimationController는 애니메이션의 전반적인 제어를 담당함.AnimationController\nduration\n시작 (forward), 중지 (stop), 반복(repeat), 역재생(reverse) 등\nvsync: 애니메이션이 화면의 새로고침 주기에 맞춰 실행되도록 동기화하는 역할\n없는 경우 버벅임, 부자연스러울 수 있음\nthis를 사용하기 위해서 with TickerProviderStateMixin가 필요 Animation 객체\n실제로 어떤 값이 변할지를 정의하는 추상화된 객체\nCurvedAnimation\n애니메이션에 속도감을 부여함\nparent를 지정해줘야함. (어떤 제어를 받을 지)\nbegin:0.0, end: 1.0 이라는 건 처음 상태를 0으로 설정하고 끝을 1.0으로 설정하겠다는 것\nCurve 종류 (In은 가속, Out은 감속으로 생각하면 됨) easeInOut :애니메이션이 천천히 시작해서 중간에 가속 끝날 때 다시 천천히 멈추는 것\neaseIn: 점점 빠르게\neaseOut: 점점 느리게\nbound: 통통 튀는 효과\netc.. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/animation.html","pathToRoot":"..","attachments":[],"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":1448,"sourcePath":"flutter/Animation.md","exportPath":"flutter/animation.html","showInTree":true,"treeOrder":132,"backlinks":[],"type":"markdown"},"flutter/appbar.html":{"title":"AppBar","icon":"","description":"Scaffold 위젯의 appBar 속성에 설정되어 화면 상단의 앱바를 구성함.예시appBar: AppBar( // 1. 타이틀 설정 title: const Text( 'Card Collection', style: TextStyle(fontWeight: FontWeight.bold), ), // 2. 배경색 backgroundColor: Colors.white, // 3. 전경색 (아이콘, 텍스트 기본 색상) foregroundColor: Colors.black87, // 4. 그림자 깊이 elevation: 0, // 5. 오른쪽 액션 버튼들 actions: [ IconButton(onPressed: () {}, icon: const Icon(Icons.search)), IconButton(onPressed: () {}, icon: const Icon(Icons.filter_list)), ],\n),\n다양한 속성 제공을 하는데 잘 이용하면 거의 모든 디자인 구현 가능함. 왼쪽 영역 (Leading Area) leading: 제목 영역 왼쪽에 표시되는 위젯 (보통 뒤로가기 버튼 넣음)\nautomaticallyImplyLeading: leading 위젯을 자동으로 추가할지 결정하는 bool 값\n기본 값 true, 다른화면에서 현재 화면으로 이동했을 때 자동으로 뒤로가기 버튼 생성해줌 제목 영역 (title area) title: 제목 영역에 표시되는 위젯 (보통 Text 넣음)\ncenterTitle: 제목을 가운데로 정렬할 지 결정하는 bool 값 (안드로이드 기본 값: false, iOS: true)\ntitleSpacing: 제목 주변의 수평 간격(여백)을 조절함. titleSpacing: 0인 경우 제목 왼쪽의 여백을 없애는 거임. 레이아웃 및 크기: 앱 바의 전체적인 구조와 크기 변경 toolbarHeight: 앱 바의 기본 높이 조절 기본값(56.0)\nbottom: 앱 바의 메인 영역 바로 아래에 위젯 추가 주로 Tab을 넣어서 탭 레이아웃을 만들 때 사용하는듯\nbottom에 위젯을 넣는다면 그 만큼 높이가 늘어남 고급 효과 및 스타일 flexibleSpace: 앱 바의 배경 영역을 채우는 위젯\n주로 스크롤과 함께 동적으로 변하는 배경(예시: 이미지가 점점 작아지는 효과)를 만들 때 FlexibleSpaceBar 위젯과 함께 사용됨 shape: 앱 바의 모양을 사각형이 아닌 다른 형태로 바꿀 수 있음\nsystemOverlayStyle: 앱바 위에 있는 디바이스 상태 표시줄 스타일을 제어함\n예시 flexibleSpace: FlexibleSpaceBar( title: Text(\"Parallax Effect\"), background: Image.network( 'https://picsum.photos/400/200', fit: BoxFit.cover, ),\n), // 앱 바 하단 모서리를 둥글게 깎기\nshape: RoundedRectangleBorder( borderRadius: BorderRadius.vertical( bottom: Radius.circular(30), ),\n), // 앱 바가 어두워서 상태 표시줄 아이콘을 밝게 만들어야 할 때\nsystemOverlayStyle: SystemUiOverlayStyle.light,\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/appbar.html","pathToRoot":"..","attachments":[],"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":2737,"sourcePath":"flutter/AppBar.md","exportPath":"flutter/appbar.html","showInTree":true,"treeOrder":133,"backlinks":[],"type":"markdown"},"flutter/build-context.html":{"title":"Build Context","icon":"","description":"Flutter 앱 위젯 트리 구조로 이뤄져있음. BuildContext는 이 트리 안에서 현재 위젯이 어디에 위치하고 있는지에 대한 정보를 담고 있는 객체임. 즉 위젯 트리내에 존재하는 주소 정보라고 생각하면 될 듯build()에서 BuildContext 파라미터가 필요한 이유는 이 주소에서의 Widget을 그려야하기 때문이라고 생각하면 됨.주로 위젯 트리를 거슬러 올라가서 조상을 찾아 필요한 정보를 얻는데 사용된다.\nTheme(테마) 정보 얻기\nColor primaryColor = Theme.of(context).primaryColor; 다른 페이지로 이동하기\nNavigator.of(context).push(MaterialPageRoute(builder: (context) =&gt; CountPage())); Scaffold의 기능 사용하기 (SnackBar, Drawer 등)\nScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text('안녕하세요!'))\n);\ncontext는 위치에 따라 다르다것을 주의해야함. BuildContext는 특정 위젯의 build 메서드에 의해 생성된 위젯의 것임.@override\nWidget build(BuildContext context) { // 이 context는 Scaffold를 만드는 위젯의 것. // 아직 Scaffold가 트리에 존재하지 않음. return Scaffold( body: ElevatedButton( onPressed: () { // 이 context를 사용하면 조상 중에 Scaffold를 찾을 수 없어 에러 발생! ScaffoldMessenger.of(context).showSnackBar(...); }, child: Text('Show SnackBar'), ), );\n} // 올바른 코드 @override\nWidget build(BuildContext context) { return Scaffold( body: Builder( // 이 builder는 Scaffold의 자식으로 실행되므로, 새로운 context를 가짐. builder: (BuildContext innerContext) { return ElevatedButton( onPressed: () { // 이 innerContext는 Scaffold보다 아래에 있으므로, // 조상을 거슬러 올라가 Scaffold를 찾을 수 있음! ScaffoldMessenger.of(innerContext).showSnackBar(...); }, child: Text('Show SnackBar'), ); }, ), );\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Build Context로 할 수 있는 것","level":3,"id":"Build_Context로_할_수_있는_것_0"},{"heading":"중요한 규칙","level":3,"id":"중요한_규칙_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/build-context.html","pathToRoot":"..","attachments":[],"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":2187,"sourcePath":"flutter/Build Context.md","exportPath":"flutter/build-context.html","showInTree":true,"treeOrder":134,"backlinks":[],"type":"markdown"},"flutter/gridview.html":{"title":"GridView","icon":"","description":"GridView는 화면에 보이는 아이템만 동적으로 생성하여 그리드 형태로 보여주는 위젯임. scrollDirection Axis.vertical\nAxis.horizontal padding: 그리드 전체의 바깥 쪽에 여백을 줌\nphysics: 스크롤 동작 방식 설정 BoundingScrollPhysics() : 스크롤 끝에서 튕기는 효과 (iOS 기본)\nClampingScrollPhysics(): 스크롤 끝에서 멈추는 효과 (안드로이드 기본)\nNeverScrollablePhysics(): 스크롤 막음 shrinkWrap: GridView를 Column이나 ListView 같은 다른 스크롤 위젯 안에 넣을 때 true로 설정해야함.\n이 속성은 GridView가 자신의 콘텐츠 크기만큼만 공간을 차지하게 만들어 스크롤 충돌 문제를 해결함. true로 설정한 경우 성능 저하 가능성이 있어서 필요한 경우에만 사용해야함 GridView.builder\nGridView.count\nGridView.extent\nGridView.custom\n리스트에 수백, 수천 개의 아이템이 있더라도 현재 화면에 보이는 부분과 곧 보이게 될 일부만 미리 그려서 가장 효율적임.GridView.builder( // 1. 그리드 레이아웃을 정의하는 속성 gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, // 가로(교차축)에 2개의 아이템을 배치 crossAxisSpacing: 16, // 아이템 간의 가로 간격 mainAxisSpacing: 16, // 아이템 간의 세로 간격 childAspectRatio: 0.75, // 아이템의 가로/세로 비율 (가로 1 : 세로 1.33) ), // 2. 전체 아이템의 개수 itemCount: _cards.length, // 3. 각 아이템을 어떻게 그릴지 정의하는 함수 itemBuilder: (context, index) { return AnimationCardWidget(cardItem: _cards[index], index: index); },\n) gridDelegate: 그리드 내 아이템들의 레이아웃을 결정하는 역할 SliverGridDelegateWithFixedCrossAxisCount: 교차 축에 고정된 개수의 아이템을 배치하는 방식 itemBuilder에서 context가 의미하는건 GridView 위젯 내에서 앞으로 생성될 각 아이템이 위치할 자리의 BuildContext임. 가장 간단한 방법이다. 표시할 아이템 개수가 적고 정해져있을 때, 간단하게 그리드를 만들고 싶을 때 사용함. childern 속성에 위젯 리스트를 직접 전달하기 때문에 모든 아이템을 미리 생성한다. 그래서 아이템이 너무 많다면 성능 저하가 발생한다.GridView.count( crossAxisCount: 3, // 한 줄에 3개의 아이템을 배치 children: &lt;Widget&gt;[ Icon(Icons.home), Icon(Icons.search), Icon(Icons.settings), Icon(Icons.person), Icon(Icons.camera), Icon(Icons.mail), ],\n)\n반응형 레이아웃을 구현할 때 주로 사용됨. maxCrossAxisExtent 속성을 이용해서 각 아이템의 최대 너비 (or 높이)를 설정한다. count와 마찬가지로 childern을 통해서 위젯 리스트를 직접 전달한다.반응형의 이점과 builder의 아이템 성능적 이점을 모두 얻으려면 builder에서 gridDelegate를 SliverGridDelegateWithMaxCrossAxisExtent로 설정하면 됨.GridView.extent( maxCrossAxisExtent: 200, // 각 아이템의 최대 너비를 200으로 제한 children: &lt;Widget&gt;[ // ... 위젯 리스트 ],\n)\n위의 생성자들로 구현하기 어렵고 복잡한 커스텀된 그리드 레이아웃이 필요할 때 사용된다. 특징은 gridDelegate와 childrenDelegate를 직접 구현해야 한다.. childrenDelegate은 아이템을 생성하고 관리하는 방식을 완전히 제어할 수 있게 해준다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Grid의 공통 속성","level":2,"id":"Grid의_공통_속성_0"},{"heading":"GridView의 주요 생성자","level":2,"id":"GridView의_주요_생성자_0"},{"heading":"GridView.builder","level":3,"id":"GridView.builder_0"},{"heading":"GridView.count","level":3,"id":"GridView.count_0"},{"heading":"GridView.extent","level":3,"id":"GridView.extent_0"},{"heading":"GridView.custom","level":3,"id":"GridView.custom_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/gridview.html","pathToRoot":"..","attachments":[],"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":3820,"sourcePath":"flutter/GridView.md","exportPath":"flutter/gridview.html","showInTree":true,"treeOrder":135,"backlinks":[],"type":"markdown"},"flutter/scaffold-vs-builder.html":{"title":"Scaffold vs Builder","icon":"","description":"build 함수에서 어떤 경우에는 Scaffold를 리턴하고 어떤 경우에는 다른 Builder들을 리턴하는 경우가 있다. build 함수에서 위젯을 리턴할 때 위젯의 역할이 무엇인가에 따라 무엇을 리턴할 지에 대해 결정해야함.Scaffold는 하나의 완전한 화면, 페이지를 구성할 때 최상위 위젯으로 사용됨. Scaffold를 반환한다는 것은 하나의 페이지를 만들겠다와 똑같은 말로 받아들여도 됨.주요역할은 머티리얼 디자인의 기본 레이아웃 구조 제공 (appBar, body, floatingActionButton, drawer 등)\n화면 전체의 배경색, 상태표시줄과의 상호작용 등 페이지 수준의 시각적 요소를 관리함.\nbody는 그중&nbsp;가장 크고 핵심적인 메인 콘텐츠 영역을 담당@override Widget build(BuildContext context) { return Scaffold( backgroundColor: Colors.grey[100], appBar: AppBar( // ... app bar ... ), body: FadeTransition( opacity: _fadeAnimation, child: Padding( padding: const EdgeInsets.all(16.0), child: GridView.builder( gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, crossAxisSpacing: 16, mainAxisSpacing: 16, childAspectRatio: 0.75, ), itemCount: _cards.length, itemBuilder: (context, index) { return AnimationCardWidget(cardItem: _cards[index], index: index); }, ), ), ), ); }\n}\n보면 body에 Fade바로 위 부모 위젯의 context가 필요할 때 사용함Scaffold( body: Builder( // 이 builder는 Scaffold의 자식 위치에 있으므로, // 새로운 'context'를 통해 위로 올라가 Scaffold를 찾을 수 있습니다. builder: (context) { return ElevatedButton( onPressed: () =&gt; Scaffold.of(context).openDrawer(), child: Text('Drawer 열기'), ); }, ),\n)\n애니메이션은 60fps라서 전체 페이지를 60번씩 다시 그린다는 것은 리소스 낭비임. Animation Builder는 특정한 부분만 효율적으로 애니메이션을 하는 최적화 도구임. 애니메이션 값이 변경될 때마다 전체가 아닌 builder 함수 내부의 위젯들만 다시 그린다. // _scaleAnimation이 변경될 떄 Transform.scale 위젯을 다시 그림 @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _scaleAnimation, builder: (context, child) { return Transform.scale( scale: _scaleAnimation.value, child: GestureDetector( onTap: () {} // ...\nListView.builder( itemCount: 1000, // 아이템이 1000개라도 itemBuilder: (context, index) { // 이 코드는 화면에 보이는 몇 개의 아이템에 대해서만 실행됩니다. return ListTile(title: Text('Item $index')); },\n)\n부모 위젯이 제공하는 공간을 알아내고 그 크기에 따라 다른 UI를 보여주고 싶을 때 사용함. 반응형 UI를 만들 때의 핵심LayoutBuilder( builder: (context, constraints) { // constraints 객체에 최대/최소 너비와 높이 정보가 들어있습니다. if (constraints.maxWidth &gt; 600) { return WideLayout(); // 넓은 화면용 레이아웃 } else { return NarrowLayout(); // 좁은 화면용 레이아웃 } },\n)\n네트워크 통신이나 데이터베이스 조회처럼 완료되는 데 시간이 걸리는 비동기 작업의 결과를 UI에 표시할 때 사용FutureBuilder( future: http.get(url), // 이 Future가 완료되기를 기다립니다. builder: (context, snapshot) { if (snapshot.hasData) { return Text('성공: ${snapshot.data}'); // 성공 } else if (snapshot.hasError) { return Text('에러: ${snapshot.error}'); // 에러 } return CircularProgressIndicator(); // 로딩 중 },\n)\n일회성이 아닌 지속적으로 들어오는 데이터를 처리할 때 사용. 주로 채팅 앱, 주식 시세 추적, 위치 추적등 실시간으로 UI가 업데이트 되어야 하는 상황에 적합함StreamBuilder( stream: myChatRoom.messagesStream, // 메시지 스트림을 구독합니다. builder: (context, snapshot) { if (snapshot.hasData) { // 새 메시지가 올 때마다 이 부분이 다시 빌드됩니다. return ListView.builder(...); } return Text('메시지 기다리는 중...'); },\n)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Scaffold","level":3,"id":"Scaffold_0"},{"heading":"Scaffold는 무엇일까?","level":4,"id":"Scaffold는_무엇일까?_0"},{"heading":"Scaffold에서 body가 의미하는 것","level":4,"id":"Scaffold에서_body가_의미하는_것_0"},{"heading":"Builder","level":3,"id":"Builder_0"},{"heading":"Builder","level":4,"id":"Builder_1"},{"heading":"Animation Builder","level":4,"id":"Animation_Builder_0"},{"heading":"ListView.builder &amp; GridView.builder","level":4,"id":"ListView.builder_&_GridView.builder_0"},{"heading":"LayoutBuilder","level":4,"id":"LayoutBuilder_0"},{"heading":"FutureBuilder","level":4,"id":"FutureBuilder_0"},{"heading":"StreamBuilder","level":4,"id":"StreamBuilder_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/scaffold-vs-builder.html","pathToRoot":"..","attachments":[],"createdTime":1754545491067,"modifiedTime":1754545491067,"sourceSize":4896,"sourcePath":"flutter/Scaffold vs Builder.md","exportPath":"flutter/scaffold-vs-builder.html","showInTree":true,"treeOrder":136,"backlinks":[],"type":"markdown"},"flutter/statefulwidget-생명주기.html":{"title":"StatefulWidget 생명주기","icon":"","description":"class MainPage extends StatefulWidget { const MainPage({super.key, required this.title}); final String title; @override State&lt;MainPage&gt; createState() =&gt; _MainPageState();\n} 위젯 생성: 파라미터로 title을 받아서 위젯 생성 State 생성: 프레임워크가 override 된 createState() 메서드로 `State' 객체를 생성함 initState(): 최초의 초기화 장소, 위젯 생성 후 build() 메서드가 호출 되기전에 실행됨. 위젯이 화면에 보이기 전에 필요한 모든 사전 작업 처리 컨트롤러 초기화\n리스너 등록\n데이터 로딩 UI 구축: State의 build() 가 호출되어 UI 그림 상태변화: setState()가 호출되면 build() 호출되어서 UI 업데이트 일어남 dispose(): 리소스 정리, 메모리 누수 방지\nState 객체가 위젯 트리에서 영구적으로 제거될 때 한번 호출됨. initState랑 쌍이라고 할 수 있음\ninitState에서 설정한 리소스 정리하는 곳 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/statefulwidget-생명주기.html","pathToRoot":"..","attachments":[],"createdTime":1754545491067,"modifiedTime":1754545491067,"sourceSize":1051,"sourcePath":"flutter/StatefulWidget 생명주기.md","exportPath":"flutter/statefulwidget-생명주기.html","showInTree":true,"treeOrder":137,"backlinks":[],"type":"markdown"},"flutter/tickerproviderstatemixin.html":{"title":"TickerProviderStateMixin","icon":"","description":"TickerProviderStateMixin는 애니메이션을 만들기 위해 필요한 기능Mixin이란?\nDart 언어의 특징 중 하나로, 클래스에 특정 기능을 섞어 넣는(mix-in) 방법\n상속과 비슷하지만 여러 Mixin을 하나의 클래스에 적용할 수 있어 유연\nTickerProvider의 역할은?\nAnimationController은 Tick을 받아서 애니메이션의 각 프레임을 업데이트함.\nTickerProvider는 Ticker를 제공하는 역할\nTickerProviderStateMixin는 무엇?\nStatefulWidget의 State 클래스에서 AnimationController를 쉽게 사용할 수 있도록 제공되는 Mixin\nMixin을 with 키워드로 추가하면 State가 Ticker를 제공할 수 있음\n위젯이 화면에서 사라질 때 Ticker를 정리해서 메모리 누수 방지\nSingleTickerProviderStateMixin\nTickerProviderStateMixin 경량화된 버전\nState에서 단 하나의 Animation Controller를 사용할 수 있음.\n가볍고 리소스 소모 적음\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"flutter/tickerproviderstatemixin.html","pathToRoot":"..","attachments":[],"createdTime":1754545491067,"modifiedTime":1754545491067,"sourceSize":978,"sourcePath":"flutter/TickerProviderStateMixin.md","exportPath":"flutter/tickerproviderstatemixin.html","showInTree":true,"treeOrder":138,"backlinks":[],"type":"markdown"},"graphics/etc/golf-simulator-using-sfml.html":{"title":"Golf Simulator using SFML","icon":"","description":"C++, SFML을 이용해서 간단한 2D 골프 시뮬레이터를 만든 과정을 공유할 것입니다.이 프로젝트는 C++ 코드로 골프공 움직임을 시뮬레이션하고, SFML 라이브러리를 이용해서 렌더링 하는 것이 목표입니다..\n└── src ├── core │&nbsp;&nbsp; ├── GolfBall.cpp │&nbsp;&nbsp; ├── GolfBall.h │&nbsp;&nbsp; ├── Simulator.cpp │&nbsp;&nbsp; └── Simulator.h └── main.cpp\nclass GolfBall {\nprivate: const double gravity = 9.81; // 중력가속도 const double airDensity = 1.225; // 공기밀도 const double mass = 0.0459; // 골프공 질량 const double radius = 0.0213; // 골프공 반지름 const double dragCoefficient; // 항력계수: 0.47 const double liftCoefficient; // 양력계수: 0.1 double x, y; // 골프공 위치 double vx, vy; // x축, y축 방향의 속도 double spin; // 회전속도 (rad/s) public: GolfBall(double initialVelocity, double launchAngle, double initialSpin); void update(double dt); bool isFlying() const; std::pair&lt;double, double&gt; getPosition() const;\n}\n골프공에 작용하는 주요 힘은 간단하게 아래 3가지만 고려했습니다.\n중력\n항력\n양력\nvoid GolfBall::update(double dt) { double velocity = sqrt(vx * vx + vy * vy); // 스칼라 double area = M_PI * radius * radius; // 골프공 단면적 // 공기저항력 계산 double dragForce = 0.5 * airDensity * dragCoefficient * area * velocity * velocity; // 양력 계산 double liftForce = 0.5 * airDensity * liftCoefficient * area * velocity * velocity; // F = ma -&gt; a = F/m을 이용. double ax = -(dragForce * vx / velocity) / mass; double ay = -gravity - (dragForce * vy / velocity) / mass + (liftForce/mass); x += vx * dt; y += vy * dt; vx += ax * dt; vy += ay * dt; }\nupdate 함수에서 위치(x,y)를 업데이트 하고 속도 (vx, vy)를 업데이트 하기 위해\n항력(dragForce), 양력(liftForce)를 계산한 다음 이를 이용해 가속도를 구했습니다.<a data-href=\"SFML\" href=\"graphics/etc/sfml.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">SFML</a>class Simulator {\nprivate: sf::RenderWindow window; // SFML 윈도우 GolfBall golfBall; // 골프공 객체 sf::CircleShape ballShape; // 골프공 그래픽 sf::View camera; // 카메라 뷰 const float SCALE = 10.0f; // 물리적 거리를 픽셀로 변환하는 비율 (1m = 10px)\n}\nSimulator::Simulator(double initialVelocity, double launchAngle, double initialSpin) : window(sf::VideoMode(sf::Vector2u(800, 600)), \"Golf Simulator\") { camera.setSize(sf::Vector2f(1600.f, 1200.f)); // ...\n}\nwindow 사이즈를 800, 600으로 설정했고 camera size를 2배로 설정했다. 따라서 2배 넓은 시야를 가진다. (축소 모드)void Simulator::run() { while (window.isOpen()) { handleEvents(); // 이벤트 처리 update(); // 물리 시뮬레이션 업데이트 render(); // 화면 렌더링 }\n}\nvoid Simulator::render() { window.clear(sf::Color(50, 50, 50)); updateCamera(); window.draw(groundShape); auto position = golfBall.getPosition(); sf::Vector2f ballPosition(position.first * SCALE, 500.f - position.second * SCALE); ballShape.setPosition(ballPosition); window.draw(ballShape); window.display(); }\n핵심이 되는 함수다. 이 함수는 매 프레임마다 호출된다. 그래서 clear가 반드시 필요하다. clear를 하지 않으면 이전 프레임의 그림이 남아있어 새로운 프레임이 계속 중첩되어서 그려질 것이다. updateCamera()를 호출해서 카메라 위치를 업데이트하고 window에 groundShape를 그린다. (ground는 위치가 고정이라 그려주기만 하면 됨.)그 다음으로는 ballShape를 그려야하므로 ball의 위치를 가져온다. 현재 ball의 위치를 ballPosition 을 생성할 때 y축의 값이 500.f - position.second * SCALE 인 이유는 SFML의 좌표계와 ball의 좌표계가 다르기 때문이다.\n물리 시뮬레이션 좌표계 Y축이 위로 갈수록 양수 (+)\n지면이 0\n공이 위로 올라갈수록 y값이 증가 SFML 화면 좌표계 Y축이 아래로 갈수록 양수 (+)\n화면 최상단이 0\n아래로 갈수록 y값이 증가 500.0f는 지면의 y좌표고 - position.second * SCALE 는 물리 좌표계의 y값을 화면 좌표계로 변환한 값이다.물리 좌표계 화면 좌표계 ↑ +y 0 ───── │ │ ↓ +y │ │ 0 ───── 500 ─────\n\b마지막으로 ball의 위치를 설정하고 window에 그린 다음에 display 하면 끝이다.void Simulator::updateCamera() { auto ballPos = golfBall.getPosition(); sf::Vector2f targetCenter(ballPos.first * SCALE, 300.f); // 부드러운 카메라 이동 cameraCenter.x = cameraCenter.x + (targetCenter.x - cameraCenter.x) * CAMERA_SPEED;\n}\n표준 STL을 이용해서 리팩토링 진행함.\nSimulator에서 GolfBall을 참조할 때 raw pointer를 사용 했는데 unique_ptr로 변경\nmake_pair(x,y)를 이용해 Position을 정의 하는 것보다 Struct으로 정의하는 것이 확장에 유리\nEvent Handler를 visitor pattern으로 해결\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/golf_simulator\" target=\"_self\">https://github.com/psychehose/golf_simulator</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"구조","level":3,"id":"구조_0"},{"heading":"물리 모델","level":3,"id":"물리_모델_0"},{"heading":"렌더링","level":3,"id":"렌더링_0"},{"heading":"SFML 설치","level":4,"id":"SFML_설치_0"},{"heading":"핵심 구성 요소","level":4,"id":"핵심_구성_요소_0"},{"heading":"화면 설정","level":4,"id":"화면_설정_0"},{"heading":"메인 게임 루프","level":4,"id":"메인_게임_루프_0"},{"heading":"render() 함수","level":4,"id":"render()_함수_0"},{"heading":"골프공을 자연스럽게 따라가는 카메라 구현","level":4,"id":"골프공을_자연스럽게_따라가는_카메라_구현_0"},{"heading":"리팩토링","level":3,"id":"리팩토링_0"},{"heading":"repos","level":4,"id":"repos_0"}],"links":["graphics/etc/sfml.html"],"author":"","coverImageURL":"","fullURL":"graphics/etc/golf-simulator-using-sfml.html","pathToRoot":"../..","attachments":[],"createdTime":1735664604542,"modifiedTime":1752496355211,"sourceSize":5740,"sourcePath":"graphics/etc/Golf Simulator using SFML.md","exportPath":"graphics/etc/golf-simulator-using-sfml.html","showInTree":true,"treeOrder":141,"backlinks":[],"type":"markdown"},"graphics/etc/sfml.html":{"title":"SFML","icon":"","description":"크로스 플랫폼 Golf Simulator를 만들면서 빠른 그래픽 렌더링을 위해 사용해봤다.\nSFML은 C++로 작성된 멀티미디어 라이브러리다. 게임 개발이나 그래픽 애플리케이션을 만들 때 사용되는 크로스 플랫폼 프레임워크다. 주로 2D 엔진일 때 사용하는듯?SFML은 다양한 모듈을 지원하는데 내가 사용한 모듈은 Graphics, System, Window다. Window: 어플리케이션의 창과 입력을 관리하는 핵심 모듈 sf::RenderWindow - 윈도우\nsf::VideoMode - 해상도\nsf::Event - 입력 이벤트 처리 System: 유틸 모듈 (Thread, Clock 등등 지원함) sf::Vector - 벡터 연산 Graphics: 렌더링 sf::CircleShape: 골프공\nsf::RectangleShape: 그라운드\nsf::View - 카메라 cmake를 이용하고 있어서 CMakeLists.txt에서 라이브러리를 링크하는 형태로 적용했다.\nSFML 예제를 보면 CMake의 FetchContent 모듈을 통해서 SFML을 다운로드하고 의존성을 관리한다.FetchContent_Declare(SFML GIT_REPOSITORY https://github.com/SFML/SFML.git GIT_TAG 3.0.0 GIT_SHALLOW ON EXCLUDE_FROM_ALL SYSTEM\n)\nFetchContent_MakeAvailable(SFML) # ... target_link_libraries(${PROJECT_NAME} PRIVATE SFML::Graphics SFML::Window SFML::System\n) ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"SFML (Simple and Fast Multimedia Library)","level":3,"id":"SFML_(Simple_and_Fast_Multimedia_Library)_0"},{"heading":"설치와 적용","level":3,"id":"설치와_적용_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/etc/sfml.html","pathToRoot":"../..","attachments":[],"createdTime":1735664846664,"modifiedTime":1735666283958,"sourceSize":1402,"sourcePath":"graphics/etc/SFML.md","exportPath":"graphics/etc/sfml.html","showInTree":true,"treeOrder":142,"backlinks":["graphics/etc/golf-simulator-using-sfml.html"],"type":"markdown"},"graphics/metal/0.-metal-basic.html":{"title":"0. Metal Basic","icon":"","description":"<img alt=\"metal_rendering_pipeline.png\" src=\"images/metal_rendering_pipeline.png\" target=\"_self\">MTLDevice\nGPU에 대한 추상화된 인터페이스\n리소스(버퍼, 텍스처 등) 생성을 담당\n커맨드 큐 생성\nGPU 메모리 할당 관리\n일반적으로 MTLCreateSystemDefaultDevice()로 생성\nMTLCommandQueue\nGPU에 전송할 명령어들의 큐\n커맨드 버퍼들을 순차적으로 관리\n렌더링 명령을 GPU에 전달하는 파이프라인\ndevice.makeCommandQueue()로 생성\nMTLRenderPipelineState\n그래픽스 렌더링 파이프라인의 상태를 캡슐화\n셰이더 프로그램, 버텍스 레이아웃, 블렌딩 모드 등 포함\n렌더링 설정을 고정하여 성능 최적화\nMTLBuffer\nGPU 메모리에 할당된 데이터 버퍼\n버텍스 데이터, 변환 행렬 등을 저장\nCPU-GPU 간 데이터 전송에 사용\nMTLDepthStencilState\n깊이(Z) 테스트와 스텐실 테스트 설정을 관리\n3D 렌더링에서 물체의 앞뒤 관계 처리\n렌더링과정\nMTLDevice로 필요한 리소스들 생성\nMTLBuffer에 데이터 저장\nMTLRenderPipelineState로 렌더링 파이프라인 설정\nMTLCommandQueue를 통해 커맨드 버퍼 생성\n커맨드 버퍼에 렌더링 명령 인코딩\n커맨드 버퍼 커밋하여 GPU 실행\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/metal_rendering_pipeline.png","fullURL":"graphics/metal/0.-metal-basic.html","pathToRoot":"../..","attachments":["images/metal_rendering_pipeline.html"],"createdTime":1752512486110,"modifiedTime":1752512492915,"sourceSize":1276,"sourcePath":"graphics/metal/0. Metal Basic.md","exportPath":"graphics/metal/0.-metal-basic.html","showInTree":true,"treeOrder":144,"backlinks":[],"type":"markdown"},"graphics/metal/depth-buffer.html":{"title":"Depth buffer","icon":"","description":"3D 공간에서 렌더링을 할 때 여러 오브젝트가 겹쳐 있을 때,&nbsp;어떤 것이 앞에 있고 뒤에 있는지 판단이 필요하다.깊이 버퍼를 사용하기 위해서 렌더링이 되는 metalView의 깊이 버퍼 정밀도를 설정해야한다.// 깊이 버퍼의 정밀도를 32bit 부동 소수점 사용한다. (높은 정밀도)\n// 깊이 값 범위은 0.0(가까움) ~ 1.0 (멈)\u001f\nmetalView.depthStencilPixelFormat = .depth32Float\n그런 다음에 깊이 테스트 규칙을 정의 해야 한다. 겹쳐 있을 때 판단할 근거가 필요하기 때문이다. 이때 사용 하는 것이 MTLDepthStencilState 이다. 이 객체를 통해서 어떤 조건에서 픽셀을 그릴지 결정한다. 즉 깊이 테스트 규칙을 정의한다.다음은 MTLDepthStencilState를 생성하는 방법이다.let descriptor = MTLDepthStencilDescriptor() // 깊이 테스트 규칙 설정 템플릿\ndescriptor.depthCompareFunction = .less // 더 가까운 것 우선시\ndescriptor.isDepthWriteEnabled = true // 픽셀 그릴 때 깊이 값 업데이트\nreturn device.makeDepthStencilState(descriptor: descriptor)\n아래는 depthCompareFunction의 규칙 enum이다..never // 절대 그리지 않음\n.less // 더 가까우면 그림 (일반적)\n.equal // 같은 깊이면 그림\n.lessEqual // 가깝거나 같으면 그림\n.greater // 더 멀면 그림 (역순)\n.notEqual // 다른 깊이면 그림\n.greaterEqual // 멀거나 같으면 그림\n.always // 항상 그림 (깊이 무시)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/metal/depth-buffer.html","pathToRoot":"../..","attachments":[],"createdTime":1751455892432,"modifiedTime":1751455892432,"sourceSize":1598,"sourcePath":"graphics/metal/Depth buffer.md","exportPath":"graphics/metal/depth-buffer.html","showInTree":true,"treeOrder":145,"backlinks":[],"type":"markdown"},"graphics/metal/metal-rendering-pipeline.html":{"title":"Metal Rendering pipeline","icon":"","description":" 초기화 Device 생성\nCommandQueue 생성 자원 생성 Vertex Buffer 생성\nTexture Descriptor 생성 파이프라인 상태 객체 생성 셰이더 함수 로드\n렌더 파이프라인 상태 생성 (RenderPipelineState) 명령 인코딩 CommandBuffer 생성\nRednerPassDescriptor 생성\n렌더 인코더 생성\n파이프라인 상태 설정\n자원 설정\n그리기 명령\n인코딩 종료 실행 및 표시 명령 버퍼 커밋 앱 초기화 (단 한번 수행) MTLDevice 생성\nMTLCommandQueue 생성\n셰이더 컴파일 및 MTLRenderPipelineState 생성\n정적 자원 (버퍼, 텍스쳐) 생성 프레임 마다 수행 MTLCommandBuffer 생성\nMTLRenderPassDescriptor 설정\nMTLRenderCommandEncoder 생성\n렌더링 상태 및 자원 설정\n그리기 명령 인코딩\n인코딩 종료\n명령 버퍼 커밋 및 실행 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Metal Rendering pipeline","level":2,"id":"Metal_Rendering_pipeline_1"},{"heading":"Metal Rendering pipeline flow","level":2,"id":"Metal_Rendering_pipeline_flow_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/metal/metal-rendering-pipeline.html","pathToRoot":"../..","attachments":[],"createdTime":1751291017365,"modifiedTime":1752512484491,"sourceSize":992,"sourcePath":"graphics/metal/Metal Rendering pipeline.md","exportPath":"graphics/metal/metal-rendering-pipeline.html","showInTree":true,"treeOrder":146,"backlinks":[],"type":"markdown"},"graphics/metal/shadow-map.html":{"title":"Shadow Map","icon":"","description":"shadowMapSize - 그림자 맵 텍스처의 해상도(예: 1024x1024, 2048x2048) 높을수록 → 더 정밀한 그림자, 더 부드러운 경계 낮을수록 → 거친 그림자, 계단 현상 발생 PCF에서 텍셀 크기 계산에 사용\nshadowBias - \"Shadow Acne\" (그림자 여드름) 현상 방지 부동소수점 정밀도 한계로 인한 자기 그림자 현상을 방지 깊이 비교 시 작은 오프셋을 추가하여 오차 보정 목적: 광원 시점에서 본 장면의 깊이 정보만 저장\n결과물: Shadow Map (깊이 텍스처)\nDepth-Only Pass가 필요한 이유는 2-Pass 렌더링 1단계: 광원 시점에서 깊이만 렌더링 (현재 함수)\n2단계: 카메라 시점에서 색상 + 그림자 렌더링 효율성: 색상 계산 없이 깊이만 저장하여 성능 최적화 그림자 판단 기준: 나중에 \"이 픽셀이 광원에서 보이는가?\"를 판단할 데이터 생성 out.shadowPosition = shadowUniforms.lightViewProjectionMatrix * worldPosition; 좌표계 변환 체인: 로컬 좌표 → 월드 좌표 → 광원 뷰 좌표 → 광원 클립 좌표 핵심 연산: 각 정점을 광원의 시점에서 본 좌표로 변환\n나중에 \"이 점이 그림자 안인지 밖인지\" 판단할 데이터 준비 왜 정점 셰이더에서?: GPU 병렬 처리 효율성\n프래그먼트 셰이더에서 보간된 값 사용 문제상황: 단순 그림자 매핑은 계단 현상 발생\n해결: 주변 여러 샘플을 확인해서 부드러운 그림자 생성\n그래서 x = -1 ... 1 , y = -1 ... 1 을 사용해서 총 9개 샘플 사용 (3 x 3 커널) float sampleShadowMapPCF(depth2d&lt;float&gt; shadowMap, sampler shadowSampler, float2 shadowCoord, float currentDepth, float bias, float shadowMapSize) { float shadow = 0.0; float2 texelSize = 1.0 / shadowMapSize; // 3x3 PCF for (int x = -1; x &lt;= 1; ++x) { for (int y = -1; y &lt;= 1; ++y) { float2 offset = float2(x, y) * texelSize; float pcfDepth = shadowMap.sample(shadowSampler, shadowCoord + offset); shadow += (currentDepth - bias) &gt; pcfDepth ? 1.0 : 0.0; } } return shadow / 9.0; // 9개 샘플의 평균\n} NDC 좌표 변환\nfloat3 projCoords = in.shadowPosition.xyz / in.shadowPosition.w; projCoords = projCoords * 0.5 + 0.5; 그림자 적용\nfloat3 finalColor = ambient + (1.0 - shadow) * (diffuse + specular); Ambient**: 항상 유지 (간접광 시뮬레이션)\nDiffuse/Specular: 그림자 영향으로 감소\n(1.0 - shadow): &nbsp;shadow가 1이면 완전 어둡게, 0이면 원래 밝기 단계별 과정 Shadow Map 생성: 광원 시점에서 깊이만 렌더링\n메인 렌더링: 카메라 시점에서 색상 + 조명 계산\n그림자 테스트: 각 픽셀이 광원에서 보이는지 확인\nPCF 적용: 부드러운 그림자 경계 생성\n최종 색상 합성: 조명 + 그림자 결합 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Depth-Only Pass의 의미","level":4,"id":"Depth-Only_Pass의_의미_0"},{"heading":"Blinn-Phong 정점 셰이더 (그림자 적용)","level":4,"id":"Blinn-Phong_정점_셰이더_(그림자_적용)_0"},{"heading":"PCF (Percentage Closer Filtering)","level":4,"id":"PCF_(Percentage_Closer_Filtering)_0"},{"heading":"Blinn-Phong 프래그먼트 셰이더","level":4,"id":"Blinn-Phong_프래그먼트_셰이더_0"},{"heading":"전체 그림자 렌더링 파이프라인","level":4,"id":"전체_그림자_렌더링_파이프라인_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/metal/shadow-map.html","pathToRoot":"../..","attachments":[],"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":3285,"sourcePath":"graphics/metal/Shadow Map.md","exportPath":"graphics/metal/shadow-map.html","showInTree":true,"treeOrder":147,"backlinks":[],"type":"markdown"},"graphics/metal/uniform-buffer.html":{"title":"Uniform Buffer","icon":"","description":"\nCPU와 GPU 간의 효율적인 데이터 공유\n동적으로 업데이트되는 데이터 처리에 적합\n메모리 정렬과 크기 관리 중요\n적절한 에러 처리 필요\ndevice.makeBuffer( length: MemoryLayout&lt;Uniforms&gt;.size, // 버퍼 크기 options: .storageModeShared // 메모리 저장 모드\n)\n// MTLDevice의 메서드\nfunc makeBuffer( length: Int, // 버퍼 크기 (바이트) options: MTLResourceOptions // 메모리 관리 옵션\n) -&gt; MTLBuffer? // 생성된 Metal 버퍼 반환\n// 가능한 옵션들:\n.storageModeShared // CPU와 GPU가 모두 접근 가능\n.storageModePrivate // GPU만 접근 가능\n.storageModeManaged // CPU와 GPU 각각 별도 복사본 관리 // .storageModeShared 사용 시\nCPU (Swift) ⟷ 공유 메모리 ⟷ GPU (Metal)\n- 양방향 직접 접근 가능\n- 동기화 오버헤드 최소화\n- 작은 크기의 자주 업데이트되는 데이터에 적합 // Uniform 버퍼 생성\nlet uniformBuffer = device.makeBuffer( length: MemoryLayout&lt;Uniforms&gt;.size, options: .storageModeShared\n) // 데이터 업데이트\nlet uniforms = Uniforms( modelMatrix: modelMatrix, viewMatrix: camera.viewMatrix, projectionMatrix: camera.projectionMatrix\n)\nmemcpy(uniformBuffer.contents(), &amp;uniforms, MemoryLayout&lt;Uniforms&gt;.size)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Uniform Buffer","level":3,"id":"Uniform_Buffer_1"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/metal/uniform-buffer.html","pathToRoot":"../..","attachments":[],"createdTime":1752512573860,"modifiedTime":1752512627279,"sourceSize":1406,"sourcePath":"graphics/metal/Uniform Buffer.md","exportPath":"graphics/metal/uniform-buffer.html","showInTree":true,"treeOrder":148,"backlinks":[],"type":"markdown"},"graphics/opengl/01.기본/01.-기본.html":{"title":"01. 기본","icon":"","description":"\nGL과 윈도우 시스템(OS가 아님 창을 여는)은 같이 가야함\n윈도우\n윈도우 시스템은 각 OS에 종속되어 있음\nX윈도우 (리눅스), MS 윈도우(MS), Cocoa 윈도우(애플)\n멀티플랫폼을 지원하는게 좋음 -&gt; freeglut 등등 라이브러리가 나왔으나 현재는 GLFW (그래픽 라이브러리 프레임워크) 사용\nGLEW: OpenGL Extension\n편의를 위한 추가 기능\n<a data-tooltip-position=\"top\" aria-label=\"https://www.glfw.org/download.html%EC%97%90%EC%84%9C\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.glfw.org/download.html%EC%97%90%EC%84%9C\" target=\"_self\">https://www.glfw.org/download.html에서</a> 프리 컴파일드 바이너리 다운로드 64bit압축을 풀면 있는 Include 폴더 안에 있는 GLFW 폴더와 자신의 컴파일러에 맞는 폴더를 찾아야함.\nex) 비쥬얼 스튜디오 2022는 lib-vc2022비쥬얼 스튜디오가 설치되어 있는 폴더에서 컴파일러 폴더 찾기ex) C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\XX.YY.ZZZZZ경로 안에 있는 Include에 GLFW 복붙\nlib\\x64\\ 에 static library 3개 (glfw3.lib, glfw3_mt.lib, glfw3dll.lib) 복붙\nbin\\Hostx64\\x64 에 dynamic library (glfw3.dll) 복붙\n설치 완료.테스트로 300 x 300 윈도우 생성#include &lt;GLFW/glfw3.h&gt;\n#pragma comment(lib, \"opengl32.lib\")\n#pragma comment(lib, \"glfw3.lib\")\n#include &lt;stdio.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)\nconst unsigned int WIN_H = 300; int main(void) { // start GLFW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, \"Hello GLFW\", NULL, NULL); glfwMakeContextCurrent(window); // main loop while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } // done glfwTerminate(); return 0;\n}\nRun 할 때, Config를 Release, x64로 변경하고 Run C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\XX.YY.ZZZZZ경로 안에 있는 Include에 GLEW 복붙\nlib\\x64\\ 에 static library (lib) 복붙\nbin\\Hostx64\\x64 에 dynamic library (dll) 복붙\n다운로드 된 파일 중 glewinfo.exe 클릭 -&gt;glewinfo.txt 생성glewinfo는 지원하는 opengl 버전, 함수가 적혀 있음visualinfo.ext 클릭 -&gt; visualinfo.txt 생성\nvisualinfo는 opengl extension 리스트와 가능한 프레임버퍼 설정 적혀있음// HelloGLEW.cpp : This file contains the 'main' function. Program execution begins and ends there.\n// #include &lt;GL/glew.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#pragma comment(lib, \"opengl32.lib\")\n#pragma comment(lib, \"glew32.lib\")\n#pragma comment(lib, \"glfw3.lib\")\n#include &lt;stdio.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)\nconst unsigned int WIN_H = 300; int main() { // start GLFW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, \"Hello GLEW\", NULL, NULL); glfwMakeContextCurrent(window); // start GLEW glewInit(); // checking OpenGL version (optional) const char* strVersion = (const char*)(glGetString(GL_VERSION)); printf(\"version = %s\\n\", strVersion); fflush(stdout); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;\n}\n<br><img alt=\"glew32_install_error.png\" src=\"images/glew32_install_error.png\" target=\"_self\">위 같은 오류가 뜨는 이유는 운영체제가 DLL 파일을 못 찾는 경우에 발생glew32.dll, glfw3.dll를 C:Windws/System32에 붙여 넣으면 해결됨GLAD는 Multi-language GL/GLX/WGL loader - generator의 약자임.\nOpenGL 함수 포인터를 로드하고 관리하는 데 사용<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://glad.dav1d.de\" target=\"_self\">https://glad.dav1d.de</a> 에 접속하고 버전 선택하고 generateinclude 안에 있는 두 폴더 glad, KHR은 위에서 GLEW, GLFW 설치한 것처럼 복붙src에 있는 glad.c는 내 c++ 프로젝트에 복붙해서 사용","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 기본","level":1,"id":"1._기본_0"},{"heading":"GLFW 설치","level":2,"id":"GLFW_설치_0"},{"heading":"GLEW 설치","level":2,"id":"GLEW_설치_0"},{"heading":"GLAD","level":2,"id":"GLAD_0"}],"links":[],"author":"","coverImageURL":"images/glew32_install_error.png","fullURL":"graphics/opengl/01.기본/01.-기본.html","pathToRoot":"../../..","attachments":["images/glew32_install_error.html"],"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":3765,"sourcePath":"graphics/opengl/01.기본/01. 기본.md","exportPath":"graphics/opengl/01.기본/01.-기본.html","showInTree":true,"treeOrder":151,"backlinks":[],"type":"markdown"},"graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html":{"title":"02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용","icon":"","description":"윈도우 시스템 추상화기능\n초기화\n윈도우 관리 윈도우 생성 / 파괴 callback registration 다양한 콜백 제공\n마우스, 키보드, 스크린 등의 이벤트 처리 기능 대표 함수 void glfwInit() void glfwTerminate() GLFWwindow glfwCreateWindow(int width, int height, const char title, GLFWmonitor monitor, GLFWwindow share); 윈도우와 이것과 연관된 OpenGL context 생성하는 함수\ncontext는 현재 OpenGL state와 internal variables임 void glfwMakeContextCurrent(GLFWwindow* win); 앞으로 모든 gl 명령어는 지정한 window에 적용하겠다. int glfwWindowShouldClose(GLFWwindow* win); void glfwPollEvents(); 현재 어떤 이벤트들이 발생했는지 체크 void glfwSwapBuffers(GLFWwindow* win); 윈도우 화면 업데이트 좌표계 윈도우 시스템 좌표계 프레임버퍼 / 픽셀 = 2차원 배열\ninteger 좌표 사용\nupper-left cornet에 원점 (오른쪽: x축 양수, 아래쪽: y축 양수) 3D 그래픽스 좌표계 수학에서 사용하는 3차원 좌표계\nfloat 좌표 사용\n오른손 좌표계 GLFW의 보일러 플레이트...\nglfwInit();\nGLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, \"Hello GLFW\", NULL, NULL);\nglfwMakeContextCurrent(window); // prepare initial setting for gl\nglewInit(); // glew init\n...\n// // main loop\nwhile (!glfwWindowShouldClose(window)) { // draw ... draw an image ... //GLFW actions - update glfwSwapBuffers(win); glfwPollEvents();\n}\n// done\nglfwTerminate();\nreturn 0;\n... ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용","level":1,"id":"2._콜백함수와_컬러_기초_이론_-_GLFW_개요_및_사용_0"},{"heading":"GLFW","level":4,"id":"GLFW_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html","pathToRoot":"../../..","attachments":[],"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":1639,"sourcePath":"graphics/opengl/01.기본/02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용.md","exportPath":"graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html","showInTree":true,"treeOrder":152,"backlinks":[],"type":"markdown"},"graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html":{"title":"03. 콜백함수와 컬러 기초 이론 - Callback 함수","icon":"","description":"\n전체 윈도우를 그려야하는 상황일 때 콜됨\n윈도우가 resized 될 때\niconified 되고, 화면에 re-mapped 될 때\n콜백 함수를 만들 때 아래 형태로 만들어야함.typedef void (*GLFWwindowrefreshfun)(GLFWwindow* win);\n// win은 refresh될 윈도우임.\nwin에 콜백 함수 등록을 하는 함수GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* win, GLFWwindowrefreshfun func);\nfunc가 NULL이면 current callback function은 제거된다.// HelloRefreshCallback.cpp : This file contains the 'main' function. Program execution begins and ends there.\n// #include \"GL/glew.h\"\n#include \"GLFW/glfw3.h\" #pragma comment(lib, \"opengl32.lib\")\n#pragma comment(lib, \"glew32.lib\")\n#pragma comment(lib, \"glfw3.lib\") #include &lt;iostream&gt;\n#include &lt;string.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)\nconst unsigned int WIN_H = 300;\nconst unsigned int WIN_X = 100; // window position in pixels, (X, Y) const unsigned int WIN_Y = 100; // 등록할 콜백 함수\nvoid refreshFunc(GLFWwindow* window) { printf(\"refresh called\\n\"); fflush(stdout); // 설정된 컬러로 화면을 지움 glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW action - update glfwSwapBuffers(window);\n} int main(int argc, char* argv[])\n{ // get your program name\n#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\\\') + 1);\n#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);\n#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare - callback 등록 glfwSetWindowRefreshCallback(window, refreshFunc); // 화면을 지울 때 어떤 색깔로 지울지 설정함. glClearColor(0.5F, 0.8F, 0.8F, 1.0F); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;\n}\nOpenGL: state machineOpenGL 내부 변수:GLclampf colorClearValue[4]; // RGBA 값\n효율성을 높이기 위해, 명령어 큐에 기록하고 return\n실행은 명령어 큐에서 지연 실행함\nOpenGL 응용 프로그램 - 명령어 큐 (지연 실행) - OpenGL rendering pipelinedelayed execution 관련함수\nvoid glFlush(); OpenGL 명령 큐를 flush\n주의할점: 대부분은 바로 실행되지만, 일부는 시간이 더 필요할 수 있음. void glFinish(); OpenGL 명령어 큐를 flush하고 모두 완료되는 것을 확인 후에 return\n주의할 점: 시간이 오래 걸릴 수도 있음 두 함수 다 명령어 큐에 있는 걸 다 업데이트 하기 때문에 명령어 큐가 전체 비워짐 -&gt; 내가 글리길 원하는 그림을 실행하면 바로 그릴 수 있음. 다만 명령어 큐를 다 비워야하기 때문에 약간의 시간지연이 발생등록할 함수 typedeftypedef void(*GLFWkeyfun)(GLFWwindow* win, int key, int scancode, int action, int mods);\nparameter\nwin: 윈도우\nkey: keyboard key\nscancode: system specific scancode -&gt; 사용하지 않음\naction: GLFW_PRESS, GLFW_RELEASE, GLFW_REPEAT\nmods: modifier keys (GLFW_MOD_SHIFT, CONTROL, ALT, SUPER)\n해당하는 윈도우에 함수 등록GLFWkeyfun glfwSetKeyCallback(GLFWwindow* win, GLFWkeyfun func);\n함수에 null을 넣으면 함수 등록 취소.예시.\nCTRL + SHIFT + 'C' 인 경우\nkey: 'C'\nmods: GLFW_MOD_SHIFT | GLFW_MOD+CONTROL\naction: GLFW_PRESS (GLFW_RELEASE 이벤트도 발생하긴 함) #include &lt;GL/glew.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#pragma comment(lib, \"opengl32.lib\")\n#pragma comment(lib, \"glew32.lib\")\n#pragma comment(lib, \"glfw3.lib\")\n#pragma warning(disable: 4711 4710 4100)\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; // for strrchr() const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)\nconst unsigned int WIN_H = 300;\nconst unsigned int WIN_X = 100; // window position in pixels, (X, Y) const unsigned int WIN_Y = 100; void refreshFunc(GLFWwindow* window) { // refresh glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW action glfwSwapBuffers(window);\n} void keyFunc(GLFWwindow* window, int key, int scancode, int action, int mods) { switch (key) { case GLFW_KEY_ESCAPE: if (action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } break; }\n} int main(int argc, char* argv[]) { // get your program name\n#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\\\') + 1);\n#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);\n#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare glfwSetWindowRefreshCallback(window, refreshFunc); glfwSetKeyCallback(window, keyFunc); glClearColor(0.933F, 0.769F, 0.898F, 1.0F); // main loop while (! glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;\n} GLFW 함수 설명\nvoid glfwSetWindowShouldClose(GLFWwindow* win, int value);\n// 특정 윈도우의 close flag를 설정할 수 있음 int glfwWindowShouldClose(GLFWwindow* win);\n// 특정 윈도우의 close flag를 리턴함.\n// return 하는 값이 0이 아니면 윈도우를 close 해야하는 상황\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"3. 콜백함수와 컬러 기초 이론 - Callback 함수","level":1,"id":"3._콜백함수와_컬러_기초_이론_-_Callback_함수_0"},{"heading":"refresh callback","level":4,"id":"refresh_callback_0"},{"heading":"refresh callback registration - 콜백 함수 등록","level":4,"id":"refresh_callback_registration_-_콜백_함수_등록_0"},{"heading":"OpenGL: delayed execution","level":4,"id":"OpenGL_delayed_execution_0"},{"heading":"Keyboard 콜백","level":4,"id":"Keyboard_콜백_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html","pathToRoot":"../../..","attachments":[],"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":5995,"sourcePath":"graphics/opengl/01.기본/03. 콜백함수와 컬러 기초 이론 - Callback 함수.md","exportPath":"graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html","showInTree":true,"treeOrder":153,"backlinks":[],"type":"markdown"},"graphics/opengl/01.기본/04.-컬러-기초이론.html":{"title":"04. 컬러 기초이론","icon":"","description":"모든 색을 Red, Green, Blue를 조정해서 만들 수 있음.\n컬러모델 컴퓨터 / 소프트웨어에서 컬러를 표현하는 방법\n다양한 모델: RGB, CMY(잉크), grayscale ... color gamut (컬러 개멋), 색 영역 특정 컬러 모델에서 표현 가능한 모든 색상 영역 Color cube, Color solid 3원색을 쓰는 컬러모델에서\nColor gamut은 cube 정육면체 형태 <img alt=\"rgb_color_model.png\" src=\"images/rgb_color_model.png\" target=\"_self\"><br><img alt=\"cmy_model.png\" src=\"images/cmy_model.png\" target=\"_self\"> RGB color system 가산 색계 - 더할 수록 밝아짐\n모니터, LCD 형광물질로 RGB 색상 컴퓨터 그래픽스의 주된 관심사 CMY color system 감산 색계 - 더할 수록 어두워짐\n프린터, 인쇄용 두 모델은 서로 변환 가능함 <br><img alt=\"rgb_cmy_conversion.png\" src=\"images/rgb_cmy_conversion.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"4. 컬러 기초이론","level":1,"id":"4._컬러_기초이론_0"},{"heading":"RGB","level":4,"id":"RGB_0"},{"heading":"Color Model","level":4,"id":"Color_Model_0"},{"heading":"RGB Model vs CMY Model","level":4,"id":"RGB_Model_vs_CMY_Model_0"}],"links":[],"author":"","coverImageURL":"images/rgb_color_model.png","fullURL":"graphics/opengl/01.기본/04.-컬러-기초이론.html","pathToRoot":"../../..","attachments":["images/rgb_color_model.html","images/cmy_model.html","images/rgb_cmy_conversion.html"],"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":858,"sourcePath":"graphics/opengl/01.기본/04. 컬러 기초이론.md","exportPath":"graphics/opengl/01.기본/04.-컬러-기초이론.html","showInTree":true,"treeOrder":154,"backlinks":[],"type":"markdown"},"graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html":{"title":"05. 컬러 이미지 저장 방식","icon":"","description":"\n이미지 -&gt; (색깔 있는) 사각형의 2차원 배열\n픽셀 pixel (= picture element)로 프레임버퍼를 표현함 컬러 심도 (색 깊이), bit depth 픽셀 당 몇 bit를 사용할 것인가 (메모리 비용) 인간의 시각은 200단계 색상 차이를 인식 그래서 256 즉 8bit를 사용하는 것이 일반적 <img alt=\"bw_grayscale.png\" src=\"images/bw_grayscale.png\" target=\"_self\"><br><img alt=\"3colorchannel.png\" src=\"images/3colorchannel.png\" target=\"_self\">\ngray scale을 확장함 rgb 픽셀 값을 그레이스케일 형태로 저장\nred 채널만 뽑아서, g 채널만, b 채널만 3개의 그레이스케일 이미지 저장\n합성 -&gt; 컬러 이미지 <br><img alt=\"color_image.png\" src=\"images/color_image.png\" target=\"_self\">\ncolor image 한 픽셀마다 3개의 채널을 사용함\n각 채널마다 8비트로 저장\n그러면 한 픽셀당 24bit 사용 -&gt; 24bit 컬러 모델 각 픽셀마다 3개의 채널을 가지는 것을 Direct Color System이라고 부름 그래픽 카드 내부 구조 framebuffer: 각 픽셀마다 3 채널을 사용 (rgb)\n각 채널마다 n bit 할당: - 총 2^3n Color\n3n = 8, 12, 24, 30 .... 사용 True Color System 3n = 24 -&gt; 현재 가장 많이 사용 HDRI = high dynamic range imaging 3n = 30 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5. 컬러 이미지 저장 방식","level":1,"id":"5._컬러_이미지_저장_방식_0"},{"heading":"raster(래스터) 저장 방식","level":4,"id":"raster(래스터)_저장_방식_0"},{"heading":"Color Depth","level":4,"id":"Color_Depth_0"},{"heading":"BW and grayscale","level":4,"id":"BW_and_grayscale_0"},{"heading":"Color Image 저장 방법","level":4,"id":"Color_Image_저장_방법_0"},{"heading":"Direct Color System","level":4,"id":"Direct_Color_System_0"}],"links":[],"author":"","coverImageURL":"images/bw_grayscale.png","fullURL":"graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html","pathToRoot":"../../..","attachments":["images/bw_grayscale.html","images/3colorchannel.html","images/color_image.html"],"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":1312,"sourcePath":"graphics/opengl/01.기본/05. 컬러 이미지 저장 방식.md","exportPath":"graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html","showInTree":true,"treeOrder":155,"backlinks":[],"type":"markdown"},"graphics/opengl/01.기본/06.-rgba-컬러-모델.html":{"title":"06. RGBA 컬러 모델","icon":"","description":" True Color System with alpha channel 4n = 32\n픽셀당 4byte -&gt; (R, G, B, A)\n0~255 사이의 정수 OpenGL은 float 사용 void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);\n<img alt=\"color_vs_grayscale.png\" src=\"images/color_vs_grayscale.png\" target=\"_self\">흑백 -&gt; 컬러는 이론상 불가능하지만, 수요가 있다보니 수작업으로 작업했음.\n요즘은 인공지능을 도입해서 변환하고 있음.<br><img alt=\"grey_to_color_using_ai.png\" src=\"images/grey_to_color_using_ai.png\" target=\"_self\">\n키보드 콜백 등록 q w e - &gt; 각각 r g b 값 높임\na s d -&gt; 각각 r g b 값 낮춤 // ChangeColor.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n#include &lt;GL/glew.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#pragma comment(lib, \"opengl32.lib\")\n#pragma comment(lib, \"glew32.lib\")\n#pragma comment(lib, \"glfw3.lib\")\n#pragma warning(disable: 4711 4710 4100)\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; const unsigned int WIN_W = 300;\nconst unsigned int WIN_H = 300;\nconst unsigned int WIN_X = 100;\nconst unsigned int WIN_Y = 100; GLfloat clr[4] = { 0.933F, 0.769F, 0.898F, 1.0F }; void refresh_callback(GLFWwindow* window);\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mods); void refresh_callback(GLFWwindow* window)\n{ glClear(GL_COLOR_BUFFER_BIT); glFinish(); glfwSwapBuffers(window);\n} void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)\n{ switch (key) { case 'Q': clr[0] += 0.01F; if (clr[0] &gt; 1.0F) clr[0] = 1.0F; break; case 'W': clr[1] += 0.01F; if (clr[1] &gt; 1.0F) clr[1] = 1.0F; break; case 'E': clr[2] += 0.01F; if (clr[2] &gt; 1.0F) clr[2] = 1.0F; break; case 'A': clr[0] -= 0.01F; if (clr[0] &lt; 0.0F) clr[0] = 0.0F; break; case 'S': clr[1] -= 0.01F; if (clr[1] &lt; 0.0F) clr[1] = 0.0F; break; case 'D': clr[2] -= 0.01F; if (clr[2] &lt; 0.0F) clr[2] = 0.0F; break; case GLFW_KEY_ESCAPE: if (action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } break; } glClearColor(clr[0], clr[1], clr[2], clr[3]);\n} int main(int argc, char* argv[])\n{ // get your program name\n#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\\\') + 1);\n#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);\n#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare glfwSetWindowRefreshCallback(window, refresh_callback); glfwSetKeyCallback(window, key_callback); glClearColor(clr[0], clr[1], clr[2], clr[3]); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"6. RGBA 컬러 모델","level":1,"id":"6._RGBA_컬러_모델_0"},{"heading":"Color vs Grayscale","level":4,"id":"Color_vs_Grayscale_0"},{"heading":"컬러 변환 프로그래밍","level":3,"id":"컬러_변환_프로그래밍_0"}],"links":[],"author":"","coverImageURL":"images/color_vs_grayscale.png","fullURL":"graphics/opengl/01.기본/06.-rgba-컬러-모델.html","pathToRoot":"../../..","attachments":["images/color_vs_grayscale.html","images/grey_to_color_using_ai.html"],"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":2977,"sourcePath":"graphics/opengl/01.기본/06. RGBA 컬러 모델.md","exportPath":"graphics/opengl/01.기본/06.-rgba-컬러-모델.html","showInTree":true,"treeOrder":156,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html":{"title":"01. 그래픽스 파이프라인","icon":"","description":"vertex input -&gt; vertex processing -&gt; primitive assembly -&gt; rasterization -&gt; fragment processing -&gt; blend -&gt; framebuffer<img alt=\"graphic_pipeline.png\" src=\"images/graphic_pipeline.png\" target=\"_self\">\nVertex: 꼭지점\nfragment = pixel + 색상, 깊이 ... 사용자의 vertex data -&gt; 좌표 변환\n카메라 효과 vertex 결합 -&gt; graphics primitive\n1 vertex -&gt; 점\n2 vertices -&gt; 선분\n3 vertices -&gt; 삼각형 primitive에 포함되는 pixel 선정\n프레임 버퍼에서 출력될 pixel들이 선택됨 각 픽셀이 어떤 색을 가져야할 지 계산됨. fragment 단위 처리로 다양한 효과\n후처리 단계 프레임 버퍼에 하나의 primitive로 저장됨\n그래픽 파이프라인이란 vertex input이 각 단계를 거쳐 프레임버퍼에 하나의 primitive로 저장되는 과정이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 그래픽스 파이프라인","level":1,"id":"1._그래픽스_파이프라인_0"},{"heading":"파이프라인","level":4,"id":"파이프라인_0"},{"heading":"vertex Input","level":4,"id":"vertex_Input_0"},{"heading":"vertex processing","level":4,"id":"vertex_processing_0"},{"heading":"primitive assembly","level":4,"id":"primitive_assembly_0"},{"heading":"rasterization","level":4,"id":"rasterization_0"},{"heading":"fragment processing","level":4,"id":"fragment_processing_0"},{"heading":"blend (post - processing)","level":4,"id":"blend_(post_-_processing)_0"},{"heading":"framebuffer","level":4,"id":"framebuffer_0"}],"links":[],"author":"","coverImageURL":"images/graphic_pipeline.png","fullURL":"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html","pathToRoot":"../../..","attachments":["images/graphic_pipeline.html"],"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":978,"sourcePath":"graphics/opengl/02.응용/01. 그래픽스 파이프라인.md","exportPath":"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html","showInTree":true,"treeOrder":158,"backlinks":["graphics/이론/렌더링-파이프라인-이론.html"],"type":"markdown"},"graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html":{"title":"02. 프로그래머블 그래픽스 파이프라인","icon":"","description":"<img alt=\"paralle_processing.png\" src=\"images/paralle_processing.png\" target=\"_self\">그래픽스 파이프라인이 병렬화되면서, 병렬 처리를 고려한 small size 프로그램이 필요해짐.\n-&gt; Shader의 등장shader = small, special - purpose program\nsmall size\n병렬 처리\n<br><img alt=\"programmable_pipeline.png\" src=\"images/programmable_pipeline.png\" target=\"_self\"> 그래픽스가 fixed VLSI 칩으로 구현 -&gt; fixed pipeline 병렬처리 도입, 일부는 shader로 구현 -&gt; programmable pipeline vertex shader: vertex processing을 대체\nfragment shader: fragment processing을 대체 shader 용어는 모호할 때가 많음 -&gt; 문맥으로 파악하자 vertex processing에 대응되는 프로세싱에 사용되는 코어를 의미하는 경우\n실제 GPU에서 수행되고 있는 프로그램을 의미하는 경우 DirectX HLSL(high-level shader language)\nOpenGL SL(OpenGL shader language)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2. 프로그래머블 그래픽스 파이프라인","level":1,"id":"2._프로그래머블_그래픽스_파이프라인_0"},{"heading":"프로그래머블 파이프라인","level":4,"id":"프로그래머블_파이프라인_0"},{"heading":"Shader programming","level":4,"id":"Shader_programming_0"}],"links":[],"author":"","coverImageURL":"images/paralle_processing.png","fullURL":"graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html","pathToRoot":"../../..","attachments":["images/paralle_processing.html","images/programmable_pipeline.html"],"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":900,"sourcePath":"graphics/opengl/02.응용/02. 프로그래머블 그래픽스 파이프라인.md","exportPath":"graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html","showInTree":true,"treeOrder":159,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/03.-gpu-내부-구조.html":{"title":"03. GPU 내부 구조","icon":"","description":"<img alt=\"gpu_structure.png\" src=\"images/gpu_structure.png\" target=\"_self\">기본 구조는 인풋 레지스터가 있고, 프로세서가 처리한 후 아웃풋 레지스터로 넘겨주는 형식.\nvertext shader와 fragment shader는 GPU Core임\n버텍스 쉐이더와 프래그먼트 쉐이더는 독립적이며 그 사이에 fixed hardware가 있음.\n각각 쉐이더 프로세서는 임시 변수를 저장할 레지스터를 가지고 있음. (tempory variable)\n글로벌 변수가 필요할 수도 있기 때문에 글로벌 레지스터도 있음 (uniform register)\n버텍스 쉐이더 프로세서 처리 값인 varying 레지스터의 값과 rasterization을 거친 varying 레지스터의 값은 다름.\n레지스터는 하나는 내부적으로 4차원 좌표 (x,y,z,w)로 처리하고 타입은 float.\nprimitive assembly 단계에서 적용 가능\n꼭지점이 2개가 주어지면, 나머지 좌표가 결정됨 (보간법)\n컬러도 보간할 수 있음\n<br><img alt=\"linear_interpolation.png\" src=\"images/linear_interpolation.png\" target=\"_self\"><br><img alt=\"bi_linear_interpolation.png\" src=\"images/bi_linear_interpolation.png\" target=\"_self\">\nrasterization의 핵심 기능\n처음에 선분으로 연결하고 보간함\n선분끼리 보간함\n두번 보간해서 이중 선형 보간\n<br><img alt=\"vertex_shader.png\" src=\"images/vertex_shader.png\" target=\"_self\">\nvertex processor가 a vertex data -&gt; normalized vertex data로 변환함\n각각의 버텍스에 적용\ngl_Position, gl_PointSize 같은 pre - defined 되어 있는 레지스터에 값을 넣으면 후처리 단계에서 바로 사용 가능\n<br><img alt=\"primitive_assembly_rasterization.png\" src=\"images/primitive_assembly_rasterization.png\" target=\"_self\">\n3개의 버텍스 정보가 병렬처리를 거쳐서 3개의 버텍스 위치를 gl_Position 레지스터에 동시에 넣어줌\nprimitive assembly로 오면서 3개의 정보가 결합해 삼각형인지 판단\n3개의 버텍스로 시작했지만, 수천개 수만개의 프래그먼트가 생성됨\n이 삼각형 내부에 있는 픽셀을 선택하고 각 픽셀마다 프레그먼트 쉐이더를 진행함.\n<br> <img alt=\"fragment_shader.png\" src=\"images/fragment_shader.png\" target=\"_self\">이중선형보간을 통해 삼각형 내부에 속한 픽셀 하나하나 대응되는 데이터를 가지고 있음.\n이 프래그먼트마다 Fragment Shader를 돌리면 픽셀의 최종값을 결정함. output이 나오고 이는 곧 framebuffer에 업데이트 되는 값임.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"3. GPU 내부 구조","level":1,"id":"3._GPU_내부_구조_0"},{"heading":"레지스터는 어떻게 이뤄져 있을까?","level":4,"id":"레지스터는_어떻게_이뤄져_있을까?_0"},{"heading":"선형 보간 (linear interpolation)","level":4,"id":"선형_보간_(linear_interpolation)_0"},{"heading":"이중 선형 보간 (bi-linear interpolation)","level":4,"id":"이중_선형_보간_(bi-linear_interpolation)_0"},{"heading":"Vertex Shader","level":4,"id":"Vertex_Shader_0"},{"heading":"Primitive Assembly &amp; Rasterization","level":4,"id":"Primitive_Assembly_&_Rasterization_0"},{"heading":"Fragment Shader","level":4,"id":"Fragment_Shader_0"}],"links":[],"author":"","coverImageURL":"images/gpu_structure.png","fullURL":"graphics/opengl/02.응용/03.-gpu-내부-구조.html","pathToRoot":"../../..","attachments":["images/gpu_structure.html","images/linear_interpolation.html","images/bi_linear_interpolation.html","images/vertex_shader.html","images/primitive_assembly_rasterization.html","images/fragment_shader.html"],"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":2443,"sourcePath":"graphics/opengl/02.응용/03. GPU 내부 구조.md","exportPath":"graphics/opengl/02.응용/03.-gpu-내부-구조.html","showInTree":true,"treeOrder":160,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/04.-glsl.html":{"title":"04. GLSL","icon":"","description":"\nC style\n새로운 자료형 도입, 연산 추가 vector, matrix\n벡터, 행렬 연산\n샘플러 for 텍스쳐 맵핑\nGL Master Library GLM으로 발전\nC++ style <img alt=\"opengl_shader_program_process.png\" src=\"images/opengl_shader_program_process.png\" target=\"_self\">\nOpenGL 소스코드를 컴파일 .exe 프로그램을 실행 (OpenGL 프로그램)\nOpenGL 프로그램 내에서 vertext shader, fragment shader를 위한 소스코드를 내부에서 컴파일함.\nGPU는 shader 프로그램 동시 실행\nOpenGL 프로그램에서 user data를 vertex input으로 보냄\n그래픽스 파이프라인 통과 -&gt; 화면 출력\n<br><img alt=\"shader_program_structure.png\" src=\"images/shader_program_structure.png\" target=\"_self\">\nOpenGL은 내부적으로 컴파일러와 실행환경을 가지고 있음\nVertext Shader Object, Fragment Shader\nglCreateShader -&gt; Shader object를 만듦\nglShaderSource -&gt; 소스코드 내보내기\nglCompileShader -&gt; vertex shader 를 위한 소스코드가 컴파일\n내부적으로 obj 파일을 저장하게 됨\nShader 프로그램이 두 obj 파일을 묶어서 다운로드 함 (glAttachProgram)\nglLinkProgram: GPU 쉐이더 Processor에서 실행 가능한 형태로 결합\nglUseProgram: 최종적으로 그래픽 카드에서 실행 #version // 3.3 버전 코어 피쳐 사용\nin vec4 vertexPos; // in은 input 레지스터 사용, x,y,z,w 사용 void main(void)\n{ gl_Polsition = vertexPos\n} <br><img alt=\"vertext_shader_parallel.png\" src=\"images/vertext_shader_parallel.png\" target=\"_self\"><br><img alt=\"rasterization_mean.png\" src=\"images/rasterization_mean.png\" target=\"_self\">#version 330 core out vec4 FragColor; // 프레임버퍼 업데이트. void main()\n{ FragColor = vec4(1.0, 0.0, 0.0, 1.0); // red color\n} <br><img alt=\"fragment_shader_execute.png\" src=\"images/fragment_shader_execute.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"4. GLSL","level":1,"id":"4._GLSL_0"},{"heading":"GLSL","level":4,"id":"GLSL_0"},{"heading":"OpenGL 쉐이더 프로그래밍 전체 과정","level":4,"id":"OpenGL_쉐이더_프로그래밍_전체_과정_0"},{"heading":"Shader Program 구조","level":4,"id":"Shader_Program_구조_0"},{"heading":"Vertex Shader 실행","level":4,"id":"Vertex_Shader_실행_0"},{"heading":"Rasterization","level":4,"id":"Rasterization_0"},{"heading":"Fragment Shader Program","level":4,"id":"Fragment_Shader_Program_0"}],"links":[],"author":"","coverImageURL":"images/opengl_shader_program_process.png","fullURL":"graphics/opengl/02.응용/04.-glsl.html","pathToRoot":"../../..","attachments":["images/opengl_shader_program_process.html","images/shader_program_structure.html","images/vertext_shader_parallel.html","images/rasterization_mean.html","images/fragment_shader_execute.html"],"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":1802,"sourcePath":"graphics/opengl/02.응용/04. GLSL.md","exportPath":"graphics/opengl/02.응용/04.-glsl.html","showInTree":true,"treeOrder":161,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/05.-shader-programming-코드-분석.html":{"title":"05. Shader Programming 코드 분석","icon":"","description":"\nshader program 컴파일 방법\nconst char* vertSource = \"#version 330 core \\n\\\nin vec4 vertexPos; \\n\\\nvoid main(void) { \\n\\ gl_Position = vertexPos; \\n\\\n}\"; const char* fragSource = \"#version 330 core \\n\\\nout vec4 FragColor; \\n\\\nvoid main(void) { \\n\\ FragColor = vec4(1.0, 0.0, 0.0, 1.0); \\n\\\n}\"; GLuint vert = 0; // vertex shader ID number\nGLuint frag = 0; // fragment shader ID number\nGLuint prog = 0; // shader program ID number\nC 프로그램 내에 gl 소스코드를 작성해야해서 스트링 형태로 저장void initFunc(void) { // vert: vertex shader vert = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vert, 1, &amp;vertSource, NULL); glCompileShader(vert); // compile to get .OBJ // frag: fragment shader frag = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(frag, 1, &amp;fragSource, NULL); glCompileShader(frag); // compile to get .OBJ // prog: program prog = glCreateProgram(); glAttachShader(prog, vert); glAttachShader(prog, frag); glLinkProgram(prog); // link to get .EXE // execute it! glUseProgram(prog); // 그래픽 카드에 exe 파일을 실행시키라는 명령어\n} 컴파일 해서 최종적으로 executable 형태로 만들어서 그래픽 카드에 전송하는 것 GLunit glCreateShader(GLenum shaderType); shaderType: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER 버텍스 쉐이더인지, 프래그먼트 쉐이더인지 shaderID를 return 함 void glShaderSource(GLunit shaderID, Glsizei count, const GLChar* string, const GLint length); 소스 전달 함수\nGLSizei - 문자열 개수가 몇개냐\nGLChar** string - 각 문자열 시작주소\nGLint* 각 문자열의 길이 void glCompileShader(GLuint shaderID); 소스를 컴파일 하고 obj 파일을 생성 GLuint glCreateProgram(); shader program을 생성\nprogramID을 리턴함 void glAttachShader(GLuint programID, GLuint shaderID); 쉐이더를 프로그램에 어태치함\n두번 불려야함 (vertex shader, fragment shader) void glLinkProgram(GLuint programID); 쉐이더 obj를 링크하고 executable을 만듦 void glUseProgram(GLuint programID); 프로그램을 GPU에 설치함 void drawFunc(void) { // clear in gray color glClear(GL_COLOR_BUFFER_BIT); // provide the vertex attributes GLuint loc = glGetAttribLocation(prog, \"vertexPos\"); glEnableVertexAttribArray(loc); glVertexAttribPointer(loc, 4, GL_FLOAT, GL_FALSE, 0, vertPos); // draw a triangle glDrawArrays(GL_TRIANGLES, 0, 3); // done glFinish();\n} <img alt=\"use_vertex_attirbute_arrays.png\" src=\"images/use_vertex_attirbute_arrays.png\" target=\"_self\"> GLint glGetAttribLocation(GLuint programID, const GLchar* name); 입력값: 프로그램 ID와, 대응되는 인풋 레지스터 이름\n인풋 레지스터 인덱스가 리턴됨 void glEnableVertexAttribArray(GLuint index); 인풋 레지스터를 enable void glDisableVertexAttribArray(GLuint index); 인풋 레지스터를 Disable void glFinish(void); OpenGL 명령어 큐에 있는 모든 명령을 Finish 시키는 함수 void glVertexAttribPointer(GLuint index, GLint size, gLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer); <br><img alt=\"glVertexAttribPointer.png\" src=\"images/glvertexattribpointer.png\" target=\"_self\">\nvoid glDrawArrays(GLenum mode, GLint first, Glsizei count); Vertex 데이터를 Primitive Assembly 단계에서 어떻게 해석할 지를 결정\nmode: 하나씩 사용할건지, 2개식 사용할건지, 3개씩 묶어서 사용할건지\nfirst: 어디서부터 사용할건지 보통 0\ncount: 갯수 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5. Shader Programming 코드 분석","level":1,"id":"5._Shader_Programming_코드_분석_0"},{"heading":"initFunc","level":1,"id":"initFunc_0"},{"heading":"GL Functions","level":4,"id":"GL_Functions_0"},{"heading":"drawFunc","level":1,"id":"drawFunc_0"},{"heading":"GL Functions","level":4,"id":"GL_Functions_1"}],"links":[],"author":"","coverImageURL":"images/use_vertex_attirbute_arrays.png","fullURL":"graphics/opengl/02.응용/05.-shader-programming-코드-분석.html","pathToRoot":"../../..","attachments":["images/use_vertex_attirbute_arrays.html","images/glvertexattribpointer.html"],"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":3578,"sourcePath":"graphics/opengl/02.응용/05. Shader Programming 코드 분석.md","exportPath":"graphics/opengl/02.응용/05.-shader-programming-코드-분석.html","showInTree":true,"treeOrder":162,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/06.-재사용가능한-코드.html":{"title":"06. 재사용가능한 코드","icon":"","description":"const char* vertSource = \"#version 330 core \\n\\\nin vec4 vertexPos; \\n\\\nvoid main(void) { \\n\\ gl_Position = vertexPos; \\n\\\n}\"; const char* fragSource = \"#version 330 core \\n\\\nout vec4 FragColor; \\n\\\nvoid main(void) { \\n\\ FragColor = vec4(1.0, 0.0, 0.0, 1.0); \\n\\\n}\"; vertex / fragment shader source code는 const char* 임\n별도의 파일로 저장하고, 읽어오는 함수를 사용하는 것이 편함.\nconst char* loadFile( const char* filename ) { FILE* fp = fopen( filename, \"r\" ); if (fp == NULL) { fprintf(stderr, \"Error: cannot open \\\"%s\\\"\\n\", filename); return NULL; } // get file size to allocate a buffer fseek(fp, 0, SEEK_END); size_t len = ftell(fp); rewind(fp); char* buf = (char*)malloc(sizeof(char) * (len + 4)); // read in the whole contents: (ASSUMPTION: small file size) size_t size = fread(buf, sizeof(char), len, fp); fclose(fp); buf[size] = '\\0'; // done return (const char*)buf;\n}\n<img alt=\"export_shader_code.png\" src=\"images/export_shader_code.png\" target=\"_self\">loadFile에서 malloc을 사용 했기 때문에 free 꼭 해줘야함 (InitFunc에서 free 시키기)const char* vertSource = loadFile( vertFileName );\nconst char* fragSource = loadFile( fragFileName );\nfree( (void*)vertSource );\nfree( (void*)fragSource ); 현재 = Old\ninput attribute = attribute\noutput varying register = varying\nFragColor = gl_FragColor GLSL 변수-&gt; Register 사용 어느 Register를 사용할것인가? GLSL 컴파일러가 할당\n프로그래머가 강제로 할당 가능 -&gt; layout 키워드 n번째 register 할당<br>\n<img alt=\"layout_qualifier.png\" src=\"images/layout_qualifier.png\" target=\"_self\"> GLuint loc = glGetAttribLocation(prog, \"vertexPos\");\nvertexPos가 저장된 레지스터 번호 가져 오는 방법 prog는 뭐지? - glProgram같은 layout에 할당할 시 컴파일러가 화냄 (에러 발생)OpenGL은 오래되어서 컴파일 안되는 레거시 코드가 많음.Example.\nglBegin / glEnd\nglVertex3f, 4f, 3fv, 4fv\nglColor3f, 4f, 3fv, 4fv\nglNormal3f, 3fv\nGLUT function 사용 -&gt; 현재 GLUT 사용자 없음.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"6. 재사용가능한 코드","level":1,"id":"6._재사용가능한_코드_0"},{"heading":"shader program","level":4,"id":"shader_program_0"},{"heading":"Old syntex","level":4,"id":"Old_syntex_0"},{"heading":"layout 키워드","level":4,"id":"layout_키워드_0"},{"heading":"Legacy","level":4,"id":"Legacy_0"}],"links":[],"author":"","coverImageURL":"images/export_shader_code.png","fullURL":"graphics/opengl/02.응용/06.-재사용가능한-코드.html","pathToRoot":"../../..","attachments":["images/export_shader_code.html","images/layout_qualifier.html"],"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":2133,"sourcePath":"graphics/opengl/02.응용/06. 재사용가능한 코드.md","exportPath":"graphics/opengl/02.응용/06.-재사용가능한-코드.html","showInTree":true,"treeOrder":163,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/07.-glsl-자료형.html":{"title":"07. GLSL 자료형","icon":"","description":"\nGLSL 자료형 Vector GLSL Matrix GLSL 언어적 특징\nGLSL Qualifiers varying colors 프로그램\n<img alt=\"type_structure.png\" src=\"images/type_structure.png\" target=\"_self\">\nbasic type int, uint, float, double, bool 주로 float을 사용함<br>\n<img alt=\"register_vec.png\" src=\"images/register_vec.png\" target=\"_self\"> vectors float형: vec2, vec3, vec4\nint형: ivecn\nboolean형: bvecn Matrices float형: mat2, mat3, mat4\n주의: 열 우선임<br>\n<img alt=\"matrix_row_prior.png\" src=\"images/matrix_row_prior.png\" target=\"_self\"> 기본적으로 attribute는 4개의 float을 담음.vec4를 주로 이용하는데 attribute의 멤버에 따라 어떻게 해석할 지 달라짐.\n단순 value\n배열로 나타내기\nxyzw -&gt; 좌표\nstpq -&gt; 텍스처 좌표\nrgba -&gt; rgba 색상 a.xyzw = v.xyzw; // default\na = v.wzyx; // shuffled\n단! 서로 다른 도메인끼리는 불가\nxyzw, rgba, stpq 혼용불가 -&gt; .xgt 불가능\n2차원 배열\nfloat 형만 있음\n열 우선임 -&gt; mat (n x m)일 때 n이 열, m이 행\n레지스터에서 Matrix -&gt; mat4인 경우 -&gt; 4개의 register 포인터 자료형 없음\nvector, matrix가 기본 자료형\nc++스타일 구조체 사용가능\n<br><img alt=\"func_1.png\" src=\"images/func_1.png\" target=\"_self\">\n파라미터에 in, out, inout을 넣을 수 있음기본적으로 안붙이면 in (call by value)고\nout을 붙이면 y에 대한 call by ref임<br><img alt=\"math_func.png\" src=\"images/math_func.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"7. GLSL 자료형","level":1,"id":"7._GLSL_자료형_0"},{"heading":"Data Types","level":4,"id":"Data_Types_0"},{"heading":"스위즐링 연산 가능","level":4,"id":"스위즐링_연산_가능_0"},{"heading":"Matrix","level":4,"id":"Matrix_0"},{"heading":"GLSL 특징","level":4,"id":"GLSL_특징_0"},{"heading":"함수","level":4,"id":"함수_0"}],"links":[],"author":"","coverImageURL":"images/type_structure.png","fullURL":"graphics/opengl/02.응용/07.-glsl-자료형.html","pathToRoot":"../../..","attachments":["images/type_structure.html","images/register_vec.html","images/matrix_row_prior.html","images/func_1.html","images/math_func.html"],"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":1384,"sourcePath":"graphics/opengl/02.응용/07. GLSL 자료형.md","exportPath":"graphics/opengl/02.응용/07.-glsl-자료형.html","showInTree":true,"treeOrder":164,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/08.-uniform-variable.html":{"title":"08. Uniform Variable","icon":"","description":"N개의 삼각형을 그린다고 가정하면, 각 삼각형은 각각의 3개의 Vertex Pos를 가질 거임.GLfloat vertPosFirst[] = { -0.5F, -0.5F, 0.0F, 1.0F, +0.0F, -0.5F, 0.0F, 1.0F, -0.5F, +0.0F, 0.0F, 1.0F,\n}; GLfloat vertPosSecond[] = { 0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.0F, 0.0F, 1.0F, 0.0F, 0.5F, 0.0F, 1.0F,\n}; ... n개가 필요함. 이렇게 n개의 삼각형 vertPos를 가지기 보다는 잘 정의된 vertex pos를 가지고 값을 더해서 새로운 삼각형을 표현할 수가 있음. -&gt; uniform variable을 사용하자.Uniform Variable은 일종의 전역변수임<img alt=\"using_uniform.png\" src=\"images/using_uniform.png\" target=\"_self\">uniform variable은 uniform vec4로 선언함.#version 330 core in vec4 aPos; // vertex position: attribute\nin vec4 aColor; // vertex color: attribute\nout vec4 vColor; // varying color: varying\nuniform vec4 uMove; // movement vector: uniform void main(void) { gl_Position = aPos + uMove; vColor = aColor;\n} void drawFunc(void) { // clear in gray color glClear(GL_COLOR_BUFFER_BIT); // provide the vertex attributes GLuint locPos = glGetAttribLocation(prog, \"aPos\"); glEnableVertexAttribArray(locPos); glVertexAttribPointer(locPos, 4, GL_FLOAT, GL_FALSE, 0, vertPos); // provide the color attributes GLuint locColor = glGetAttribLocation(prog, \"aColor\"); glEnableVertexAttribArray(locColor); glVertexAttribPointer(locColor, 4, GL_FLOAT, GL_FALSE, 0, vertColor); // draw the first triangle GLuint locMove = glGetUniformLocation(prog, \"uMove\"); glUniform4f(locMove, -0.5F, -0.5F, 0.0F, 0.0F); glDrawArrays(GL_TRIANGLES, 0, 3); // draw the second triangle glUniform4f(locMove, 0.0F, 0.0F, 0.0F, 0.0F); glDrawArrays(GL_TRIANGLES, 0, 3); // done glFinish();\n} // prog: Program\n// name: string for uniform variable name\n// return: location index of the specified uniform variable GLint glGetUniformLocation(GLuint prog, const GLchar* name); // 아래 함수는 값을 넣을 수 있음\nvoid glUniform1f(GLint loc, Glfloat v0);\nvoid glUniform2f(GLint loc, Glfloat v0 ...v1);\nvoid glUniform3f(GLint loc, Glfloat v0 ... v1 ... v2);\nvoid glUniform4f(GLint loc, Glfloat v0 ... v1 ... v2 ... v3); // 벡터도 넣을 수 있음. 예시 const GLfloat uMoveValue[] = {0.5f, 0.5f 0.5f, 0.5f }; void glUniform1fv(GLint loc, GLsizei count, const GLfloat* value);\nvoid glUniform2fv(GLint loc, GLsizei count, const GLfloat* value);\nvoid glUniform3fv(GLint loc, GLsizei count, const GLfloat* value);\nvoid glUniform4fv(GLint loc, GLsizei count, const GLfloat* value); // transpose 전치 되어 있는 지?\nvoid glUniformMatrix4fv(GLint loc, GLsizei count, GLbooleadn transpose,const GLfloat* value); count는 몇개를 보낼건지에 대한 거임. 예시를 보면 이해감// 단일 float 값 설정\nGLfloat brightness = 0.8f;\nglUniform1fv(brightnessLocation, 1, &amp;brightness); // 3D 벡터 (색상) 설정\nGLfloat color[] = {1.0f, 0.0f, 0.0f}; // 빨간색\nglUniform3fv(colorLocation, 1, color); // 여러 개의 2D 벡터 설정\nGLfloat positions[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f}; // 3개의 2D 위치\nglUniform2fv(positionsLocation, 3, positions);\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"8. Uniform Variable","level":1,"id":"8._Uniform_Variable_0"},{"heading":"Uniform Variable Functions","level":4,"id":"Uniform_Variable_Functions_0"}],"links":[],"author":"","coverImageURL":"images/using_uniform.png","fullURL":"graphics/opengl/02.응용/08.-uniform-variable.html","pathToRoot":"../../..","attachments":["images/using_uniform.html"],"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":3215,"sourcePath":"graphics/opengl/02.응용/08. Uniform Variable.md","exportPath":"graphics/opengl/02.응용/08.-uniform-variable.html","showInTree":true,"treeOrder":165,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/09.-glsl-디버그-함수들.html":{"title":"09. GLSL 디버그 함수들","icon":"","description":"\nGLSL 디버그 함수들\nOpenGL 함수의 디버깅\nOpenGL debug output\n#version 330 core in vec3 vColor; // LINK ERROR: type mismatch ! out vec4 FragColor; // fragment color: framebuffer void main(void) { FragColor = vColor; // ERROR: type mismatch!\n}\n위의 코드는 error 가 있는 frag 파일임. 이를 컴파일 했을 때 문제가 생김. 그러나 프로그램은 실행이 됨. - 회색 화면이 출력됨.디버그를 하기 위해서는 아래의 GLSL 함수를 이용 해야함.void glGetShaderiv(GLuint shader, GLenum pname, GLint* params); pname: 어떤 값을 전달 받을 것인가에 대한 정의임. GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH ... params: pname에 대한 결과 GL_COMPILE_STATUS을 지정했다면, 성공: true(1) 실패: false(0) void glGetShaderInfoLog(GLuint shader, GLsizei maxLen, GLsizei* length, GLchar* infoLog); maxLen: infoLog array의 최대 길이\nlength: infoLog array의 길이\ninfoLog: 로그 정보 (버퍼에 담겨서 옴)\nprog에서 디버깅 하기 (링킹, 실행)<img alt=\"prog_debugging.png\" src=\"images/prog_debugging.png\" target=\"_self\">실제 사용 vert, frag에서<br>\n<img alt=\"glsl_debugging_1.png\" src=\"images/glsl_debugging_1.png\" target=\"_self\"> prog에서<br>\n<img alt=\"glsl_debugging2.png\" src=\"images/glsl_debugging2.png\" target=\"_self\"> 디버깅 결과 정상<br>\n<img alt=\"debugging_success.png\" src=\"images/debugging_success.png\" target=\"_self\"> 에러 발생<br>\n<img alt=\"debugging_failure.png\" src=\"images/debugging_failure.png\" target=\"_self\"> OpenGL 드라이버 내부에 error flag 변수를 이용\nGLenum glGetError(); 함수를 이용.\nGLenum glGetError(); returns: errorFlag\n리턴 되고나면 error flag 변수를 GL_NO_ERROR로 초기화\n<br><img alt=\"gl_error_flag.png\" src=\"images/gl_error_flag.png\" target=\"_self\">\nOpenGL debug extension - 크로노스 그룹에서 만들었음.\nOpenGL 4.3에서 core feature가 되었음.\nnew 이벤트 드라이븐 모델임 OpenGL Error는 event임.\nevent handler는 callback function임 debug event 원인: API, WINDOW_SYSTEM, SHADER_COMPILER, …\n종류: ERROR, UNDEFINED_BEHAVIOR, PERFORMANCE, MARKER (사용자가 표시한것), …\n심각성의 정도: severe levels, HIGH, MEDIUM, LOW, NOTIFICATION 그 중 DONT_CARE는 everything임 glEnable(GL_DEBUG_OUTPUT); // 디버그 사용 활성화\nglEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); // 결과 즉시 출력\nglDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0 ,NULL, GL_TRUE); // -&gt; 모든 디버그 메세지 받음\nglDebugMessageCallback(DebugLog, NULL); // DebugLog라는 함수를 콜백으로 등록함.\nvoid glEnable(GLenum cap);\nvoid glDisable(Glenum cap);\nOpenGL 내부의 특정 기능을 on/off함void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled); debug 이벤트 설정 - source, type, severity\nenabled: 기능을 끌 것인지 켤 것인지.\nids: 에러 id 넘버에 따라서 기능을 끌 것인지 켤 것인지 - ids다보니까 배열임\ncount: ids는 포인터 타입이라 길이가 없음. 길이를 여기에 넣으면 됨\n콜백함수 등록에 관하여.typedef void (*DEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam); userParam: 사용자가 특정한 파라미터를 넣을 수 있음 -&gt; 추가적인 컨텍스트나 데이터 전달 가능\nvoid APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam) { MyLogger* logger = (MyLogger*)userParam; logger-&gt;log(message);\n} // 콜백 설정 시\nMyLogger myLogger;\nglDebugMessageCallback(debugCallback, &amp;myLogger); MyLogger 객체의 포인터가 userParam으로 전달되어, 콜백 함수 내에서 로깅에 사용\nuserParam은 const void* 타입이므로, 사용 시 적절한 타입으로 캐스팅해야 함\n전달된 객체나 데이터의 생명주기 관리해야함\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"9. GLSL 디버그 함수들","level":1,"id":"9._GLSL_디버그_함수들_0"},{"heading":"Contents","level":4,"id":"Contents_0"},{"heading":"GLSL 디버그 함수들","level":2,"id":"GLSL_디버그_함수들_0"},{"heading":"OpenGL 에러 처리 방법 (구버전)","level":2,"id":"OpenGL_에러_처리_방법_(구버전)_0"},{"heading":"OpenGL Debug Output (이걸 보통 사용)","level":4,"id":"OpenGL_Debug_Output_(이걸_보통_사용)_0"}],"links":[],"author":"","coverImageURL":"images/prog_debugging.png","fullURL":"graphics/opengl/02.응용/09.-glsl-디버그-함수들.html","pathToRoot":"../../..","attachments":["images/prog_debugging.html","images/glsl_debugging_1.html","images/glsl_debugging2.html","images/debugging_success.html","images/debugging_failure.html","images/gl_error_flag.html"],"createdTime":1743691206983,"modifiedTime":1743691206983,"sourceSize":4052,"sourcePath":"graphics/opengl/02.응용/09. GLSL 디버그 함수들.md","exportPath":"graphics/opengl/02.응용/09.-glsl-디버그-함수들.html","showInTree":true,"treeOrder":166,"backlinks":[],"type":"markdown"},"graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html":{"title":"10. OpenGL 깊이 버퍼와 렌더링 순서","icon":"","description":"깊이 버퍼는 3D 그래픽스에서 어떤 물체가 다른 물체를 가리는지 결정하는 핵심 메커니즘이다.\n작동 원리: 각 픽셀마다 카메라로부터의 거리(Z값)를 저장\n범위: 일반적으로 [0.0, 1.0] (0.0은 near plane, 1.0은 far plane)\n정밀도: 일반적으로 16비트, 24비트 또는 32비트 (24비트가 가장 일반적)\n분포: 비선형적 분포 - 가까운 거리에서 정밀도가 높고, 먼 거리에서는 정밀도가 낮음\n// 깊이 테스트 활성화\nglEnable(GL_DEPTH_TEST); // 깊이 테스트 비교 함수 설정 (기본값은 GL_LESS)\nglDepthFunc(GL_LESS); // 새 픽셀의 깊이 값이 작을 때(더 가까울 때) 통과\n// 렌더링 루프에서 매 프레임마다 색상 버퍼와 깊이 버퍼를 함께 초기화\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n// 깊이 버퍼 쓰기 활성화 (기본값)\nglDepthMask(GL_TRUE); // 깊이 버퍼 쓰기 비활성화 (투명 오브젝트 그릴 때 유용)\nglDepthMask(GL_FALSE); GL_LESS: 새 값이 작을 때 통과 (기본값)\nGL_LEQUAL: 새 값이 작거나 같을 때 통과\nGL_GREATER: 새 값이 클 때 통과\nGL_GEQUAL: 새 값이 크거나 같을 때 통과\nGL_EQUAL: 새 값이 같을 때만 통과\nGL_NOTEQUAL: 새 값이 다를 때 통과\nGL_ALWAYS: 항상 통과\nGL_NEVER: 절대 통과하지 않음\nZ-fighting은 두 물체가 거의 같은 깊이에 있을 때 깜빡이는 현상입니다.\n깊이 버퍼의 제한된 정밀도\nnear plane과 far plane 사이의 거리가 너무 큰 경우\n특히 먼 거리에서 정밀도가 낮아지는 비선형 분포로 인해 발생 near/far plane 비율 줄이기: 시야 범위를 필요한 만큼만 설정\nglm::mat4 projection = glm::perspective(glm::radians(45.0f), aspect_ratio, 0.1f, 100.0f); 높은 정밀도의 깊이 버퍼 사용: 24비트 또는 32비트 깊이 버퍼 사용\n물체 배치 조정: 서로 다른 물체가 완전히 같은 깊이에 있지 않도록 약간 간격 두기\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 깊이 버퍼 (Z-buffer) 기본 개념","level":2,"id":"1._깊이_버퍼_(Z-buffer)_기본_개념_0"},{"heading":"2. 깊이 버퍼 설정 방법","level":2,"id":"2._깊이_버퍼_설정_방법_0"},{"heading":"기본 설정","level":3,"id":"기본_설정_0"},{"heading":"깊이 버퍼 초기화","level":3,"id":"깊이_버퍼_초기화_0"},{"heading":"깊이 버퍼 쓰기 제어","level":3,"id":"깊이_버퍼_쓰기_제어_0"},{"heading":"깊이 비교 함수 옵션","level":3,"id":"깊이_비교_함수_옵션_0"},{"heading":"3. 깊이 버퍼 정밀도와 Z-fighting","level":2,"id":"3._깊이_버퍼_정밀도와_Z-fighting_0"},{"heading":"원인","level":3,"id":"원인_0"},{"heading":"해결 방법","level":3,"id":"해결_방법_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html","pathToRoot":"../../..","attachments":[],"createdTime":1743691206983,"modifiedTime":1743691206983,"sourceSize":2388,"sourcePath":"graphics/opengl/02.응용/10. OpenGL 깊이 버퍼와 렌더링 순서.md","exportPath":"graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html","showInTree":true,"treeOrder":167,"backlinks":[],"type":"markdown"},"graphics/rasterizer/0.-목표에-대해서.html":{"title":"0. 목표에 대해서","icon":"","description":"렌더링 파이프라인에서 일어나는 일들을 직접 구현 하는 것을 목표로 한다. 직접 Rasterizer를 구현하면서 모르는 개념은 학습하고 아는 개념은 좀 더 다듬을 것이다. 더 자세히 이해하고 넘어가는 것이 목표다.그리고 좀 더 잘 기억하고 잘 기록하는 것이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/rasterizer/0.-목표에-대해서.html","pathToRoot":"../..","attachments":[],"createdTime":1752496366911,"modifiedTime":1752496661853,"sourceSize":343,"sourcePath":"graphics/Rasterizer/0. 목표에 대해서.md","exportPath":"graphics/rasterizer/0.-목표에-대해서.html","showInTree":true,"treeOrder":169,"backlinks":[],"type":"markdown"},"graphics/rasterizer/1.-브레젠험-직선-알고리즘.html":{"title":"1. 브레젠험 직선 알고리즘","icon":"","description":"Bresenham's Line Algorithm은 두 점 사이의 직선을 픽셀 격자 위에 그리는 효율적인 방법이다. 화면은 이산적인 (정수 좌표라는 뜻) 픽셀로 구성되어 있기 때문에 수학적으로 연속적인 직선을 어떤 픽셀에 그릴지 결정해야 한다. 따라서 부동소수점 연산 대신에 정수 연산만 한다.내가 이해한 것에 의하면 브레젠험 직선 알고리즘의 핵심은 '오차(Error)'다.\n오차는 이상적인 직선 (수학적으로 연속적인 직선)과 실제로 그려진 픽셀들 사이의 수직거리다.\n즉, 오차 = 직선의 y 좌표 - 현재 픽셀의 y좌표이다.예를 들면 어떤 직선의 방정식가 있고 (5, 2.7)를 지난다고 가정한다. 만약 우리가 (5,2)를 선택했다면 오차는 2.7 - 2 = 0.7이 되는 것이다.브레젠험 직선 알고리즘은 x좌표가 이동할 때마다 오차를 누적하고 이 오차가 0.5를 넘으면 다음 픽셀은 위쪽으로 이동 시킨다. (y -&gt; y+1)먼저 기울기를 생각해야한다. 기울기는 dy / dx로 정의하고 m이라고 가정한다.만약 0 &lt; m &lt;= 1 이라면 x를 움직이고 y가 이동할 지 계산한다. 즉 주도축은 x축이다.\n만약 m &gt;= 1 이라면 y를 움직이고 x가 이동할 지 계산한다. 즉 주도축은 y축이다.이제 오차를 어떻게 누적하는지 살펴보자.기울기가 0 &lt; m &lt;= 1, 현재 픽셀이 (x,y)에 있다고 가정한다.\n주도축은 x축이므로 x를 이동 시킨다. x' = x + 1\n현재 오차에 기울기를 더함 error = error + m (기울기는 x가 변할 때의 y의 변화값임)\n만약 여기에서 error &gt;= 0.5이라면:\ny 이동 y' = y + 1\nerror = error - 1\n만약 아니라면:\ny를 유지 y' = y\n동작 방식은 이렇지만 아직 손볼 곳이 좀 남아있다. 왜냐하면 브레젠험 직선 알고리즘은 부동 소수점 연산을 사용하지 않는다. 그래서 정리를 통해서 정수 연산으로 바꿔줘야 한다.오차를 누적할 때의 식이 error = error + m인데 여기에서 m은 기울기라 유리수가 나올 수 있다. 그래서 양변에 dx를 곱해줘서 정수 연산을 유지할 수 있다.error dx = error dx + (m dx = dy) 따라서 모든 error 대신에 error dx를 사용한다. 이를 scaled_error라고 해보자. 그러면 아래처럼 정리할 수 있다.error dx &gt;= 0.5이라면 -&gt; scaled_error &gt;= (1/2) dx\ny 이동 y' = y + 1\nscaled_error = scaled_error - dx\nscaled_error = scaled_error + dy\n마찬가지로 아직 1/2 * dx 니까 양변에 또 2를 곱해주면 된다.정리하면 아래와 같다.error_2scaled = 0 // error × dx × 2\nthreshold = dx // dx/2 × 2 for each x: if error_2scaled &gt;= threshold: // 완전한 정수 비교! y++ error_2scaled = error_2scaled - (dx × 2) // dx×2를 빼기 error_2scaled = error_2scaled + (dy × 2) // dy×2를 더하기\n이걸 C++ 코드로 작성하면\nvoid bresenham(int x1, int y1, int x2, int y2) { int dx = abs(x2 - x1); int dy = abs(y2 - y1); int stepX = (x1 &lt; x2) ? 1 : -1; int stepY = (y1 &lt; y2) ? 1 : -1; if (dx &gt;= dy) { int x = x1; int y = y1; int error = dx; // 초기 오차 = dx (0.5 × 2 × dx와 같음) for (int i = 0; i &lt;= dx; i++) { drawPixel(x, y); if (i &lt; dx) { // 마지막 픽셀이 아닌 경우 error += 2 * dy; if (error &gt;= 2 * dx) { y += stepY; error -= 2 * dx; } x += stepX; } } } else { int x = x1; int y = y1; int error = dy; // 초기 오차 = dy (0.5 × 2 × dy와 같음) for (int i = 0; i &lt;= dy; i++) { drawPixel(x, y); if (i &lt; dy) { // 마지막 픽셀이 아닌 경우 error += 2 * dx; if (error &gt;= 2 * dy) { x += stepX; error -= 2 * dy; } y += stepY; } } } std::cout &lt;&lt; \"\\n\\n\";\n}\n구현한 코드를 보면 주도축을 분기해서 경우에 따라 처리했다. 다만 실제 코드에서는 좀 더 간결하게 주도축을 미리 나누지 않고 하나의 루프에서 처리한다.void bresenham_optimized(int x0, int y0, int x1, int y1) { int dx = abs(x1 - x0); int dy = abs(y1 - y0); int sx = x0 &lt; x1 ? 1 : -1; int sy = y0 &lt; y1 ? 1 : -1; int err = dx - dy; // 핵심: 두 축의 이동 균형 지표 int step = 0; while (true) { drawPixel(x0, y0, \"o\"); if (x0 == x1 &amp;&amp; y0 == y1) break; int e2 = 2 * err; bool moved_x = false, moved_y = false; // X 이동 조건: e2 &gt; -dy if (e2 &gt; -dy) { err -= dy; x0 += sx; moved_x = true; } // Y 이동 조건: e2 &lt; dx if (e2 &lt; dx) { err += dx; y0 += sy; moved_y = true; } step++; } std::cout &lt;&lt; \"\\n\\n\";\n}\n이 코드는 직관적으로 이해해보는 것이 목표다. 핵심 아이디어는 균형 관리다.알고리즘의 목표는 각 픽셀에서 '실제 직선과의 거리'를 최소화하는 것이 목표다. 그래서 균형은 매 순간 '가장 가까운 픽셀'을 선택하는 것이다. 그러기 위해서는 dx:dy 비율을 유지하면서 이동 해야 한다.\n이 비율을 실시간으로 체크하면서 균형을 추적 해야한다. 이 알고리즘에서는 dx -dy를 이용해서 균형을 추적 한다.int err = dx - dy;에서 dx는 x축 이동 할당량, dy는 y축 이동 할당량이라고 생각하면 err은 균형의 기울어진 정도로 생각할 수 있다.먼저 x 좌표의 이동 조건을 보자.if (2 * err &gt; -dy) 이 식을 변형을 하면 2 * err &gt; -dy\n2 * (dx - dy) &gt; -dy\n2 * dx &gt; dy\ndx &gt; (1 / 2) * dy 로 변형을 할 수 있다.\n즉, dx &gt; (1 / 2) * dy 식은 'x로 이동 할당량이 y 이동 할당량의 절반보다 크면' 이라고 해석할 수 있다.\n다시 말해서 x축이 충분히 여유가 있으니 x를 한칸 이동하고 y축에게 빚을 지는 것이다. 이때 -dy 해야하는데 빼기를 하는 이유는 균형에 대한 정의를 (dx - dy)로 정의 했기 때문이다.y 좌표의 이동조건을 보자.if (2 * err &lt; dx) 이 식을 변형을 하면\n2 * err &lt; dx\n2 * (dx - dy) &lt; dx\ndx &lt; 2 * dy\n(1/2) * dx &lt; dy\n로 변형할 수 있다.\n즉 (1/2) * dx &lt; dy은 x 이동이 여유가 없으니 y를 이동하고 x축에 빚을 진다. ( +dx)이러한 방식으로 루프 안에서 균형을 계속 맞춰가면서 픽셀을 찍어주면 두 점 사이의 직선과 근사한 직선을 그릴 수 있게 된다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"알고리즘의 목적","level":4,"id":"알고리즘의_목적_0"},{"heading":"아이디어","level":4,"id":"아이디어_0"},{"heading":"동작 방식","level":4,"id":"동작_방식_0"},{"heading":"코드 개선 사항","level":4,"id":"코드_개선_사항_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/rasterizer/1.-브레젠험-직선-알고리즘.html","pathToRoot":"../..","attachments":[],"createdTime":1752496673734,"modifiedTime":1752506723611,"sourceSize":6698,"sourcePath":"graphics/Rasterizer/1. 브레젠험 직선 알고리즘.md","exportPath":"graphics/rasterizer/1.-브레젠험-직선-알고리즘.html","showInTree":true,"treeOrder":170,"backlinks":[],"type":"markdown"},"graphics/unreal-engine/basic.html":{"title":"Basic","icon":"","description":" 최종 색상 = 베이스 컬러 × 조명 &lt; = &gt; 조명 = 최종 색상 ÷ 베이스 컬러 빼기로 그림자 임계값을 조정하는 원리\nShadow Bias을 0.5로 가정함\n조명 값 0.7 - 0.5 = 0.2 (양수) → 하이라이트\n조명 값 0.3 - 0.5 = -0.2 (음수) → 그림자\nSaturate 적용 후\n양수는 그대로 유지 (하이라이트 영역)\n음수는 0이 됨 (그림자 영역)\n즉 빼기 연산으로 임계점을 이동하는 것임. 그림자 임계값의 의미\n몇 퍼센트 이상의 조명이 있어야 밝은 영역으로 볼 것인가?\nShadow Bias = 0.3 → 30% 이상이면 하이라이트\nShadow Bias = 0.7 → 70% 이상이면 하이라이트 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/unreal-engine/basic.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491026,"modifiedTime":1754545491026,"sourceSize":701,"sourcePath":"graphics/Unreal Engine/Basic.md","exportPath":"graphics/unreal-engine/basic.html","showInTree":true,"treeOrder":172,"backlinks":[],"type":"markdown"},"graphics/unreal-engine/material.html":{"title":"Material","icon":"","description":"Base Color (기본 색상)\n역할: 오브젝트의 기본 색상을 결정\n입력값: RGB 벡터 (0-1 범위)\nMetallic (금속성)\n역할: 표면이 금속인지 비금속인지 결정\n입력값: 0 (비금속) ~ 1 (완전한 금속)\n특징: 0 또는 1의 극값을 주로 사용 (중간값은 드물게 사용 - 먼지, 녹슨 \b금속 같은 혼합 표면)\n플라스틱 = 0, 철/금 = 1\nRoughness (거칠기)\n역할: 표면의 거칠기 정도 (반사의 선명도)\n입력값: 0 (완전히 매끄러움) ~ 1 (매우 거칠음)\n거울 = 0, 종이 = 0.8\nNormal (법선)\n역할: 표면의 디테일한 굴곡 정보\n입력값: Normal Map 텍스처 (RGB)\n특징: 실제 지오메트리 변경 없이 디테일 추가\nSpecular (반사 강도)\n역할: 비금속 재질의 반사 강도 조절\n입력값: 0 (반사 없음) ~ 1 (강한 반사)\n기본값: 0.5 (대부분의 재질에 적합 - 반사율 4%) 플라스틱 장난감: 0.9 (높은 반사)\n나무, 천: 0.1-0.3 (낮은 반사)\n유리: 1.0 (최대 반사) 특이사항: Metallic이 1일 때는 효과 없음 (금속은 Base Color로 반사색 결정)\nEmissive (자체 발광)\n역할: 라이팅 없이도 스스로 빛을 내는 효과\n입력값: RGB 색상 (1 초과 가능 → 더 밝은 발광)\n특징: 주변 오브젝트도 밝힐 수 있음 (Lumen 사용 시)\n사용 예시: LED 스크린: 밝은 컬러값 (2, 2, 2)\n네온사인: 특정 색상 (0, 5, 10) - 파란 네온\n마법 효과: 애니메이션되는 발광값 Opacity (투명도)\n역할: 머티리얼의 투명한 정도 조절\n입력값: 0 (완전 투명) ~ 1 (완전 불투명)\n전제조건: Material의 Blend Mode를 Translucent로 설정 필요\n사용 예시: 유리창: 0.1-0.3\n물: 0.7-0.9\n홀로그램: 0.5 World Position Offset (월드 위치 오프셋)\n역할: 버텍스의 월드 좌표를 직접 변형\n입력값: XYZ 벡터 (변형할 거리)\n특징: 메시 자체를 변형시킴 (그림자도 함께 변형)\n사용 예시: 깃발 흔들림: Sin 함수로 Y축 움직임\n물결 효과: 여러 주파수의 파동 조합\n폭발 효과: 버텍스를 바깥쪽으로 밀어냄 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"주로 사용하는 Output","level":3,"id":"주로_사용하는_Output_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/unreal-engine/material.html","pathToRoot":"../..","attachments":[],"createdTime":1752590582977,"modifiedTime":1752590582977,"sourceSize":2278,"sourcePath":"graphics/Unreal Engine/Material.md","exportPath":"graphics/unreal-engine/material.html","showInTree":true,"treeOrder":173,"backlinks":[],"type":"markdown"},"graphics/unreal-engine/rim-light와-fresnel-노드.html":{"title":"Rim Light와 Fresnel 노드","icon":"","description":"광원을 등지고 있을 때 오브젝트의 테두리가 밝게 빛나는 현상을 본 적이 있을것이다. 오브젝트의 가장자리(윤곽)를 따라 나타나는 조명 효과를 림라이트 또는 역광이라고 한다. 컴퓨터 그래픽스에서는 오브젝트를 배경에서 분리시켜 입체감이 증가하고, 실루엣을 강조해서 시각적 효과를 강하게 주는 효과로 이용한다.이러한 효과는 언리얼엔진 머티리얼 에디터에서 손쉽게 만들 수 있다. Fresnel 노드를 이용해서 만드는데 프레넬이 뭔지부터 알아보자.언리얼엔진 문서에 의하면\n프레넬&nbsp;은 화각에 따라 반사되는 빛의 세기가 달라지는 현상을 설명하는 용어입니다. 예를 들어 웅덩이 위에 서서 수직으로 내려다보는 경우 수면 위에 빛 반사가 많지는 않을 것입니다. 관찰자가 머리를 움직여 웅덩이의 수면이 시선과 평행이 될수록 수면 위의 빛 반사가 점점 더 많이 보일 것입니다. 물과 유리는 모두 강한 프레넬 경향성을 띠며, 이는 정면에서 보면 상대적으로 투명해 보이고 비스듬한 각도에서 보면 빛을 더 많이 반사함을 뜻합니다.\n언리얼 엔진에서&nbsp;Fresnel 머티리얼 표현식&nbsp;은 표면 노멀과 카메라 방향의&nbsp;내적을 기준으로 감쇠를 계산합니다. 표면 노멀이 카메라를 똑바로 가리켰을 때 출력 값은 0이며, 프레넬 이펙트가 일어나지 않음을 뜻합니다. 표면 노멀이 카메라와 직각일 때 출력 값은 1이며, 프레넬 이펙트가 완전히 일어남을 뜻합니다. 그런 다음 중앙에 음의 컬러가 없도록 결과는 [0, 1]로 범위제한됩니다. 이 개념을 보여주는 것이 다음 이미지입니다.\n<img alt=\"fresnel.png\" src=\"images/fresnel.png\" target=\"_self\">표면 노말과 카메라 방향 벡터를 내적해서 결과가 -1이 나오면 구의 중앙이고 0이 나오면 구의 가장자리가 나온다.(노멀과 카메라 방향이 수직이기 때문에)\n참고: 내적은 두 벡터가 얼마나 같은 방향인지 측정할 때 사용됨\n다만 프레넬 노드는 내적 값을 바로 이용하지 않고 내부 에서 처리한다. 그래서 내부에서 이 내적 값을 이용해서 값을 출력한다. 프레넬 노드는 0인 경우 어두워지고 1인 경우는 밝아진다. 즉 프레넬 노드를 사용하면 림 라이트를 쉽게 구현할 수 있다.프레넬 노드에는 3가지 머티리얼 표현식이 있다.\nExponenln\nBaseReflectFractionIn\nNormal\nExponenln은 프레넬 이펙트의 감쇠를 제어하는 입력이다. 감쇠 속도는 빠를수록 가장자리의 좁은 영역만 밝다. 그리고 급격한 밝기 변화라서 선명하고 날카로운 림라이트 효과를 줄 수 있다. 감쇠 속도가 느리다면 가장자리에서 중앙까지 부드럽게 변화한다. 그래서 자연스러운 그라데이션이 펄쳐져 넓은 영역에 걸친 부드러운 림라이트 효과를 줄 수 있다.BaseReflectFractionIn는 표면을 정면에서 볼 때의 스페큘러 리플렉션 부분을 지정한다. 이 값을 1로 설정하면 프레넬이 사실상 비활성화된다. (중앙도 밝아져버리니까)Normal은 노멀 맵을 입력하여 프레넬 이펙트 렌더링 방식을 변경할 수 있다. 노멀 맵은 탄젠트 스페이스에서 월드 스페이스로 변환해야한다.골프공, 피부와 같이 울퉁불퉁하고 복잡한 림라이트를 넣으려면 Normal을 이용해야하는데 노멀 맵 텍스쳐를 바로 넣으면 안되고 TransformVector&nbsp;표현식을 통해 전달해야 한다. 이를 통해 노멀 맵을 탄젠트 스페이스에서 월드 스페이스로 변환할 수 있다. 만약 이 트랜스폼을 거치지 않으면 노멀 맵은 의도한 대로 프레넬에 영향을 주지 않는다.Fresnel 노드 출력값\n정면: 0 (어두움)\n가장자리: 1 (밝음)\n뒷면: 0 즉 가장자리만 밝게 만드는 마스크를 생성한다.\n물 표면: 정면에서 보면 투명 (물속이 보임)\n옆에서 보면 반사 (하늘이 반사됨) 유리창: 정면: 투명하게 안이 보임\n비스듬히: 반사되어 거울처럼 보임 비눗방울: 가장자리가 더 강하게 반사되어 밝게 보임 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Fresnel 요약","level":4,"id":"Fresnel_요약_0"},{"heading":"현실에서의 Fresnel 효과","level":4,"id":"현실에서의_Fresnel_효과_0"}],"links":[],"author":"","coverImageURL":"images/fresnel.png","fullURL":"graphics/unreal-engine/rim-light와-fresnel-노드.html","pathToRoot":"../..","attachments":["images/fresnel.html"],"createdTime":1752590582977,"modifiedTime":1752590582977,"sourceSize":4423,"sourcePath":"graphics/Unreal Engine/Rim Light와 Fresnel 노드.md","exportPath":"graphics/unreal-engine/rim-light와-fresnel-노드.html","showInTree":true,"treeOrder":174,"backlinks":[],"type":"markdown"},"graphics/이론/modeling.html":{"title":"Modeling","icon":"","description":"수학을 배운 경험이 있다면 x^2&nbsp; + y^2 = 1 형태의 식을 본 적이 있을 것이다. 이러한 형태를 음함수라고 하는데 GPU는 음함수를 잘 처리하지 못한다. 그러면 어떻게 하느냐? 평면의 점을 샘플링해서 Polygon Mesh로 만든다. (샘플링을 한다는 것은 정점과, 법선 벡터를 잘 뽑는 것을 의미한다.)어떤 물체가 있고 이를 잘 샘플링해서 폴리곤 메쉬로 만들었다. 이렇게 만들어진 메쉬를 컴퓨터(?)는 어떻게 저장을 하는 지 알아보자.<img src=\"https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">t1, t2, t3라는 삼각형 메쉬가 존재한다. 이를 메모리에 저장을 하는 방법은 간단하다. 좌표를 그냥 배열에 때려넣으면 된다. 때려 넣고 나니 문제점이 있는 것 같다.&nbsp; vertex array를 보면 중복되는 것이 많다는 것을 알 수 있다. 낭비가 심하다. 그래서 위와 같이 저장하지 않는다. 문제를 해결하기 위해 인덱스를 추가해 보자.<br><img src=\"https://blog.kakaocdn.net/dn/bB6wFv/btstk41D2xI/WHrJSexTiosKNTGHhMQe40/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">각 정점들에 index를 줘서 해결하면 더 빠르게 처리할 수 있다.3ds Max와 같은 모델링 프로그램을 이용해서 export를 하면 .obj 파일을 얻을 수 있다. 간단한 구를 모델링해서 export를 해서 열면 어떤 데이터가 들어 있을까?구는 26개의 정점과 48개의 삼각형으로 이뤄져 있다.<br><img src=\"https://blog.kakaocdn.net/dn/d3DpsC/btstkTy9Ufk/3TFup6zSfeHakZy5345wc1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">v는 Vertex를 의미하고, 숫자는 순서대로 x, y, z이다.vn는 Vertex Noraml을 의미하고 숫자는 순서대로 x, y, z이다.f는 face를 의미하고 v // vn 을 의미한다. (구는 v와 vn이 1:1로 대응하지만, 직육면체와 같은 입체에서는 vn이 중복될 수 있다.)<br><img src=\"https://blog.kakaocdn.net/dn/1Vyde/btsth6yLCPq/GbVkDxpfn73pFLdUo44HZ1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">.obj를 Import 하게 되면 메모리는 위와 같이 저장된다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.kocw.net/home/search/kemView.do?kemId=1349173\" target=\"_self\">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Export&nbsp; Data","level":4,"id":"Export _Data_0"},{"heading":"Import","level":4,"id":"Import_0"},{"heading":"Ref.","level":4,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png","fullURL":"graphics/이론/modeling.html","pathToRoot":"../..","attachments":[],"createdTime":1735624912401,"modifiedTime":1735624953441,"sourceSize":2154,"sourcePath":"graphics/이론/Modeling.md","exportPath":"graphics/이론/modeling.html","showInTree":true,"treeOrder":176,"backlinks":[],"type":"markdown"},"graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html":{"title":"Phong vs Blinn-Phong 셰이딩 모델","icon":"","description":"두 모델 모두&nbsp;3가지 조명 성분을 합쳐서 최종 색상을 계산\n최종 색상 = Ambient + Diffuse + Specular\n모든 방향에서 균등하게 오는 빛\n그림자 부분도 완전히 검은색이 되지 않게 해줌\nambient = ambientColor × ambientStrength 표면에서 모든 방향으로 균등하게 산란되는 빛\n램버트 코사인 법칙 적용\ndiffuse = lightColor × max(0, dot(normal, lightDirection)) 특정 방향으로만 반사되는 빛 (하이라이트)\n**여기서 Phong과 Blinn-Phong의 차이가 발생함 완전 반사 벡터(R) 계산: R = reflect(-L, N) 반사벡터와 시선벡터 내적: dot(R, V) 최종: specular = pow(max(0, dot(R, V)), shininess) 장점: 물리적으로 직관적 (실제 반사 방향 계산)\n단점: reflect() 함수 연산이 비쌈 (벡터 계산 복잡)\n시각적: 더 날카롭고 집중된 하이라이트 하프 벡터(H) 계산: H = normalize(L + V) 하프벡터와 노말벡터 내적: dot(N, H) 최종: specular = pow(max(0, dot(N, H)), shininess) 장점: 계산이 더 빠름 (normalize 한 번만)\n단점: 물리적 정확도는 Phong보다 약간 떨어짐\n시각적: 좀 더 부드럽고 넓은 하이라이트\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 조명 모델의 기본 구성","level":3,"id":"1._조명_모델의_기본_구성_0"},{"heading":"<strong>Ambient Light (환경광)</strong>","level":4,"id":"**Ambient_Light_(환경광)**_0"},{"heading":"<strong>Diffuse Light (확산광)</strong>","level":4,"id":"**Diffuse_Light_(확산광)**_0"},{"heading":"<strong>Specular Light (정반사광)</strong>","level":4,"id":"**Specular_Light_(정반사광)**_0"},{"heading":"2. Phong 셰이딩 모델 (1975)","level":3,"id":"2._Phong_셰이딩_모델_(1975)_0"},{"heading":"<strong>Specular 계산 방식</strong>","level":4,"id":"**Specular_계산_방식**_0"},{"heading":"<strong>특징</strong>","level":4,"id":"**특징**_0"},{"heading":"3. Blinn-Phong 셰이딩 모델 (1977)","level":3,"id":"3._Blinn-Phong_셰이딩_모델_(1977)_0"},{"heading":"<strong>Specular 계산 방식</strong>","level":4,"id":"**Specular_계산_방식**_1"},{"heading":"<strong>특징</strong>","level":4,"id":"**특징**_1"},{"heading":"4. 핵심 차이점","level":3,"id":"4._핵심_차이점_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html","pathToRoot":"../..","attachments":[],"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":2150,"sourcePath":"graphics/이론/Phong vs Blinn-Phong 셰이딩 모델.md","exportPath":"graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html","showInTree":true,"treeOrder":177,"backlinks":[],"type":"markdown"},"graphics/이론/vsync-(수직-동기화).html":{"title":"VSync (수직 동기화)","icon":"","description":"화면이 Frame을 받을 준비가 되면 GPU에게 V-Sync를 보내고 GPU는 프레임을 화면에 전달순서\n화면(Display)은 한 프레임을 완전히 보여준 뒤, 다음 프레임을 받을 준비가 되면 V-Sync 신호를 보냄\n엔진(GPU)은 이 신호를 받아야만 비로소 자신이 그려놓은 새 프레임을 화면에 전달\nGPU는 더블 버퍼링 기술을 이용함. 더블 버퍼링이란 GPU는 메모리에 최소 두개의 그림판, 프레임 버퍼를 가진다는 것을 의미함.\n프론트버퍼: 화면에 직접 연결된 버퍼로 우리가 볼 수 있음\n백 버퍼: GPU가 다음에 보여줄 프레임을 그리는 작업 공간으로 우리가 볼 수 없음. 렌더링 작업은 여기에서 발생 사용자가 화면 (프론트 버퍼)을 보는 동안 GPU는 백버퍼에서 다음 프레임을 준비함. GPU가 백 버퍼에 다 그리면 V-Sync 신호를 기다림\nV-Sync 신호 발생\nBuffer Swap / Flip (버퍼 교체) 백 버퍼는 프론트 버퍼가 되고 프론트 버퍼는 백버퍼가 됨.\n데이터 복사가 아닌 포인터를 변경하기 때문에 매우 빠름 인풋 랙 (Input Lag)\n최대 성능 확인\n인풋 랙은 V-Sync의 \"기다리는 특성 때문에 발생한다.\n[사용자 액션]: 사용자가 마우스를 클릭하여 총을 쏨 (시간: 0ms)\n[GPU 렌더링]: GPU가 총을 쏘는 장면을 백 버퍼에 즉시 그리기 시작함 (완료까지 5ms 소요, 총 시간: 5ms)\n[V-Sync의 대기]:&nbsp;문제 발생함. GPU는 그림을 다 그렸지만, 아직 화면의 V-Sync 신호가 오지 않았음. 다음 신호는 16.67ms 시점에 올 예정. GPU는&nbsp;약 11ms를 아무것도 안 하고 기다려야 합니다.\n[버퍼 교체]: V-Sync 신호가 오자, GPU가 백 버퍼를 프론트 버퍼로 교체(총 시간: 16.67ms)\n[화면 표시]: 사용자는 마우스를 클릭한 지 약 16.67ms 후에야 총알이 나가는 것을 보게됨. 화면 찢어짐 화면 업데이트보다 GPU가 프레임을 그리는 속도가 더 빠름\n윗부분은 이전 프레임, 아랫부분은 새로 그린 프레임\n화면의 중간에 가로로 선이 그어진 것처럼 위아래가 어긋남\n<img alt=\"Screen Tearing\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 버벅거림 Stutter GPU가 너무 느리게 그려서 프레임 완성이 안되어 있음, 그러면 디스플레이는 이전 페이지를 한번 더 보여줌 (프레임 드랍)\n사용자는 순간적으로 화면이 멈칫 Jank GPU가 프레임을 그리는 속도가 일정하지 않는 경우\n사용자는 애니메이션이 부드럽게 이어지지 않고 뚝뚝 끊기거나 울렁거리는 것처럼 보임 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"요약","level":2,"id":"요약_0"},{"heading":"작동 방식","level":3,"id":"작동_방식_0"},{"heading":"PC 게임은 V-Sync 옵션이 있는 경우가 있는데 그 이유?","level":4,"id":"PC_게임은_V-Sync_옵션이_있는_경우가_있는데_그_이유?_0"},{"heading":"V-Sync를 껐을 때 발생할 수 있는 문제","level":4,"id":"V-Sync를_껐을_때_발생할_수_있는_문제_0"}],"links":[],"author":"","coverImageURL":"https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg","fullURL":"graphics/이론/vsync-(수직-동기화).html","pathToRoot":"../..","attachments":[],"createdTime":1754545491067,"modifiedTime":1754545491068,"sourceSize":2955,"sourcePath":"graphics/이론/VSync (수직 동기화).md","exportPath":"graphics/이론/vsync-(수직-동기화).html","showInTree":true,"treeOrder":178,"backlinks":[],"type":"markdown"},"graphics/이론/동차-좌표계와-원근-분할.html":{"title":"동차 좌표계와 원근 분할","icon":"","description":"Homogeneous Coordinates동차 좌표계는 n차원 공간을 n+1차원으로 표현하는 좌표계다. 3D 그래픽스에서는 3차원 공간의 점을 (x, y, z, w)와 같이 4차원 벡터로 표현한다.\nw가 1인 경우: (x, y, z, 1)은 3D 공간의 점 (x, y, z)\nw가 0인 경우: (x, y, z, 0)은 방향 벡터(무한 거리의 점)\nw가 다른 값일 경우: (x, y, z, w)는 3D 공간의 점 (x/w, y/w, z/w)를 나타냄\n동차 좌표계는 왜 사용하는가?\n투영 변환을 선형 변환으로 표현할 수 있음\n무한 거리의 점(방향)을 표현할 수 있음\n이동(translation) 변환을 행렬로 표현할 수 있음\n정의한 Vector4 (동차좌표계를 위한 자료구조)에 아래 함수가 정의되어 있는 이유는?// Perspective division (원근 분할) void perspectiveDivide() { if (w != 0) { x /= w; y /= w; z /= w; w = 1; } } 모델-뷰-투영 변환(MVP) 이후 정점은 동차 좌표계로 표현된다.\n원근 분할을 통해 이 동차 좌표를 정규화된 디바이스 좌표(NDC)로 변환한다.\n이 과정에서 w 값이 클수록(카메라에서 멀수록) 좌표가 작아지는 원근감 효과가 생긴다.\n원근 투영에서 w 성분은 보통 정점의 원래 z 값(깊이)과 관련이 있으며, 이 값으로 나누는 과정에서 멀리 있는 물체가 작게 보이는 원근감 효과가 만들어진다.NDC 좌표 (Normalized Device Coordinates)NDC 좌표는 3D 그래픽스 파이프라인에서 사용되는 표준화된 좌표계다. 이는 장치와 독립적인 좌표 공간으로, 일반적으로 모든 좌표가 [-1, 1] 범위 내로 정규화된다.NDC 좌표의 특징\nx, y, z 모두 -1에서 1 사이의 값을 가집니다 (일부 API에서는 z가 0~1 범위)\n화면의 중앙은 (0, 0)\n왼쪽 하단은 (-1, -1), 오른쪽 상단은 (1, 1)\nNDC 좌표의 유용성\n하드웨어 독립성: 모든 그래픽스 하드웨어가 이해할 수 있는 표준화된 형식\n다양한 해상도와 화면 비율에 관계없이 일관된 처리 가능 클리핑 최적화: NDC 공간에서 -1~1 범위를 벗어나는 좌표는 화면 밖에 있는 것으로 간주하여 쉽게 클리핑 가능\n불필요한 렌더링 연산 감소 좌표 변환 단순화: NDC에서 화면 좌표(픽셀)로의 변환은 간단한 스케일링과 오프셋 연산으로 가능\n서로 다른 뷰포트나 타깃으로 렌더링할 때 유연성 제공 텍스처 좌표 매핑: NDC와 유사한 개념으로 텍스처 좌표도 0~1로 정규화되어 있어 텍스처 매핑에 일관성 제공 렌더링 파이프라인에서 NDC 좌표의 위치\n모델 좌표 → 월드 좌표 → 뷰 좌표 → 클립 좌표\n클립 좌표에서 원근 분할\n결과로 NDC 좌표 획득\nNDC 좌표에서 뷰포트 변환을 통해 화면 좌표(픽셀) 생성\n3D 그래픽스 파이프라인의 일반적인 변환 흐름:\n모델 공간 → 월드 공간 → 뷰 공간 → 클립 공간 → NDC 공간 → 화면 공간NDC 공간은 [-1, 1]이고 View Port 행렬을 곱해줘서 화면 공간 (View Port)에 그려진다.NDC 공간에서 view port에 그려지기 위해서는 아래 공식을 적용해주면 된다. X_화면 = (X_NDC + 1) × (width/2) + x\nY_화면 = (1 - Y_NDC) × (height/2) + y (Y축 반전)\nZ_화면 = Z_NDC (깊이 값 유지)\n이 공식을 행렬로 만들어주면 그것이 viewportMatrix다.// 뷰포트 설정 void updateViewport(int x, int y, int width, int height) { viewportMatrix = Matrix4(); // NDC [-1, 1] -&gt; Screen [0, width/height] viewportMatrix.m[0][0] = width / 2.0f; viewportMatrix.m[0][3] = x + width / 2.0f; viewportMatrix.m[1][1] = -height / 2.0f; // Y축 반전 viewportMatrix.m[1][3] = y + height / 2.0f; viewportMatrix.m[2][2] = 1.0f; }\n예를 하나 들어서 ViewMatrix을 검증해보자.NDCX 좌표를 X화면으로 변환할 때 영향을 주는 요소들은 다음과 같다.viewportMatrix.m[0][0] = width / 2.0f;\nviewportMatrix.m[0][3] = x + width / 2.0f;\nNDC 좌표 (X, Y, Z, 1)에 곱하면 X 좌표의 계산은 X_화면 = width/2 * X_NDC + (x + width/2)이를 아래처럼 변형할 수 있다.X_화면 = width/2 * X_NDC + (x + width/2) = width/2 * X_NDC + x + width/2 * 1 = width/2 * (X_NDC + 1) + x &lt;- 공식 검증\n따라서 view port matrix를 통해서 화면 공간으로 변환할 수 있다. // 정점 변환 (3D -&gt; 2D) Vector4 transformVertex(const Vector3 &amp;vertex) { // 1. 모델 공간 -&gt; 클립 공간 Vector4 clipPos = mvpMatrix * Vector4(vertex, 1.0f); // 2. 원근 분할 (Perspective Division) clipPos.perspectiveDivide(); // 3. 뷰포트 변환 Vector4 screenPos = viewportMatrix * clipPos; return screenPos; } ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"참고","level":4,"id":"참고_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/이론/동차-좌표계와-원근-분할.html","pathToRoot":"../..","attachments":[],"createdTime":1754545491026,"modifiedTime":1754545491026,"sourceSize":4994,"sourcePath":"graphics/이론/동차 좌표계와 원근 분할.md","exportPath":"graphics/이론/동차-좌표계와-원근-분할.html","showInTree":true,"treeOrder":179,"backlinks":[],"type":"markdown"},"graphics/이론/렌더링-파이프라인-이론.html":{"title":"렌더링 파이프라인 이론","icon":"","description":"공부를 하면서 다시 정리하는 것이다. 그래픽스 파이프라인에 대해서는 아래 글을 다시 읽어보자.<a data-href=\"01. 그래픽스 파이프라인\" href=\"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">01. 그래픽스 파이프라인</a>\nVertex Input\nVertex Shader (정점 변환) Primitive Assembly\nClipping\nRasterization\nFragment Shader (픽셀 셰이딩)\nOutput\nModel -&gt; World -&gt; View -&gt; Projection -&gt; NDC -&gt; Screen NDC는 Normalized Device Coordinates의 준말로 모든 좌표가 [-1, 1] 범위로 정규화된 3D 공간을 의미한다.\nNDC를 거쳐야 하는 이유는 NDC는 모든 그래픽스 하드웨어가 이해할 수 있는 표준화된 좌표계이기 때문이다. 그렇기 때문에 클리핑, 깊이 값, 투영 왜곡 처리를 단순하게 처리할 수 있다. View Frustum: 카메라가 볼 수 있는 공간 6개 평면: Near, Far, Left, Right, Top, Bottom\nSutherland-Hodgman 알고리즘: 다각형 클리핑\n클리핑은 카메라가 볼 수 없는 부분을 잘라내는 과정이다. 총 6개의 평면이 있는데 각 단어에 맞게 한계값을 설정하는 것이다. Ex) Near Plane은 너무 가까운 물체를 방지하는 값이다.\n스캔라인 알고리즘: 삼각형을 픽셀로 변환\nEdge Function: 점이 삼각형 내부인지 판별\n레스터화는 3D 삼각형을 2D 픽셀로 변환하는 과정이다. 그 중 스캔라인 알고리즘은 Y축을 따라 한 줄씩 스캔하면서 삼각형을 채우는 방법이다. 주로 구형 GPU 같이 하드웨어가 제한적이거나 특정 최적화가 필요할 때 구현해서 사용한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"그래픽스 파이프라인","level":2,"id":"그래픽스_파이프라인_0"},{"heading":"좌표계 변환 (Vertex Transform)","level":4,"id":"좌표계_변환_(Vertex_Transform)_0"},{"heading":"클리핑 (Clipping)","level":4,"id":"클리핑_(Clipping)_0"},{"heading":"래스터화 (Rasterization)","level":4,"id":"래스터화_(Rasterization)_0"}],"links":["graphics/opengl/02.응용/01.-그래픽스-파이프라인.html"],"author":"","coverImageURL":"","fullURL":"graphics/이론/렌더링-파이프라인-이론.html","pathToRoot":"../..","attachments":[],"createdTime":1752391096503,"modifiedTime":1752392500292,"sourceSize":1715,"sourcePath":"graphics/이론/렌더링 파이프라인 이론.md","exportPath":"graphics/이론/렌더링-파이프라인-이론.html","showInTree":true,"treeOrder":180,"backlinks":[],"type":"markdown"},"graphics/이론/변환행렬.html":{"title":"변환행렬","icon":"","description":"`월드 포지션 = 로컬x (로컬X축) + 로컬y (로컬Y축) + 로컬z * (로컬Z축) + (로컬 원점)\b예시)\n로컬 좌표: (2, 3, 1)\nvX = (1, 0, 0) // 로컬 X축이 월드에서 어느 방향인지\nvY = (0, 1, 0) // 로컬 Y축이 월드에서 어느 방향인지 vZ = (0, 0, 1) // 로컬 Z축이 월드에서 어느 방향인지\nvPos = (10, 20, 5) // 로컬 원점이 월드에서 어디에 있는지 월드 포지션 = 2 * (1, 0 , 0) + 3 * (0, 1, 0) + 1 * (0, 0, 1) + (10, 20, 50)\n일반화\nWorld Positon = x * vX + y * vY + z * vZ + vPos성분 분해를 하게 되면World.x = (x * vX.x) + (y * vY.x) + (z * vZ.x) + vPos.x\nWorld.y = (x * vX.y) + (y * vY.y) + (z * vZ.y) + vPos.y\nWorld.z = (x * vX.z) + (y * vY.z) + (z * vZ.z) + vPos.z이걸 행렬 곱셈으로 표현하면[World.x] [vX.x vY.x vZ.x] [x] [vPos.x]\n[World.y] = [vX.y vY.y vZ.y] [y] + [vPos.y]\n[World.z] [vX.z vY.z vZ.z] [z] [vPos.z]\n즉 World Position을 TR (회전하고 나서 더하기) 두번의 연산으로 표현한다.이를 Homogeneous Coordinates를 도입하면, 회전과 평행이동을 하나의 행렬로 표현할 수 있다.3D를 4D로 확장하고 4행의 값은 (0,0,0,1) 으로 설정한다. 3D 공간 변환에서는 아핀 변화를 이용한다. 아핀 변환은 물리적 거리와 각도를 보존하고 투영이 아닌 순수한 공간 변환에서 사용된다. 그리고 1은 '점(Point)'이라는 것을 의미한다.[vX.x vY.x vZ.x vPos.x]\n[vX.y vY.y vZ.y vPos.y]\n[vX.z vY.z vZ.z vPos.z]\n[ 0 0 0 1 ]\n확장된 행렬 하나가 만들어졌고 이 행렬을 이용해서 회전과 평행이동을 한번에 계산할 수 있게 된다.\n로컬 원점 기준으로 이동해서 상대 위치를 구한다.\n상대위치 = (world.x, world.y, world,z) - (local.x, local.y, local.z) 각 축으로 투영한다. (내적한다.)\nlocal.x = 상대위치 * vX\nlocal.y = 상대위치 * vY\nlocal.z = 상대위치 * vZ\n아직 다 안씀..","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"로컬 -&gt; 월드","level":4,"id":"로컬_->_월드_0"},{"heading":"월드 -&gt; 로컬","level":3,"id":"월드_->_로컬_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"graphics/이론/변환행렬.html","pathToRoot":"../..","attachments":[],"createdTime":1751879420587,"modifiedTime":1752496314668,"sourceSize":2118,"sourcePath":"graphics/이론/변환행렬.md","exportPath":"graphics/이론/변환행렬.html","showInTree":true,"treeOrder":181,"backlinks":[],"type":"markdown"},"graphics/이론/컴퓨터-그래픽스-기초와-수학.html":{"title":"컴퓨터 그래픽스 기초와 수학","icon":"","description":"컴퓨터 그래픽스는 3D 인풋을 받아 2D 공간에 표현하는 것에 대한 학문이다.컴퓨터 그래픽스의 Production는 5단계로 나눌 수 있다.<img src=\"https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Modeling은 Polygon Mesh로 형태를 만드는 작업과 질감 처리 같은 Texture를 만드는 작업을 말한다.Rigging은 뼈대를 만들고 Polygon Mesh와 관계를 만드는 작업을 말한다.Animation은 Rigging를 통해 만들어진 관계들을 시퀀스로 만들어 실제로 움직이는 것처럼 보이게 만드는 작업이다.Rendering은 3차원에 있는 Scene을 2차원 Scene으로 나타내는 과정이다. 여기에서 중요한 이슈는 텍스쳐와 빛을 처리하는 것이다.Post-Processing는 후처리를 해서 좀 더 사실적으로 보이게 하는 작업이다. 필수 작업은 아니다.1번 ~ 3번의 작업은 그래픽 아티스트가 작업하고 4번 ~ 5번은 컴퓨터 프로그램이 처리한다.<br><img src=\"https://blog.kakaocdn.net/dn/mFeAO/btstpF7SkJM/2hgcK3ZnsHKFQ7ORXIcLN1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">일반적으로 게임의 하단에 Unity와 Unreal과 같은 게임엔진이 있고 게임 엔진에서 Graphics API를 사용한다. Graphics API에는 DirectX, Vulkan, OpenGL, Metal 등이 있다. Graphics API는 GPU를 구동하기 위한 추상화 되어 있는 인터페이스다.그래픽스 분야에서는 기본적으로 선형대 수학을 정말 많이 사용하는 것 같다.&nbsp;Line, Ray, and Linear Interpolation<br><img src=\"https://blog.kakaocdn.net/dn/QVQu5/btstqsArCYv/IB9YYR1LMmXpo37iJ5BsY0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">t의 범위에 따라서 p(t)를 부르는 이름이 달라진다.t의 범위가 -inf &lt; t &lt; inf 인 경우 Infinite linet의 범위가 0 &lt;= t &lt; inf 인 경우 Rayt의 범위가 0 &lt;= t &lt;= 1 인 경우 Line segmentp(t)에 대한 식을 풀어쓰면 Line segment는 p0과 p1의 Line interpolation과 대응한다는 것을 알 수 있다.<br><img src=\"https://blog.kakaocdn.net/dn/bTDV50/btstpCQPsfu/XuWI7yGFk88ChA1GK782NK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이것이 의미하는 바는 p0와 p1 사이에 위치하는 값을 양 끝점의 값으로 추정할 수 있다는 것이다.(선형보간법)<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.kocw.net/home/search/kemView.do?kemId=1349173\" target=\"_self\">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"그래픽스 기초","level":3,"id":"그래픽스_기초_0"},{"heading":"수학","level":3,"id":"수학_0"},{"heading":"Ref.","level":4,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png","fullURL":"graphics/이론/컴퓨터-그래픽스-기초와-수학.html","pathToRoot":"../..","attachments":[],"createdTime":1735624889065,"modifiedTime":1735624911169,"sourceSize":2307,"sourcePath":"graphics/이론/컴퓨터 그래픽스 기초와 수학.md","exportPath":"graphics/이론/컴퓨터-그래픽스-기초와-수학.html","showInTree":true,"treeOrder":182,"backlinks":[],"type":"markdown"},"hose/develop.html":{"title":"Develop","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"hose/develop.html","pathToRoot":"..","attachments":[],"createdTime":1737037094008,"modifiedTime":1748688668793,"sourceSize":0,"sourcePath":"Hose/Develop.md","exportPath":"hose/develop.html","showInTree":true,"treeOrder":184,"backlinks":[],"type":"markdown"},"hose/내가-블로그를-시작한-이유.html":{"title":"내가 블로그를 시작한 이유","icon":"","description":"나는 왜 블로그를 하려고 결심했을까? 이상하게도 나는 처음에 이 글을 쓰기로 결심을 하고 블로그를 시작해야 할 이유에 대해 생각을 해봤다. 그래서 먼저 든 생각은 우리가 흔히 쓰는 블로그라는 말이 어떤 의미가 있는지 궁금했다. 위키피디아에 의하면 블로그의 정의는 다음과 같다고 한다.\n블로그라는 말은 웹(web)과 로그(log, 기록)를 합친 낱말로, 스스로가 가진 느낌이나 품어오던 생각, 알리고 싶은 견해나 주장 같은 것을&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%B0\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%B0\" target=\"_self\">일기</a>처럼 차곡차곡 적어 올리는 형식을 취한다\n무엇인가를 '기록하다' 라는 글을 보았을 때 나는 Record 라는 단어를 떠올렸다. 이 단어는 나에게 어떠한 감흥조차 주지 못했는데 Log 라는 단어는 왜인지 모르게&nbsp;(사실 안다)&nbsp;중요한 느낌을 준다.나는 2016년 가을부터 학교에서 컴퓨터 관련 수업을 들었고, 2020년부터 iOS 개발을 시작했다. 개발을 시작하기 전에 나는 내가 생각한 대로&nbsp;많은 것들을 손쉽게 구현할 수 있을 거라고 생각했지만, 현실은 달랐다. 아직도 기억나는 일이 있다. SOPT 과제에서 서버와 통신해서 그 값들을 보여주는 기능을 구현했어야 했다. 나는 호기롭게 네트워킹을 시도했었지만, 화면에 어떠한 변화도 없었다. 나는 어떤 코드를 잘못 작성했는지 파악할 수 없었기 때문에&nbsp;여러 곳에 dump 함수를 이용해서 잘못된 부분을 찾을 수 있었다. 이것이 아마 나의&nbsp;의미 있는 첫&nbsp;Log&nbsp;일 것이다.나(코드몽키)와 마찬가지로 개발자들은 Log의 중요성을 매우 잘 알 것이다.&nbsp;어떠한 문제가 발생했을 때 Log를 통해서 문제 해결의 단초를 얻을 수 있고, Log 분석을 통해 중요한 정보들을 수집할 수도 있다. 따라서 Logging은 정말 중요하다.나는 개발을 하면서 크고 작은 문제에 부딪힌다. 보통 stackoverflow, 국내 개발 블로그, 공식문서를 보면 많은 것들이 해결된다. 그러나, 해결되지 않는 경우도 많다. 나는 문제에 직면했을 때, 만화 나루토에 나오는&nbsp;마이트 가이를 존경하기 때문에, 포기하지 않고 노력한다. 그래서 정말 많은 시간을 들여서 어찌어찌 어려운 것들을 해결한 경험들이 있다. '역시 난 대단하다.' 이렇게 끝났으면 참 좋은 결말일 텐데,&nbsp;생각해보면 현재의 나에겐 남는 것이 많이 없는 것 같다.&nbsp;시간이 흘러 같은 문제를 직면했을 때,&nbsp;노력한 기억만 남아서, 시간이 좀 덜 걸릴 뿐이지 다시 시행착오를 겪을 것이다. 정말&nbsp;비효율적이지 않나?&nbsp;개발을 하다가 Issue가 생겼을 때 검색 하면 인터넷에 양질의 글들이 참 많다는 것을 알 수 있다. 그러나, 글들이 추상적이고 과감한 생략되어 있으면 나는 이 Issue를 어렵다고 생각하고 이해하기를 포기한 적도 있다.&nbsp;그럴 때마다 자책하면서 자존감이 떨어졌었는데, 시간을 들여&nbsp;시행착오를 겪어보니 사실은 어려울 게 없는 것이었다. &nbsp;만약 해당 Issue가 좀 더&nbsp;자세하게 기록되어 있었다면 바로 감을 잡을 수 있었을지도 모른다. 마치 해석학에서 Compact를 공부할 때와 같았다. 혼자 책을 볼 때 어떠한 것도 이해하지 못하고 자책만 했었는데, 교수님의 설명을 듣고 몇 문제를 풀어보니 감을 잡을 수 있었기 때문이다.&nbsp;(감만 잡았었음.)최근에 Architecture에 지대한 관심을 가지기 시작했다.&nbsp;Framework와 Library, DIP, Modularize 등등 어려운 개념들에 대한 글들을 열심히 읽었고 어떤 것들은 5번 이상씩 읽었다. 그래서 나는 이러한 개념들을 이해했다고 생각했다. 어느 날 이러한 주제에 대해서 이야기가 나왔는데 누군가가 나에게 설명을 요구했는데 나는 말하는 것에 확신이 없었다. 나는 안다는 착각에 빠져있었던 것 같다. 내가 어떤 지식에 관해서&nbsp;확실하게 누군가에게 설명할 수 있다면 그것은 내가 확실하게 아는 것이지 않을까?결론은 다음과 같다.나는 개발에 있어서 비효율을 제거하고 싶고, 좀 더 상세하게 기록해서 같은 어려움을 겪는 사람들에게 도움이 되고 싶고, 내가 확실하게 설명할 수 있을 정도로 알고 싶기 때문에 블로그를 시작하게 되었다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"hose/내가-블로그를-시작한-이유.html","pathToRoot":"..","attachments":[],"createdTime":1735621785179,"modifiedTime":1735621805711,"sourceSize":4654,"sourcePath":"Hose/내가 블로그를 시작한 이유.md","exportPath":"hose/내가-블로그를-시작한-이유.html","showInTree":true,"treeOrder":185,"backlinks":[],"type":"markdown"},"images/3colorchannel.html":{"title":"3colorchannel","icon":"","description":"<img src=\"images/3colorchannel.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/3colorchannel.png","fullURL":"images/3colorchannel.html","pathToRoot":"..","attachments":["images/3colorchannel.html"],"createdTime":1724571717957,"modifiedTime":1724571717958,"sourceSize":398882,"sourcePath":"images/3colorchannel.png","exportPath":"images/3colorchannel.html","showInTree":true,"treeOrder":187,"backlinks":["graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html"],"type":"attachment"},"images/aggregate.html":{"title":"aggregate","icon":"","description":"<img src=\"images/aggregate.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/aggregate.png","fullURL":"images/aggregate.html","pathToRoot":"..","attachments":["images/aggregate.html"],"createdTime":1710855209764,"modifiedTime":1710855209764,"sourceSize":98091,"sourcePath":"images/aggregate.png","exportPath":"images/aggregate.html","showInTree":true,"treeOrder":188,"backlinks":["ios/fat-framework.html"],"type":"attachment"},"images/allpublic.html":{"title":"allpublic","icon":"","description":"<img src=\"images/allpublic.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/allpublic.png","fullURL":"images/allpublic.html","pathToRoot":"..","attachments":["images/allpublic.html"],"createdTime":1710855209767,"modifiedTime":1710855209768,"sourceSize":48860,"sourcePath":"images/allpublic.png","exportPath":"images/allpublic.html","showInTree":true,"treeOrder":189,"backlinks":["ios/swift,-objective-c-interoperability.html"],"type":"attachment"},"images/bfs_1.html":{"title":"BFS_1","icon":"","description":"<img src=\"images/bfs_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/bfs_1.png","fullURL":"images/bfs_1.html","pathToRoot":"..","attachments":["images/bfs_1.html"],"createdTime":1719764579395,"modifiedTime":1719764579396,"sourceSize":769588,"sourcePath":"images/BFS_1.png","exportPath":"images/bfs_1.html","showInTree":true,"treeOrder":190,"backlinks":["algorithm/lecture/bfs.html"],"type":"attachment"},"images/bfs_2.html":{"title":"BFS_2","icon":"","description":"<img src=\"images/bfs_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/bfs_2.png","fullURL":"images/bfs_2.html","pathToRoot":"..","attachments":["images/bfs_2.html"],"createdTime":1719764657808,"modifiedTime":1719764657808,"sourceSize":887930,"sourcePath":"images/BFS_2.png","exportPath":"images/bfs_2.html","showInTree":true,"treeOrder":191,"backlinks":["algorithm/lecture/bfs.html"],"type":"attachment"},"images/bi_linear_interpolation.html":{"title":"bi_linear_interpolation","icon":"","description":"<img src=\"images/bi_linear_interpolation.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/bi_linear_interpolation.png","fullURL":"images/bi_linear_interpolation.html","pathToRoot":"..","attachments":["images/bi_linear_interpolation.html"],"createdTime":1730808631673,"modifiedTime":1730808631674,"sourceSize":404027,"sourcePath":"images/bi_linear_interpolation.png","exportPath":"images/bi_linear_interpolation.html","showInTree":true,"treeOrder":192,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment"},"images/ble_configuration.html":{"title":"ble_configuration","icon":"","description":"<img src=\"images/ble_configuration.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble_configuration.png","fullURL":"images/ble_configuration.html","pathToRoot":"..","attachments":["images/ble_configuration.html"],"createdTime":1714816620140,"modifiedTime":1714816620140,"sourceSize":83464,"sourcePath":"images/ble_configuration.png","exportPath":"images/ble_configuration.html","showInTree":true,"treeOrder":193,"backlinks":[],"type":"attachment"},"images/ble_host_controller.html":{"title":"ble_host_controller","icon":"","description":"<img src=\"images/ble_host_controller.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble_host_controller.png","fullURL":"images/ble_host_controller.html","pathToRoot":"..","attachments":["images/ble_host_controller.html"],"createdTime":1710855209732,"modifiedTime":1710855209732,"sourceSize":93521,"sourcePath":"images/ble_host_controller.png","exportPath":"images/ble_host_controller.html","showInTree":true,"treeOrder":194,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment"},"images/ble-attribute-table.html":{"title":"ble-attribute-table","icon":"","description":"<img src=\"images/ble-attribute-table.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-attribute-table.png","fullURL":"images/ble-attribute-table.html","pathToRoot":"..","attachments":["images/ble-attribute-table.html"],"createdTime":1710855209732,"modifiedTime":1710855209733,"sourceSize":97663,"sourcePath":"images/ble-attribute-table.png","exportPath":"images/ble-attribute-table.html","showInTree":true,"treeOrder":195,"backlinks":["ble/3.-ble-att,-gatt.html"],"type":"attachment"},"images/ble-conn-fig-1.html":{"title":"ble-conn-fig-1","icon":"","description":"<img src=\"images/ble-conn-fig-1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-conn-fig-1.png","fullURL":"images/ble-conn-fig-1.html","pathToRoot":"..","attachments":["images/ble-conn-fig-1.html"],"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":97797,"sourcePath":"images/ble-conn-fig-1.png","exportPath":"images/ble-conn-fig-1.html","showInTree":true,"treeOrder":196,"backlinks":["ble/4.-ble-디바이스-연결.html"],"type":"attachment"},"images/ble-conn-fig-2.html":{"title":"ble-conn-fig-2","icon":"","description":"<img src=\"images/ble-conn-fig-2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-conn-fig-2.png","fullURL":"images/ble-conn-fig-2.html","pathToRoot":"..","attachments":["images/ble-conn-fig-2.html"],"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":39578,"sourcePath":"images/ble-conn-fig-2.png","exportPath":"images/ble-conn-fig-2.html","showInTree":true,"treeOrder":197,"backlinks":["ble/4.-ble-디바이스-연결.html"],"type":"attachment"},"images/ble-conn-fig-3.html":{"title":"ble-conn-fig-3","icon":"","description":"<img src=\"images/ble-conn-fig-3.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-conn-fig-3.png","fullURL":"images/ble-conn-fig-3.html","pathToRoot":"..","attachments":["images/ble-conn-fig-3.html"],"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":38156,"sourcePath":"images/ble-conn-fig-3.png","exportPath":"images/ble-conn-fig-3.html","showInTree":true,"treeOrder":198,"backlinks":["ble/4.-ble-디바이스-연결.html"],"type":"attachment"},"images/ble-connection.html":{"title":"ble-connection","icon":"","description":"<img src=\"images/ble-connection.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-connection.png","fullURL":"images/ble-connection.html","pathToRoot":"..","attachments":["images/ble-connection.html"],"createdTime":1710855209734,"modifiedTime":1710855209734,"sourceSize":103318,"sourcePath":"images/ble-connection.png","exportPath":"images/ble-connection.html","showInTree":true,"treeOrder":199,"backlinks":[],"type":"attachment"},"images/ble-connection-1.html":{"title":"ble-connection 1","icon":"","description":"<img src=\"images/ble-connection-1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"docs/images/ble-connection-1.png","fullURL":"images/ble-connection-1.html","pathToRoot":"..","attachments":["images/ble-connection-1.html"],"createdTime":1710855209733,"modifiedTime":1710855209734,"sourceSize":103318,"sourcePath":"images/ble-connection 1.png","exportPath":"images/ble-connection-1.html","showInTree":true,"treeOrder":200,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment"},"images/ble-data-exchange.html":{"title":"ble-data-exchange","icon":"","description":"<img src=\"images/ble-data-exchange.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-data-exchange.png","fullURL":"images/ble-data-exchange.html","pathToRoot":"..","attachments":["images/ble-data-exchange.html"],"createdTime":1710855209734,"modifiedTime":1710855209734,"sourceSize":109854,"sourcePath":"images/ble-data-exchange.png","exportPath":"images/ble-data-exchange.html","showInTree":true,"treeOrder":201,"backlinks":["ble/3.-ble-att,-gatt.html"],"type":"attachment"},"images/ble-gatt-structure.html":{"title":"ble-gatt-structure","icon":"","description":"<img src=\"images/ble-gatt-structure.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-gatt-structure.png","fullURL":"images/ble-gatt-structure.html","pathToRoot":"..","attachments":["images/ble-gatt-structure.html"],"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":111762,"sourcePath":"images/ble-gatt-structure.png","exportPath":"images/ble-gatt-structure.html","showInTree":true,"treeOrder":202,"backlinks":["ble/3.-ble-att,-gatt.html"],"type":"attachment"},"images/ble-l2cap.html":{"title":"ble-l2cap","icon":"","description":"<img src=\"images/ble-l2cap.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-l2cap.png","fullURL":"images/ble-l2cap.html","pathToRoot":"..","attachments":["images/ble-l2cap.html"],"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":90933,"sourcePath":"images/ble-l2cap.png","exportPath":"images/ble-l2cap.html","showInTree":true,"treeOrder":203,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment"},"images/ble-link-layer.html":{"title":"ble-link-layer","icon":"","description":"<img src=\"images/ble-link-layer.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ble-link-layer.png","fullURL":"images/ble-link-layer.html","pathToRoot":"..","attachments":["images/ble-link-layer.html"],"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":31520,"sourcePath":"images/ble-link-layer.png","exportPath":"images/ble-link-layer.html","showInTree":true,"treeOrder":204,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment"},"images/blendspace.html":{"title":"Blendspace","icon":"","description":"<img src=\"images/blendspace.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/blendspace.png","fullURL":"images/blendspace.html","pathToRoot":"..","attachments":["images/blendspace.html"],"createdTime":1710855209736,"modifiedTime":1710855209737,"sourceSize":641674,"sourcePath":"images/Blendspace.png","exportPath":"images/blendspace.html","showInTree":true,"treeOrder":205,"backlinks":["ue/blendspace와-blendspace1d-차이점.html"],"type":"attachment"},"images/bpgi_onbeginplay.html":{"title":"bpgi_onbeginplay","icon":"","description":"<img src=\"images/bpgi_onbeginplay.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/bpgi_onbeginplay.png","fullURL":"images/bpgi_onbeginplay.html","pathToRoot":"..","attachments":["images/bpgi_onbeginplay.html"],"createdTime":1724571717940,"modifiedTime":1724571717941,"sourceSize":37007,"sourcePath":"images/bpgi_onbeginplay.png","exportPath":"images/bpgi_onbeginplay.html","showInTree":true,"treeOrder":206,"backlinks":[],"type":"attachment"},"images/broadcastip_address.html":{"title":"broadcastip_address","icon":"","description":"<img src=\"images/broadcastip_address.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/broadcastip_address.png","fullURL":"images/broadcastip_address.html","pathToRoot":"..","attachments":["images/broadcastip_address.html"],"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":98496,"sourcePath":"images/broadcastip_address.png","exportPath":"images/broadcastip_address.html","showInTree":true,"treeOrder":207,"backlinks":["network/09.-broadcast-ip-주소-&-loopback-주소.html"],"type":"attachment"},"images/build_process.html":{"title":"build_process","icon":"","description":"<img src=\"images/build_process.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/build_process.png","fullURL":"images/build_process.html","pathToRoot":"..","attachments":["images/build_process.html"],"createdTime":1710855209750,"modifiedTime":1710855209750,"sourceSize":64168,"sourcePath":"images/build_process.png","exportPath":"images/build_process.html","showInTree":true,"treeOrder":208,"backlinks":["cpp/basic/0.-c,-c++-컴파일-과정.html"],"type":"attachment"},"images/bw_grayscale.html":{"title":"bw_grayscale","icon":"","description":"<img src=\"images/bw_grayscale.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/bw_grayscale.png","fullURL":"images/bw_grayscale.html","pathToRoot":"..","attachments":["images/bw_grayscale.html"],"createdTime":1724571717958,"modifiedTime":1724571717959,"sourceSize":177310,"sourcePath":"images/bw_grayscale.png","exportPath":"images/bw_grayscale.html","showInTree":true,"treeOrder":209,"backlinks":["graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html"],"type":"attachment"},"images/change_scheme.html":{"title":"change_scheme","icon":"","description":"<img src=\"images/change_scheme.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/change_scheme.png","fullURL":"images/change_scheme.html","pathToRoot":"..","attachments":["images/change_scheme.html"],"createdTime":1710855209754,"modifiedTime":1710855209755,"sourceSize":73919,"sourcePath":"images/change_scheme.png","exportPath":"images/change_scheme.html","showInTree":true,"treeOrder":210,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment"},"images/cmake_setting.html":{"title":"cmake_setting","icon":"","description":"<img src=\"images/cmake_setting.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cmake_setting.png","fullURL":"images/cmake_setting.html","pathToRoot":"..","attachments":["images/cmake_setting.html"],"createdTime":1710855209756,"modifiedTime":1710855209756,"sourceSize":301772,"sourcePath":"images/cmake_setting.png","exportPath":"images/cmake_setting.html","showInTree":true,"treeOrder":211,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment"},"images/cmy_model.html":{"title":"cmy_model","icon":"","description":"<img src=\"images/cmy_model.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cmy_model.png","fullURL":"images/cmy_model.html","pathToRoot":"..","attachments":["images/cmy_model.html"],"createdTime":1724571717959,"modifiedTime":1724571717959,"sourceSize":267248,"sourcePath":"images/cmy_model.png","exportPath":"images/cmy_model.html","showInTree":true,"treeOrder":212,"backlinks":["graphics/opengl/01.기본/04.-컬러-기초이론.html"],"type":"attachment"},"images/collectpso.html":{"title":"collectpso","icon":"","description":"<img src=\"images/collectpso.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/collectpso.png","fullURL":"images/collectpso.html","pathToRoot":"..","attachments":["images/collectpso.html"],"createdTime":1719838659337,"modifiedTime":1719838659337,"sourceSize":21519,"sourcePath":"images/collectpso.png","exportPath":"images/collectpso.html","showInTree":true,"treeOrder":213,"backlinks":["ue/pso-(pipeline-state-object)-수집.html"],"type":"attachment"},"images/color_image.html":{"title":"color_image","icon":"","description":"<img src=\"images/color_image.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/color_image.png","fullURL":"images/color_image.html","pathToRoot":"..","attachments":["images/color_image.html"],"createdTime":1724571717960,"modifiedTime":1724571717960,"sourceSize":285111,"sourcePath":"images/color_image.png","exportPath":"images/color_image.html","showInTree":true,"treeOrder":214,"backlinks":["graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html"],"type":"attachment"},"images/color_vs_grayscale.html":{"title":"color_vs_grayscale","icon":"","description":"<img src=\"images/color_vs_grayscale.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/color_vs_grayscale.png","fullURL":"images/color_vs_grayscale.html","pathToRoot":"..","attachments":["images/color_vs_grayscale.html"],"createdTime":1724571717960,"modifiedTime":1724571717961,"sourceSize":354188,"sourcePath":"images/color_vs_grayscale.png","exportPath":"images/color_vs_grayscale.html","showInTree":true,"treeOrder":215,"backlinks":["graphics/opengl/01.기본/06.-rgba-컬러-모델.html"],"type":"attachment"},"images/common_ui_plugin.html":{"title":"Common_ui_plugin","icon":"","description":"<img src=\"images/common_ui_plugin.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/common_ui_plugin.png","fullURL":"images/common_ui_plugin.html","pathToRoot":"..","attachments":["images/common_ui_plugin.html"],"createdTime":1724571717940,"modifiedTime":1724571717940,"sourceSize":9707,"sourcePath":"images/Common_ui_plugin.png","exportPath":"images/common_ui_plugin.html","showInTree":true,"treeOrder":216,"backlinks":[],"type":"attachment"},"images/compared_ext_trigger.html":{"title":"compared_ext_trigger","icon":"","description":"<img src=\"images/compared_ext_trigger.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/compared_ext_trigger.png","fullURL":"images/compared_ext_trigger.html","pathToRoot":"..","attachments":["images/compared_ext_trigger.html"],"createdTime":1736697355563,"modifiedTime":1736697355563,"sourceSize":144452,"sourcePath":"images/compared_ext_trigger.png","exportPath":"images/compared_ext_trigger.html","showInTree":true,"treeOrder":217,"backlinks":["infra/p4-extension,-p4-triggers.html"],"type":"attachment"},"images/concurrent.html":{"title":"concurrent","icon":"","description":"<img src=\"images/concurrent.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/concurrent.png","fullURL":"images/concurrent.html","pathToRoot":"..","attachments":["images/concurrent.html"],"createdTime":1710855209769,"modifiedTime":1710855209769,"sourceSize":224190,"sourcePath":"images/concurrent.png","exportPath":"images/concurrent.html","showInTree":true,"treeOrder":218,"backlinks":["ios/동기,-비동기.html"],"type":"attachment"},"images/cpp_1.html":{"title":"cpp_1","icon":"","description":"<img src=\"images/cpp_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_1.png","fullURL":"images/cpp_1.html","pathToRoot":"..","attachments":["images/cpp_1.html"],"createdTime":1717918207669,"modifiedTime":1717918207669,"sourceSize":237712,"sourcePath":"images/cpp_1.png","exportPath":"images/cpp_1.html","showInTree":true,"treeOrder":219,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment"},"images/cpp_2.html":{"title":"cpp_2","icon":"","description":"<img src=\"images/cpp_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_2.png","fullURL":"images/cpp_2.html","pathToRoot":"..","attachments":["images/cpp_2.html"],"createdTime":1717918387053,"modifiedTime":1717918387053,"sourceSize":273603,"sourcePath":"images/cpp_2.png","exportPath":"images/cpp_2.html","showInTree":true,"treeOrder":220,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment"},"images/cpp_3.html":{"title":"cpp_3","icon":"","description":"<img src=\"images/cpp_3.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_3.png","fullURL":"images/cpp_3.html","pathToRoot":"..","attachments":["images/cpp_3.html"],"createdTime":1718520040498,"modifiedTime":1718520040498,"sourceSize":88165,"sourcePath":"images/cpp_3.png","exportPath":"images/cpp_3.html","showInTree":true,"treeOrder":221,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment"},"images/cpp_4.html":{"title":"cpp_4","icon":"","description":"<img src=\"images/cpp_4.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_4.png","fullURL":"images/cpp_4.html","pathToRoot":"..","attachments":["images/cpp_4.html"],"createdTime":1718520040498,"modifiedTime":1718520040499,"sourceSize":24551,"sourcePath":"images/cpp_4.png","exportPath":"images/cpp_4.html","showInTree":true,"treeOrder":222,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment"},"images/cpp_5.html":{"title":"cpp_5","icon":"","description":"<img src=\"images/cpp_5.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_5.png","fullURL":"images/cpp_5.html","pathToRoot":"..","attachments":["images/cpp_5.html"],"createdTime":1718520241779,"modifiedTime":1718520241780,"sourceSize":41839,"sourcePath":"images/cpp_5.png","exportPath":"images/cpp_5.html","showInTree":true,"treeOrder":223,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment"},"images/cpp_6.html":{"title":"cpp_6","icon":"","description":"<img src=\"images/cpp_6.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_6.png","fullURL":"images/cpp_6.html","pathToRoot":"..","attachments":["images/cpp_6.html"],"createdTime":1718521210207,"modifiedTime":1718521210207,"sourceSize":174995,"sourcePath":"images/cpp_6.png","exportPath":"images/cpp_6.html","showInTree":true,"treeOrder":224,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment"},"images/cpp_7.html":{"title":"cpp_7","icon":"","description":"<img src=\"images/cpp_7.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_7.png","fullURL":"images/cpp_7.html","pathToRoot":"..","attachments":["images/cpp_7.html"],"createdTime":1718526857149,"modifiedTime":1718526857150,"sourceSize":105916,"sourcePath":"images/cpp_7.png","exportPath":"images/cpp_7.html","showInTree":true,"treeOrder":225,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment"},"images/cpp_8.html":{"title":"cpp_8","icon":"","description":"<img src=\"images/cpp_8.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_8.png","fullURL":"images/cpp_8.html","pathToRoot":"..","attachments":["images/cpp_8.html"],"createdTime":1718528192210,"modifiedTime":1718528192210,"sourceSize":25704,"sourcePath":"images/cpp_8.png","exportPath":"images/cpp_8.html","showInTree":true,"treeOrder":226,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment"},"images/cpp_9.html":{"title":"cpp_9","icon":"","description":"<img src=\"images/cpp_9.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_9.png","fullURL":"images/cpp_9.html","pathToRoot":"..","attachments":["images/cpp_9.html"],"createdTime":1718528199266,"modifiedTime":1718528199267,"sourceSize":50752,"sourcePath":"images/cpp_9.png","exportPath":"images/cpp_9.html","showInTree":true,"treeOrder":227,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment"},"images/cpp_10.html":{"title":"cpp_10","icon":"","description":"<img src=\"images/cpp_10.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_10.png","fullURL":"images/cpp_10.html","pathToRoot":"..","attachments":["images/cpp_10.html"],"createdTime":1735109236636,"modifiedTime":1735109236636,"sourceSize":88781,"sourcePath":"images/cpp_10.png","exportPath":"images/cpp_10.html","showInTree":true,"treeOrder":228,"backlinks":["cpp/modern/4.-shared,-weak-ptr.html"],"type":"attachment"},"images/cpp_11.html":{"title":"cpp_11","icon":"","description":"<img src=\"images/cpp_11.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_11.png","fullURL":"images/cpp_11.html","pathToRoot":"..","attachments":["images/cpp_11.html"],"createdTime":1735109444001,"modifiedTime":1735109444002,"sourceSize":92686,"sourcePath":"images/cpp_11.png","exportPath":"images/cpp_11.html","showInTree":true,"treeOrder":229,"backlinks":["cpp/modern/4.-shared,-weak-ptr.html"],"type":"attachment"},"images/cpp_12.html":{"title":"cpp_12","icon":"","description":"<img src=\"images/cpp_12.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_12.png","fullURL":"images/cpp_12.html","pathToRoot":"..","attachments":["images/cpp_12.html"],"createdTime":1735110647426,"modifiedTime":1735110647426,"sourceSize":63339,"sourcePath":"images/cpp_12.png","exportPath":"images/cpp_12.html","showInTree":true,"treeOrder":230,"backlinks":["cpp/modern/4.-shared,-weak-ptr.html"],"type":"attachment"},"images/cpp_13.html":{"title":"cpp_13","icon":"","description":"<img src=\"images/cpp_13.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_13.png","fullURL":"images/cpp_13.html","pathToRoot":"..","attachments":["images/cpp_13.html"],"createdTime":1735210581953,"modifiedTime":1735210581954,"sourceSize":91927,"sourcePath":"images/cpp_13.png","exportPath":"images/cpp_13.html","showInTree":true,"treeOrder":231,"backlinks":["cpp/concurrency/2.-mutex,-deadlock.html"],"type":"attachment"},"images/cpp_14.html":{"title":"cpp_14","icon":"","description":"<img src=\"images/cpp_14.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_14.png","fullURL":"images/cpp_14.html","pathToRoot":"..","attachments":["images/cpp_14.html"],"createdTime":1735309162898,"modifiedTime":1735309162898,"sourceSize":101382,"sourcePath":"images/cpp_14.png","exportPath":"images/cpp_14.html","showInTree":true,"treeOrder":232,"backlinks":["cpp/concurrency/4.-future,-async,-promise.html"],"type":"attachment"},"images/cpp_memory_struct.html":{"title":"cpp_memory_struct","icon":"","description":"<img src=\"images/cpp_memory_struct.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/cpp_memory_struct.png","fullURL":"images/cpp_memory_struct.html","pathToRoot":"..","attachments":["images/cpp_memory_struct.html"],"createdTime":1754545491068,"modifiedTime":1754545491069,"sourceSize":171474,"sourcePath":"images/cpp_memory_struct.png","exportPath":"images/cpp_memory_struct.html","showInTree":true,"treeOrder":233,"backlinks":["cs/09.-c++-메모리-구조.html"],"type":"attachment"},"images/data_transfer_struct.html":{"title":"data_transfer_struct","icon":"","description":"<img src=\"images/data_transfer_struct.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/data_transfer_struct.png","fullURL":"images/data_transfer_struct.html","pathToRoot":"..","attachments":["images/data_transfer_struct.html"],"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":631577,"sourcePath":"images/data_transfer_struct.png","exportPath":"images/data_transfer_struct.html","showInTree":true,"treeOrder":234,"backlinks":["network/06.-tcp-ip-송수신-구조.html"],"type":"attachment"},"images/datahandle_row_result.html":{"title":"datahandle_row_result","icon":"","description":"<img src=\"images/datahandle_row_result.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/datahandle_row_result.png","fullURL":"images/datahandle_row_result.html","pathToRoot":"..","attachments":["images/datahandle_row_result.html"],"createdTime":1724571717953,"modifiedTime":1724571717954,"sourceSize":19027,"sourcePath":"images/datahandle_row_result.png","exportPath":"images/datahandle_row_result.html","showInTree":true,"treeOrder":235,"backlinks":["ue/datatable_asset_ref.html"],"type":"attachment"},"images/debugging_failure.html":{"title":"debugging_failure","icon":"","description":"<img src=\"images/debugging_failure.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/debugging_failure.png","fullURL":"images/debugging_failure.html","pathToRoot":"..","attachments":["images/debugging_failure.html"],"createdTime":1730808631674,"modifiedTime":1730808631675,"sourceSize":176534,"sourcePath":"images/debugging_failure.png","exportPath":"images/debugging_failure.html","showInTree":true,"treeOrder":236,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment"},"images/debugging_success.html":{"title":"debugging_success","icon":"","description":"<img src=\"images/debugging_success.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/debugging_success.png","fullURL":"images/debugging_success.html","pathToRoot":"..","attachments":["images/debugging_success.html"],"createdTime":1730808631675,"modifiedTime":1730808631675,"sourceSize":144960,"sourcePath":"images/debugging_success.png","exportPath":"images/debugging_success.html","showInTree":true,"treeOrder":237,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment"},"images/dfs_1.html":{"title":"DFS_1","icon":"","description":"<img src=\"images/dfs_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/dfs_1.png","fullURL":"images/dfs_1.html","pathToRoot":"..","attachments":["images/dfs_1.html"],"createdTime":1719763592496,"modifiedTime":1719763592496,"sourceSize":796867,"sourcePath":"images/DFS_1.png","exportPath":"images/dfs_1.html","showInTree":true,"treeOrder":238,"backlinks":["algorithm/lecture/dfs.html"],"type":"attachment"},"images/dfs_2.html":{"title":"DFS_2","icon":"","description":"<img src=\"images/dfs_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/dfs_2.png","fullURL":"images/dfs_2.html","pathToRoot":"..","attachments":["images/dfs_2.html"],"createdTime":1719763717770,"modifiedTime":1719763717770,"sourceSize":827352,"sourcePath":"images/DFS_2.png","exportPath":"images/dfs_2.html","showInTree":true,"treeOrder":239,"backlinks":["algorithm/lecture/dfs.html"],"type":"attachment"},"images/ebtnode_result_aborted.html":{"title":"ebtnode_result_aborted","icon":"","description":"<img src=\"images/ebtnode_result_aborted.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ebtnode_result_aborted.png","fullURL":"images/ebtnode_result_aborted.html","pathToRoot":"..","attachments":["images/ebtnode_result_aborted.html"],"createdTime":1710855209739,"modifiedTime":1710855209743,"sourceSize":2050056,"sourcePath":"images/ebtnode_result_aborted.png","exportPath":"images/ebtnode_result_aborted.html","showInTree":true,"treeOrder":240,"backlinks":[],"type":"attachment"},"images/ebtnode_result_failed.html":{"title":"ebtnode_result_failed","icon":"","description":"<img src=\"images/ebtnode_result_failed.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ebtnode_result_failed.png","fullURL":"images/ebtnode_result_failed.html","pathToRoot":"..","attachments":["images/ebtnode_result_failed.html"],"createdTime":1710855209743,"modifiedTime":1710855209747,"sourceSize":1897692,"sourcePath":"images/ebtnode_result_failed.png","exportPath":"images/ebtnode_result_failed.html","showInTree":true,"treeOrder":241,"backlinks":[],"type":"attachment"},"images/ebtnode_result_inprogress.html":{"title":"ebtnode_result_inprogress","icon":"","description":"<img src=\"images/ebtnode_result_inprogress.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ebtnode_result_inprogress.png","fullURL":"images/ebtnode_result_inprogress.html","pathToRoot":"..","attachments":["images/ebtnode_result_inprogress.html"],"createdTime":1710855209747,"modifiedTime":1710855209750,"sourceSize":1709730,"sourcePath":"images/ebtnode_result_inprogress.png","exportPath":"images/ebtnode_result_inprogress.html","showInTree":true,"treeOrder":242,"backlinks":[],"type":"attachment"},"images/ebtnode_result_type.html":{"title":"ebtnode_result_type","icon":"","description":"<img src=\"images/ebtnode_result_type.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ebtnode_result_type.png","fullURL":"images/ebtnode_result_type.html","pathToRoot":"..","attachments":["images/ebtnode_result_type.html"],"createdTime":1710855209750,"modifiedTime":1710855209750,"sourceSize":28011,"sourcePath":"images/ebtnode_result_type.png","exportPath":"images/ebtnode_result_type.html","showInTree":true,"treeOrder":243,"backlinks":[],"type":"attachment"},"images/executable_file_structure.html":{"title":"executable_file_structure","icon":"","description":"<img src=\"images/executable_file_structure.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/executable_file_structure.png","fullURL":"images/executable_file_structure.html","pathToRoot":"..","attachments":["images/executable_file_structure.html"],"createdTime":1710855209752,"modifiedTime":1710855209752,"sourceSize":135281,"sourcePath":"images/executable_file_structure.png","exportPath":"images/executable_file_structure.html","showInTree":true,"treeOrder":244,"backlinks":[],"type":"attachment"},"images/export_shader_code.html":{"title":"export_shader_code","icon":"","description":"<img src=\"images/export_shader_code.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/export_shader_code.png","fullURL":"images/export_shader_code.html","pathToRoot":"..","attachments":["images/export_shader_code.html"],"createdTime":1730808631675,"modifiedTime":1730808631676,"sourceSize":232733,"sourcePath":"images/export_shader_code.png","exportPath":"images/export_shader_code.html","showInTree":true,"treeOrder":245,"backlinks":["graphics/opengl/02.응용/06.-재사용가능한-코드.html"],"type":"attachment"},"images/fatframework_path.html":{"title":"fatframework_path","icon":"","description":"<img src=\"images/fatframework_path.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/fatframework_path.png","fullURL":"images/fatframework_path.html","pathToRoot":"..","attachments":["images/fatframework_path.html"],"createdTime":1710855209764,"modifiedTime":1710855209765,"sourceSize":236754,"sourcePath":"images/fatframework_path.png","exportPath":"images/fatframework_path.html","showInTree":true,"treeOrder":246,"backlinks":["ios/fat-framework.html"],"type":"attachment"},"images/foldering_as_is.html":{"title":"foldering_as_is","icon":"","description":"<img src=\"images/foldering_as_is.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/foldering_as_is.png","fullURL":"images/foldering_as_is.html","pathToRoot":"..","attachments":["images/foldering_as_is.html"],"createdTime":1724571717968,"modifiedTime":1724571717968,"sourceSize":14318,"sourcePath":"images/foldering_as_is.png","exportPath":"images/foldering_as_is.html","showInTree":true,"treeOrder":247,"backlinks":[],"type":"attachment"},"images/foldering_to_be.html":{"title":"foldering_to_be","icon":"","description":"<img src=\"images/foldering_to_be.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/foldering_to_be.png","fullURL":"images/foldering_to_be.html","pathToRoot":"..","attachments":["images/foldering_to_be.html"],"createdTime":1724679437333,"modifiedTime":1724679437333,"sourceSize":12843,"sourcePath":"images/foldering_to_be.png","exportPath":"images/foldering_to_be.html","showInTree":true,"treeOrder":248,"backlinks":["ue/sounds-개선.html"],"type":"attachment"},"images/fragment_shader.html":{"title":"fragment_shader","icon":"","description":"<img src=\"images/fragment_shader.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/fragment_shader.png","fullURL":"images/fragment_shader.html","pathToRoot":"..","attachments":["images/fragment_shader.html"],"createdTime":1730808631676,"modifiedTime":1730808631677,"sourceSize":450079,"sourcePath":"images/fragment_shader.png","exportPath":"images/fragment_shader.html","showInTree":true,"treeOrder":249,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment"},"images/fragment_shader_execute.html":{"title":"fragment_shader_execute","icon":"","description":"<img src=\"images/fragment_shader_execute.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/fragment_shader_execute.png","fullURL":"images/fragment_shader_execute.html","pathToRoot":"..","attachments":["images/fragment_shader_execute.html"],"createdTime":1730808631678,"modifiedTime":1730808631680,"sourceSize":645434,"sourcePath":"images/fragment_shader_execute.png","exportPath":"images/fragment_shader_execute.html","showInTree":true,"treeOrder":250,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment"},"images/framework_path.html":{"title":"framework_path","icon":"","description":"<img src=\"images/framework_path.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/framework_path.png","fullURL":"images/framework_path.html","pathToRoot":"..","attachments":["images/framework_path.html"],"createdTime":1710855209766,"modifiedTime":1710855209767,"sourceSize":199600,"sourcePath":"images/framework_path.png","exportPath":"images/framework_path.html","showInTree":true,"treeOrder":251,"backlinks":["ios/fat-framework.html"],"type":"attachment"},"images/fresnel.html":{"title":"fresnel","icon":"","description":"<img src=\"images/fresnel.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/fresnel.png","fullURL":"images/fresnel.html","pathToRoot":"..","attachments":["images/fresnel.html"],"createdTime":1752590582977,"modifiedTime":1752590582979,"sourceSize":679528,"sourcePath":"images/fresnel.png","exportPath":"images/fresnel.html","showInTree":true,"treeOrder":252,"backlinks":["graphics/unreal-engine/rim-light와-fresnel-노드.html"],"type":"attachment"},"images/func_1.html":{"title":"func_1","icon":"","description":"<img src=\"images/func_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/func_1.png","fullURL":"images/func_1.html","pathToRoot":"..","attachments":["images/func_1.html"],"createdTime":1730808631680,"modifiedTime":1730808631680,"sourceSize":120737,"sourcePath":"images/func_1.png","exportPath":"images/func_1.html","showInTree":true,"treeOrder":253,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment"},"images/gameflowchart.html":{"title":"GameFlowChart","icon":"","description":"<img src=\"images/gameflowchart.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/gameflowchart.png","fullURL":"images/gameflowchart.html","pathToRoot":"..","attachments":["images/gameflowchart.html"],"createdTime":1710855209737,"modifiedTime":1710855209738,"sourceSize":71598,"sourcePath":"images/GameFlowChart.png","exportPath":"images/gameflowchart.html","showInTree":true,"treeOrder":254,"backlinks":["ue/월드의-생명주기.html"],"type":"attachment"},"images/gl_error_flag.html":{"title":"gl_error_flag","icon":"","description":"<img src=\"images/gl_error_flag.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/gl_error_flag.png","fullURL":"images/gl_error_flag.html","pathToRoot":"..","attachments":["images/gl_error_flag.html"],"createdTime":1730808631681,"modifiedTime":1730808631682,"sourceSize":115525,"sourcePath":"images/gl_error_flag.png","exportPath":"images/gl_error_flag.html","showInTree":true,"treeOrder":255,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment"},"images/glew32_install_error.html":{"title":"glew32_install_error","icon":"","description":"<img src=\"images/glew32_install_error.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/glew32_install_error.png","fullURL":"images/glew32_install_error.html","pathToRoot":"..","attachments":["images/glew32_install_error.html"],"createdTime":1710855209770,"modifiedTime":1710855209770,"sourceSize":42922,"sourcePath":"images/glew32_install_error.png","exportPath":"images/glew32_install_error.html","showInTree":true,"treeOrder":256,"backlinks":["graphics/opengl/01.기본/01.-기본.html"],"type":"attachment"},"images/glsl_debugging_1.html":{"title":"glsl_debugging_1","icon":"","description":"<img src=\"images/glsl_debugging_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/glsl_debugging_1.png","fullURL":"images/glsl_debugging_1.html","pathToRoot":"..","attachments":["images/glsl_debugging_1.html"],"createdTime":1730808631683,"modifiedTime":1730808631684,"sourceSize":315674,"sourcePath":"images/glsl_debugging_1.png","exportPath":"images/glsl_debugging_1.html","showInTree":true,"treeOrder":257,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment"},"images/glsl_debugging2.html":{"title":"glsl_debugging2","icon":"","description":"<img src=\"images/glsl_debugging2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/glsl_debugging2.png","fullURL":"images/glsl_debugging2.html","pathToRoot":"..","attachments":["images/glsl_debugging2.html"],"createdTime":1730808631682,"modifiedTime":1730808631683,"sourceSize":310477,"sourcePath":"images/glsl_debugging2.png","exportPath":"images/glsl_debugging2.html","showInTree":true,"treeOrder":258,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment"},"images/glvertexattribpointer.html":{"title":"glVertexAttribPointer","icon":"","description":"<img src=\"images/glvertexattribpointer.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/glvertexattribpointer.png","fullURL":"images/glvertexattribpointer.html","pathToRoot":"..","attachments":["images/glvertexattribpointer.html"],"createdTime":1730808631680,"modifiedTime":1730808631681,"sourceSize":803090,"sourcePath":"images/glVertexAttribPointer.png","exportPath":"images/glvertexattribpointer.html","showInTree":true,"treeOrder":259,"backlinks":["graphics/opengl/02.응용/05.-shader-programming-코드-분석.html"],"type":"attachment"},"images/gpu_structure.html":{"title":"gpu_structure","icon":"","description":"<img src=\"images/gpu_structure.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/gpu_structure.png","fullURL":"images/gpu_structure.html","pathToRoot":"..","attachments":["images/gpu_structure.html"],"createdTime":1730808631684,"modifiedTime":1730808631684,"sourceSize":233489,"sourcePath":"images/gpu_structure.png","exportPath":"images/gpu_structure.html","showInTree":true,"treeOrder":260,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment"},"images/graphic_pipeline.html":{"title":"graphic_pipeline","icon":"","description":"<img src=\"images/graphic_pipeline.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/graphic_pipeline.png","fullURL":"images/graphic_pipeline.html","pathToRoot":"..","attachments":["images/graphic_pipeline.html"],"createdTime":1724679437333,"modifiedTime":1724679437333,"sourceSize":146778,"sourcePath":"images/graphic_pipeline.png","exportPath":"images/graphic_pipeline.html","showInTree":true,"treeOrder":261,"backlinks":["graphics/opengl/02.응용/01.-그래픽스-파이프라인.html"],"type":"attachment"},"images/greedy_1.html":{"title":"greedy_1","icon":"","description":"<img src=\"images/greedy_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/greedy_1.png","fullURL":"images/greedy_1.html","pathToRoot":"..","attachments":["images/greedy_1.html"],"createdTime":1719241549677,"modifiedTime":1719241549680,"sourceSize":1130554,"sourcePath":"images/greedy_1.png","exportPath":"images/greedy_1.html","showInTree":true,"treeOrder":262,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment"},"images/greedy_2.html":{"title":"greedy_2","icon":"","description":"<img src=\"images/greedy_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/greedy_2.png","fullURL":"images/greedy_2.html","pathToRoot":"..","attachments":["images/greedy_2.html"],"createdTime":1719241549680,"modifiedTime":1719241549686,"sourceSize":2298930,"sourcePath":"images/greedy_2.png","exportPath":"images/greedy_2.html","showInTree":true,"treeOrder":263,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment"},"images/greedy_3.html":{"title":"greedy_3","icon":"","description":"<img src=\"images/greedy_3.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/greedy_3.png","fullURL":"images/greedy_3.html","pathToRoot":"..","attachments":["images/greedy_3.html"],"createdTime":1719241549686,"modifiedTime":1719241549690,"sourceSize":2122424,"sourcePath":"images/greedy_3.png","exportPath":"images/greedy_3.html","showInTree":true,"treeOrder":264,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment"},"images/greedy_4.html":{"title":"greedy_4","icon":"","description":"<img src=\"images/greedy_4.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/greedy_4.png","fullURL":"images/greedy_4.html","pathToRoot":"..","attachments":["images/greedy_4.html"],"createdTime":1719241549691,"modifiedTime":1719241549695,"sourceSize":2150616,"sourcePath":"images/greedy_4.png","exportPath":"images/greedy_4.html","showInTree":true,"treeOrder":265,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment"},"images/grey_to_color_using_ai.html":{"title":"grey_to_color_using_ai","icon":"","description":"<img src=\"images/grey_to_color_using_ai.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/grey_to_color_using_ai.png","fullURL":"images/grey_to_color_using_ai.html","pathToRoot":"..","attachments":["images/grey_to_color_using_ai.html"],"createdTime":1724571717961,"modifiedTime":1724571717962,"sourceSize":212484,"sourcePath":"images/grey_to_color_using_ai.png","exportPath":"images/grey_to_color_using_ai.html","showInTree":true,"treeOrder":266,"backlinks":["graphics/opengl/01.기본/06.-rgba-컬러-모델.html"],"type":"attachment"},"images/hostapp_file.html":{"title":"hostapp_file","icon":"","description":"<img src=\"images/hostapp_file.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/hostapp_file.png","fullURL":"images/hostapp_file.html","pathToRoot":"..","attachments":["images/hostapp_file.html"],"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":34963,"sourcePath":"images/hostapp_file.png","exportPath":"images/hostapp_file.html","showInTree":true,"treeOrder":267,"backlinks":["ios/fat-framework.html"],"type":"attachment"},"images/immutable_mutable.html":{"title":"immutable_mutable","icon":"","description":"<img src=\"images/immutable_mutable.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/immutable_mutable.png","fullURL":"images/immutable_mutable.html","pathToRoot":"..","attachments":["images/immutable_mutable.html"],"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":78402,"sourcePath":"images/immutable_mutable.png","exportPath":"images/immutable_mutable.html","showInTree":true,"treeOrder":268,"backlinks":["ios/objective-c.html"],"type":"attachment"},"images/inc_support.html":{"title":"inc_support","icon":"","description":"<img src=\"images/inc_support.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/inc_support.png","fullURL":"images/inc_support.html","pathToRoot":"..","attachments":["images/inc_support.html"],"createdTime":1722511221529,"modifiedTime":1722511221529,"sourceSize":29604,"sourcePath":"images/inc_support.png","exportPath":"images/inc_support.html","showInTree":true,"treeOrder":269,"backlinks":["infra/jenkins-안드로이드-패키징.html"],"type":"attachment"},"images/initializer_list_char.html":{"title":"initializer_list_char","icon":"","description":"<img src=\"images/initializer_list_char.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/initializer_list_char.png","fullURL":"images/initializer_list_char.html","pathToRoot":"..","attachments":["images/initializer_list_char.html"],"createdTime":1738469787018,"modifiedTime":1738469787019,"sourceSize":43161,"sourcePath":"images/initializer_list_char.png","exportPath":"images/initializer_list_char.html","showInTree":true,"treeOrder":270,"backlinks":["cpp/modern/6.-uniform-initializer.html"],"type":"attachment"},"images/insight_after.html":{"title":"insight_after","icon":"","description":"<img src=\"images/insight_after.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/insight_after.png","fullURL":"images/insight_after.html","pathToRoot":"..","attachments":["images/insight_after.html"],"createdTime":1730808631708,"modifiedTime":1730808631708,"sourceSize":11597,"sourcePath":"images/insight_after.png","exportPath":"images/insight_after.html","showInTree":true,"treeOrder":271,"backlinks":["ue/sounds-개선.html"],"type":"attachment"},"images/insight_before.html":{"title":"insight_before","icon":"","description":"<img src=\"images/insight_before.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/insight_before.png","fullURL":"images/insight_before.html","pathToRoot":"..","attachments":["images/insight_before.html"],"createdTime":1730808631709,"modifiedTime":1730808631709,"sourceSize":9803,"sourcePath":"images/insight_before.png","exportPath":"images/insight_before.html","showInTree":true,"treeOrder":272,"backlinks":["ue/sounds-개선.html"],"type":"attachment"},"images/ip4v_header.html":{"title":"ip4v_header","icon":"","description":"<img src=\"images/ip4v_header.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/ip4v_header.png","fullURL":"images/ip4v_header.html","pathToRoot":"..","attachments":["images/ip4v_header.html"],"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":108041,"sourcePath":"images/ip4v_header.png","exportPath":"images/ip4v_header.html","showInTree":true,"treeOrder":273,"backlinks":["network/07.-ipv4-header-형식.html"],"type":"attachment"},"images/layout_qualifier.html":{"title":"layout_qualifier","icon":"","description":"<img src=\"images/layout_qualifier.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/layout_qualifier.png","fullURL":"images/layout_qualifier.html","pathToRoot":"..","attachments":["images/layout_qualifier.html"],"createdTime":1730808631684,"modifiedTime":1730808631685,"sourceSize":297491,"sourcePath":"images/layout_qualifier.png","exportPath":"images/layout_qualifier.html","showInTree":true,"treeOrder":274,"backlinks":["graphics/opengl/02.응용/06.-재사용가능한-코드.html"],"type":"attachment"},"images/linear_interpolation.html":{"title":"linear_interpolation","icon":"","description":"<img src=\"images/linear_interpolation.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/linear_interpolation.png","fullURL":"images/linear_interpolation.html","pathToRoot":"..","attachments":["images/linear_interpolation.html"],"createdTime":1730808631685,"modifiedTime":1730808631686,"sourceSize":383876,"sourcePath":"images/linear_interpolation.png","exportPath":"images/linear_interpolation.html","showInTree":true,"treeOrder":275,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment"},"images/math_func.html":{"title":"math_func","icon":"","description":"<img src=\"images/math_func.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/math_func.png","fullURL":"images/math_func.html","pathToRoot":"..","attachments":["images/math_func.html"],"createdTime":1730808631686,"modifiedTime":1730808631686,"sourceSize":126361,"sourcePath":"images/math_func.png","exportPath":"images/math_func.html","showInTree":true,"treeOrder":276,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment"},"images/matrix_row_prior.html":{"title":"matrix_row_prior","icon":"","description":"<img src=\"images/matrix_row_prior.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/matrix_row_prior.png","fullURL":"images/matrix_row_prior.html","pathToRoot":"..","attachments":["images/matrix_row_prior.html"],"createdTime":1730808631686,"modifiedTime":1730808631687,"sourceSize":139225,"sourcePath":"images/matrix_row_prior.png","exportPath":"images/matrix_row_prior.html","showInTree":true,"treeOrder":277,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment"},"images/metal_rendering_pipeline.html":{"title":"metal_rendering_pipeline","icon":"","description":"<img src=\"images/metal_rendering_pipeline.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/metal_rendering_pipeline.png","fullURL":"images/metal_rendering_pipeline.html","pathToRoot":"..","attachments":["images/metal_rendering_pipeline.html"],"createdTime":1732431283258,"modifiedTime":1732431283258,"sourceSize":87904,"sourcePath":"images/metal_rendering_pipeline.png","exportPath":"images/metal_rendering_pipeline.html","showInTree":true,"treeOrder":278,"backlinks":["graphics/metal/0.-metal-basic.html"],"type":"attachment"},"images/nativizedassets.html":{"title":"NativizedAssets","icon":"","description":"<img src=\"images/nativizedassets.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/nativizedassets.png","fullURL":"images/nativizedassets.html","pathToRoot":"..","attachments":["images/nativizedassets.html"],"createdTime":1710855209753,"modifiedTime":1710855209754,"sourceSize":365059,"sourcePath":"images/NativizedAssets.png","exportPath":"images/nativizedassets.html","showInTree":true,"treeOrder":279,"backlinks":["ue/ue4-source-ios-debugging-on-macos.html"],"type":"attachment"},"images/navigation.html":{"title":"Navigation","icon":"","description":"<img src=\"images/navigation.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/navigation.png","fullURL":"images/navigation.html","pathToRoot":"..","attachments":["images/navigation.html"],"createdTime":1710855209738,"modifiedTime":1710855209739,"sourceSize":1082780,"sourcePath":"images/Navigation.png","exportPath":"images/navigation.html","showInTree":true,"treeOrder":280,"backlinks":["ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html"],"type":"attachment"},"images/object_file_header.html":{"title":"object_file_header","icon":"","description":"<img src=\"images/object_file_header.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/object_file_header.png","fullURL":"images/object_file_header.html","pathToRoot":"..","attachments":["images/object_file_header.html"],"createdTime":1710855209752,"modifiedTime":1710855209753,"sourceSize":66978,"sourcePath":"images/object_file_header.png","exportPath":"images/object_file_header.html","showInTree":true,"treeOrder":281,"backlinks":["cpp/basic/0.-c,-c++-컴파일-과정.html"],"type":"attachment"},"images/opengl_shader_program_process.html":{"title":"opengl_shader_program_process","icon":"","description":"<img src=\"images/opengl_shader_program_process.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/opengl_shader_program_process.png","fullURL":"images/opengl_shader_program_process.html","pathToRoot":"..","attachments":["images/opengl_shader_program_process.html"],"createdTime":1730808631687,"modifiedTime":1730808631689,"sourceSize":1013791,"sourcePath":"images/opengl_shader_program_process.png","exportPath":"images/opengl_shader_program_process.html","showInTree":true,"treeOrder":282,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment"},"images/packet.html":{"title":"packet","icon":"","description":"<img src=\"images/packet.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/packet.png","fullURL":"images/packet.html","pathToRoot":"..","attachments":["images/packet.html"],"createdTime":1724571717943,"modifiedTime":1724571717944,"sourceSize":484235,"sourcePath":"images/packet.png","exportPath":"images/packet.html","showInTree":true,"treeOrder":283,"backlinks":["network/04.-패킷의-생성과-전달.html"],"type":"attachment"},"images/paralle_processing.html":{"title":"paralle_processing","icon":"","description":"<img src=\"images/paralle_processing.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/paralle_processing.png","fullURL":"images/paralle_processing.html","pathToRoot":"..","attachments":["images/paralle_processing.html"],"createdTime":1730808631689,"modifiedTime":1730808631689,"sourceSize":128064,"sourcePath":"images/paralle_processing.png","exportPath":"images/paralle_processing.html","showInTree":true,"treeOrder":284,"backlinks":["graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html"],"type":"attachment"},"images/primitive_assembly_rasterization.html":{"title":"primitive_assembly_rasterization","icon":"","description":"<img src=\"images/primitive_assembly_rasterization.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/primitive_assembly_rasterization.png","fullURL":"images/primitive_assembly_rasterization.html","pathToRoot":"..","attachments":["images/primitive_assembly_rasterization.html"],"createdTime":1730808631689,"modifiedTime":1730808631691,"sourceSize":650335,"sourcePath":"images/primitive_assembly_rasterization.png","exportPath":"images/primitive_assembly_rasterization.html","showInTree":true,"treeOrder":285,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment"},"images/printf.html":{"title":"printf","icon":"","description":"<img src=\"images/printf.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/printf.png","fullURL":"images/printf.html","pathToRoot":"..","attachments":["images/printf.html"],"createdTime":1710855209753,"modifiedTime":1710855209753,"sourceSize":108395,"sourcePath":"images/printf.png","exportPath":"images/printf.html","showInTree":true,"treeOrder":286,"backlinks":["cpp/basic/0.-c,-c++-컴파일-과정.html"],"type":"attachment"},"images/prog_debugging.html":{"title":"prog_debugging","icon":"","description":"<img src=\"images/prog_debugging.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/prog_debugging.png","fullURL":"images/prog_debugging.html","pathToRoot":"..","attachments":["images/prog_debugging.html"],"createdTime":1730808631691,"modifiedTime":1730808631692,"sourceSize":178240,"sourcePath":"images/prog_debugging.png","exportPath":"images/prog_debugging.html","showInTree":true,"treeOrder":287,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment"},"images/programmable_pipeline.html":{"title":"programmable_pipeline","icon":"","description":"<img src=\"images/programmable_pipeline.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/programmable_pipeline.png","fullURL":"images/programmable_pipeline.html","pathToRoot":"..","attachments":["images/programmable_pipeline.html"],"createdTime":1730808631692,"modifiedTime":1730808631693,"sourceSize":486510,"sourcePath":"images/programmable_pipeline.png","exportPath":"images/programmable_pipeline.html","showInTree":true,"treeOrder":288,"backlinks":["graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html"],"type":"attachment"},"images/pso.html":{"title":"pso","icon":"","description":"<img src=\"images/pso.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/pso.png","fullURL":"images/pso.html","pathToRoot":"..","attachments":["images/pso.html"],"createdTime":1724571717969,"modifiedTime":1724571717970,"sourceSize":85554,"sourcePath":"images/pso.png","exportPath":"images/pso.html","showInTree":true,"treeOrder":289,"backlinks":[],"type":"attachment"},"images/pso_data.html":{"title":"pso_data","icon":"","description":"<img src=\"images/pso_data.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/pso_data.png","fullURL":"images/pso_data.html","pathToRoot":"..","attachments":["images/pso_data.html"],"createdTime":1719838659338,"modifiedTime":1719838659338,"sourceSize":24251,"sourcePath":"images/pso_data.png","exportPath":"images/pso_data.html","showInTree":true,"treeOrder":290,"backlinks":["ue/pso-(pipeline-state-object)-수집.html"],"type":"attachment"},"images/rasterization_mean.html":{"title":"rasterization_mean","icon":"","description":"<img src=\"images/rasterization_mean.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/rasterization_mean.png","fullURL":"images/rasterization_mean.html","pathToRoot":"..","attachments":["images/rasterization_mean.html"],"createdTime":1730808631693,"modifiedTime":1730808631694,"sourceSize":547080,"sourcePath":"images/rasterization_mean.png","exportPath":"images/rasterization_mean.html","showInTree":true,"treeOrder":291,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment"},"images/register_vec.html":{"title":"register_vec","icon":"","description":"<img src=\"images/register_vec.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/register_vec.png","fullURL":"images/register_vec.html","pathToRoot":"..","attachments":["images/register_vec.html"],"createdTime":1730808631694,"modifiedTime":1730808631694,"sourceSize":36023,"sourcePath":"images/register_vec.png","exportPath":"images/register_vec.html","showInTree":true,"treeOrder":292,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment"},"images/removedinternal.html":{"title":"removedinternal","icon":"","description":"<img src=\"images/removedinternal.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/removedinternal.png","fullURL":"images/removedinternal.html","pathToRoot":"..","attachments":["images/removedinternal.html"],"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":44765,"sourcePath":"images/removedinternal.png","exportPath":"images/removedinternal.html","showInTree":true,"treeOrder":293,"backlinks":["ios/swift,-objective-c-interoperability.html"],"type":"attachment"},"images/rgb_cmy_conversion.html":{"title":"rgb_cmy_conversion","icon":"","description":"<img src=\"images/rgb_cmy_conversion.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/rgb_cmy_conversion.png","fullURL":"images/rgb_cmy_conversion.html","pathToRoot":"..","attachments":["images/rgb_cmy_conversion.html"],"createdTime":1724571717962,"modifiedTime":1724571717962,"sourceSize":22210,"sourcePath":"images/rgb_cmy_conversion.png","exportPath":"images/rgb_cmy_conversion.html","showInTree":true,"treeOrder":294,"backlinks":["graphics/opengl/01.기본/04.-컬러-기초이론.html"],"type":"attachment"},"images/rgb_color_model.html":{"title":"rgb_color_model","icon":"","description":"<img src=\"images/rgb_color_model.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/rgb_color_model.png","fullURL":"images/rgb_color_model.html","pathToRoot":"..","attachments":["images/rgb_color_model.html"],"createdTime":1724571717962,"modifiedTime":1724571717962,"sourceSize":347295,"sourcePath":"images/rgb_color_model.png","exportPath":"images/rgb_color_model.html","showInTree":true,"treeOrder":295,"backlinks":["graphics/opengl/01.기본/04.-컬러-기초이론.html"],"type":"attachment"},"images/robot_maze.html":{"title":"robot_maze","icon":"","description":"<img src=\"images/robot_maze.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/robot_maze.png","fullURL":"images/robot_maze.html","pathToRoot":"..","attachments":["images/robot_maze.html"],"createdTime":1736064754186,"modifiedTime":1736064754187,"sourceSize":9685,"sourcePath":"images/robot_maze.png","exportPath":"images/robot_maze.html","showInTree":true,"treeOrder":296,"backlinks":["algorithm/leetcode/62.-unique-paths.html"],"type":"attachment"},"images/sandbox_error.html":{"title":"sandbox_error","icon":"","description":"<img src=\"images/sandbox_error.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/sandbox_error.png","fullURL":"images/sandbox_error.html","pathToRoot":"..","attachments":["images/sandbox_error.html"],"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":90251,"sourcePath":"images/sandbox_error.png","exportPath":"images/sandbox_error.html","showInTree":true,"treeOrder":297,"backlinks":["ios/fat-framework.html"],"type":"attachment"},"images/serial.html":{"title":"serial","icon":"","description":"<img src=\"images/serial.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/serial.png","fullURL":"images/serial.html","pathToRoot":"..","attachments":["images/serial.html"],"createdTime":1710855209769,"modifiedTime":1710855209770,"sourceSize":190288,"sourcePath":"images/serial.png","exportPath":"images/serial.html","showInTree":true,"treeOrder":298,"backlinks":["ios/동기,-비동기.html"],"type":"attachment"},"images/shader_program_structure.html":{"title":"shader_program_structure","icon":"","description":"<img src=\"images/shader_program_structure.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/shader_program_structure.png","fullURL":"images/shader_program_structure.html","pathToRoot":"..","attachments":["images/shader_program_structure.html"],"createdTime":1730808631694,"modifiedTime":1730808631696,"sourceSize":1027728,"sourcePath":"images/shader_program_structure.png","exportPath":"images/shader_program_structure.html","showInTree":true,"treeOrder":299,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment"},"images/simulator_device_error.html":{"title":"simulator_device_error","icon":"","description":"<img src=\"images/simulator_device_error.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/simulator_device_error.png","fullURL":"images/simulator_device_error.html","pathToRoot":"..","attachments":["images/simulator_device_error.html"],"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":24329,"sourcePath":"images/simulator_device_error.png","exportPath":"images/simulator_device_error.html","showInTree":true,"treeOrder":300,"backlinks":["ios/fat-framework.html"],"type":"attachment"},"images/slate_arcitecture_1.html":{"title":"SLATE_ARCITECTURE_1","icon":"","description":"<img src=\"images/slate_arcitecture_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/slate_arcitecture_1.png","fullURL":"images/slate_arcitecture_1.html","pathToRoot":"..","attachments":["images/slate_arcitecture_1.html"],"createdTime":1710855209759,"modifiedTime":1710855209760,"sourceSize":224814,"sourcePath":"images/SLATE_ARCITECTURE_1.png","exportPath":"images/slate_arcitecture_1.html","showInTree":true,"treeOrder":301,"backlinks":["ue/slate-architecture.html"],"type":"attachment"},"images/slate_arcitecture_2.html":{"title":"SLATE_ARCITECTURE_2","icon":"","description":"<img src=\"images/slate_arcitecture_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/slate_arcitecture_2.png","fullURL":"images/slate_arcitecture_2.html","pathToRoot":"..","attachments":["images/slate_arcitecture_2.html"],"createdTime":1710855209760,"modifiedTime":1710855209760,"sourceSize":124195,"sourcePath":"images/SLATE_ARCITECTURE_2.png","exportPath":"images/slate_arcitecture_2.html","showInTree":true,"treeOrder":302,"backlinks":["ue/slate-architecture.html"],"type":"attachment"},"images/slate_arcitecture_3.html":{"title":"SLATE_ARCITECTURE_3","icon":"","description":"<img src=\"images/slate_arcitecture_3.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/slate_arcitecture_3.png","fullURL":"images/slate_arcitecture_3.html","pathToRoot":"..","attachments":["images/slate_arcitecture_3.html"],"createdTime":1710855209760,"modifiedTime":1710855209762,"sourceSize":526967,"sourcePath":"images/SLATE_ARCITECTURE_3.png","exportPath":"images/slate_arcitecture_3.html","showInTree":true,"treeOrder":303,"backlinks":["ue/slate-architecture.html"],"type":"attachment"},"images/slate_arcitecture_4.html":{"title":"SLATE_ARCITECTURE_4","icon":"","description":"<img src=\"images/slate_arcitecture_4.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/slate_arcitecture_4.png","fullURL":"images/slate_arcitecture_4.html","pathToRoot":"..","attachments":["images/slate_arcitecture_4.html"],"createdTime":1710855209762,"modifiedTime":1710855209763,"sourceSize":248247,"sourcePath":"images/SLATE_ARCITECTURE_4.png","exportPath":"images/slate_arcitecture_4.html","showInTree":true,"treeOrder":304,"backlinks":["ue/slate-architecture.html"],"type":"attachment"},"images/slate_overview_1.html":{"title":"SLATE_OVERVIEW_1","icon":"","description":"<img src=\"images/slate_overview_1.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/slate_overview_1.png","fullURL":"images/slate_overview_1.html","pathToRoot":"..","attachments":["images/slate_overview_1.html"],"createdTime":1710855209763,"modifiedTime":1710855209763,"sourceSize":90359,"sourcePath":"images/SLATE_OVERVIEW_1.png","exportPath":"images/slate_overview_1.html","showInTree":true,"treeOrder":305,"backlinks":["ue/slate-overview.html"],"type":"attachment"},"images/slate_overview_2.html":{"title":"SLATE_OVERVIEW_2","icon":"","description":"<img src=\"images/slate_overview_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/slate_overview_2.png","fullURL":"images/slate_overview_2.html","pathToRoot":"..","attachments":["images/slate_overview_2.html"],"createdTime":1710855209763,"modifiedTime":1710855209763,"sourceSize":16778,"sourcePath":"images/SLATE_OVERVIEW_2.png","exportPath":"images/slate_overview_2.html","showInTree":true,"treeOrder":306,"backlinks":["ue/slate-overview.html"],"type":"attachment"},"images/sphere-indexing-screenshot.html":{"title":"sphere-indexing-screenshot","icon":"","description":"<img src=\"images/sphere-indexing-screenshot.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/sphere-indexing-screenshot.png","fullURL":"images/sphere-indexing-screenshot.html","pathToRoot":"..","attachments":["images/sphere-indexing-screenshot.html"],"createdTime":1743604604148,"modifiedTime":1743604604148,"sourceSize":62639,"sourcePath":"images/sphere-indexing-screenshot.png","exportPath":"images/sphere-indexing-screenshot.html","showInTree":true,"treeOrder":307,"backlinks":["qt/opengl/opengl-sphere-그리기.html"],"type":"attachment"},"images/subnetmask.html":{"title":"subnetmask","icon":"","description":"<img src=\"images/subnetmask.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/subnetmask.png","fullURL":"images/subnetmask.html","pathToRoot":"..","attachments":["images/subnetmask.html"],"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":22693,"sourcePath":"images/subnetmask.png","exportPath":"images/subnetmask.html","showInTree":true,"treeOrder":308,"backlinks":["network/08.-서브넷-마스크와-cidr.html"],"type":"attachment"},"images/subset_graph.html":{"title":"subset_graph","icon":"","description":"<img src=\"images/subset_graph.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/subset_graph.png","fullURL":"images/subset_graph.html","pathToRoot":"..","attachments":["images/subset_graph.html"],"createdTime":1719241549696,"modifiedTime":1719241549700,"sourceSize":1319039,"sourcePath":"images/subset_graph.png","exportPath":"images/subset_graph.html","showInTree":true,"treeOrder":309,"backlinks":["algorithm/leetcode/78.-subsets.html"],"type":"attachment"},"images/symbol_find_result.html":{"title":"symbol_find_result","icon":"","description":"<img src=\"images/symbol_find_result.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/symbol_find_result.png","fullURL":"images/symbol_find_result.html","pathToRoot":"..","attachments":["images/symbol_find_result.html"],"createdTime":1710855209756,"modifiedTime":1710855209757,"sourceSize":94053,"sourcePath":"images/symbol_find_result.png","exportPath":"images/symbol_find_result.html","showInTree":true,"treeOrder":310,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment"},"images/symbol_result.html":{"title":"symbol_result","icon":"","description":"<img src=\"images/symbol_result.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/symbol_result.png","fullURL":"images/symbol_result.html","pathToRoot":"..","attachments":["images/symbol_result.html"],"createdTime":1710855209757,"modifiedTime":1710855209757,"sourceSize":224111,"sourcePath":"images/symbol_result.png","exportPath":"images/symbol_result.html","showInTree":true,"treeOrder":311,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment"},"images/type_structure.html":{"title":"type_structure","icon":"","description":"<img src=\"images/type_structure.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/type_structure.png","fullURL":"images/type_structure.html","pathToRoot":"..","attachments":["images/type_structure.html"],"createdTime":1730808631697,"modifiedTime":1730808631697,"sourceSize":89283,"sourcePath":"images/type_structure.png","exportPath":"images/type_structure.html","showInTree":true,"treeOrder":312,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment"},"images/u2_soundtype.html":{"title":"u2_soundtype","icon":"","description":"<img src=\"images/u2_soundtype.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/u2_soundtype.png","fullURL":"images/u2_soundtype.html","pathToRoot":"..","attachments":["images/u2_soundtype.html"],"createdTime":1724679437333,"modifiedTime":1724679437334,"sourceSize":6442,"sourcePath":"images/u2_soundtype.png","exportPath":"images/u2_soundtype.html","showInTree":true,"treeOrder":313,"backlinks":["ue/sounds-개선.html"],"type":"attachment"},"images/use_vertex_attirbute_arrays.html":{"title":"use_vertex_attirbute_arrays","icon":"","description":"<img src=\"images/use_vertex_attirbute_arrays.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/use_vertex_attirbute_arrays.png","fullURL":"images/use_vertex_attirbute_arrays.html","pathToRoot":"..","attachments":["images/use_vertex_attirbute_arrays.html"],"createdTime":1730808631697,"modifiedTime":1730808631699,"sourceSize":913884,"sourcePath":"images/use_vertex_attirbute_arrays.png","exportPath":"images/use_vertex_attirbute_arrays.html","showInTree":true,"treeOrder":314,"backlinks":["graphics/opengl/02.응용/05.-shader-programming-코드-분석.html"],"type":"attachment"},"images/usermode_kernalmode.html":{"title":"usermode_kernalmode","icon":"","description":"<img src=\"images/usermode_kernalmode.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/usermode_kernalmode.png","fullURL":"images/usermode_kernalmode.html","pathToRoot":"..","attachments":["images/usermode_kernalmode.html"],"createdTime":1724571717944,"modifiedTime":1724571717953,"sourceSize":1937082,"sourcePath":"images/usermode_kernalmode.png","exportPath":"images/usermode_kernalmode.html","showInTree":true,"treeOrder":315,"backlinks":[],"type":"attachment"},"images/using_uniform.html":{"title":"using_uniform","icon":"","description":"<img src=\"images/using_uniform.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/using_uniform.png","fullURL":"images/using_uniform.html","pathToRoot":"..","attachments":["images/using_uniform.html"],"createdTime":1730808631700,"modifiedTime":1730808631703,"sourceSize":1221648,"sourcePath":"images/using_uniform.png","exportPath":"images/using_uniform.html","showInTree":true,"treeOrder":316,"backlinks":["graphics/opengl/02.응용/08.-uniform-variable.html"],"type":"attachment"},"images/var_error.html":{"title":"var_error","icon":"","description":"<img src=\"images/var_error.jpg\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/var_error.jpg","fullURL":"images/var_error.html","pathToRoot":"..","attachments":["images/var_error.html"],"createdTime":1724571717970,"modifiedTime":1724571717972,"sourceSize":232611,"sourcePath":"images/var_error.jpg","exportPath":"images/var_error.html","showInTree":true,"treeOrder":317,"backlinks":["ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html"],"type":"attachment"},"images/vertex_shader.html":{"title":"vertex_shader","icon":"","description":"<img src=\"images/vertex_shader.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/vertex_shader.png","fullURL":"images/vertex_shader.html","pathToRoot":"..","attachments":["images/vertex_shader.html"],"createdTime":1730808631703,"modifiedTime":1730808631704,"sourceSize":517973,"sourcePath":"images/vertex_shader.png","exportPath":"images/vertex_shader.html","showInTree":true,"treeOrder":318,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment"},"images/vertext_shader_parallel.html":{"title":"vertext_shader_parallel","icon":"","description":"<img src=\"images/vertext_shader_parallel.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/vertext_shader_parallel.png","fullURL":"images/vertext_shader_parallel.html","pathToRoot":"..","attachments":["images/vertext_shader_parallel.html"],"createdTime":1730808631704,"modifiedTime":1730808631706,"sourceSize":882522,"sourcePath":"images/vertext_shader_parallel.png","exportPath":"images/vertext_shader_parallel.html","showInTree":true,"treeOrder":319,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment"},"images/vtableoperation.html":{"title":"vtableoperation","icon":"","description":"<img src=\"images/vtableoperation.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/vtableoperation.png","fullURL":"images/vtableoperation.html","pathToRoot":"..","attachments":["images/vtableoperation.html"],"createdTime":1754545491069,"modifiedTime":1754545491071,"sourceSize":343938,"sourcePath":"images/vtableoperation.png","exportPath":"images/vtableoperation.html","showInTree":true,"treeOrder":320,"backlinks":["cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html"],"type":"attachment"},"images/wbp_ui_transition.html":{"title":"wbp_ui_transition","icon":"","description":"<img src=\"images/wbp_ui_transition.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/wbp_ui_transition.png","fullURL":"images/wbp_ui_transition.html","pathToRoot":"..","attachments":["images/wbp_ui_transition.html"],"createdTime":1724571717941,"modifiedTime":1724571717941,"sourceSize":57064,"sourcePath":"images/wbp_ui_transition.png","exportPath":"images/wbp_ui_transition.html","showInTree":true,"treeOrder":321,"backlinks":[],"type":"attachment"},"images/whoami.html":{"title":"whoami","icon":"","description":"<img src=\"images/whoami.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/whoami.png","fullURL":"images/whoami.html","pathToRoot":"..","attachments":["images/whoami.html"],"createdTime":1722511221529,"modifiedTime":1722511221529,"sourceSize":6297,"sourcePath":"images/whoami.png","exportPath":"images/whoami.html","showInTree":true,"treeOrder":322,"backlinks":["infra/jenkins-안드로이드-패키징.html"],"type":"attachment"},"infra/helix-core-workflow.html":{"title":"Helix Core Workflow","icon":"","description":"Update: 2024/12/18\n소개\nStream Depot 구조 이해하기\n일반적인 작업 흐름\n코드 리뷰 프로세스\n주의사항\n이 문서는 우리 팀의 Helix Core 작업 환경과 프로세스를 설명합니다. 개발팀과 아트팀이 효율적으로 협업할 수 있도록 설계되었습니다.우리는 Local Depot 대신 Stream Depot을 사용합니다. Stream Depot의 주요 장점은:\n브랜치 관리의 용이성\n변경사항의 명확한 추적\n팀 간 협업 효율성 향상\n자동화된 머지 충돌 감지 Mainline Stream: 제품의 안정된 버전을 포함하는 최상위 스트림\nDevelopment Stream: 활발한 개발이 이루어지는 주요 통합 스트림\nTask/Feature Stream 개별 개발자나 아티스트의 작업 공간\nDevelopment 스트림에서 분기\n특정 기능이나 작업을 위한 독립된 환경 Release Stream: 출시된 버전을 보관하는 스트림 작업 시작하기 Development 스트림에서 새로운 Task/Feature 스트림 생성\n작업할 스트림으로 전환 변경사항 제출 자신의 Task/Feature 스트림에는 자유롭게 submit 가능\nDevelopment 스트림으로의 머지는 코드 리뷰 필수 머지 프로세스 작업 완료 후 Development 스트림과 머지 진행\nSwarm을 통한 코드 리뷰 승인 필요\n승인 후 머지 진행 Swarm 설정이 필요한 부분:\n리뷰어 자동 할당 규칙 설정\n승인 필요 인원 수 설정\n머지 전 필수 리뷰 정책 설정\n리뷰 만료 기간 설정\n자동 알림 설정 스트림 접근 제한 Development와 Mainline 스트림에 직접 submit 금지\n반드시 머지 프로세스를 통해서만 변경사항 반영 코드 품질 관리 Mainline 스트림에는 검증된 코드만 허용\n모든 머지는 코드 리뷰 승인 필수 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"목차","level":2,"id":"목차_0"},{"heading":"소개","level":2,"id":"소개_0"},{"heading":"Stream Depot 구조 이해하기","level":2,"id":"Stream_Depot_구조_이해하기_0"},{"heading":"Stream 구조 설명","level":2,"id":"Stream_구조_설명_0"},{"heading":"일반적인 작업 흐름","level":2,"id":"일반적인_작업_흐름_0"},{"heading":"코드 리뷰 프로세스","level":2,"id":"코드_리뷰_프로세스_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"infra/helix-core-workflow.html","pathToRoot":"..","attachments":[],"createdTime":1734522365541,"modifiedTime":1735574042983,"sourceSize":2109,"sourcePath":"Infra/Helix Core Workflow.md","exportPath":"infra/helix-core-workflow.html","showInTree":true,"treeOrder":324,"backlinks":[],"type":"markdown"},"infra/helix-core,-helix-swarm-구성.html":{"title":"Helix core,  Helix Swarm 구성","icon":"","description":"\n저장소 설정\nsudo tee /etc/yum.repos.d/perforce.repo &lt;&lt; 'EOF'\n[perforce]\nname=Perforce\nbaseurl=https://package.perforce.com/yum/rhel/9/x86_64\nenabled=1\ngpgcheck=1\ngpgkey=https://package.perforce.com/perforce.pubkey\nEOF 공개키 등록\nsudo rpm --import https://package.perforce.com/perforce.pubkey 저장소 확인\n# 저장소가 제대로 등록되었는지 확인\ndnf repolist | grep perforce\n# 패키지 검색이 되는지 확인\ndnf search helix\n# 패키지목록 초기화 하고 다시 받기\nsudo dnf clean all\nsudo dnf makecache\nsudo dnf update Helix Core 서버 설치 (p4d) sudo dnf install helix-p4d p4d 초기 설정\nsudo /opt/perforce/sbin/configure-helix-p4d.sh\nexport P4CHARSET=utf8 # 텍스트 인코딩\nmaster가 config할 때 정한 이름이였던 거 같음 P4 설정 파일 경로: /etc/perforce/p4dctl.conf.d/master.conf P4 루트 디렉토리: /opt/perforce/servers/master/root 서버중지 - sudo systemctl stop p4d 또는 sudo -u perforce p4dctl stop master 서버 재시작 - sudo systemctl restart p4d 또는 sudo -u perforce p4dctl restart master 부팅 시 자동 시작 설정: sudo systemctl enable p4d aws인 경우 인바운드 추가해서 1666 포트 추가로 열기 Swram 필수 패키지 설치\nsudo dnf install httpd php php-xml php-mbstring php-json php-gd php-curl Apache 웹 서버 활성화\nsudo systemctl enable httpd\nsudo systemctl start httpd Swarm 설치\nsudo dnf install helix-swarm Swarm 초기설정\nsudo /opt/perforce/swarm/bin/configure-swarm.sh post installation 설정 (거의 꼭 해야함)\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://help.perforce.com/helix-core/helix-swarm/swarm/current/Content/Swarm/setup.post.html#Post-install_configuration_options\" target=\"_self\">https://help.perforce.com/helix-core/helix-swarm/swarm/current/Content/Swarm/setup.post.html#Post-install_configuration_options</a>p4 configure set filetype.bypasslock=1 #exclusive lock 핸들링\np4 configure show filetype.bypasslock\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"perforce helix core","level":3,"id":"perforce_helix_core_0"},{"heading":"Swarm","level":3,"id":"Swarm_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"infra/helix-core,-helix-swarm-구성.html","pathToRoot":"..","attachments":[],"createdTime":1734787474580,"modifiedTime":1737704717627,"sourceSize":2038,"sourcePath":"Infra/Helix core,  Helix Swarm 구성.md","exportPath":"infra/helix-core,-helix-swarm-구성.html","showInTree":true,"treeOrder":325,"backlinks":[],"type":"markdown"},"infra/jenkins-설치-및-구성.html":{"title":"Jenkins 설치 및 구성","icon":"","description":"자동화 시스템 구축\n젠킨스에서 Java 11은 2024.07.31까지 지원 Deprecated 될 예정\nOpenJDK 17로 구성 완료 sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:148) at java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:129) at java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297) at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:383)\nCaused: sun.security.validator.ValidatorException: PKIX path building failed at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:388) at java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:271) at java.base/sun.security.validator.Validator.validate(Validator.java:256) at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:230) at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:132) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1302)\nCaused: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:130) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:378) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:321) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:316) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1318) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.onConsumeCertificate(CertificateMessage.java:1195) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.consume(CertificateMessage.java:1138) at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:393) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:476) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:447) at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:201) at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:172) at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1506) at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1421) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:455) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:426) at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:586) at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:187) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect0(HttpURLConnection.java:2909) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect(HttpURLConnection.java:2818) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1929) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1599) at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:223) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1321)\nCaused: java.io.IOException: Failed to load https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi to C:\\ProgramData\\Jenkins\\.jenkins\\plugins\\mailer.jpi.tmp at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1332)\nCaused: java.io.IOException: Failed to download from https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi (redirected to: https://get.jenkins.io/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1366) at hudson.model.UpdateCenter$DownloadJob._run(UpdateCenter.java:1923) at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:2235) at hudson.model.UpdateCenter$DownloadJob.run(UpdateCenter.java:1897) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) at hudson.remoting.AtmostOneThreadExecutor$Worker.run(AtmostOneThreadExecutor.java:121) at java.base/java.lang.Thread.run(Thread.java:1583)\nsuncertpathbuilderexception unable to find valid certification path to requested target를 인터넷에 검색했을 때 -Https를 사용하는 웹사이트에 연결을 시도할 때 Java에서 신뢰하는 인증서 목록에 해당 웹사이트의 인증서가 존재하지 않아서 발생하는 문제라고 한다.그래서 예전에 전달받은 인증서를 jdk(jre)/lib/securites/cacert에 keytool 명령어를 이용해 현재 사용하는 자바인증서에 인증서를 넣었음.keytool -importcert -alias {alias name} -keystore \"C:\\Program Files\\Java\\jdk-21.0.2\\lib\\security\\cacerts\" -storepass changeit -file C:\\Users\\psyche95\\Desktop\\CERT\\{.cer}\nsuncertpathbuilderexception unable to find valid certification path to requested target는 해결 되었으나 아래의 문제가 발생java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty\n검색하니, openjdk에서 발생할 수 있다고 함 -&gt; oracle jdk의 cacert로 교체하면 된다고 해서 교체 -&gt; 같은 에러 반복 cacert 문제가 아님을 확인환경변수 JAVA_HOME 확인-&gt; java8 사용하고 있었음.\nJAVA_HOME java21로 변경이로써 플러그인 업데이트 가능하게 됨. + 배치파일 작성 후 빌드 가능그래도 계속 안된다면, java cacert에서 회사 사내 인증서 없애고 JAVA_HOME 설정 다시 할 것java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty at java.base/java.security.cert.PKIXParameters.setTrustAnchors(PKIXParameters.java:200) at java.base/java.security.cert.PKIXParameters.&lt;init&gt;(PKIXParameters.java:120) at java.base/java.security.cert.PKIXBuilderParameters.&lt;init&gt;(PKIXBuilderParameters.java:104) at java.base/sun.security.validator.PKIXValidator.&lt;init&gt;(PKIXValidator.java:94) Caused: java.lang.RuntimeException: Unexpected error\n해결한 줄 알았는데, 다시 발생해서 재설치 진행함.jdk 21은 젠킨스에 도입된 지 얼마 되지 않아서 jdk 17로 교체.sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target그냥 check certificate 하지 않는 게 정신건강에 이로울 거 같아서 skip-certificate-check 플러그인을 hpi로 받음. 그러고나서 C:\\ProgramData\\Jenkins.jenkins\\plugins에 직접 hpi를 넣고 설치 젠킨스 재시작이로써 해결 완료되었고 현재까지는 잘 작동함.Unreal Engine4로 작업을 하고 있는데, ugs를 사용하지 않아 개발자가 주기적으로 binary를 depot에 올려줘야 하는 상황 (perforce helix core 사용)아래 batch 파일을 통해 일정 시간에 컴파일하고 만들어진 binary를 submit 함.@echo off\nsetlocal enabledelayedexpansion set ENGINE_PATH=C:\\Users\\owner\\Perforce\\psyche95_GZ-PSYCHE9503_8014\\GolfzonMEngine\nset PROJECT_PATH=C:\\Users\\owner\\Perforce\\psyche95_GZ-PSYCHE9503_8014\\WaveM\\U2Client_Wave :: 접근 권한 설정\nicacls \"%ENGINE_PATH%\" /grant Everyone:(F)\nicacls \"%PROJECT_PATH%\" /grant Everyone:(F) :: 필요한 폴더와 파일 삭제\necho Deleting unnecessary files and folders...\nif exist \"%PROJECT_PATH%\\.vs\" rmdir /s /q \"%PROJECT_PATH%\\.vs\"\nif exist \"%PROJECT_PATH%\\DerivedDataCache\" rmdir /s /q \"%PROJECT_PATH%\\DerivedDataCache\"\nif exist \"%PROJECT_PATH%\\Intermediate\" rmdir /s /q \"%PROJECT_PATH%\\Intermediate\"\nif exist \"%PROJECT_PATH%\\Saved\" rmdir /s /q \"%PROJECT_PATH%\\Saved\"\nif exist \"%PROJECT_PATH%\\U2Client.sln\" del /f /q \"%PROJECT_PATH%\\U2Client.sln\" :: Unreal Engine을 이용해 비주얼 스튜디오 프로젝트 파일 생성\necho Generating Visual Studio project files...\n\"%ENGINE_PATH%\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe\" -projectfiles -project=\"%PROJECT_PATH%\\U2Client.uproject\" -game -progress\nif %errorlevel% neq 0 ( echo Failed to generate Visual Studio project files. curl -X POST -H \"Content-type: application/json\" --data \"{\\\"text\\\":\\\"Failed to generate Visual Studio project files\\\", \\\"channel\\\":\\\"#dev_build\\\"}\" \"https://hooks.slack.com/services/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\" exit /b %errorlevel%\n) :: 비주얼 스튜디오를 이용해 U2Client.sln 빌드\necho Building the U2Client.sln...\n\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\Common7\\IDE\\devenv.com\" \"%PROJECT_PATH%\\U2Client.sln\" /Build \"Development Editor|Win64\" /Project \"U2Client\"\necho Errorlevel after build: %errorlevel%\nif %errorlevel% neq 0 ( echo Build process failed, checking log... curl -X POST -H \"Content-type: application/json\" --data \"{\\\"text\\\":\\\"Build process failed\\\", \\\"channel\\\":\\\"#dev_build\\\"}\" \"https://hooks.slack.com/services/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\" exit /b %errorlevel%\n) :: 변경된 PDB 및 DLL 파일 검사 및 Perforce로 체크아웃\npushd \"%PROJECT_PATH%\\Binaries\\Win64\"\nset CHANGES_EXIST=\nfor %%f in (*.pdb *.dll) do ( :: 파일 접미사 체크 및 변경 검사 echo %%f | findstr /R /C:\".*-[0-9][0-9][0-9][0-9]\\.\" &gt; nul if errorlevel 1 ( :: 파일이 마지막으로 변경된 시간 가져오기 for /f \"tokens=2 delims==\" %%t in ('wmic datafile where name^=\"%%f\" get lastmodified /value') do set LASTMOD=%%t :: Perforce에 저장된 파일의 수정 시간 비교 p4 -u psyche95 fstat -T headTime %%f | findstr /C:\"headTime\" set HEADTIME=!headTime! if \"!LASTMOD:~0,14!\" neq \"!HEADTIME!\" ( set CHANGES_EXIST=true p4 -u psyche95 edit %%f ) )\n)\npopd :: 변경점이 있으면 제출하고, 없으면 되돌리기\nif defined CHANGES_EXIST ( echo Changes detected. Submitting to Perforce... p4 -u psyche95 submit -d \"automate submit\"\n) else ( echo No changes detected. Reverting changes... pushd \"%PROJECT_PATH%\\Binaries\\Win64\" for %%f in (*.pdb *.dll) do ( p4 -u psyche95 revert %%f ) popd\n) echo Finished: SUCCESS ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Jenkins 설치","level":2,"id":"Jenkins_설치_0"},{"heading":"설정 이슈 및 해결 과정","level":2,"id":"설정_이슈_및_해결_과정_0"},{"heading":"플러그인 다운로드, 업데이트 안됨","level":3,"id":"플러그인_다운로드,_업데이트_안됨_0"},{"heading":"sun.security.provider.certpath.SunCertPathBuilderException","level":4,"id":"sun.security.provider.certpath.SunCertPathBuilderException_0"},{"heading":"java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty","level":4,"id":"java.security.InvalidAlgorithmParameterException_the_trustAnchors_parameter_must_be_non-empty_0"},{"heading":"auto commit","level":4,"id":"auto_commit_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"infra/jenkins-설치-및-구성.html","pathToRoot":"..","attachments":[],"createdTime":1733121252270,"modifiedTime":1736945671713,"sourceSize":11293,"sourcePath":"Infra/Jenkins 설치 및 구성.md","exportPath":"infra/jenkins-설치-및-구성.html","showInTree":true,"treeOrder":326,"backlinks":[],"type":"markdown"},"infra/jenkins-안드로이드-패키징.html":{"title":"Jenkins 안드로이드 패키징","icon":"","description":"\nJenkins는 JAVA 11 지원 X -&gt; JDK 17\n@echo off\nsetlocal enabledelayedexpansion :: Java 11 Setting -\nset JAVA_HOME=C:\\Program Files\\Android\\Android Studio\\jre\nset PATH=%JAVA_HOME%\\bin;%PATH%\nset JAVA_EXE=\"%JAVA_HOME%\\bin\\java.exe\"\n:: Gradle 설정\nset GRADLE_USER_HOME=%USERPROFILE%\\.gradle_java11\n:: Java 옵션 설정\nset _JAVA_OPTIONS=-Djava.specification.version=11 :: 기본 경로 설정\nset ENGINE_PATH=D:\\Develop\\GolfzonMEngine\nset PROJECT_PATH=C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\nset PROJECT_NAME=U2Client\nset OUTPUT_DIR=C:\\Users\\psyche95\\Desktop\\Golfzon\\M_Packaging :: Android SDK 및 NDK 설정\nset ANDROID_HOME=C:\\Users\\psyche95\\AppData\\Local\\Android\\Sdk\nset ANDROID_NDK_PATH=%ANDROID_HOME%\\ndk\\25.2.9519653\nset NDKROOT=%ANDROID_NDK_PATH% :: 출력 폴더 설정\nfor /f \"tokens=2 delims==\" %%I in ('wmic os get localdatetime /value') do set TIMESTAMP=%%I\nset NEW_OUTPUT_DIR=%OUTPUT_DIR%\\Build_Android_%TIMESTAMP:~0,8%_%TIMESTAMP:~8,6% :: 필요한 디렉토리 생성\nif not exist \"%NEW_OUTPUT_DIR%\" mkdir \"%NEW_OUTPUT_DIR%\" :: 프로젝트 파일 확인\nif not exist \"%PROJECT_PATH%\\%PROJECT_NAME%.uproject\" ( echo Error: Project file not found! exit /b 1\n) echo Starting Android packaging for %PROJECT_NAME%... :: Project Build\ncall \"%ENGINE_PATH%\\Engine\\Build\\BatchFiles\\RunUAT.bat\" ^\nBuildCookRun ^\n-nocompileeditor ^\n-installed -nop4 ^\n-project=%PROJECT_PATH%\\%PROJECT_NAME%.uproject ^\n-cook -stage -archive -archivedirectory=\"%NEW_OUTPUT_DIR%\" ^\n-package ^\n-ue4exe=\"%ENGINE_PATH%\\Engine\\Binaries\\Win64\\UE4Editor-Cmd.exe\" ^\n-compressed ^\n-ddc=InstalledDerivedDataBackendGraph ^\n-pak ^\n-prereqs ^\n-targetplatform=Android -cookflavor=ASTC ^\n-build ^\n-CrashReporter ^\n-target=%PROJECT_NAME% ^\n-clientconfig=Development ^\n-utf8output ^\n-AndroidSDK=\"%ANDROID_HOME%\" ^\n-AndroidNDK=\"%NDKROOT%\" if %ERRORLEVEL% neq 0 ( echo Error: Build failed with exit code %ERRORLEVEL% exit /b %ERRORLEVEL%\n) echo Android packaging completed successfully.\necho Output directory: %NEW_OUTPUT_DIR%\nexit /b 0 -nocompileeditor: 에디터 컴파일을 건너뜀 -installed: 엔진 바이너리로 빌드 -nop4: Perforce 연동을 비활성화 -project: 프로젝트 파일의 경로를 지정 -cook: 콘텐츠 쿠킹을 수행 -stage: 패키징된 게임을 스테이징 디렉토리로 복사 -archive: 패키지된 게임을 아카이브 -archivedirectory: 아카이브 디렉토리를 지정 -package: 게임을 패키징 -ue4exe: 사용할 UE4 Editor 실행 파일의 경로를 지정 -compressed: 패키지를 압축 -ddc: 사용할 파생 데이터 캐시(DDC) 설정을 지정 DDC는 파생 데이터 캐시를 의미합니다. 이는 에셋 처리 결과를 저장하는 캐시 시스템입니다. 예를 들어, 텍스처의 압축 버전이나 머티리얼의 컴파일된 버전 등이 여기에 저장됩니다. DDC를 사용하면 에셋 처리 시간을 줄이고, 여러 사용자 간에 처리된 데이터를 공유할 수 있습니다. -pak: 콘텐츠를 PAK 파일로 패키징 -prereqs: 필요한 선행 요구사항을 포함 -targetplatform: 대상 플랫폼을 Android로 설정 -cookflavor: 쿠킹 설정을 ASTC(텍스처 압축 형식)로 지정 -build: 코드를 빌드 -CrashReporter: 크래시 리포터를 포함 -target: 빌드할 프로젝트 이름을 지정 -clientconfig: 클라이언트 구성을 Development or Shipping -utf8output: 출력을 UTF-8로 인코딩 -AndroidSDK: Android SDK 경로를 지정 -AndroidNDK: Android NDK 경로를 지정 Execution of commandlet took: 123.49 seconds LogShaderCompilers: Display: === FShaderJobCache stats === LogShaderCompilers: Display: Total job queries 0, among them cache hits 0 (0.00%) LogShaderCompilers: Display: Tracking 0 distinct input hashes that result in 0 distinct outputs (0.00%) LogShaderCompilers: Display: RAM used: 0.00 MB (0.00 GB) of 1638.40 MB (1.60 GB) budget. Usage: 0.00% LogShaderCompilers: Display: ================================================ LogShaderCompilers: Display: Shaders left to compile 0 LogShaderCompilers: Display: Shaders left to compile 0 OptickLog: Display: OptickPlugin UnLoaded! LogHttp: Display: cleaning up 0 outstanding Http requests. LogContentStreaming: Display: There are 1 unreleased StreamingManagers\nTook 140.1294547s to run UE4Editor-Cmd.exe, ExitCode=0\n********** COOK COMMAND COMPLETED **********\n********** BUILD COMMAND STARTED **********\nRunning: D:\\Develop\\GolfzonMEngine\\Engine\\Binaries\\DotNET\\UnrealBuildTool.exe U2Client Android Development -Project=C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\U2Client.uproject -Manifest=C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Build\\Manifest.xml -nobuilduht -NoHotReload -xgeexport C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\U2Client.uproject -NoUBTMakefiles -remoteini=\"C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\" -skipdeploy -log=\"C:\\Windows\\system32\\config\\systemprofile\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\UBT-U2Client-Android-Development.txt\" Engine Directory:D:\\Develop\\GolfzonMEngine\\Engine Project Directory:C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client Adjust SDK found in C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Plugins\\Adjust\\Source\\Adjust\\../ThirdParty/Android Engine Directory:D:\\Develop\\GolfzonMEngine\\Engine Project Directory:C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client Engine Directory:D:\\Develop\\GolfzonMEngine\\Engine Project Directory:C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client D:\\Develop\\GolfzonMEngine\\Engine\\Source\\Runtime\\Engine\\Engine.Build.cs: warning: Referenced directory 'D:\\Develop\\GolfzonMEngine\\Engine\\Source\\Launch\\Public' does not exist. PLATFORM_ANDROID_NDK_VERSION = 250300 NDK toolchain: r25c, NDK version: 33, GccVersion: 4.9, ClangVersion: 14.0.7 Parsing headers for U2Client Running UnrealHeaderTool \"C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\U2Client.uproject\" \"C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Build\\Android\\U2Client\\Development\\U2Client.uhtmanifest\" -LogCmds=\"loginit warning, logexit warning, logdatabase error\" -Unattended -WarningsAsErrors -abslog=\"C:\\Windows\\system32\\config\\systemprofile\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\UHT-U2Client-Android-Development.txt\" -installed LogInit: Display: Loading text-based GConfig.... Reflection code generated for U2Client in 3.4027725 seconds Compiling Native 64-bit code with NDK API 'android-33' Writing manifest to C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Build\\Manifest.xml XGEEXPORT: Exported 'D:\\Develop\\GolfzonMEngine\\Engine\\Intermediate\\Build\\UBTExport.000.xge.xml' Total execution time: 6.14 seconds\nTook 6.2589684s to run UnrealBuildTool.exe, ExitCode=0\nRunning: C:\\Program Files (x86)\\Incredibuild\\xgConsole.exe \"C:\\Windows\\system32\\config\\systemprofile\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\UAT_XGE.xml\" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread Fatal Error: File not found: C:\\Windows\\system32\\config\\systemprofile\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\UAT_XGE.xml\nTook 0.0520074s to run xgConsole.exe, ExitCode=3\nBUILD FAILED: Command failed (Result:3): C:\\Program Files (x86)\\Incredibuild\\xgConsole.exe \"C:\\Windows\\system32\\config\\systemprofile\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\UAT_XGE.xml\" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread. See logfile for details: 'xgConsole-2024.07.31-10.14.49.txt'\nAutomationTool exiting with ExitCode=1 (Error_Unknown)\nError: AutomationTool execution failed. Check log: C:\\Windows\\system32\\config\\systemprofile\\UnrealEngine\\BuildTemp\\UAT_Log.txt\nBuild step 'Execute Windows batch command' marked build as failure\nFinished: FAILURE\n인크레디빌드 사용시에 패키징 에러가 발생함.\n로그에서 실패한 이유가 File Not found인데 실제 경로에 가보니 해당 파일이 있었다.\n그래서 권한을 주는 등 다양한 방법을 적용해봤으나 계속해서 같은 이유로 실패했다.인크레디빌드 Agent를 끄고 패키징을 하면 Incredibuild 관련 부분을 통과할 수 있었다. 또는 RunUAT 실행 인자에 -noxge를 추가해도 Incredibuild가 꺼져서 관련 부분을 통과할 수 있었다. 이를 통해, Incredibuild 관련 이슈라 판단하고 incredibuild support에 질문함.<img alt=\"inc_support.png\" src=\"images/inc_support.png\" target=\"_self\">윈도우 젠킨스 설치시에 Windows Service에 등록된다.젠킨스를 이용해서 빌드를 할 때 Window Service에 등록된 사용자로 빌드를 하는데 기본 값이 SYSTEM 사용자다. 그래서 이를 바꿔줘야한다.WIN + R를 누르고 services.msc를 입력해서 서비스를 연다.Jenkins Service를 돌릴 윈도우 계정이 필요한데 회사 도메인을 이용한 사내아이디를 사용 해야했다.Jenkins - 속성 - 로그온 - 찾아보기\n아이디 검색 - 비밀번호 입력하고 젠킨스 중지C:\\Program Files\\Jenkins 로 이동해서 jenkins.xml을 수정한다. xml을 열어서 &lt;arguments&gt; 있는 곳에 다음 값을 추가한다. (젠킨스 서비스가 시작할 때 domain 아이디로 로그인 하겠다고 알려줘야함)&lt;arguments&gt;-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar \"C:\\Program Files\\Jenkins\\jenkins.war\" --httpPort=12000 --webroot=\"%ProgramData%\\Jenkins\\war --serviceLogonAccount={yourdomain\\yourid} --serviceLogonPassword={your_passward}\"&lt;/arguments&gt;\ndomain과 id를 하는 법은 cmd를 열고 whoami 입력<br><img alt=\"whoami.png\" src=\"images/whoami.png\" target=\"_self\">젠킨스 다시 시작하고 젠킨스 빌드시에 Incredibuild에서 에러나는 부분을 넘어갈 수 있다. ====2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================\nCopied file C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\app\\src\\main\\jniLibs\\arm64-v8a\\libUE4.so.\nCopied file C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\app\\src\\main\\assets\\main.obb.png.\n[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)\nMaking .apk with Gradle...\nTo honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).\nDaemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:\nBuild file 'Z:\\build.gradle' line: 14 * What went wrong:\nA problem occurred evaluating root project 'app'.\n&gt; Could not open dsl generic class cache for script 'Z:\\buildscriptAdditions.gradle' (C:\\Users\\psyche95\\.gradle\\caches\\7.5\\scripts\\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:\n&gt; Run with --stacktrace option to get the stack trace.\n&gt; Run with --info or --debug option to get more log output.\n&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)\n* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s\nERROR: cmd.exe failed with args /c \"C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\rungradle.bat\" :app:assembleDebug (see C:\\Users\\psyche95\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\Log.txt for full exception trace)\nAutomationTool exiting with ExitCode=1 (Error_Unknown)\nBUILD FAILED\nError: Build failed with exit code 1\nBuild step 'Execute Windows batch command' marked build as failure\nFinished: FAILURE\nDataview (inline field '===2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================\nCopied file C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\app\\src\\main\\jniLibs\\arm64-v8a\\libUE4.so.\nCopied file C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\app\\src\\main\\assets\\main.obb.png.\n[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)\nMaking .apk with Gradle...\nTo honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).\nDaemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:\nBuild file 'Z:\\build.gradle' line: 14 * What went wrong:\nA problem occurred evaluating root project 'app'.\n&gt; Could not open dsl generic class cache for script 'Z:\\buildscriptAdditions.gradle' (C:\\Users\\psyche95\\.gradle\\caches\\7.5\\scripts\\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:\n&gt; Run with --stacktrace option to get the stack trace.\n&gt; Run with --info or --debug option to get more log output.\n&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)\n* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s\nERROR: cmd.exe failed with args /c \"C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\rungradle.bat\" :app:assembleDebug (see C:\\Users\\psyche95\\AppData\\Roaming\\Unreal Engine\\AutomationTool\\Logs\\D+Develop+GolfzonMEngine\\Log.txt for full exception trace)\nAutomationTool exiting with ExitCode=1 (Error_Unknown)\nBUILD FAILED\nError: Build failed with exit code 1\nBuild step 'Execute Windows batch command' marked build as failure\nFinished: FAILURE'): Error: -- PARSING FAILED -------------------------------------------------- &gt; 1 | ===2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64=========================================== | ^ 2 | Copied file C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\app\\src\\main\\jniLibs\\arm64-v8a\\libUE4.so. 3 | Copied file C:\\Users\\psyche95\\Desktop\\jenkins_build\\GolfzonM\\U2Client\\Intermediate\\Android\\arm64\\gradle\\app\\src\\main\\assets\\main.obb.png. Expected one of the following: '(', 'null', boolean, date, duration, file link, list ('[1, 2, 3]'), negated field, number, object ('{ a: 1, b: 2 }'), string, variable\n젠킨스 설정시에 java 버전을 21로 올렸기 때문에 발생하는 에러다. 현재 gradle 7.5를 사용하고 있는데 gradle 7.5가 지원하는 상방은 java 18이다. 그래서 패키징시에 명시적으로 java 11 path를 넣고 패키징을 했다.\n:: batch 파일 상단 :: Java 11 Setting -\nset JAVA_HOME=C:\\Program Files\\Android\\Android Studio\\jre\nset PATH=%JAVA_HOME%\\bin;%PATH%\nset JAVA_EXE=\"%JAVA_HOME%\\bin\\java.exe\"\n:: Gradle 설정\nset GRADLE_USER_HOME=%USERPROFILE%\\.gradle_java11\n:: Java 옵션 설정\nset _JAVA_OPTIONS=-Djava.specification.version=11 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TL; DR","level":3,"id":"TL;_DR_0"},{"heading":"RunUAT 인자 역할","level":3,"id":"RunUAT_인자_역할_0"},{"heading":"Issue","level":3,"id":"Issue_0"},{"heading":"Incredibuild 사용시 패키징 실패","level":4,"id":"Incredibuild_사용시_패키징_실패_0"},{"heading":"Gradle 문제 (JAVA 버전)","level":3,"id":"Gradle_문제_(JAVA_버전)_0"}],"links":[],"author":"","coverImageURL":"images/inc_support.png","fullURL":"infra/jenkins-안드로이드-패키징.html","pathToRoot":"..","attachments":["images/inc_support.html","images/whoami.html"],"createdTime":1724571717956,"modifiedTime":1736945653302,"sourceSize":13318,"sourcePath":"Infra/Jenkins 안드로이드 패키징.md","exportPath":"infra/jenkins-안드로이드-패키징.html","showInTree":true,"treeOrder":327,"backlinks":[],"type":"markdown"},"infra/p4-extension,-p4-triggers.html":{"title":"P4 extension, P4 Triggers","icon":"","description":"trigger와 extension을 사용하면 Helix core에서 발생하는 동작과 바인딩해서 유저가 작생한 로직을 실행할 수 있음.\n특정 Perforce 명령어가 실행될 때 자동으로 실행되는 스크립트\n주로 간단한 검증이나 알림을 위해 사용\nshell, python, perl 등 사용\nform - out을 이용해서 디폴트 description 변경 Perforce 서버의 기능을 확장하는 플러그인 형태의 프로그램\nlua로 작성되며 Perforce API를 직접 사용할 수 있음\n복잡한 로직에 적합함\nswarm을 extension으로 사용했음.\n\b둘은 동시 사용 가능예시는 form-out 이벤트가 발생할 때 default description를 변경하는 것이다.\np4 trigger와 바인딩할 파일(shell, python 등등 가능) 을 p4 서버 내에 만든다.\n#!/bin/bash formfile=\"$1\" sed -i '/\\&lt;enter description\\&gt;/c\\r [기능출시예정일자][이름][커밋내용]' \"$formfile\" p4 서버 내에서 trigger와 바인딩 한다.\n$ p4 triggers\n# Triggers 아래에\n# $ {Trigger 이름} {Trigger 이벤트 종류} \"{file path}\" Triggers: form_template form-out change \"/opt/perforce/triggers/form_template.sh %formfile%\" 앞으로는 form-out change가 이벤트가 발생하면 자동으로 해당 스크립트가 실행된다.Extname을 가진 스켈레톤 폴더를 만든다.$ cd $P4ROOT/server.extension.dir\n$ p4 extension --sample Extname\nmanifest.json, main.lua 을 수정한다.manifest.json에 들어 가야할 필수 요소들이 있기 때문에 문서를 참고[Server Extension JSON manifest fields][https://help.perforce.com/helix-core/server-apps/extensions/current/Content/Extensions/extensionjson.html]main.lua 파일에 우리가 원하는 로직을 작성 해야한다. 어떤 Event Callback을 받아서 처리할건지는 문서를 참고{ \"manifest_version\": 1, \"api_version\": 20191, \"script_runtime\": { \"language\": \"lua\", \"version\": \"5.3\" }, \"key\": \"여기에_새로_생성한_UUID_입력\", \"name\": \"My Extension name\", \"namespace\": \"MyCompany\", \"version\": \"1.0\", \"version_name\": \"\", \"description\": \"My descrip\", \"compatible_products\": [ \"p4d\" ], \"default_locale\": \"en\", \"supported_local\" : [\"en\"], \"developer\": { \"name\": \"Your Company\", \"url\": \"https://your-company.com/\" }, \"license\": \"MIT\", \"license_body\": \"Copyright 2024, Your Company Name\"\n} [Server extension callbacks][https://help.perforce.com/helix-core/server-apps/extensions/current/Content/Extensions/extensioncallbacks.html#Server_extension_callbacks]<img alt=\"compared_ext_trigger.png\" src=\"images/compared_ext_trigger.png\" target=\"_self\">InstanceConfigEvent()에서 어떤 이벤트 callback을 정의하고, 그에 해당하는 함수를 작성 해야한다. function GlobalConfigFields() return {}\nend function GlobalConfigEvents() return {}\nend function InstanceConfigFields() return {}\nend function InstanceConfigEvents() return { [\"form-out\"] = \"change\", [\"form-in\"] = \"change\" }\nend function FormOut() return true\nend function FormIn() return true\nend\n# change-desc-template 폴더 안에 main.lua,manifest.json 존재\nsudo -u perforce p4 extension --package change-desc-template # sign없이 install\nsudo -u perforce p4 extension --install change-desc-template.p4-extension -y --allow-unsigned # Extuser를 super 권한이 있는 user로 변경, 전역설정\nsudo -u perforce p4 extension --configure Perforce::Change-Description-Template # Extuser를 super 권한이 있는 user로 변경, 전역설정 # super 권한이 있는 user로 변경, 인스턴스 설정\nsudo -u perforce p4 extension \\ --configure Perforce::Change-Description-Template \\ --name \"ChangeDescInstance\" \\ -y\n# 현재 돌고 있는 익스텐션 확인\nsudo -u perforce p4 extension --list --type=extensions # To list all instance configurations:\nsudo -u perforce p4 extension --list --type configs #configs (all), global, instance # extension 모두 지우기\nsudo -u perforce p4 extension --delete Perforce::Change-Description-Template -y # extension name 기반 instance 지우기\nsudo -u perforce p4 extension --delete Perforce::Change-Description-Template --name instance name -y ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"P4 Trigger","level":3,"id":"P4_Trigger_0"},{"heading":"P4 Extension","level":3,"id":"P4_Extension_0"},{"heading":"p4 trigger 적용법","level":4,"id":"p4_trigger_적용법_0"},{"heading":"p4 extension 적용법","level":4,"id":"p4_extension_적용법_0"}],"links":[],"author":"","coverImageURL":"images/compared_ext_trigger.png","fullURL":"infra/p4-extension,-p4-triggers.html","pathToRoot":"..","attachments":["images/compared_ext_trigger.html"],"createdTime":1737458659182,"modifiedTime":1737458659183,"sourceSize":4421,"sourcePath":"Infra/P4 extension, P4 Triggers.md","exportPath":"infra/p4-extension,-p4-triggers.html","showInTree":true,"treeOrder":328,"backlinks":[],"type":"markdown"},"infra/perforce-label.html":{"title":"Perforce Label","icon":"","description":"체리 픽을 위해서 changing list (정확히는 파일)에 label을 태그할 수 있다. label은 반드시 'super' 계정으로 만든다.Development에 submit -&gt; p4 trigger -&gt; 'auto_label.sync.sh' 실행\nscript path: /opt/perforce/triggers/auto_label_sync.sh\np4 login -&gt; chaging_list number로 description 조회\nRegex pattern으로 [yyyy.mm] 패턴 찾기\nlabel_name 생성: REL-yyyy.mm\nlabel_name으로 조회 및 없는 경우 생성\nRegex를 이용해서 변경 파일들 조회\np4 tag 실행\n#/opt/perforce/triggers/auto_label_sync.sh P4PASSWD=\"\" p4 login &lt;&lt;EOF\n$P4PASSWD\nEOF changelist_number=$1 desc=$(p4 -ztag describe -s \"$changelist_number\" | grep \"^... desc\" | sed 's/^... desc //') # [yyyy.mm] 형식을 추출하는 정규표현식 패턴\ndate_pattern=$(echo \"$desc\" | grep -o '\\[[0-9]\\{4\\}\\.[0-9]\\{2\\}\\]' | sed 's/\\[//;s/\\]//')\nlabel_name=\"REL-$date_pattern\" # Label이 있는지 체크\nlabel_exists=$(p4 labels | grep \"^$label_name\") # 만약 Label이 없다면, 만들어주기\nif [ -z \"$label_exists\" ]; then p4 label -i &lt;&lt; EOF\nLabel: $label_name\nOwner: super\nDescription: auto $label_name description\nOptions: unlocked\nView: //reltest/dev/...\nEOF\nfi files=$(p4 -ztag describe -s \"$changelist_number\" | grep \"^... depotFile[0-9]* \" | sed 's/^... depotFile[0-9]* //' | sed \"s|$|@$changelist_number|\" | tr '\\n' ' ')\np4 tag -l \"$label_name\" $files p4 label - 모든 레이블 조회\np4 files {label_name} - label과 파일 연관 관계 조회. p4 tag -d -l {label_name} {depot_path} - label과 파일 연관 관계 끊기\np4 label -d {label_name} - label 삭제\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"label tagging 로직","level":4,"id":"label_tagging_로직_0"},{"heading":"명령어","level":4,"id":"명령어_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"infra/perforce-label.html","pathToRoot":"..","attachments":[],"createdTime":1739188974319,"modifiedTime":1739188974319,"sourceSize":1695,"sourcePath":"Infra/Perforce Label.md","exportPath":"infra/perforce-label.html","showInTree":true,"treeOrder":329,"backlinks":[],"type":"markdown"},"infra/perforce-명령어.html":{"title":"Perforce 명령어","icon":"","description":"# Open command Windows here 선택 후\np4 changes -m1 \"./...#have\"\np4 set P4IGNORE=.p4ignore p4 depots # 현재 존재하는 depot 확인\np4 depot -t stream {streamdepotname}\np4 stream -t mainline //mystream/main #mainline 설정\np4 stream -t development -P //mystream/main //mystream/dev #development 설정 -t development: 스트림의 타입을 'development'로 지정. 이는 이 스트림이 개발 작업을 위한 것. -P //mystream/main: 부모 스트림을 지정. //mystream/main은 부모 스트림의 전체 경로.\n//mystream/dev: 생성하려는 새 스트림의 전체 경로\np4 streams -a //{Depot_name}/...\n#development 스트림 강제 삭제\np4 stream -F -d //{Depot_name}/develop #\bdevelop 스트림의 파일 삭제\np4 stream --obliterate -y //{Depot_name}/develop\np4 obliterate -y //{Depot_name}/...\np4 depot -f -d {Depot_name}\np4 edit -t +w -c {changing_list_number} ...\np4 user -f {username} # 아이디 생성\np4 passwd {username} # 비밀번호 설정\np4 users\n# 1. 해당 사용자의 클라이언트 워크스페이스 삭제\np4 client -d username-workspace # 2. 그 다음 사용자 삭제\np4 user -d username # 3. 삭제가 제대로 되었는지 확인\np4 users | grep username\n$ sudo -u perforce p4dctl restart master\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"명령어","level":2,"id":"명령어_0"},{"heading":"base revision 체크하는 방법","level":3,"id":"base_revision_체크하는_방법_0"},{"heading":"ignore 적용","level":3,"id":"ignore_적용_0"},{"heading":"depot 조회","level":3,"id":"depot_조회_0"},{"heading":"stream depot 생성","level":3,"id":"stream_depot_생성_0"},{"heading":"stream 설정","level":3,"id":"stream_설정_0"},{"heading":"stream 확인","level":3,"id":"stream_확인_0"},{"heading":"stream 삭제","level":3,"id":"stream_삭제_0"},{"heading":"local depot 삭제","level":3,"id":"local_depot_삭제_0"},{"heading":"쓰기 권한으로 변경","level":3,"id":"쓰기_권한으로_변경_0"},{"heading":"유저 생성","level":3,"id":"유저_생성_0"},{"heading":"모든 유저 조회","level":3,"id":"모든_유저_조회_0"},{"heading":"유저 삭제","level":3,"id":"유저_삭제_0"},{"heading":"서버 재시작","level":3,"id":"서버_재시작_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"infra/perforce-명령어.html","pathToRoot":"..","attachments":[],"createdTime":1735918424722,"modifiedTime":1737704466311,"sourceSize":1696,"sourcePath":"Infra/Perforce 명령어.md","exportPath":"infra/perforce-명령어.html","showInTree":true,"treeOrder":330,"backlinks":[],"type":"markdown"},"infra/swarm-teams.html":{"title":"Swarm Teams","icon":"","description":"Swarm에 커스텀 모듈을 만들어야 한다.$SWARM_ROOT config\n└──custom.modules.config.php module\n└── Teams ├── Module.php ├── config │ └── module.config.php └── src └── Listener └── TeamsActivityListener.php custom.modules.config.php 클래스를 자동 로드하고 어떤 사용자 정의 모듈을 실행해야 하는지 확인 module.config.php Swarm이 모듈을 인식하도록 하는 설정 파일\nPHP 배열 형태로 이벤트 리스너 바인딩, 서비스 등록 Module.php module.config.php를 불러오는 파일.\nnamespace 설정해야함\ngetConfig()를 구현해야함 // custom.modules.config.php\n&lt;?php\n\\Laminas\\Loader\\AutoloaderFactory::factory( array( 'Laminas\\Loader\\StandardAutoloader' =&gt; array( 'namespaces' =&gt; array( 'Teams' =&gt; BASE_PATH . '/module/Teams/src', ) ) )\n);\nreturn [ 'Teams'\n];\n// Module.php\n&lt;?php\n/** * Perforce Swarm Teams Module * * @author psyche95 */ namespace Teams; class Module\n{ public function getConfig() { return include __DIR__ . '/config/module.config.php'; }\n} // module.config.php\n&lt;?php\n/** * Perforce Swarm Teams Module * * @author psyche95 */ $listeners = [Teams\\Listener\\TeamsActivityListener::class]; return [ 'listeners' =&gt; $listeners, 'service_manager' =&gt;[ 'factories' =&gt; array_fill_keys( $listeners, Events\\Listener\\ListenerFactory::class ) ], Events\\Listener\\ListenerFactory::EVENT_LISTENER_CONFIG =&gt; [ Events\\Listener\\ListenerFactory::ALL =&gt; [ Teams\\Listener\\TeamsActivityListener::class =&gt; [ [ Events\\Listener\\ListenerFactory::PRIORITY =&gt; Events\\Listener\\ListenerFactory::HANDLE_MAIL_PRIORITY + 1, Events\\Listener\\ListenerFactory::CALLBACK =&gt; 'handleEvent', // callback 함수 등록 Events\\Listener\\ListenerFactory::MANAGER_CONTEXT =&gt; 'queue' // custom module 사용 ] ] ], ], 'teams' =&gt; [ 'swarm_host' =&gt; '', 'teams_webhook' =&gt; '', 'email' =&gt; '', 'id' =&gt; '', ]\n]; Events\\Listener\\ListenerFactory::CALLBACK =&gt; 'handleEvent' : callback 함수 등록 Events\\Listener\\ListenerFactory::MANAGER_CONTEXT =&gt; 'queue': custom module 사용 'teams' =&gt; [] : src에서 멤버 변수로 사용할 hashmap custom.module.config.php에서 지정한 BASE_PATH에 로직을 작성할 소스파일을 생성하고 구현한다.\n// src/Listener/TeamsActivityLister.php\n&lt;?php\n/** * Perforce Swarm Teams Module * * @author psyche95\n*/ namespace Teams\\Listener; use Events\\Listener\\AbstractEventListener;\nuse Reviews\\Model\\Review;\nuse Comments\\Model\\Comment;\nuse Laminas\\EventManager\\Event;\nuse Laminas\\Http\\Client;\nuse Laminas\\Http\\Request; class TeamsActivityListener extends AbstractEventListener\n{ public function handleEvent(Event $event) { $activity = $event-&gt;getParam('activity'); if (!$activity) { return; } $logger = $this-&gt;services-&gt;get('logger'); $config = $this-&gt;services-&gt;get('config'); $p4Admin = $this-&gt;services-&gt;get('p4_admin'); // Host address of Swarm for link back URLs $host = $this-&gt;services-&gt;get('ViewHelperManager')-&gt;get('qualifiedUrl'); $logger-&gt;info(\"Teams: event / id =&gt; \" . $event-&gt;getName() . \" / \" . $event-&gt;getParam('id')); // taken from mail module, this doesn't seem to work $data = (array) $event-&gt;getParam('data') + array('quiet' =&gt; null); $quiet = $event-&gt;getParam('quiet', $data['quiet']); if ($quiet === true) { $logger-&gt;info(\"Teams: event is silent(notifications are being batched), returning.\"); return; } // it's better not to tag user involved in activity, only review author //$user = $this-&gt;tagUser($config, $activity-&gt;get('user')); $user = $activity-&gt;get('user'); $action = $activity-&gt;get('action'); $target = $activity-&gt;get('target'); $link = $activity-&gt;get('link'); $projects = $activity-&gt;get('projects'); $logger-&gt;err(\"Projects =&gt; \" . json_encode($projects)); if (count($link) &gt; 0) { if (count($link) &gt; 1) { $link = $host($link[0], $link[1]); } else { $link = $host($link[0]); } } $eventString = $user . \" \" . $action . \" \" . $target; $linkMessage = $link; $linkMessage = str_replace('localhost', $config['teams']['swarm_host'], $linkMessage); $reviewId = -1; switch($event-&gt;getName()) { case \"task.comment.batch\": if (preg_match('/^reviews\\/(\\d+)$/', $event-&gt;getParam('id'), $matches)) { $reviewId = $matches[1]; $eventString = \"Comments have been made on review \" . $reviewId . \" =&gt; \" . $host('review', array('review' =&gt; $reviewId)); } break; case \"task.review\": $reviewId = $event-&gt;getParam('id'); $eventData = $event-&gt;getParam('data'); if (isset($eventData['isAdd']) &amp;&amp; $eventData['isAdd']) { //new review $reviewId = 0; } $logger-&gt;info(\"Teams: event data =&gt; \" . json_encode($eventData)); break; case \"task.comment\": try { $comment = Comment::fetch($event-&gt;getParam('id'), $p4Admin); $topic = $comment-&gt;get('topic'); if (preg_match('/^reviews\\/(\\d+)$/', $topic, $matches)) { $reviewId = $matches[1]; } } catch (\\Exception $e) { $logger-&gt;err(\"Teams: error when fetching comment : \" . $e-&gt;getMessage()); } //don't treat single comments, wait for the comment.batch return; break; default: $logger-&gt;info(\"Teams: event not treated \" . $eventString); return; } $notify = \"\"; if ($reviewId &gt; 0) { try { $review = Review::fetch($reviewId, $p4Admin); $reviewAuthor = $review-&gt;get('author'); } catch (\\Exception $e) { $logger-&gt;err(\"Teams: error when fetching review : \" . $e-&gt;getMessage()); } } else if ($reviewId == 0) { //notify everybody $notify = '@everyone '; } $eventString = \"Hey \" . $notify . \"! \" . $eventString; $logger-&gt;info(\"Teams: \" . $eventString); $leadid = \"\"; $leadname = \"\"; $projname = \"\"; if (!empty($projects)) { foreach ($projects as $key =&gt; $projectArray) { switch ($key) { case \"\": break 2; case \"\": break 2; } } } // URL to POST messages to Teams $teamsUrl = $config['teams']['teams_webhook']; $this-&gt;postTeams($teamsUrl, $eventString, $leadid, $leadname, $projname, $linkMessage); $logger-&gt;info(\"Teams: handleEvent end.\"); } private function postTeams($url, $msg, $leadid, $leadname, $projname, $linkMessage) { $logger = $this-&gt;services-&gt;get('logger'); $config = $this-&gt;services-&gt;get('config'); $team_leader_id = $config['teams']['']; $team_leader_name = $config['teams']['']; try { $messageData = [ 'type' =&gt; 'message', 'attachments' =&gt; [ [ 'contentType' =&gt; 'application/vnd.microsoft.card.adaptive', 'content' =&gt; [ 'width' =&gt; 'Full', 'type' =&gt; 'AdaptiveCard', 'body' =&gt; [ [ 'type' =&gt; 'TextBlock', 'size' =&gt; 'Medium', 'weight' =&gt; 'Bolder', 'text' =&gt; $projname . ' Perforce Swarm Notification' ], [ 'type' =&gt; 'TextBlock', 'text' =&gt; '&lt;at&gt;' . $team_leader_name . '&lt;/at&gt; &lt;at&gt;' . $leadname . '&lt;/at&gt;' ], [ 'type' =&gt; 'TextBlock', 'text' =&gt; $msg ], [ 'type' =&gt; 'ActionSet', 'actions' =&gt; [ [ 'type' =&gt; 'Action.OpenUrl', 'title' =&gt; 'Go to Swarm', 'url' =&gt; $linkMessage ] ] ] ], '$schema' =&gt; 'http://adaptivecards.io/schemas/adaptive-card.json', 'version' =&gt; '1.0', 'msteams' =&gt; [ 'entities' =&gt; [ [ 'type' =&gt; 'mention', 'text' =&gt; '&lt;at&gt;' . $team_leader_name . '&lt;/at&gt;', 'mentioned' =&gt; [ 'id' =&gt; $team_leader_id, 'name' =&gt; $team_leader_name ] ], [ 'type' =&gt; 'mention', 'text' =&gt; '&lt;at&gt;' . $leadname . '&lt;/at&gt;', 'mentioned' =&gt; [ 'id' =&gt; $leadid, 'name' =&gt; $leadname ] ] ] ] ] ] ] ]; $client = new Client(); $client-&gt;setUri($url); $client-&gt;setMethod(Request::METHOD_POST); $client-&gt;setRawBody(json_encode($messageData)); $client-&gt;setHeaders(['Content-Type' =&gt; 'application/json']); $response = $client-&gt;send(); if (!$response-&gt;isSuccess()) { $logger-&gt;err(\"Teams: Failed to send message. Status: \" . $response-&gt;getStatusCode()); } } catch (\\Exception $e) { $logger-&gt;err(\"Teams: Error sending message: \" . $e-&gt;getMessage()); } }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"infra/swarm-teams.html","pathToRoot":"..","attachments":[],"createdTime":1737458659183,"modifiedTime":1737458659183,"sourceSize":9378,"sourcePath":"Infra/Swarm Teams.md","exportPath":"infra/swarm-teams.html","showInTree":true,"treeOrder":331,"backlinks":[],"type":"markdown"},"interview_practice/c++.html":{"title":"C++","icon":"","description":"표준을 준수해서 크로스플랫폼 호환성 확보하기 위해서 Clang++으로 변경했다.\nDWORD, BOOL과 같은 VC++ 타입들을 제거하고 표준으로 변경했다. DWORD -&gt; unsigned long, BOOL -&gt; int\n파일 IO ReadFile, WriteFile -&gt; filesystem, fstream 사용\nmutex -&gt; recursive_mutex\nVC++ 확장 제거\n// MSVC 확장\n__max(a, b)\n__min(a, b) // 표준 C++ 대안\nstd::max(a, b)\nstd::min(a, b) new / delete -&gt; shared_ptr\nA클래스가 B, C, D, E 클래스를 프로퍼티로 가지고 있어서 의존함. B, C, D,E 들도 서로 각각 참조 관계를 이루고 있다. new - delete를 사용한다면 의존성이 있는 순서대로 해제해야한다. shared_ptr을 이용하면 순서와 관계 없이 메모리가 안전하게 관리되어서 이용하게 되었다.\n스마트포인터가 쓰여야 할 때는 언제인가\n헤비 리소스라서 복사를 금지하고 싶을 때 unique_ptr을 사용하고, 런타임에 파생 클래스 인스턴스를 가리켜야 할 때 객체 슬라이싱 문제를 해결하기 위해 스마트 포인터를 사용한다. 또 쓰레드 프로그래밍에서 비동기로 큰 데이터를 넘겨줄 때와 같이 여러 객체가 동일 리소스를 생명주기 끝까지 참조해야 할 때 shared_ptr을 사용한다.\ntemplate 코드\n파일 입출력에 LoadType, LoadValue 2개씩 n개의 타입들이 있다. 그러면 코드 확장이 불편하고 수정사항을 각각 반영해야한다. 그래서 템플릿을 사용했다. 템플릿을 이용하면 코드 중복제거, 유지보수성 향상, 타입 안전성, 일관된 인터페이스에서 이점을 가질 수 있다. 즉 코드 감소, 유지보수 부담이 감소한다. 그리고 명시적 인스턴스화를 사용해서 중복 링크 문제를 해결하고, 특수화를 이용해서 특별한 로직 구성한다. 만약 특수화가 아니면 일반적인 템플릿 코드 적용된다.C / C++은 스택과 힙 영역 할당에 자유가 있다. 데이터가 큰 객체들을 모두 스택에 올리면 스택오버플로우 위험이 있다. 이때 포인터를 이용해서 동적을 할당을 해서 힙에 올리면 된다. 하지만 현대 C++ STL 도입 후에는 STL 컨테이너를 이용하는 것이 낫다. STL 컨테이너는 값 타입이지만 내부적으로는 메모리를 힙으로 관리하기 때문이다. 또한 함수를 통과 시킬 때 파라미터로 call by reference를 이용해야하는 경우에도 참조 타입으로 사용하면 되어서 포인터를 사용할 여지가 줄어든다. 다만 포인터를 사용해야하는 경우도 있다.\n소유권이 명확하고 리소스가 매우 큰 데이터인 경우\n데이터가 복사·이동 자체가 비싸거나 금지(non-copyable)된 경우와 복사할 필요 없이 한 번만 넘겨주고 소멸 시 자동 해제하고 싶을 때 std::unique_ptr&lt;T&gt;를 사용한다.\n다형성 관리 측면 - 런타임에서 파생 클래스를 기반 클래스로 다뤄야할 경우\n포인터를 사용하지 않고 값으로 처리하면 객체 슬라이싱 문제가 발생한다. std::vector&lt;Base&gt;처럼 값 컨테이너에 넣으면 슬라이싱 되므로 포인터로 보관해야한다.class Scene { std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes_; public: void addShape(std::unique_ptr&lt;Shape&gt; s) { shapes_.push_back(std::move(s)); } }; 공유 소유(Shared Ownership)\n여러 객체가 동일 리소스를 생명주기 끝까지 참조해야 할 때 포인터를 사용한다. 다만 소유권을 고려해야 하므로 보통 shared_ptr을 사용한다. 주로 이벤트 디스패쳐, 캐시, 브로드캐스트 구조에서 사용된다. 동시성 프로그래밍에서 에서 콜백 함수로 데이터를 던져줄 때 데이터 크기가 크다면 shared_ptr로 주는 경우가 많다.\n비소유 관찰자\n소유권이 없고 관찰(view)만 할 수 있을 때 관찰은 할 수 있지만 소멸 책임은 외부에 있는 경우에 원시 포인터나 참조자를 사용한다.\n책임 분리 패턴\n책임 분리패턴이란 PImpl(Pointer to Implementation) 패턴은 C++에서 인터페이스와 구현 세부사항을 완전히 분리해, 컴파일 의존성과 바이너리 호환성(ABI 안정성)을 확보하기 위해 널리 쓰이는 기법이다. 이때 전방선언을 하고 이 타입을 포인터로 가지고 있다.책임 분리 패턴을 사용하면 좋은 것이 헤더-소스 의존성 최소화를 할 수 있고, 클래스 내부 구현이 헤더에 드러내지 않아 구현 변경시 헤더가 바뀌지 않는다. 그래서 코드를 재컴파일할 필요가 줄어든다.코드 예시// Widget.h\n#pragma once\n#include &lt;memory&gt; class Widget {\npublic: Widget(); ~Widget(); void doSomething(); // 복사·이동 생성자/대입 연산자도 필요 시 선언 private: struct Impl; // 전방 선언 std::unique_ptr&lt;Impl&gt; pImpl; // 구현체 소유 포인터\n}; // Widget.cpp\n#include \"Widget.h\"\n#include &lt;iostream&gt; // Impl 정의\nstruct Widget::Impl { int data; void helper() { std::cout &lt;&lt; \"helper: \" &lt;&lt; data &lt;&lt; \"\\n\"; }\n}; Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()) { pImpl-&gt;data = 42;\n} Widget::~Widget() = default; // unique_ptr가 Impl 파괴 void Widget::doSomething() { // 실제 로직은 Impl이 담당 pImpl-&gt;helper();\n} // (필요하면) 복사·이동 연산자 구현\nWidget::Widget(const Widget&amp; other) : pImpl(std::make_unique&lt;Impl&gt;(*other.pImpl)) {} Widget&amp; Widget::operator=(const Widget&amp; other) { if (this != &amp;other) { *pImpl = *other.pImpl; } return *this;\n} Widget::Widget(Widget&amp;&amp;) noexcept = default;\nWidget&amp; Widget::operator=(Widget&amp;&amp;) noexcept = default;\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Q. VC++에서 Clang++으로 변경한 이유","level":3,"id":"Q._VC++에서_Clang++으로_변경한_이유_0"},{"heading":"Q. Legacy C / C++에서 Modern C++로 리팩토링 할 때 무엇을 했는지","level":3,"id":"Q._Legacy_C_/_C++에서_Modern_C++로_리팩토링_할_때_무엇을_했는지_0"},{"heading":"Q. 현대 C++에서 포인터를 사용 해야하는 경우","level":3,"id":"Q._현대_C++에서_포인터를_사용_해야하는_경우_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"interview_practice/c++.html","pathToRoot":"..","attachments":[],"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":6059,"sourcePath":"Interview_practice/C++.md","exportPath":"interview_practice/c++.html","showInTree":true,"treeOrder":333,"backlinks":[],"type":"markdown"},"interview_practice/ios-(1).html":{"title":"iOS (1)","icon":"","description":"(a) iOS 앱의 라이프사이클 상태들(Not Running, Inactive, Active, Background, Suspended)을 설명하고, 각 상태에서 주의해야 할 점을 말해주세요.(b) 앱이 백그라운드로 전환될 때 시스템이 자동으로 정지시키는 것들이 있는데, 어떤 것들이 있고 이를 어떻게 대응해야 하나요?(c) 앱이 백그라운드/포그라운드 전환될 때 Observable 스트림 관리에서 주의할 점이 있나요? (a) iOS 앱 라이프사이클 상태 Not Running 앱이 아예 실행되지 않은 상태\n메모리에 로드되지 않음 Inactive 앱이 포그라운드에 있지만 이벤트를 받지 않음\n전화가 오거나, Control Center 열 때 잠깐 거치는 상태\n주의점: 애니메이션이나 타이머 일시정지 Active 앱이 포그라운드에서 정상 실행 중\n사용자 이벤트를 받을 수 있는 상태 Background 앱이 백그라운드에서 실행 중\n제한된 시간(보통 30초)만 코드 실행 가능\n주의점: UI 업데이트 금지 Suspended 백그라운드에 있지만 코드 실행 안 함\n메모리는 유지되지만 CPU 사용 안 함\n주의점: 언제든 메모리에서 제거될 수 있음 (b) 백그라운드에서 자동 정지되는 것들\n타이머\n애니메이션\n네트워크 요청 (일부)\n(c) 스트림 관리하기\n백그라운드/포그라운드 전환 UI, 애니메이션, 주기적으로 실행하는 것들 (폴링) 중지, 재시작\n포그라운드 전환시 데이터 새로고침하기 (사용자 경험 up)\n타이머 pause / resume\nsizeThatFits()은 필요한 경우에 셀의 적절한 크기를 리턴하는 함수이다. flex.layout(mode: .adjustHeight) 에서 높이만 계산하고 TableView에 적절한 높이를 제공한다.그런 다음에 layoutSubviews()에서는 실제 서브뷰들을 배치한다.Q. sizeThatFits()에서 pinLayout을 이용해서 고정하는 이유너비를 고정해야 FlexLayout이 정확한 높이를 계산하기 때문이다. // 예시: 긴 텍스트가 있는 라벨\nnameLabel.text = \"아주 긴 이름이 들어가서 여러 줄로 표시될 수 있는 텍스트\"\nnameLabel.numberOfLines = 0\n이 경우에 Label이 몇 줄로 표시 될 지 모르기 때문에 정확한 높이 계산이 불가능하기 때문이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Q.","level":3,"id":"Q._0"},{"heading":"Q. sizeThatFits() , layoutSubviews()에서 작성한 flex layout 코드는 각각 어떤 역할을 하나?","level":3,"id":"Q._sizeThatFits()_,_layoutSubviews()에서_작성한_flex_layout_코드는_각각_어떤_역할을_하나?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"interview_practice/ios-(1).html","pathToRoot":"..","attachments":[],"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":2521,"sourcePath":"Interview_practice/iOS (1).md","exportPath":"interview_practice/ios-(1).html","showInTree":true,"treeOrder":334,"backlinks":[],"type":"markdown"},"interview_practice/platform-sdk-(1).html":{"title":"Platform SDK (1)","icon":"","description":"언리얼엔진에서 네이티브 코드와 설정을 통합하기 위한 XML 스크립트임. 주로 Android, iOS에서 사용되며 빌드시에 플랫폼별 자동적용 됨.역할은\n네이티브 라이브러리 통합 (안드로이드 : AAR, iOS: Framework)\n플랫폼 설정 안드로이드 권한, proguard 설정 등\niOS info.plist key-value 설정 구글 로그인으로 플로우\n클라이언트는 구글 로그인 창으로 리다이렉트\n유저는 로그인하고 인가서버는 클라이언트에게 인가코드를 넘겨줌\n클라이언트는 백엔드에게 인가코드를 넘겨준다.\n백엔드는 클라이언트에게 받은 인가코드로 구글 인가서버에서 검증\n백엔드는 구글 인가서버로부터 액세스 토큰을 발급받음.\n백엔드는 이 구글 엑세스 토큰으로 구글 리소스 서버에 접속할 수 있음\n백엔드는 클라이언트에게 엑세스 토큰을 넘겨줌 (이 액세스 토큰은 구글 엑세스 토큰이 보통 아니고 자체 백엔드 엑세스 토큰임) 앱스토어 커넥트에서 상품 등록 (product id, 소모성, 갱신형 etc...) product id로 상품 정보 요청 사용자 결제 요청 Apple 결제 처리 및 영수증 생성 결제 결과 처리 클라이언트는 기본적인 영수증 검증을 하기 영수증 여부 검사 (데이터 존재 유무)\n앱 무결성 (앱 번들 아이디를 확인한다든지 등.)\n거래 정보 기본 확인 (transaction id, prouduct id) 거래 완료 처리 (성공이든, 실패든 일단 transaction은 완료 처리 해야함) 거래 완료 처리를 안하면 계속 pending 상태로 남아 있게됨. 그러면 중복 결제 가능성 있음\n사용자는 결제를 완료 했는데 결제 프로세스가 실행된다면 유저경험이 매우 떨어진다!! 백엔드로 영수증 보냄 (영수증 검증은 백엔드에서 진행하길 적극 권장) 구글 결제 서비스 연결 (Start Connection)\n결제 서비스 연결 확인\n상품 조회 - Qurey Sku details\n구매시작 - Launch Billing Flow\n사용자 결제\n구매 후 처리 Acknowledge Purchase\n백엔드 검증 로직 (Purchase Token를 백엔드로 보내야함)\nConsume 상태 확인\n이렇게 볼 때, iOS는 사용자 경험을 좀 더 우선시 하는 거 같고, 안드로이드는 부정 구매에 대한 방어에 초점이 맞춰져 있는 거 같다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UPL","level":3,"id":"UPL_0"},{"heading":"OAuth Flow","level":3,"id":"OAuth_Flow_0"},{"heading":"IAP Flow","level":3,"id":"IAP_Flow_0"},{"heading":"iOS IAP","level":4,"id":"iOS_IAP_0"},{"heading":"안드로이드 IAP","level":4,"id":"안드로이드_IAP_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"interview_practice/platform-sdk-(1).html","pathToRoot":"..","attachments":[],"createdTime":1751981687162,"modifiedTime":1751981771007,"sourceSize":2575,"sourcePath":"Interview_practice/Platform SDK (1).md","exportPath":"interview_practice/platform-sdk-(1).html","showInTree":true,"treeOrder":335,"backlinks":[],"type":"markdown"},"interview_practice/platform-sdk-(2).html":{"title":"Platform SDK (2)","icon":"","description":"<a href=\".?query=tag:interview\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#interview\">#interview</a>Q. C++ SDK를 iOS/Android에서 사용할 때, 메모리 관리에서 주의해야 할 점은 무엇인가요? 특히 C++에서 할당한 메모리를 JNI나 Objective-C에서 해제할 때 문제가 될 수 있는 상황을 설명해주세요. 힙 관리자의 차이 C++ runtime, JVM, iOS ARC가 각각 다른 메모리 관리자를 사용하기 때문에한쪽에서 할당한 메모리를 다른 쪽에서 해제하면 크래시가 발생합니다. JNI에서는 Global/Local Reference 문제가 있습니다. C++에서 반환한 객체 포인터를 Java에서 오래 보관하려면 NewGlobalRef로 변환해야 하고, 사용 후 반드시 DeleteGlobalRef로 해제해야 합니다. iOS에서는 ARC와의 충돌할 수 있습니다. C++에서 할당한 메모리를 Objective-C 객체로 래핑할 때 소유권이 불분명해질 수 있어요. 이런 경우 메모리를 할당할 때 unique_ptr로 선언해 메모리 소유권을 보장하고 콜백으로 값을 넘겨줄 때는 작은 객체라면 복사, 아닌 경우라면 shared_ptr을 사용합니다. Q. Android JNI 개발에서 멀티스레딩을 다룰 때 주의사항이 있나요? 특히 C++ 스레드에서 Java 메서드를 호출할 때 어떤 문제가 발생할 수 있고, 어떻게 해결하셨나요?JNIEnv 포인터가 스레드별로 고유하다는 점을 주의해야합니다. 한 스레드에서 받은 JNIEnv를 다른 스레드에서 사용하면 즉시 크래시가 발생합니다.C++ 스레드에서 Java 호출 시 문제 C++에서 생성한 스레드는 기본적으로 JVM에 연결되어 있지 않습니다. 따라서 Java 메서드를 호출하려고 하면 JNIEnv를 얻을 수 없다'는 에러가 발생합니다.따라서 Global Reference를 사용해서 Java 객체 참조를 안전하게 공유를 해야합니다. 하지만 멀티스레딩에서는 Global Reference만으로는 부족하고, 각 C++ 스레드에서 JNI 함수를 호출하려면 먼저 AttachCurrentThread로 JVM에 연결해서 JNIEnv를 얻어야 합니다. 그래서 보통 멀티 스레딩 환경이면 Global Reference + AttachCurrentThread 조합으로 사용합니다.Q. iOS에서 ARC(Automatic Reference Counting)에 대해 설명해주세요. 그리고 ARC가 있음에도 불구하고 메모리 리크가 발생할 수 있는 상황과 이를 해결하는 방법을 설명해주세요.ARC는 컴파일 타임에 retain/release 코드를 자동으로 삽입해서 reference count를 관리합니다.arc는 객체를 참조하고 있는 수를 의미하고 객체를 참조하고 있는 수가 0이 되면 그 객체는 메모리에서 해제됩니다. 그래서 컴파일러가 해주니까 실제로 메모리를 할당하고 해제하는 작업을 할 필요가 없어지죠.그럼에도 불구하고 메모리 리크가 발생할 수 있는 상황은 순환참조입니다. 주로 클로저를 이용해 콜백을 받을 때 발생하는데 클로저에서 현재 인스턴스를 접근하려면 캡쳐를 해야합니다. 이때 이 클로저에서 현재 인스턴스의 객체를 참조한다면, ref counting이 올라갑니다. 이 클로저 객체가 현재 인스턴스의 객체를 참조하게 되므로 순환참조가 발생합니다.이 경우에 메모리 리크가 발생합니다. 이를 방지하기 위해서 weak 키워드를 넣으면 인스턴스 객체가 해제될 때 클로저 객체가 잡고 있는 걸 놓아주게 됩니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:interview"],"author":"","coverImageURL":"","fullURL":"interview_practice/platform-sdk-(2).html","pathToRoot":"..","attachments":[],"createdTime":1751981861762,"modifiedTime":1751982381892,"sourceSize":3486,"sourcePath":"Interview_practice/Platform SDK (2).md","exportPath":"interview_practice/platform-sdk-(2).html","showInTree":true,"treeOrder":336,"backlinks":[],"type":"markdown"},"interview_practice/qt.html":{"title":"Qt","icon":"","description":"Qt의 Signal-Slot은 객체 간 통신을 위한 핵심 메커니즘이다. 시그널은 특정 이벤트가 발생했을 때 방출되는 신호. Slot은 시그널을 받아서 실행되는 함수 일반적인 C++ 멤버 함수와 동일하다. Signal이 발생하면 자동으로 호출됨\nSignal 방출: 특정 이벤트가 발생하면 객체에서 signal을 방출\nConnection:&nbsp; connect() 함수로 signal과 slot을 함수로 signal과 slot을 미리 연결\nSlot 실행: Signal이 방출되면 연결된 모든 slot이 자동 실행 Q_OBJECT가 없으면 일반적인 C++ 클래스\nQ_OBJECT가 있으면 Qt의 Meta-Object System이 활성화됨\nQ_OBJECT 매크로를 선언해줘야 Signal/Slot 메커니즘 사용 가능Qt는 QOpenGLWidget을 통해 OpenGL 컨텍스트를 관리하고 렌더링을 수행한다. QOpenGLWidget을 상속한다. QOpenGLWidget은 OpenGL 렌더링을 위한 위젯 클래스다. 일종의 Scene이라고 생각하면 됨. QOpenGLFunctions를 상속한다. 이건 OpenGL 함수 호출을 위한 크로스 플랫폼 래퍼다. 즉 QOpenGLWidget을, QOpenGLFunctions 2개를 상속하는 건 기본이다. 그리고 아래의 함수를 override해서 구현하면 된다.void initializeGL() override;\nvoid resizeGL(int w, int h) override;\nvoid paintGL() override;\n세 가지 핵심 가상함수의 역할은 다음과 같다. initializeGL(): OpenGL 컨텍스트 초기화 OpenGL 함수 초기화 (initializeOpenGLFunctions())\n렌더링 상태 설정 (배경색, 깊이 테스트, 면 컬링)\n셰이더 로드 및 셰이더 프로그램 설정 및 VAO/VBO/EBO를 사용한 지오메트리 생성 resizeGL(): 뷰포트 크기 조정 paintGL(): 실제 렌더링 수행 프레임 버퍼를 초기화\n셰이더 프로그램 바인딩\n카메라, 프로젝션 설정\n렌더링 (drawGround ... etc)\n셰이더 프로그램 릴리즈 정점 데이터 → VBO (GPU 메모리 저장)\n인덱스 데이터 → EBO (GPU 메모리 저장) - 어떤 정점들을 연결해서 삼각형을 만들자 정의\n속성 설정 → VAO (상태 관리) - 정점 속성 설정을 저장하는 상태 관리자\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Q. Qt의 Signal - Slot이란?","level":3,"id":"Q._Qt의_Signal_-_Slot이란?_0"},{"heading":"Q. Q_OBJECT 매크로의 역할","level":3,"id":"Q._Q_OBJECT_매크로의_역할_0"},{"heading":"Q. QOpenGL 작동 방식","level":3,"id":"Q._QOpenGL_작동_방식_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"interview_practice/qt.html","pathToRoot":"..","attachments":[],"createdTime":1752046023828,"modifiedTime":1752046023828,"sourceSize":2322,"sourcePath":"Interview_practice/Qt.md","exportPath":"interview_practice/qt.html","showInTree":true,"treeOrder":337,"backlinks":[],"type":"markdown"},"ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html":{"title":"@testable import와  빌드 환경 구성 (Build Environment Configuration) 그리고 에러","icon":"","description":"출시할 어플리케이션을 개발할 때 빌드 환경을 구성하는 것이 좋다고 생각합니다. 왜냐하면 추후에 개발 서버를 바라보고 있는 어플리케이션, 실제 서버를 바라보고 있는 어플리케이션을 파일 하나로 관리할 수 있어서요. .xcconfig file에 샥샥샥 하면 손쉽게 관리 가능합니다.&nbsp;요즘 저는 테스팅을 공부하고 있습니다. 제가 진행하고 있는 사이드 프로젝트에서도 테스트를 도입하고 싶어서 기존에 있는 기능에 테스트 코드를 작성하려고 했습니다. 유닛테스트 케이스를 생성하고 테스트를 하려고 하는데 예제에서 많이 보던 @testable import 'myProject'를 했는데 다음과 같은 에러가 발생했습니다.<img src=\"https://blog.kakaocdn.net/dn/mbkn5/btr6tX3qHqO/aCEgvC9kkSEfKcWce61a6K/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">먼저 @testable은 뭘까요? 우리가 기본적으로 Unit Test를 하기 위해서는 Unit Test Target을 만들어서 진행하게 됩니다.우리가 테스트 코드를 작성할 Unit Test Class에서 우리의 App Target에 바로 접근할 수 없어요. 왜냐하면 Target들은 별도의 모듈로 처리 되기 때문입니다. 그래서 import를 해야 합니다. 따라서 역시&nbsp;internal(아무것도 안 붙이면 자동으로 internal로 선언됨)에 접근할 수가 없어요.import UIKit // TestableImport 타겟임! // ViewController.swift class ViewController: UIViewController { private let text: String init(text: String) { self.text = text super.init(nibName: nil, bundle: nil) } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .red guard let bundleID = Bundle.main.bundleIdentifier else { return } }\n<br><img src=\"https://blog.kakaocdn.net/dn/o3sgZ/btr6qNNFQGh/4MYA16uMOU3f1hxsTM7xJ0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하지만 우리는 소프트웨어 공학적으로, 모든 것을 open과 public으로 선언하지 않잖아요? 그래서 @testable이 필요한 겁니다.@testable import TestableImport\n이렇게 선언하면 우리의 Main Target에 있는 internal에 접근할 수 있어요.이제 위에서 언급한 제 프로젝트에서 에러가 발생하는 상황을 설명할게요.\nProject Configuration 설정 총 환경 3개를 사용 - Development, Staging, Production 각각 하나의 앱을 구성할 수 있기에 앱마다 Debug, Release가 있기 때문에 총 3 * 2 = 6개의 Configuration이 구성됨 Debug(Development), Release(Development), etc.. 3개의 환경 (Development, Staging, Production)은 xcconfig file로 관리\nUnit Test Target 생성\n@testable import 'MainTarget'\ninternal 코드들 자동 완성 가능\n테스트 코드 작성 가능 테스트 성공\n그런데 위처럼 빨간 줄\n테스트 코드 작성은 잘 되고, 테스트도 잘됩니다. 그런데 저렇게 계속 빨갛게 버그처럼 사라지지 않고 있습니다. 혹시 클린빌드를 하면 될까 Xcode를 껐다 켜면 없어질까 싶어서 해봤는데 되지 않았습니다. 그래서, Sample App을 만들어서 버그를 재현해 보도록 할게요.먼저 App을 만들고 Build 환경을 구성합니다. 여기에서는 Staging을 안 쓰고 4개만 만들도록 할게요.먼저 xcconfig 파일 두 개(Development, Production)를 만들고 Configuration을 펼쳐서 아래에 있는 +를 클릭하고 Duplicate Debug 한번, Duplicate Release 한번 눌러줍니다. 그리고 이름을 바꿔주세요.<br><img src=\"https://blog.kakaocdn.net/dn/mbhAV/btr6g8Z4biV/FHgER9ZDkMrAwf9C3oyFIK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">빌드 설정이 잘 되어 있는 것을 신뢰하기 위해서, xcconfig에 코드를 작성하겠습니다. Bundle Identifier를 설정하는 코드입니다.//\n// Development.xcconfig\n// TestableImport PRODUCT_BUNDLE_IDENTIFIER = com.dev.hose.TestableImport.Development\n//\n// Production.xcconfig\n// TestableImport PRODUCT_BUNDLE_IDENTIFIER = com.dev.hose.TestableImport\n그러고 나서 Project -&gt; Target -&gt; Signing &amp; Capabilities에 가면 우리가 설정한 Configuration 총 4개가 있을 거예요.&nbsp;Bundle Identifier를 $(PRODUCT_BUNDLE_IDENTIFIER)로 입력합니다. 그러면 다음과 같이 될 거예요.<br><img src=\"https://blog.kakaocdn.net/dn/cllnVE/btr6tXClClI/Ur4edaiK4nhLgId8jx1ktK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 빌드 환경 설정은 거의 다 끝났어요. 이제 하나의 코드로 2개의 앱을 만들 수 있게 할 거예요. Scheme을 이용하면 됩니다.Scheme 바꾸는 곳 ( 시뮬레이터 바꾸는 위치 왼쪽)을 누르고 Edit Scheme을 클릭하면 아래 왼쪽과 같이 뜰 겁니다.그러면 왼쪽에 있는 것들 (Run, Test, Profile, Analyze, Archive) 눌러서 아래처럼 빌드 환경에 맞게 설정합니다.&nbsp;그런 다음에 Duplicate Sceme을 눌러서 'TargetName'(Development)으로 바꿔주고 이것 역시 빌드 환경을 설정합니다.<br><img src=\"https://blog.kakaocdn.net/dn/bHVHdV/btr6pGBf201/hUMrxOmcc0nJQjkkcR2JrK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/D3yW9/btr6pGgYbXJ/UfMLbc3Zhk0NqBlJu8jcBk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이렇게 하면 빌드 환경 설정은 끝이 납니다. 아래에서 확인할 수 있듯이 문제없이 잘 돌아가고 있어요.<br><img src=\"https://blog.kakaocdn.net/dn/buPbNv/btr53IudVAb/BF60BOxkxUvdZ2iquHV0yK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/BNH8K/btr6eWlb2H4/JZx5R7wt54DPrDeK5ek97K/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 테스트 코드를 작성하는 곳으로 돌아가겠습니다. Unit Test Target라서, 별도의 타깃이기 때문에 @testable 어노테이션을 붙여주겠습니다. 테스트를 하기 위해서 위해서 ViewController에서 private으로 선언한 text를 internal로 선언하겠습니다. 그리고 테스트를 작성할게요. 테스트를 작성하고 테스트 (Command + U)를 하면 성공적으로 테스트할 수 있습니다. 당연하게 internal로 선언된 것들도 모두 접근할 수 있고요. 하지만 아래처럼 빨간 줄은 역시 사라지지 않습니다.<br><img src=\"https://blog.kakaocdn.net/dn/DApwt/btr6oe6tR1U/Lp4FEw9Z7rw6tVdORcYCWk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이상합니다.TestableImport(Development)의 Test는 아까 Debug(Development)로 설정했고TestableImprot의 Test도 역시 Debug(Production)으로 설정했습니다. 따라서 저 빨간 줄도 사라져야 된다고 생각합니다. 이 이슈에 대해서 'Module '' was not compiled for testing'으로 많은 시간을 검색해 봤는데 대부분 Enable Testability = YES로 설정하라는 답변이 대부분이었습니다.<br><img src=\"https://blog.kakaocdn.net/dn/QX71d/btr6oXQMWqL/0qIq3atf7rNJUvPdg97hK0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Debug는 디폴트로 Enable Testability가 Yes이기 때문에 의미가 없었습니다.stackoverflow, apple developer forum에서 제시한 해결책들을 시도했으나 다 실패했습니다.그런데 이것저것 시도해 보다가 두 가지 방법을 찾았습니다.첫 번째 방법은 Productuon에서도 Enable Testability = YES로 설정을 하는 것입니다. 그랬을 때 빨간 줄이 사라졌습니다.<br><img src=\"https://blog.kakaocdn.net/dn/edVyIB/btr6qOTnJsH/ykkmDtmQ5FK6NhWlED3qjK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/bkzvTy/btr6qrjEZSn/WP35oviZ1jvNi1lKM7UYm1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Productuon에서도 Enable Testability를 지워주면 다시 빨간 줄이 생깁니다.두 번째 방법은 Project Configuration에서 Debug를 하나 더 만드는 것입니다.<br><img src=\"https://blog.kakaocdn.net/dn/cqrFvR/btr53ESUgpQ/2ifuQUTKT7ZSPQRMCqqRp0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그리고 끝입니다? 테스트를 진행하면, 빨간 줄이 사라집니다. 그냥 Configuration을 만드는 것만으로 빨간 줄이 사라집니다.\n이 문단은 상상의 나래입니다. 틀릴 확률이 매우 높습니다.\n왜 위의 두 가지 방법이 빨간 줄을 없앤 걸까요?첫 번째 방법은 모든 설정을 Testability가 가능하게 했으니, 컴파일러가 @testable에 대해서 신경 쓰지 않는 것 같습니다.두 번째 방법은 Debug Configuration이 있는 것만으로 빨간 줄이 사라졌는데 Unit Test Target의 configuration가 debug로 설정되어 있는 것 같습니다. 그래서 컴파일러가 Debug Configuration이 없으면 Testable을 사용할 수 없다고 에러를 띄우는 것 같아요.Swift Package Manager도 custom configuration을 적용할 수 없는 이슈가 있는데 이와 비슷한 이유이지 않을까 싶습니다.&nbsp;혹시 이것에 대해서 해결한 적이 있으시거나 이유를 아시는 분이면 알려주시면 감사하겠습니다. 쓰고 보니까 빌드 환경 구성 글 같아 보이네요.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/TestableImport\" target=\"_self\">https://github.com/psychehose/TestableImport</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"개요 - What is @testable","level":3,"id":"개요_-_What_is_@testable_0"},{"heading":"문제 상황 - 자동 완성 잘됨, 테스트 잘됨, 빨간 줄 안사라짐?","level":3,"id":"문제_상황_-_자동_완성_잘됨,_테스트_잘됨,_빨간_줄_안사라짐?_0"},{"heading":"버그 재현 - 빌드환경구성","level":3,"id":"버그_재현_-_빌드환경구성_0"},{"heading":"해결법들","level":3,"id":"해결법들_0"},{"heading":"자의적인 해석 그리고 찝찝함","level":3,"id":"자의적인_해석_그리고_찝찝함_0"},{"heading":"GitHub","level":4,"id":"GitHub_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/mbkn5/btr6tX3qHqO/aCEgvC9kkSEfKcWce61a6K/img.png","fullURL":"ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html","pathToRoot":"..","attachments":[],"createdTime":1735622506626,"modifiedTime":1735622762245,"sourceSize":9062,"sourcePath":"iOS/@testable import와  빌드 환경 구성 (Build Environment Configuration) 그리고 에러.md","exportPath":"ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html","showInTree":true,"treeOrder":339,"backlinks":[],"type":"markdown"},"ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html":{"title":"Could not find module 'Alamofire' for target armv7-apple-ios';","icon":"","description":"Build Setting 중 만난 에러프로젝트를 진행하면서 나중에 개발서버와 상용서버를 나눌 필요가 생길 거 같아서 빌드 세팅을 진행했다.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ios-development.tistory.com/660\" target=\"_self\">https://ios-development.tistory.com/660</a>&nbsp;을 따라가며 진행했는데, 이런 오류를 만났다. 이것은, 실기기로 빌드 했을 때 뜨는 것이고, (기억 상) 시뮬레이터로 빌드를 하게 되면 Could not find module ‘Alamofire’ for target ‘i386-apple - ios - simulator가 떴다.<br><img src=\"https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">// podfile post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end\nend\npodfile에 다음과 같이 적으면 에러 해결!문제는 Alamofire다.위 스크린 샷의 에러가 Moya + Alamofire에서 발생하고, Alamofire를 사용하는 모든 Library에서 Compile error가 발생했다. (KakaoSDK, 커스텀한 Auth library ( inner DevPods))빌드 세팅을 하기 전에는 발생하지 않았던 오류인데 빌드 세팅을 하고나서 오류가 발생했다는 점에서 일단 매우 이상했다. 아무튼 이 에러를 해결 하기 위해, 무수한 삽질을 했다.Alamofire.framework를 /library/developer ~ /Alamofire/~ 뭐 이런 경로를 쭉 타고 가서 target을 확인 해봤는데 ‘x86_64’와 ‘arm64’ 두개가 있었다. 즉 armv7-apple-ios가 없어서 오류가 발생한 것이 맞다. (빌드 세팅을 하기 전에 단일 세팅일 떄는 왜 오류가 안났는 지는 아직도 의문이다.)그래서, 네비게이션 영역을 통해서 Pods project로 들어가서 Alamofire의 Architecture 부분을 확인하였다.Architectures의 부분이 $(ARCHS_STANDADRD_64_BIT)로 되어 있었다. 이 부분은을 STANDARD ARCH(arm7, arm64)로 고쳤을 때, 에러는 해결되었다. 다만 이렇게 설정했을 때, pod install을 다시하게 되면 본래대로 $(ARCHS_STANDADRD_64_BIT)로 바뀌어서 같은 에러가 발생한다.그래서 pod install 할 때, architecture setting을 지워주는 코드를 추가 했다.post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end\nend\n그리고 나서 Pod project의 Alamofire를 들어갔을 때, Architectures가 사라졌고 에러는 해결되었다.확실하진 않지만, 심증으로는 애플에서 디버그 용도는 32bit 아키텍쳐 ( 배포용도는 64bit도 )만을 지원하기 때문인 것 같다. 위에서 말한 것과 같이, 초기 세팅은 ARCHS_STANDARD_64_BIT 였기 때문이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TL; DR","level":3,"id":"TL;_DR_0"},{"heading":"Procedure","level":3,"id":"Procedure_0"},{"heading":"Why?","level":3,"id":"Why?_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png","fullURL":"ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html","pathToRoot":"..","attachments":[],"createdTime":1735622382925,"modifiedTime":1735622391198,"sourceSize":2858,"sourcePath":"iOS/Could not find module 'Alamofire' for target armv7-apple-ios';.md","exportPath":"ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html","showInTree":true,"treeOrder":340,"backlinks":[],"type":"markdown"},"ios/fat-framework.html":{"title":"Fat Framework","icon":"","description":"환경 : Apple Silicon (M1), Xcode 14.3\bFat Framework 또는 Universal Framework는 xcframework와 다르다. xcframework가 나오기전에 프레임워크를 사용하는 방법은 .framework를 사용하는 것이었다.Xcode에서 프로젝트로 framework를 생성하고 Logger.swift를 만들고 간단한 코드 작성\n// Logger.swift import Foundation public class LoggerInFramework { public static func Logging(_ args: String) -&gt; String { debugPrint(args) return args } } 그러고나서 시뮬레이터로 빌드로 하고 Product - Show Build Folder in Finder를 클릭<img alt=\"framework_path.png\" src=\"images/framework_path.png\" target=\"_self\">LoggerFramework.swiftmodule 안에 arm64-apple-ios-simulator가 있는 것을 확인이제 이 프레임워크를 테스트 해보기 위해 새로운 앱 프로젝트를 하나 만듬<br><img alt=\"hostapp_file.png\" src=\"images/hostapp_file.png\" target=\"_self\">위처럼 프레임워크를 네비게이터에 추가해주고 Project - Targets에서 Embed를 Embed &amp; Sign으로 변경하기\n// ViewController.swift import UIKit\nimport LoggerFramework class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() LoggerInFramework.Logging(\"Hello World\") } } Simulator로 빌드 시 성공, 그러나 실제 기기로 빌드 하면 다음과 같은 에러를 뱉음\nCould not find module 'LoggerFramework' for target 'arm64-apple-ios'; found: arm64-apple-ios-simulator, at: /Users/psychehose/Study/iOSLaboratory/HostingLoggingFrameworkApp/HostingLoggingFrameworkApp/LoggerFramework.framework/Modules/LoggerFramework.swiftmodule\nswiftmodule 안에 arm64-apple-ios-simulator만 존재하기 때문그렇다면 swiftmodule 안에 arm64-apple-ios와 x86_64-apple-ios-simulator가 있다면 M1 Mac과 Intel Mac에서 모두 시뮬레이터를 돌리고 실기기에 빌드할 수 있을 것이다.framework에 저 위의 경우를 다 때려넣어서 만든 것이 Fat Framework이다.Fat Framework를 만드는 법은 Framework 프로젝트에서 Aggreate 타겟을 만들고 script를 짜서 만드는 것이 가장 간단하다.<br><img alt=\"aggregate.png\" src=\"images/aggregate.png\" target=\"_self\">Product 이름은 FatFramework로 만듬\n타겟에서 FatFramework - Build Phases에서 Target Dependency Framework (LoggerFramework) 추가하기 버튼 누르고 run script 추가하기 #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal mkdir -p \"${UNIVERSAL_OUTPUTFOLDER}\" xcodebuild BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=\"-fembed-bitcode\" -target \"${PROJECT_NAME}\" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\" clean build xcodebuild BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS=\"-fembed-bitcode\" -target \"${PROJECT_NAME}\" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR=\"${BUILD_DIR}\" BUILD_ROOT=\"${BUILD_ROOT}\" EXCLUDED_ARCHS=\"arm64\" clean build cp -R \"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework\" \"${UNIVERSAL_OUTPUTFOLDER}/\" cp -R \"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule/.\" 그리고 FatFramework Scheme을 편집을 누르고 Run에서 Build Configuration을 Release로 변경하고 기기를 Any iOS Device로 하고 빌드한다<br><img alt=\"sandbox_error.png\" src=\"images/sandbox_error.png\" target=\"_self\">위의 에러가 발생하면 Build Setting - User Script Sandboxing을 No로 설정하고 다시 빌드이제 framework의 swiftmodule을 보면 arm64-apple-ios, x86_64-apple-ios-simulator가 있게 된다.\n(arm64-apple-ios-simulator가 없는 이유는 스크립트에서 EXCLUDED_ARCHS를 했기 때문)<br><img alt=\"fatframework_path.png\" src=\"images/fatframework_path.png\" target=\"_self\">아까 만든 테스트앱에서 프레임워크를 교체하고 실기기를 빌드하면 성공한다. 그리고 intel mac에서도 simulator로 빌드하면 성공할 것임. 근데 Apple Silicon을 사용하는 맥에서 시뮬레이터로 빌드할 수 없다.swiftmodule에 arm64-apple-ios-simulator를 추가할 수는 있다. 그런데, m1 맥 테스트 앱에서 시뮬레이터로 빌드하면 다음과 같은 에러가 뜬다.<br><img alt=\"simulator_device_error.png\" src=\"images/simulator_device_error.png\" target=\"_self\">왜 이런 이유가 발생할까?Derived Data를 삭제하고, Aggregate가 아닌 프레임워크를 iOS 디바이스, 시뮬레이터 빌드를 각각 하고 프레임워크 path로 가서 손수 lipo 명령어를 사용하자lipo -create -output UniversalFramework.framework/UniversalFramework \\ Debug-iphonesimulator/LoggerFramework.framework/LoggerFramework \\ Debug-iphoneos/LoggerFramework.framework/LoggerFramework 그러면 아래와 같은 에러가 발생할 것이다.\nfatal error: /Library/Developer/CommandLineTools/usr/bin/lipo: Debug-iphonesimulator/LoggerFramework.framework/LoggerFramework and Debug-iphoneos/LoggerFramework.framework/LoggerFramework have the same architectures (arm64) and can't be in the same fat output file\n정확한 이유는 아니지만, 위의 에러 로그처럼 simulator와 실제 device의 아키텍쳐가 같아서 프레임워크를 호스팅하는 앱(Test App)이 arm64-apple-ios-simulator를 못찾는 것 같다.그래서 M1 Mac이 등장한 이후로 Fat Framework를 잘 사용하지 않는 것 같다. 대신 대부분의 경우에 xcframework를 사용한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/framework_path.png","fullURL":"ios/fat-framework.html","pathToRoot":"..","attachments":["images/framework_path.html","images/hostapp_file.html","images/aggregate.html","images/sandbox_error.html","images/fatframework_path.html","images/simulator_device_error.html"],"createdTime":1710855209764,"modifiedTime":1735554492925,"sourceSize":5359,"sourcePath":"iOS/Fat Framework.md","exportPath":"ios/fat-framework.html","showInTree":true,"treeOrder":341,"backlinks":[],"type":"markdown"},"ios/lazy-sequence.html":{"title":"Lazy Sequence","icon":"","description":"간만의 iOS 포스팅입니다.WWDC 2023에서&nbsp;**Generalize APIs with parameter packs**&nbsp;를 보고 있습니다.연관 영상으로 타고 내려가다가 WWDC 2022 Design Protocol Interfaces in Swift를 보게 되었습니다.영상에서, lazy squence를 이용한 예시가 나왔는데, 평소에 제가 쓰지 않는 Collection이라서 포스팅하게 되었습니다.\nA Sequence containing the same elements as a&nbsp;Base&nbsp;collection, but on which some operations such as&nbsp;map&nbsp;and&nbsp;filter&nbsp;&nbsp;are implemented&nbsp;lazily.\nprotocol LazySequenceProtocol : Sequence @frozen\nstruct LazySequence&lt;Base&gt; where Base : Sequence\ntypealias LazyCollection&lt;T&gt; = LazySequence&lt;T&gt; where T : Collection /** protocol LazySequenceProtocol : Sequence의 Instance Method compactMap()\ndrop()\nfilter()\nflatMap()\njoined()\nmap()\nprefix() **/\nlazy 키워드는 sequence가 처리되는 방식을 변경합니다. 예를 들면 lazy 키워드를 사용하지 않은 경우, 전체 Sequence를 처리하고 새로운 Sequence가 저장됩니다.lazy가 사용된 경우에 sequence의 값은 downstream 함수에서 요청 시에 생성됩니다. 값은 저장되지 않고 필요할 때 생성됩니다.코드로 비교를 하면서 확인해 보겠습니다.양의 정수를 요소로 가지는 배열이 있을 때 짝수로 필터링하고 2배를 하는 코드를 작성할게요.&nbsp;// lazy keyword를 사용하지 않은 경우 var numbers: [Int] = [1, 2, 3, 6, 9] let modifiedNumbers = numbers .filter { number in print(\"Even number filter\") return number % 2 == 0 }.map { number -&gt; Int in print(\"Doubling the number\") return number * 2 } print(modifiedNumbers) // 출력결과: /**\nEven number filter\nEven number filter\nEven number filter\nEven number filter\nEven number filter\nDoubling the number\nDoubling the number\n[4, 12]\n**/\nmodifiedNumbers에서 filter() 코드 블록이 upstream 함수이고, map() 코드 블록이 downstream 함수입니다. 출력된 결과를 확인하면 upstream 함수인 filter를 다 돌고 os에서 임시로 storage에 [2,6]을 할당하고 map 함수를 통과하고 있습니다.이제 lazy가 사용된 경우를 볼게요.&nbsp;// lazy keyword 사용 var numbers: [Int] = [1, 2, 3, 6, 9] let modifiedLazyNumbers = numbers.lazy .filter { number in print(\"Lazy Even number filter\") return number % 2 == 0 }.map { number -&gt; Int in print(\"Lazy Doubling the number\") return number * 2 } print(modifiedLazyNumbers) // 출력결과: /**\nLazyMapSequence&lt;LazyFilterSequence&lt;Array&lt;Int&gt;&gt;, Int&gt;(_base: Swift.LazyFilterSequence&lt;Swift.Array&lt;Swift.Int&gt;&gt;(_base: [1, 2, 3, 6, 9], _predicate: (Function)), _transform: (Function))\n**/\n출력 결과를 확인했을 때, 어떤 구체적인 값을 나타내지 않습니다. 그렇다면, 다음 코드를 추가하고 다시 실행해 보도록 하겠습니다.print(modifiedLazyNumbers.first!) // 출력결과: /**\nLazyMapSequence&lt;LazyFilterSequence&lt;Array&lt;Int&gt;&gt;, Int&gt;(_base: Swift.LazyFilterSequence&lt;Swift.Array&lt;Swift.Int&gt;&gt;(_base: [1, 2, 3, 6, 9], _predicate: (Function)), _transform: (Function))\nLazy Even number filter\nLazy Even number filter\nLazy Doubling the number\n4\n**/\n결과가 실제적인 값인 4가 나왔네요. 이렇듯,&nbsp;lazy는 필요할 때 계산한다.라는&nbsp;특징을 확인할 수 있습니다. 좋습니다.우리는 이러한 맥락에서, lazy 키워드가 붙은 경우에 sequence가 처리되는 방식을 이해할 수 있습니다. lazy를 사용하지 않을 때 모든 filter문을 돌고 map 함수를 도는 반면에, lazy를 사용할 때&nbsp; 각각의 element가 순서대로 함수를 통과하는 모습을 확인할 수 있어요.그러면 다음 코드의 실행 결과는 무엇일까요?let modifiedLazyNumbers = numbers.lazy .filter { number in print(\"Lazy Even number filter\") return number % 2 == 0 }.map { number -&gt; Int in print(\"Lazy Doubling the number\") return number * 2 } .reduce(0) { partialResult, ele in return partialResult + 1 }\n// 출력결과: /**\nLazy Even number filter\nLazy Even number filter\nLazy Doubling the number\nLazy Even number filter\nLazy Even number filter\nLazy Doubling the number\nLazy Even number filter\n**/\n.reduce 블록에서 값을 계산해서 처리할 필요가 있기 때문에 위와 같은 결과를 확인할 수 있습니다.lazy sequence에 대해 알아봤는데요. 어떨 때 사용하면 될까요?\nintermediate operation이 storage 할당하는 것을 막을 때\n불필요한 계산을 피하기 위해서 → 최종 컬렉션의 일부만 필요한 경우\ndownstream process를 더 빨리 시작하고, upstream process가 다 수행될 때까지 기다릴 필요가 없는 경우\n예시를 하나 들면, 1부터 10000까지 소수를 찾아서 어떤 작업을 하는 프로그램이 있다고 가정합시다.(의사코드로 작성)var 양의정수배열 = [1 ... 10000] 양의정수배열\n.filter { 요소가 소수입니까?\n}\n.map { 어떤 작업\n} 양의정수배열.lazy\n.filter { 요소가 소수입니까?\n}\n.map { 어떤 작업\n}\nlazy를 사용하지 않은 경우에는 전체 배열을 필터링하고&nbsp;결과인 배열의 요소에 대해 어떤 작업을 하는 반면에lazy를 사용한 경우에는 배열을 돌 때 요소가&nbsp;소수인 경우 바로 어떤 작업을 하게 됩니다.끝!import Foundation var numbers: [Int] = [1, 2, 3, 6, 9] let modifiedNumbers = numbers .filter { number in print(\"Even number filter\") return number % 2 == 0 }.map { number -&gt; Int in print(\"Doubling the number\") return number * 2 }\n//\nprint(modifiedNumbers) let modifiedLazyNumbers = numbers.lazy .filter { number in print(\"Lazy Even number filter\") return number % 2 == 0 }.map { number -&gt; Int in print(\"Lazy Doubling the number\") return number * 2 }\n// .reduce(0) { partialResult, ele in\n// return partialResult + 1\n// } print(modifiedLazyNumbers)\n//print(modifiedLazyNumbers.first!)\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.apple.com/documentation/swift/lazysequenceprotocol\" target=\"_self\">https://developer.apple.com/documentation/swift/lazysequenceprotocol</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.avanderlee.com/swift/lazy-collections-arrays/\" target=\"_self\">https://www.avanderlee.com/swift/lazy-collections-arrays/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://stackoverflow.com/questions/51917054/why-and-when-to-use-lazy-with-array-in-swift\" target=\"_self\">https://stackoverflow.com/questions/51917054/why-and-when-to-use-lazy-with-array-in-swift</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"정의 (애플 공식 문서)","level":4,"id":"정의_(애플_공식_문서)_0"},{"heading":"lazy sequence를 언제 사용하면 좋을까?","level":4,"id":"lazy_sequence를_언제_사용하면_좋을까?_0"},{"heading":"코드","level":4,"id":"코드_0"},{"heading":"Ref.","level":3,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ios/lazy-sequence.html","pathToRoot":"..","attachments":[],"createdTime":1735623166859,"modifiedTime":1735623215320,"sourceSize":6852,"sourcePath":"iOS/Lazy Sequence.md","exportPath":"ios/lazy-sequence.html","showInTree":true,"treeOrder":342,"backlinks":[],"type":"markdown"},"ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html":{"title":"Missing required module 'RxCocoaRuntime'에 대한 고찰 - SPM과 UnitTest에서의 오류","icon":"","description":"SPM으로 RxSwift를 가져오고 Unit Test를 작성한 후 테스트를 실행했을 때 다음과 같은 에러를 만난 적이 있습니다. Missing required module 'RxCocoaRuntime'\n프로젝트를 만들고 Swift Package Manager로 RxSwift를 추가하고 RxSwift, RxCocoa, RxRelay 라이브러리만을 앱 타겟에 추가합니다. 그리고 테스트 타겟은 Target Dependencies로 앱 타겟을 가지고 있고, 어떠한 라이브러리도 링킹하고 있지 않습니다.&nbsp;<img src=\"https://blog.kakaocdn.net/dn/RdgNd/btr8uTeqxjZ/YOZ0YRoqBNvxqE6hKVB9gK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/cwsx5k/btr8vHqZp1v/ZgdvWLkIyayepWxb2MLli1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그리고 AppDelegate에서 RxSwift를 import하고 RxSwift 코드를 작성합니다. 이제 애플리케이션을 빌드하면 빌드가 성공합니다. import RxSwift\nimport UIKit @main\nclass AppDelegate: UIResponder, UIApplicationDelegate { func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? ) -&gt; Bool { Observable.just(1).subscribe(onNext: { print($0) }) .dispose() return true }\n이제 UnitTest 클래스로 가서, Command + U를 눌러 테스트를 실행해보도록 할까요? 문제없이 테스트가 성공할 것입니다.\n그러면 import RxCocoa를 시도해보면 어떨까요? 그 순간 아래와 같이 에러가 발생할 거예요.&nbsp;<br><img src=\"https://blog.kakaocdn.net/dn/wKYQe/btr8u3BgSJE/9mYuSIp7sq7TNKCKlZscKK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">우리가 설정한 걸로는 아직 테스트 타겟에서 RxCocoa를 import 하지 못합니다. 그렇기 때문에 테스트 클래스에서 RxCocoa를 지우겠습니다. 그러면 위의 에러는 당연히 사라질 거예요. 다시 AppDelegate로 돌아가서 RxCocoa를 import 하고 AppDelegate에서 RxCocoa가 가지고 있는 Trait인 BehaviorRelay를 작성하도록 할게요.import RxCocoa\nimport RxSwift\nimport UIKit @main\nclass AppDelegate: UIResponder, UIApplicationDelegate { func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? ) -&gt; Bool { Observable.just(1).subscribe(onNext: { print($0) }) .dispose() BehaviorRelay(value: 2) .subscribe(onNext: { print($0) }) .dispose() return true }\n애플리케이션을 빌드하면 실행이 되고 print도 잘 찍힙니다. \u001d이걸로 봐서 앱 타겟에는 문제가 없습니다. 다시 테스트 \b클래스로 돌아가서 테스트를 실행해 볼까요?&nbsp;<br><img src=\"https://blog.kakaocdn.net/dn/C9D03/btr8lmBPXiT/efZVLhCFNcoQjVsYeSoTp0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">테스트 클래스에서 RxCocoa를 import 하지 않았는데도 RxCocoaRuntime Error가 발생했습니다.테스트 타겟에서 Target Dependency로 앱 타겟을 가지고 있기 때문입니다. 그런데 앱 타겟에서 RxCocoa를 사용하고 있어요. 문제점은 여기에서 발생하는 것 같습니다. 테스트를 실행하면, 테스트 타겟에 RxCocoaRuntime의 코드가 링킹 되지 않는 것 같아요. (근본적인 문제는 아직 잘 모르겠습니다. RxCommunity에서도 오랫동안 제기 되어온 문제이고 SPM 이슈라고 합니다) 그래서 위의 에러가 발생하는 것 같습니다. 그렇다면 테스트 타겟에 RxCocoaRuntime를 링킹 하면 문제가 해결될 것 같아요.&nbsp;\nProject -&gt; Test Target 클릭 -&gt; Build Phrase -&gt; Link Binary with Libraries -&gt; RxCocoa 넣기.\n<br><img src=\"https://blog.kakaocdn.net/dn/pox84/btr8uRnuyqS/qFYBbQf8c5W7blnOoAclsK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/snY2F/btr8uSs8KUd/XwFDicPwSOwQn663zZTHA0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">예상대로 에러는 사라지고 테스트는 성공했습니다. 다만 엄청나게 많은 경고들이 생성되었는데 코드가 중복으로 올라갔다는 경고입니다. 테스트 타겟에서 RxCocoa 코드가 올라오고 테스트 타겟이 Target Dependency로 가지고 있는 앱 타겟에서 RxCocoa 코드가 다시 한번 올라오기 때문입니다. 이제는 이 중복 경고를 지우려고 노력해 보겠습니다.RxCocoa 구현 코드에 보면, Runtime이라는 폴더가 존재합니다. 우리가 필요한 것은 Runtime에 있는 것들이니까 Link Binary with Libraries에 저것들을 넣어주면 될 것 같습니다. 이 폴더는 그대로 RxTest에 존재합니다. 그러면 테스트 타겟에 RxTest와, RxBlocking을 넣어주면 에러가 사라지지 않을까요? <br><img src=\"https://blog.kakaocdn.net/dn/LhJkD/btr8lN7y6mF/2ENFkbrfG0lRyqMtvlL611/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/cKdACd/btr8vtNoZgD/qf6HkEldHPDPwmjwXLK12K/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/kSoQd/btr8wR770kI/kHzTCf6oRbxGoNvMPhVTD1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">아쉽게도 에러가 사라지지 않았습니다. 논리적으로 사라질 거라고 생각했는데 그러지 않네요. 이러한 이슈는 위에 언급한 것처럼 오래전부터 있어 왔습니다. 물론 해결 방법은 있습니다. 해결 방법도 꽤나 다양합니다. 무튼 해결 방법은 있는데 근본적으로 어떤 문제가 있는지는 언급되지는 않네요. SPM 이슈일 것이라고만 나와있습니다. 그 말에 충분히 신빙성이 있는 게 같은 환경에서 .xcframework로 링킹 하면 해당 에러는 발생하지가 않습니다. 예상 가능한 건 RxCocoaRuntime이 중요 포인트다 라는 것 정도인 것 같습니다. 구현된 RxCocoa를 살펴보면 SPM인 경우에 import RxCocoaRuntime을 하는 걸 볼 수 있기 때문입니다.&nbsp;<br><img src=\"https://blog.kakaocdn.net/dn/89GV2/btr8LLUimFH/rjYwZmkK4zW57rakC1hXG0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">RxSwift Issue와 구글 검색을 통해서 몇 가지 해결 방법을 찾았습니다. 근데 다수의 해결 방법들은 코드가 중복 적재되어서 경고가 뜹니다.참고해 주세요. &nbsp;1. 테스트 타겟에 Link Binary with Libraries에 RxCocoa를 추가한다. 중복 적재 경고(O)\n위에서 사용했던 방법입니다.\nProject -&gt; Test Target 클릭 -&gt; Build Phrase -&gt; Link Binary with Libraries -&gt; RxCocoa 넣기\n2.&nbsp;&nbsp;TEST_HOST를 바꿔주는 방법입니다. 중복 적재 (X)&nbsp;# Test Target -&gt; Build Setting -&gt; TEST_HOST 검색 -&gt; '$(BUNDLE_EXECUTABLE_FOLDER_PATH)/' 지우기 $(BUILT_PRODUCTS_DIR)/&lt;YOUR APPNAME&gt;.app/&lt;YOUR APPNAME&gt;\n이걸로 추측하는 건데, Bundle Loader 부분이 조금 다르게 처리되어 있는 듯합니다. 이상하게 앱 타겟에서는 Bundle Loader 부분이 설정이 안되어 있고, 테스트 타겟에서는 Bundle Loader 값이 $(TEST_HOST) 입니다. 그래서 TEST_HOST 값을 설정해 주면 RxCocoaRuntime을 가지고 올 수 있는 것이 아닐지 예상합니다.<br><img src=\"https://blog.kakaocdn.net/dn/b1epQr/btr8Ima3ymS/GGWPfB0bGI15LIqGfmld2k/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n전처리 사용해서 해결 - 중복적재 (O)\nOther Swift Flags는 Swift 컴파일러에게 pass 하라고 명령하는 것입니다. 이걸 입력하지 않을 경우 SPM에 구현되어 있는 RxCocoa에서 import RxCocoaRuntime 할 때 import를 못했으나, Other Swift Flags를 설정하면 컴파일하기 전에 코드를 올리기 때문에 에러가 발생하지 않는 것 같습니다. 테스트 타겟에 RxTest와 RxBlocking을 추가하면 코드 중복 적재 경고가 뜨는데요. 위의 이유 때문입니다. C언어에서 #include와 똑같은 것입니다.\nTest Target -&gt; Build Setting -&gt; Other Swift Flags 검색 -&gt; -Xcc -fmodule-map-file=(PLATFORM_NAME)/RxCocoaRuntime.modulemap\n<br><img src=\"https://blog.kakaocdn.net/dn/rK1Pi/btr8Jo621JB/5cfUXLTnju2vW2zbnLgZK0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">4.&nbsp; 앱 타겟과 테스트 타겟에서 RxCocoa 대신에 RxCocoa-Dynamic을 사용한다- 중복 적재 (X)&nbsp;문제로 돌아가서 단순하게 그냥 해결하겠습니다. 우리가 달성하고 싶은 건 다음과 같습니다.\n&nbsp;테스트 타겟은 RxCocoaRuntime이 필요함 (-&gt; RxCocoa를 Link Binary wtih Libraries에 넣음)\n그러면 코드가 중복 적재되는데 이를 해결하고 싶음 (-&gt; dynamic을 사용하면 됨)\n보통 SPM은 static library(.o type)으로 코드를 가져오는데, 코드 자체를 Heap 영역에 때려 넣습니다. 따라서 코드 자체 말고 Dynamic library reference를 Heap 영역에 넣어 필요할 때마다 Stack 영역에서 가져오는 dynamic으로 변경 시에 중복 적재 경고가 뜨지 않습니다. <br><img src=\"https://blog.kakaocdn.net/dn/bLcSx2/btr8IJcErfK/n0F7LhRlFUIgfNsgVCDK1K/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/CWUS5/btr8KHkMfIj/g3AxUDBhU3MycwdBI2B2Jk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nLocal SPM을 만들어서 ThirdPartyLibrary를 관리하는 ThirdPartyManager를 만드는 것입니다. - 중복적재 (X)\n<br><img src=\"https://blog.kakaocdn.net/dn/caj5Qa/btr8J4m6q6o/qhgCquDO1aqVGYm1Jkw3Ok/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그래프를 그리면 다음과 같이 되겠습니다. Local SPM 코드를 다음과 같이 작성할 수 있어요.// swift-tools-version: 5.7\n// The swift-tools-version declares the minimum version of Swift required to build this package. // Package.swift import PackageDescription let package = Package( name: \"ThirdPartyManager\", platforms: [.iOS(.v14)], products: [ .library( name: \"ThirdPartyManager\", type: .dynamic, targets: [\"ThirdPartyManager\"] ), .library( name: \"TestResolver\", targets: [\"TestResolver\"] ) ], dependencies: [ .package(url: \"https://github.com/ReactiveX/RxSwift.git\", exact: \"6.5.0\") ], targets: [ .target( name: \"ThirdPartyManager\", dependencies: [ .product(name: \"RxSwift\", package: \"Rxswift\"), .product(name: \"RxCocoa\", package: \"Rxswift\") ] ), .target( name: \"TestResolver\", dependencies: [ .product(name: \"RxTest\", package: \"Rxswift\"), .product(name: \"RxBlocking\", package: \"Rxswift\") ] ), .testTarget( name: \"ThirdPartyManagerTests\", dependencies: [\"ThirdPartyManager\"]), ]\n)\nLocal SPM으로 RxSwift를 가져온 후에, target을 만들어줍니다. 이것을 library로 외부에 노출하면 되겠습니다. 이때, ThirdPartyManager(library)는 dynamic library로 지정하겠습니다. 그리고 앱을 실행해 보고, 테스트를 실행하면 무사히 통과하고 중복 적재 경고도 없음을 알 수 있습니다. 코드 중복은 dynamic을 적절히 사용하면 해결할 수 있겠네요. Local SPM을 사용해서 에러를 해결하는 코드는 아래 GitHub을 참고해 주세요.<br><img src=\"https://blog.kakaocdn.net/dn/btgkkT/btr8MpRhc9s/xN9BkJxxkyCrB2DMc75m21/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/NA8tG/btr8I1qNiyC/CCn3uUazzNLgSmfSnStWOk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">SPM 사용 시에 RxCocoaRuntime 모듈을 찾을 수 없는 에러에 대해서 이제 다양한 방법으로 해결할 수 있게 되었습니다. 처음에 왜 뜨는지 조차 이유를 몰랐었는데, 어느 정도 감을 잡은 후에는 즐겁게 해결할 수 있었어요. 라이브러리에 이슈에 대해서 공부할 때마다 Mach -O Type의 중요성을 깨닫는 것 같습니다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/SPMRxCocoaRuntimeError\" target=\"_self\">https://github.com/psychehose/SPMRxCocoaRuntimeError</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/apple/swift-package-manager/issues/4581\" target=\"_self\">https://github.com/apple/swift-package-manager/issues/4581</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/ReactiveX/RxSwift/issues/2127\" target=\"_self\">https://github.com/ReactiveX/RxSwift/issues/2127</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://stackoverflow.com/questions/58125428/missing-required-module-xyz-on-unit-tests-when-using-swift-package-manager\" target=\"_self\">https://stackoverflow.com/questions/58125428/missing-required-module-xyz-on-unit-tests-when-using-swift-package-manager</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://forums.swift.org/t/missing-required-modules-when-importing-an-spm-framework/24856\" target=\"_self\">https://forums.swift.org/t/missing-required-modules-when-importing-an-spm-framework/24856</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/ReactiveX/RxSwift/issues/2057\" target=\"_self\">https://github.com/ReactiveX/RxSwift/issues/2057</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<strong>\b</strong>문제 상황 재현","level":3,"id":"**\b**문제_상황_재현_0"},{"heading":"왜 이런 에러가 발생할까?","level":3,"id":"왜_이런_에러가_발생할까?_0"},{"heading":"Missing required module 'RxCocoaRuntime' 해결방법 총정리","level":3,"id":"Missing_required_module_'RxCocoaRuntime'_해결방법_총정리_0"},{"heading":"생각","level":4,"id":"생각_0"},{"heading":"GitHub","level":4,"id":"GitHub_0"},{"heading":"Reference","level":4,"id":"Reference_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/RdgNd/btr8uTeqxjZ/YOZ0YRoqBNvxqE6hKVB9gK/img.png","fullURL":"ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html","pathToRoot":"..","attachments":[],"createdTime":1736176210787,"modifiedTime":1736176233291,"sourceSize":12236,"sourcePath":"iOS/Missing required module 'RxCocoaRuntime'에 대한 고찰 - SPM과 UnitTest에서의 오류.md","exportPath":"ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html","showInTree":true,"treeOrder":343,"backlinks":[],"type":"markdown"},"ios/network-timeout-unittest.html":{"title":"Network Timeout UnitTest","icon":"","description":"서버 통신을 담당하는 NetworkManager에서 Timeout Error를 시뮬레이팅 하는 법은URLProtocol을 Confirm하고, Error를 Response로 넘겨주는 방식으로 처리하는 것이 간편\nclass TimeoutURLProtocol: URLProtocol { override class func canInit(with request: URLRequest) -&gt; Bool { return true } override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest { return request } override func startLoading() { // Introduce a delay (simulating a timeout) DispatchQueue.global().asyncAfter(deadline: .now() + 3.0) { // Respond with an error self.client?.urlProtocol(self, didFailWithError: NSError(domain: NSURLErrorDomain, code: NSURLErrorTimedOut, userInfo: nil)) self.client?.urlProtocolDidFinishLoading(self) } } override func stopLoading() { // Clean up or additional actions, if needed }\n}\n그런 다음에 test code 안에서, URLSessionConfiguration이 protocol을 컨펌함func testURLSessionTimeout() { let expectation = XCTestExpectation(description: \"Time out expectation\") let config = URLSessionConfiguration.ephemeral config.protocolClasses = [TimeoutURLProtocol.self] // Timeout Interval, 단위는 seconds config.timeoutIntervalForRequest = 3 let session = URLSession(configuration: config, delegate: nil, delegateQueue: nil) let task = session.dataTask(with: url) { data, response, error in if let error = error { // Time out error print(\"Error: \\(error)\") // Error 발생 기대 충족 expectation.fulfill() return } guard let data = data else { let noDataError = NSError() // No Data Error return } // Success, There is Data. print(data) } task.resume() wait(for: [expectation], timeout: 4) } 그러면 TimeoutURLProtocol, config.timeoutIntervalForRequest과 wait()을 통해서 타임아웃 에러를 시뮬레이팅할 수 있음.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ios/network-timeout-unittest.html","pathToRoot":"..","attachments":[],"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":2133,"sourcePath":"iOS/Network Timeout UnitTest.md","exportPath":"ios/network-timeout-unittest.html","showInTree":true,"treeOrder":344,"backlinks":[],"type":"markdown"},"ios/objective-c.html":{"title":"Objective - C","icon":"","description":"#import &lt;Foundation/Foundation.h&gt; @interface Vehicle : NSObject { // Declare Member variable int wheels; int seats;\n} - (int) wheels;\n- (int) seats;\n- (void) setWheels:(int) w; - (void) setSeats:(int) s; - (void) print; @end @implementation Vehicle - (int)wheels { return wheels\n} - (int)seats { return seats\n} - (void)setWheels:(int)w { wheels = w;\n} - (void)setSeats:(int)s { seats = s;\n} - (void)print { NSLog(@\"Vehicle have %i wheels and %i seats.\", wheels, seats);\n} @end // 대괄호는 메세지를 구분해주는 기호\n// [Receiver message] 형식 int main(int argc, const char * argv[]) { @autoreleasepool { // vehicle을 alloc 하고 init 하라 Vehicle* vehicle = [[Vehicle alloc] init]; [vehicle setWheels: 4]; [vehicle setSeats: 2]; [vehicle print]; NSLog(@\"wheels: %i, seats: %i\", [vehicle wheels], [vehicle seats]); } return 0; }\nObjective-C 는 선언과 구현이 분리되어 있음@interface ~ @end는 선언부임\n@implementation ~@end는 구현부임[ ] 대괄호는 message를 구분하는 기호로 주로 사용됨. [Receiver Message] 형식임. 그리고 멤버 메서드는 message의 일종임. getter setter를 이용할 때도 초기 버전에는 리시버 메세지 형식을 그대로 따라야 했으나, 지금은 Dot 접근도 가능함 getter 구현시에 관행적으로 get을 붙이지 않는다. getWheels(X) -&gt; wheels(O)\ngetter, setter를 매번 구현하는 것은 귀찮음. getter setter를 지우고 선언부 member method 영역에 @property로 선언하는 것으로 대체할 수 있음. 그리고 @property로 사용하면 멤버 변수 선언을 생략해도 됨만약, @property 선언만 하고 멤버변수를 선언하지 않았을 때 객체 내부에서 해당 변수를 사용하기 위해서는 _ 을 붙여줘야함. @property를 선언한 변수는 내부적으로 _\\name 으로 선언되기 때문내부에서도 같은 이름을 사용하고 싶으면 @synthesize를 사용해야함.\n@interface Vehicle : NSObject { // 생략 가능! // int wheels; // int seats; } @property int wheels;\n@property int seats; @end @implementation Vehicle\n@synthesize seats; - (void)print { NSLog(@\"Vehicle have %i wheels and %i seats.\", _wheels, seats);\n} @end int main(int argc, const char * argv[]) { @autoreleasepool { // vehicle을 alloc 하고 init 하라 Vehicle* vehicle = [[Vehicle alloc] init]; [vehicle setWheels: 4]; [vehicle setSeats: 2]; vehicle.wheels = 4; vehicle.seats = 2; [vehicle print]; NSLog(@\"wheels: %i, seats: %i\", [vehicle wheels], [vehicle seats]); NSLog(@\"wheels: %i, seats: %i\", vehicle.wheels, vehicle.seats); } return 0; } 다른 언어와 다르게 함수를 선언할 때 Arguement를 나누는 기준이 콜론(:)이다.// 2개의 인자를 가진 함수\n- (void) setWheels:(int)w Seats:(int)s; // 호출할 때 [vehicle setWheels:4 Seats:2]; if, else if, else, switch문 대부분의 언어와 똑같음.\nfor, while문도 마찬가지NSString과 NSMutableString이 있음. 둘 다 객체 타입NSString과 NSMutableString의 차이점은 자기 자신을 바꿀 수 있냐임.\nNSString은 append, insert 같은 함수가 없음. 자신은 변화 불가능이니까String 초기화시 alloc과 init을 이용하고 @\"\"를 이용해 값을 넣을 수 있음\n보통 바로 NSString* varname = @\"\"; 로 바로 초기화함.\nint main(int argc, const char * argv[]) { @autoreleasepool { NSString* str = [[NSString alloc]init]; str = @\"This is NSString\"; NSString* str2 = [[NSString alloc]initWithString:@\"This is NSString\"]; NSLog(@\"str: %@\", str); NSLog(@\"str: %@\", str2); // immutable class - 자기 자신은 변화를 못하기 때문에 새로 할당해야함. NSString* result; // substringFromIndex result = [str substringFromIndex:6]; NSLog(@\"result: %@\", result); // substringToIndex result = [str substringToIndex:6]; NSLog(@\"result: %@\", result); // method chaining result = [[str substringToIndex:11 ] substringFromIndex:8]; NSLog(@\"result: %@\", result); //substringWithRange result = [[str substringWithRange:NSMakeRange(8, 3)] lowercaseString]; NSLog(@\"result: %@\", result); result = [[str substringWithRange:NSMakeRange(8, 3)] uppercaseString]; NSLog(@\"result: %@\", result); // NSMutableString - 자기 자신 수정 가능, 할당해서 사용해야함 string처럼 =@\"\"로 불가 NSMutableString* mstr = [NSMutableString stringWithString:str]; NSLog(@\"mstr: %@\", mstr); [mstr appendString:@ \" and NSMutableString\"]; NSLog(@\"mstr: %@\", mstr); [mstr insertString:@\"Mutable\" atIndex:8]; NSLog(@\"mstr: %@\", mstr); } return 0; }\nNSMutableString은 무조건 할당해서 사용해야한다. NSString처럼 =@\"\"로 사용하면 아래처럼 경고를 주고 NSMutableString 메서드를 사용하게 되면 런타임에서 에러가 발생한다.\n<img alt=\"immutable_mutable.png\" src=\"images/immutable_mutable.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"기본","level":2,"id":"기본_0"},{"heading":"함수 Arguement 쓰는 법","level":2,"id":"함수_Arguement_쓰는_법_0"},{"heading":"조건문, 반복문","level":2,"id":"조건문,_반복문_0"},{"heading":"스트링","level":2,"id":"스트링_0"}],"links":[],"author":"","coverImageURL":"images/immutable_mutable.png","fullURL":"ios/objective-c.html","pathToRoot":"..","attachments":["images/immutable_mutable.html"],"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":5349,"sourcePath":"iOS/Objective - C.md","exportPath":"ios/objective-c.html","showInTree":true,"treeOrder":345,"backlinks":[],"type":"markdown"},"ios/orientation.html":{"title":"Orientation","icon":"","description":"Project - Target - General - Deployment Info에서 iPhone Orientation을 체크 / 체크해제를 할 수 있다.이것을 체크 하게 되면 동일한 효과를 얻는다.\n// AppDelegate.swift func application( _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow? ) -&gt; UIInterfaceOrientationMask { return // 체크한 항목들 } supportedInterfaceOrientations를 지정하면 아이폰에서 '자동 화면 회전'을 설정한 경우 아이폰을 어떻게 잡고 있느냐에 따라서 해당하는 InterfaceOrientation으로 화면이 회전 된다. LandscapeRight로 고정을 했는데 SFSafariViewController에서 애플로그인을 하고 돌아온 다음에 화면이 Portrait이 되는 경우가 있다고 함. AppDelegate에 접근해서 InterfaceOrientation을 LandscapeRight로 다시 변경하면 된다. // AppDelegate.swift\nimport UIKit\n@main class AppDelegate: UIResponder, UIApplicationDelegate { @objc var allList: UIInterfaceOrientationMask = .portrait func application( _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow? ) -&gt; UIInterfaceOrientationMask { return allList } } Swift private func rotate() { let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene (UIApplication.shared.delegate as! AppDelegate).allList = .landscapeRight if #available(iOS 16.0, *) { debugPrint(\"above 16.0\") windowScene?.requestGeometryUpdate(.iOS(interfaceOrientations: .landscapeRight)) self.setNeedsUpdateOfSupportedInterfaceOrientations() } else { debugPrint(\"below 16.0\") let value = UIDeviceOrientation.landscapeRight.rawValue UIDevice.current.setValue(value, forKey: \"orientation\") } }\nObjective-C- (void)rotate:(UIButton *)button { AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate]; UIInterfaceOrientationMask e = UIInterfaceOrientationMaskLandscapeRight; appDelegate.allList = e; NSNumber *value = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeRight]; [[UIDevice currentDevice] setValue:value forKey:@\"orientation\"]; }\n샘플 프로젝트에서 SFSafariViewController에서 돌아올 때 화면 전환이 되는 버그를 재현할 순 없었지만 화면 전환은 위의 코드를 사용 했을 때 쉽게 바꿀 수 있었다. 주의해야할 점은 AppDelegate에 있는 supportedInterfaceOrientationsFor를 먼저 바꿔주고 setValue를 하거나 화면 업데이트를 해줘야 한다는 점이다.그리고 추가적으로 UIInterfaceOrientation과 UIInterfaceOrientationMask 차이점이다.\nUIInterfaceOrientation is Constants that specify the orientation of the app's user interface.\nUIInterfaceOrientation는 enum value이고 App의 user interface라고 한다.\nUIInterfaceOrientationMask is Constants that specify a view controller’s supported interface orientations.\nUIInterfaceOrientationMask ViewController의 interface orientation이라고 한다.UIInterfaceOrientation은 처음 앱의 interface orientation이고 최상위 뷰컨트롤러인 UIWindowScene의 interface orientation이다. UIViewController에서 UIInterfaceOrientation인 interfaceOrientation은 deprecated여서 사용할 수 없고 아래처럼 windowScene에서 접근할 수 있다. read-only value라 바꿀 순 없다.let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene windowScene.interfaceOrientation 이러한 interfaceOrientation을 바꾸기 위해서 사용하는게 바로 UIInterfaceOrientationMask다.\nUIInterfaceOrientationMask는 바꿀 방향을 표시하는 bitmask다. SDK에게 어떤 방향으로 바꿀거에요. 라고 알려줄 때 사용하는 프로퍼티다. 그리고 화면 전환을 하면 된다.여담으로 이건 버그인 것 같은데, AppDelegate에서 supportedInterfaceOrientationsFor에서 portrait를 제외하면 추후 화면전환을 사용할 수 없다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Situation","level":3,"id":"Situation_0"},{"heading":"Task","level":3,"id":"Task_0"},{"heading":"Action","level":3,"id":"Action_0"},{"heading":"Result","level":3,"id":"Result_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ios/orientation.html","pathToRoot":"..","attachments":[],"createdTime":1710855209769,"modifiedTime":1710855209769,"sourceSize":4212,"sourcePath":"iOS/Orientation.md","exportPath":"ios/orientation.html","showInTree":true,"treeOrder":346,"backlinks":[],"type":"markdown"},"ios/photokit을-다뤄보자-(이론편).html":{"title":"PhotoKit을 다뤄보자 (이론편)","icon":"","description":"<img src=\"https://blog.kakaocdn.net/dn/5mg6k/btr3ft0Suio/SnPjEjZKMZu9EObJNZkfjK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">&nbsp;PhotoKit은 애플에서 자체적으로 제공하는 프레임워크로 사진 앱에서 관리하는 Asset(photo, Video)에 대해서 접근을 가능하게 해 줍니다. PhoKit을 이용하면 사진 앱에 있는 앨범에 접근하여 Asset들을 가져올 수 있습니다.PhotoKit의 객체는 PHObject 객체를 기본적으로 상속받습니다. PHObject는 Asset, Collection의 추상적인 superclass입니다.따라서 이 객체를 다룰 때, 직접적으로 생성하거나 사용해서는 안됩니다.&nbsp;대신에, 이 객체의 subclass인 PHAssectCollection, PHCollectionList, PHObjectPlaceHolder를 이용해서 개발을 해야 합니다.사진 앱에 있는 이미지, 비디오, 라이브 포토의 \"A representation\"입니다. 그러니까 사진, 비디오, 라이브 포토 하나하나가 PHAsset 인 셈입니다. PHAsset은 다음과 같은 특징을 가지고 있습니다.\nAsset은 class method인 fectchAssets()을 통해 개발을 시작할 수 있다.\nAsset은 메타데이터만을 가지고 있다.\nAsset은 immutable이다. (불변성을 가진다.)\nPhotos Asset Collections과 Collection Lists의 superclass입니다.이것 역시 PHObject처럼 직접적으로 create 하거나 인스턴스로 작업을 할 수 없습니다. 대신에 이것의 subclass인 PHAssetCollection 또는 PHCollectionList로 작업을 할 수 있습니다.PHCollection을 상속받습니다. PHAssetCollection은 쉽게 말하면 앨범입니다. (Photos asset grouping)Photo 프레임워크 안에 있는 Collection Object들은 member object를 직접 참조할 수 없고, 어떠한 object들도 collection object들을 직접 참조할 수 없습니다. Asset Collection의 member를 가지고 오려면, PHAsset class method를 이용해서 fetch 해야 합니다. 이것 또한 Assets과 Collection List와 마찬가지로 immutable 하기 때문에 create, rename... 기타 등등 작업을 하기 위해서 PHAssetCollectionChangeRequest Object를 사용해서 Photo Library를 업데이트해야 합니다.여러 개의 Photo Asset Collection을 리스트화한 것입니다. ( 예를 들면 기억에 나는 순간들, 연별 폴더 등 같은 것들입니다.)위의 PHAssetCollection처럼 멤버들을 직접 참조할 수 없고 직접 참조될 수 없습니다. member를 가지고 오려면 PHCollection class method를 이용해서 fetch 해야 합니다. 또한 역시 immutable 하기 때문에, PHCollectionListChangeRequest를 이용해서 업데이트해야 합니다.이 메서드를 사용하면 PHAsset, PHCollection에서 An ordered list of asset and collection을 가져올 수 있습니다.Fetch를 어떻게 할 것인가에 대한 option class이다.\n요약 및 정리 PHObject, PHCollection\nPHAsset(사진, 비디오, 라이브포토), PHAssetCollection(앨범), PHCollectionList(앨범목록)&nbsp; superclass(PHObject, PHCollection)를 직접 create 하거나, Instance를 사용하는 것은 불가능 사진, 비디오, 라이브 포토를 다루기 위해서는 하위 클래스들의 fetchMethod를 이용해서 retrive 해야만 함. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"What is PhotoKit?","level":3,"id":"What_is_PhotoKit?_0"},{"heading":"PHObject","level":3,"id":"PHObject_0"},{"heading":"PHAsset","level":3,"id":"PHAsset_0"},{"heading":"PHCollection","level":3,"id":"PHCollection_0"},{"heading":"PHAssetCollection","level":3,"id":"PHAssetCollection_0"},{"heading":"PHCollectionList","level":3,"id":"PHCollectionList_0"},{"heading":"PHFetchResult","level":3,"id":"PHFetchResult_0"},{"heading":"PHFetchOptions","level":3,"id":"PHFetchOptions_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/5mg6k/btr3ft0Suio/SnPjEjZKMZu9EObJNZkfjK/img.png","fullURL":"ios/photokit을-다뤄보자-(이론편).html","pathToRoot":"..","attachments":[],"createdTime":1735622405574,"modifiedTime":1735622438849,"sourceSize":3385,"sourcePath":"iOS/PhotoKit을 다뤄보자 (이론편).md","exportPath":"ios/photokit을-다뤄보자-(이론편).html","showInTree":true,"treeOrder":347,"backlinks":[],"type":"markdown"},"ios/photokit을-다뤄보자-(커스텀-코드편).html":{"title":"PhotoKit을 다뤄보자 (커스텀 코드편)","icon":"","description":"이번에는 직접 Photo 프레임워크를 이용해서 사용자의 앨범에 접근을 해서 collectionView에 사진을 불러오고 카메라에 접근을 해서 촬영을 하고 촬영한 이미지를 불러오겠습니다.&nbsp;컬렉션 뷰의 첫 번째 아이템(카메라 이미지)을 선택해서 카메라로 넘어가서 촬영하거나, 그 외 아이템을 클릭하면 해당하는 이미지를 헤더에 띄우는 것입니다. PhoKit의 사용법을 알면 다음과 같은 화면을 구현할 수 있게 됩니다. 인스타그램 업로드 화면 같은 뷰인데, 이미지를 띄우는 것 자체는 정말 간단합니다. 스크롤을 다룰 경우 좀 복잡해지는 것 같습니다.&nbsp;<img src=\"https://blog.kakaocdn.net/dn/duKNv8/btr3IYRGSGx/uL1BCd1x4FYtj26p5jHsy0/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">중요! 구현 하기에 앞서 앱이 유저의 카메라와, 앨범에 접근하려면 권한이 필요합니다. Info.plist로 이동해서 Key들을 추가해 주세요.<br><img src=\"https://blog.kakaocdn.net/dn/RdKg1/btr3ky1Qbev/AJH4esSzjKHQ6Po2hfAjmk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">검정 버튼이 있는 화면을 TempViewController라고 작명할게요. 화면 전환을 했을 때, 사진들이 Load 되어 있는 컬렉션 뷰가 나타나게 하기 위해서 저는 이전 화면인 TempViewController에서 미리 Fetch를 하겠습니다. 저는 viewDidLoad에서 fetchAsset()을 했는데, 버튼을 클릭했을 때 비동기처리를 하는 것, TestCollectionViewController의 생성자로 PHAsset를 주입하는 것이 더 좋은 코드였겠죠? Sample 앱이라 그냥 넘어가도록 하겠습니다.&nbsp;제가 구현한 fetchAsset() 함수 내부를 살펴보면, PHFetchOptions()의 Instance를 생성하고 옵션 값을 여러 가지 설정하고 PHAsset의 class function인 fetchAssets() 사용하는 걸 알 수 있습니다. 이론 편에서 확인한 PHObject 같은 것들은 저희는 코드 내에서 직접 작성하는 경우가 거의 없다고 할 수 있습니다. 그 하위 클래스인 PHAsset만을 사용하는 것이죠. 특이한 점은 Instance를 생성하지 않는 것입니다. 사실 아이폰 사진 앱 기능을 생각해 보면 더 효율적이라는 생각이 들긴 드네요. 안드로이드 개발을 잠깐 찾아봤을 때, 흩어져있는 사진들을 모으는 게 좀 힘들었다고 본 것 같습니다. 아이폰 같은 경우는 모든 사진이 앨범에 모이기 때문에 애플 측에서 이런 방식으로 구현한 게 아닐까 싶습니다.&nbsp;import Photos\nimport UIKit class TempVC: UIViewController { let btn: 생략 var allPhotos: PHFetchResult&lt;PHAsset&gt;! override func viewDidLoad() { super.viewDidLoad() //...// fetchAsset() } private func fetchAsset() { let allPhotoOptions = PHFetchOptions() allPhotoOptions.sortDescriptors = [NSSortDescriptor(key: \"creationDate\", ascending: true)] allPhotos = PHAsset.fetchAssets(with: allPhotoOptions) } private func tapButton() { var navigationController: UINavigationController let targetVC = TestCollectionViewController() // 여기가 핵심. targetVC에 있는 변수인 fetchResult에 넘겨준다. targetVC.fetchResult = allPhotos navigationController = UINavigationController(rootViewController: targetVC) navigationController.modalPresentationStyle = .fullScreen present(navigationController, animated: true) } }\n다음으로는, PHFetchResult을 넘겨받아서 이미지를 collectionView에 띄어주는 ViewController를 구현하겠습니다. collectionView생성 및 화면 배치는 다들 익숙하니까 생략하도록 할게요.&nbsp;이전 챕터에서 언급했듯이, fetchResult의 결과는 메타데이터(정보)입니다. 실제 이미지를 받아 와야 하므로 이것을 기반으로 Image를 요청해야 합니다. 그러기 위해서 PHImageManager라는 것이 필요합니다. PHImageManger에 구현되어 있는 method requestImage를 통해 이미지를 받아올 수 있습니다.&nbsp;class TestCollectionViewController: UIViewController { // UIComponent var pictureCV = UICollectionView().then { } // Variable &amp; properties var fetchResult: PHFetchResutl&lt;PHAsset&gt;! var photoImage: UIImage? // 여기에 카메라로 찍은 사진 저장 fileprivate let imageManager = PHImageManager() fileprivate var thumbnailSize: CGSize! //MARK: - View Life Cycle override func viewDidLoad() { super.viewDidLoad() //...생략 // } override func viewWillAppear(_ animated: Bool) { let scale = UIScreen.main.scale let cellSize = pictureCV.size thumbnailSize = CGSize(width: cellSize.width * scale, height: cellSize.height * scale) }\n}\nextension TestCollectionViewController: UICollectionViewDataSource { func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { return fetchResult.count + 1 // 카메라 이미지를 넣어야 하기 때문에, } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { guard let pictureCell = collectionView.dequeueReusableCell(withReuseIdentifier: \"PictureCell\", for: indexPath) as? PictureCell else { return UICollectionViewCell() } if indexPath.item == 0 { pictureCell.thumbnailImage = UIImage(systemName: \"camera\") return pictureCell } else { let asset = fetchResult.object(at: (indexPath.item)-1 ) pictureCell.representedAssetIdentifier = asset.localIdentifier imageManager.requestImage(for: asset, targetSize: thumbnailSize, contentMode: .aspectFill, options: nil, resultHandler: { image, _ in if pictureCell.representedAssetIdentifier == asset.localIdentifier { pictureCell.thumbnailImage = image } }) return pictureCell } }\n}\n&nbsp; 여기에서 가장 중요한 부분은 당연하게 cellForItemAt 부분입니다. 이미지를 불러오기 위해서는 다음과 같은 작업이 필요합니다.&nbsp;\n이전 화면에서 넘겨받은 fetchResult의 메타데이터를 가지고 imageManager를 통해서 요청하면 CallBack 형식으로 UIImage에 접근할 수 있습니다.그리고 코드를 확인해 보면 Asset의 localIdentifier(메타데이터)가 보이는데, 이 프로퍼티는 Unique 합니다. 이 부분을 잘 이용하면, Cell 이벤트를 잘 처리할 수 있을 것 같습니다.마지막으로 카메라 이미지를 선택했을 때 이미지에 접근하는 법입니다. 애플에서 제공하는 UIImagePickerComtroller를 사용하게 되면, UIImagePickerControllerDelegate를 통해서 클로저로 간단하게 Image에 접근할 수 있습니다. 커스텀할 필요가 없다면 사용하는 것이 좋을 것 같습니다.class TestCollectionViewCotroller: UIViewController { ///...// func didTapCamera() { let camera = UIImagePickerController() camera.sourceType = .camera camera.cameraDevice = .rear camera.cameraCaptureMode = .photo camera.delegate = self present(camera, animated: true, completion: nil) } } extension TestCollectionViewCotroller: UIImagePickerControllerDelegate &amp; UINavigationControllerDelegate { func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) { // 미디어 종류 확인 let mediaType = info[UIImagePickerController.InfoKey.mediaType] as! NSString // 미디어가 사진이면 if mediaType.isEqual(to: kUTTypeImage as NSString as String){ // 사진을 가져옴 let captureImage = info[UIImagePickerController.InfoKey.originalImage] as! UIImage // 사진을 포토 라이브러리에 저장. 안하려면 없애주면 된다. UIImageWriteToSavedPhotosAlbum(captureImage, self, nil, nil) photoImage = captureImage } // 현재의 뷰(이미지 피커) 제거 self.dismiss(animated: true, completion: { self.didTapReset() let targetVC = tempCV() targetVC.photoImage = self.photoImage self.navigationController?.pushViewController(targetVC, animated: true) }) } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { self.dismiss(animated: true, completion: nil) } }\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/duKNv8/btr3IYRGSGx/uL1BCd1x4FYtj26p5jHsy0/img.gif","fullURL":"ios/photokit을-다뤄보자-(커스텀-코드편).html","pathToRoot":"..","attachments":[],"createdTime":1735622444833,"modifiedTime":1735622471118,"sourceSize":8702,"sourcePath":"iOS/PhotoKit을 다뤄보자 (커스텀 코드편).md","exportPath":"ios/photokit을-다뤄보자-(커스텀-코드편).html","showInTree":true,"treeOrder":348,"backlinks":[],"type":"markdown"},"ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html":{"title":"Scalable Application 설계부터 구현까지 - (0) 대략의 설계","icon":"","description":"퇴사를 하고 졸업을 위해 학교에 복학하게 되었는데, 왜인지 모르게 개인 프로젝트를 진행해야 할 것 같은 느낌이 듭니다. 그래서 확장 가능한 어플리케이션을 만들어보겠습니다. 꽤나 장기 프로젝트, 포스팅이 될 것 같은데 꾸준히 이어나가도록 할게요. 사실 어떤 어플리케이션을 만들지는 아직 생각하지는 않았습니다. 정해지지 않았어요. 하지만 아직 아이디어가 없어도 어떤 방식으로 개발을 할 수 있을지는 충분히 가능하기 때문에 선 블로그 포스팅을 먼저 하도록 하겠습니다.요즘 어플리케이션 개발에 대한 생각이 바뀌었습니다. 예전에는 화려한 기술 스택, 어려운 프레임워크 사용하는 것을 선망했고 도입하기 위해 정말 애썼는데 정작 중요한 것을 많이 놓쳤다는 느낌을 받았습니다. 그래서 이번에는 기준을 잡고 천천히 기초를 다지면서 어플리케이션을 개발하려고 합니다.&nbsp;(하지만 쓰고 싶은 라이브러리는 쓰겠습니다.)처음부터 완벽할 수는 없다고 생각합니다. 특히나 저에게는요. 그래서 먼저 얼개를 draw.io를 통해서 그릴 것입니다.그리고 아이디어가 확정이 되면 어떤 기능들 필요한 지 생각해보고 이에 맞게 의존성을 수정하려고 합니다. 한번 그려볼게요.<img src=\"https://blog.kakaocdn.net/dn/coJPBI/btr7d9RpZ60/80trKYFfJ6fjchcRMwKmoK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\nApplication: App 전체에 관한 Project 입니다. UIKit인 경우에 AppDelegate, SceneDelegate가 존재합니다. 최상단 모듈이기 때문에 아래에 있는 모듈을 import 해서 접근할 수 있습니다. 따라서 이 모듈에서 우리의 어플리케이션이 작동하게 될 것입니다.\n기능: 문자 말그대로 기능이 있는 모듈입니다. 예를 들면 검색이 될 수 있고, 채팅이 될 수 있습니다. 이 기능들은 UI를 가질 수도 있고 가지지 않을 수도 있습니다. Dependency: 모든 기능들은 이 Base를 가져야 합니다. 모듈 간의 결합을 도와주는 모듈로도 사용할 수 있습니다.&nbsp; Network: 서버 통신을 위한 모듈입니다. 이 모듈에 Network Layer가 존재합니다. Design: DesignSystem에 대한 모듈입니다. 이곳에 각종 Asset과 UIComponent를 넣도록 하겠습니다. Util: 개발 효율을 높여주는 모듈입니다. 각종 Extension에 대한 소스를 가지고 있습니다. 사실 글의 첫 시작은 Tuist로 시작하려고 했는데 Tuist에 대해서 글을 쓰려면 대략적으로 제가 어떤 방식으로 설계를 했는지 알아야 될 것 같아서 짧은 글이지만 0번으로 작성하게 되었습니다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"설계","level":4,"id":"설계_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/coJPBI/btr7d9RpZ60/80trKYFfJ6fjchcRMwKmoK/img.png","fullURL":"ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html","pathToRoot":"..","attachments":[],"createdTime":1735623124626,"modifiedTime":1735623128411,"sourceSize":2855,"sourcePath":"iOS/Scalable Application 설계부터 구현까지 - (0) 대략의 설계.md","exportPath":"ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html","showInTree":true,"treeOrder":349,"backlinks":[],"type":"markdown"},"ios/scalable-application-설계부터-구현까지-(1)-tuist.html":{"title":"Scalable Application 설계부터 구현까지 - (1) Tuist","icon":"","description":"확장 가능한 어플리케이션은 모듈을 빠르게 붙이고 뗄 수 있어야 합니다. 이것을 용이하게 해주는 것이 바로 Xcode Project 관리 도구인 Tuist입니다.\nTuist is a command line tool (CLI) that aims to facilitate the generation, maintenance, and interaction with Xcode projects. It's distributed as a binary, which you can easily install and use without having to depend on other tools to manage dependencies (like you would do if the tool was written in other programming languages such as Ruby, or Java) Tuist는 Xcode 프로젝트의 생성, 유지보수 및 상호 작용을 용이하게 하는 것을 목표로 하는 CLI(명령줄 도구)입니다. 종속성을 관리하기 위해 다른 도구에 의존하지 않고 쉽게 설치하고 사용할 수 있는 이진 파일로 배포됩니다(Ruby 또는 Java와 같은 다른 프로그래밍 언어로 작성된 경우처럼).\n.\n설치 방법과 간단한 사용 방법은 Tuist 공식 홈페이지를 참고해 주세요.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://tuist.io/\" target=\"_self\">https://tuist.io/</a>Tuist is a tool that helps developers manage large Xcode projects by leveraging project generation. Moreover, it provides some tools to automate most common tasks, allowing developers to focus on building apps.<br>tuist.io](<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://tuist.io/\" target=\"_self\">https://tuist.io/</a>)&nbsp;Tuist는 Xcode 프로젝트를 빠르게 구성하는 걸 도와주는 아주 유용한 툴입니다. 높은 러닝 커브라는 단점이 존재하지만 그것을 무색하게 할 만큼 많은 장점들이 있습니다. 제가 직접 체감한 건 다음과 같아요.\nGit Conflict이 적습니다. iOS 개발할 때 .xcodeproj에서 생각보다 많이 충돌이 일어나는데 Tuist를 사용하면 이를 현저히 줄여줍니다. 정신 건강에 좋아요. 모듈화를 하는데 용이합니다.(Xcode Project에서 SPM을 추가해서 모듈화를 해본 적이 있는데 확실히 Tuist를 이용해서 Project 단위로 모듈화를 하는 게 더 간단한 것 같아요.) Swift로 프로젝트 설정이 가능합니다. 비슷한 툴인 XcodeGen은 yaml로 파일을 작성한다고 합니다. yaml을 당연히 학습해야겠죠? 구조를 확장할 때 용이합니다. 어플리케이션이 커질수록 설정들도 많아지긴 마련인데 이를 플러그인을 이용해서 가독성 있게 프로젝트를 관리할 수 있습니다. 모듈 간의 관계를 나타내는 그래프 기능 덕분에 구조 파악이 용이합니다.\n그리고 시간을 들여 Tuist Template를 만들어 놓으면 다음부터 빠르게 어플리케이션 개발을 세팅된 상태에서 할 수 있습니다.아래 명령어를 이용해서, Tuist를 설치합니다.&nbsp;curl -Ls https://install.tuist.io | bash\n프로젝트를 생성할 폴더를 생성하고 그 폴더로 이동해서 tuist project를 시작합니다.mkdir tuist-template-for-scalable-app\ncd tuist-template-for-scalable-app\ntuist init --platform ios\ntree 명령어를 이용하면 아래와 같이 폴더 및 파일들이 생성된 걸 알 수가 있어요.&nbsp;tree .\n├── Plugins\n│&nbsp;&nbsp; └── TuistTemplateForScalableApp\n│&nbsp;&nbsp; ├── Package.swift\n│&nbsp;&nbsp; ├── Plugin.swift\n│&nbsp;&nbsp; ├── ProjectDescriptionHelpers\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── LocalHelper.swift\n│&nbsp;&nbsp; └── Sources\n│&nbsp;&nbsp; └── tuist-my-cli\n│&nbsp;&nbsp; └── main.swift\n├── Project.swift\n├── Targets\n│&nbsp;&nbsp; ├── TuistTemplateForScalableApp\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Resources\n│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── LaunchScreen.storyboard\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Sources\n│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── AppDelegate.swift\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── Tests\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── AppTests.swift\n│&nbsp;&nbsp; ├── TuistTemplateForScalableAppKit\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Sources\n│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── TuistTemplateForScalableAppKit.swift\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── Tests\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── TuistTemplateForScalableAppKitTests.swift\n│&nbsp;&nbsp; └── TuistTemplateForScalableAppUI\n│&nbsp;&nbsp; ├── Sources\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── TuistTemplateForScalableAppUI.swift\n│&nbsp;&nbsp; └── Tests\n│&nbsp;&nbsp; └── TuistTemplateForScalableAppUITests.swift\n└── Tuist ├── Config.swift └── ProjectDescriptionHelpers └── Project+Templates.swift\ntuist edit\n이 디렉토리에서 tuist edit을 입력하면, Xcode 창이 뜨는데요. 이곳에서 우리가 개발할 어플리케이션에 대한 설정을 하는 겁니다. 기능들과 모듈들에 대한 것들은 Manifests Project에서 작성할 것입니다. 이것을 작성하기 전에 기능, 모듈들을 구성하기 쉽게 해주는 Plugins부터 작성하도록 하겠습니다.플러그인을 이용하면 가독성 있게 쉽게 프로젝트를 관리할 수 있습니다. Plugins를 끝까지 열면 ProjectDescription 폴더가 있는데 이곳에&nbsp;swift file을 생성하고 코드를 작성합니다.여기에서 작성한 코드들을 실제 모듈을 생성하는 코드를 작성할 때 사용하게 됩니다. 이 코드가 유용한 모듈을 생성하는 함수가 String을 parameter로 많이 필요로 합니다. 이게 모듈이 증가하게 되면 관리하기가 불편해져서, extension을 추가해서 사용하면 아주 편해집니다.한번 맛보기로 비교를 해볼까요. 왼쪽이 플러그인 사용 전이고, 오른쪽이 후입니다. 사실 왼쪽에 있는 코드도 extension을 이용해서 많이 줄인 것임에도 불구하고 오른쪽에 비하면 예쁘지 않네요. String을 그대로 넣다 보니까 재사용하기도 불편해 보이기도 하고요.<br><img src=\"https://blog.kakaocdn.net/dn/DBaUZ/btr7gSU98iI/dM9KZsQN5ZAAnhkZXErBSK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/An4BP/btr7e1STAEj/ZsPgiwRdJKdXagRryfzwY1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">플러그인 사용 전(왼), 플러그인 사용 후(오)그러면 플러그인에 어떤 코드를 작성해야 할까요? 많은 Sugar 코드가 있지만 TargetDependency에 관한 extension이 가장 중요하다고 생각합니다. 그도 그럴 것이 Tuist를 이용해서 App을 만든다는 것은 보통 모듈화를 염두에 두었다는 것이고 이는 필연적으로 의존성을 잘 핸들링해야 한다는 것을 의미하게 됩니다.첫 번째로 할 것은 이름이 너무 긴 TargetDependency를 \btypealias 걸어서 Dep으로 하겠습니다. 그러면 앞으로 우리는 TargetDependency라는 것 대신에 Dep이라는 이름으로 사용할 수 있게 되겠죠? 그다음으로는 Dep에 대한 Path 설정을 자동 완성으로 쉽게 접근하고 싶기 때문에 Path + Extension을 만들도록 하겠습니다.// Alias.swift import Foundation\nimport ProjectDescription public typealias Dep = TargetDependency import Foundation\nimport ProjectDescription // Path + Extension.swift public extension ProjectDescription.Path { static func relativeToModule(_ pathString: String) -&gt; Self { return .relativeToRoot(\"Projects/Modules/\\(pathString)\") } static func relativeToFeature(_ pathString: String) -&gt; Self { return .relativeToRoot(\"Projects/Features/\\(pathString)\") } static func relativeToApplication(_ pathString: String) -&gt; Self { return .relativeToRoot(\"Projects/Application/\\(pathString)\") } static var app: Self { return .relativeToRoot(\"Projects/Application\") }\n}\n그리고 Dep(TargetDependency)는 Project가 될 수도 있고, xcframework가 될 수도 있고, target이 될 수도 있고 등등이 될 수 있습니다. 위에서 언급했듯이, Project로 구성할 것이기 때문에 이와 관련된 코드도 작성하도록 하겠습니다.// Dep + Extension.swift extension Dep { static func module(name: String) -&gt; Self { return .project(target: name, path: .relativeToModule(name)) } static func feature(name: String) -&gt; Self { return .project(target: name, path: .relativeToFeature(name)) }\n}\n다음으로는 Application이 의존성을 가질 Feature들에 대한 것을 확장을 할거예요. Feature들도 당연히 Dep(TargetDependency)입니다. 위 왼쪽 사진에서 보면 .project(~~~) 이런식으로 들어가는데, 오른쪽은 깔끔하게 . 을 이용해 깔끔하게 접근할 수 있는 걸 볼 수 있어요.&nbsp;// Dep + Project.swift import Foundation\nimport ProjectDescription extension Dep { public struct Project { public struct Feature { } public struct Module { } }\n} public extension Dep.Project.Feature { static let Main = Dep.feature(name: \"Main\") } public extension Dep.Project.Module { static let Util = Dep.module(name: \"Util\") static let ThirdPartyWrapper = Dep.module(name: \"ThirdPartyWrapper\") static let Networkit = Dep.module(name: \"NetworkKit\") static let Design = Dep.module(name: \"Design\")\n}\n마지막으로 외부의존성에 관한 확장 코드를 작성할 거에요. Tuist에서 공식적으로 지원하는 외부 의존성은 크게 네 가지예요.\nCarthage\nXcode Swift Package Manager (Package)\nTuist Swift Package Manager (External)\nFramework\nSPM이 두 개라서 조금 이상한 것 같기도 합니다.Carthage와&nbsp;Tuist&nbsp;Swift Package Manager는 Dependencies.swift에서 작성하면 Tuist가 이를 처리해서 프레임워크로 만들어서 사용합니다.&nbsp;Xcode&nbsp;Swift Package Manager는 Project에 Package가 바로 들어갑니다. (우리가 평소 사용하는 SPM을 떠올리시면 될 것 같아요.) Tuist SPM을 사용하고 external을 하면 그래프에 안 그려지는 이슈가 있어서 저는 package를 이용하도록 하겠습니다. Carthage나 local xcframework를 사용하는 경우에도 같은 방식으로 확장해 주시면 되겠습니다.// Dep+SPM.swift import Foundation\nimport ProjectDescription extension Dep { public struct SwiftPM { }\n} public extension Dep.SwiftPM { static let Alamofire = Dep.package(product: \"Alamofire\")\n} public extension Package { static let Alamofire = Package.package(url: \"https://github.com/Alamofire/Alamofire.git\", from: \"5.6.4\")\n}\n여기까지가 유용한 기본적인 플러그인입니다. 이제 모듈을 생성하는 코드를 작성해 보도록 합시다.&nbsp;기억이 정확한 건 아닌데, 객체지향프로그래밍 수업을 들을 때 교수님께서 manifest를 언급하셨던 것 같습니다. A를 맞기 위해 6~7년 전 자바를 열심히 했던 기억이 있네요.&nbsp; 매니페스트는 무엇일까요?\n매니페스트 파일(manifest file)은&nbsp;\n컴퓨팅에서 집합의 일부 또는 논리 정연한 단위인 파일들의 그룹을 위한 메타데이터를 포함하는 파일\n이다. 예를 들어, 컴퓨터 프로그램의 파일들은 이름, 버전 번호, 라이선스, 프로그램의 구성 파일들을 가질 수 있다. - 위키백과 Manifests에 파일을 생성하는 것은 모듈에 관한 메타데이터를 작성하는 것입니다. tuist generate를 통해서 실제로 생성하는 것이고요.그러면 Manifest file을 작성합시다.&nbsp;Tuist에서 manifest file은 무조건 Project.swift라는 이름으로 생성해야 해요. 그래서 모듈을 하나 추가한다고 하면 폴더를 하나 만들고 그 안에 Project.swift를 만들면 되는 것입니다.&nbsp;그전에 file을 하나 추가하도록 할게요. 위치는 Mainfests Project 안에 있는 Tuist/ProjectDescriptionHelper에 생성하면 됩니다. 이 파일은 Project에 기본값을 추가해서 반복적인 코드를 좀 줄여줄 수 있어요. 쭉 읽어보면 어떤 내용인 지 감 잡으실 수 있을 것 같아요.// Project+Templates.swift import ProjectDescription\nimport MyPlugin public extension Project { static func project(name: String, organizationName: String = \"YourOrganizationName\", options: Options = .options(), packages: [Package] = [], product: Product, platform: Platform = .iOS, deploymentTarget: DeploymentTarget? = .iOS(targetVersion: \"15.0\", devices: .iphone), dependencies: [Dep] = [], infoPlist: [String: InfoPlist.Value] = [:], sources: SourceFilesList = [\"Sources/**\"], resources: ResourceFileElements = [\"Resources/**\"], scriptAction: [TargetScript] = [], resourceSynthesizers: [ResourceSynthesizer] = []) -&gt; Project { let settings: Settings = Settings.settings() let bundleID = product == .app ? \"com.YourAppName\" : \"com.\\(organizationName).\\(name)\" let isEnableResource = (product == .app || product == .framework) let target = Target(name: name, platform: platform, product: product, bundleId: bundleID, deploymentTarget: deploymentTarget, infoPlist: .extendingDefault(with: infoPlist), sources: sources, resources: isEnableResource ? resources : [], scripts: scriptAction, dependencies: dependencies) let testTargetDependencies: [Dep] = [.target(name: \"\\(name)\")] let testTarget = Target(name: \"\\(name)Tests\", platform: platform, product: .unitTests, bundleId: \"\\(bundleID)Tests\", deploymentTarget: deploymentTarget, infoPlist: .default, sources: \"\\(name)Tests/**\", dependencies: testTargetDependencies) let targets: [Target] = [target, testTarget] return Project(name: name, organizationName: organizationName, options: options, packages: packages, settings: settings, targets: targets, resourceSynthesizers: resourceSynthesizers) }\n}\n이제 본격적으로 진짜로 Manifest file(Project.swift)를 작성해 봐요. Manifest 폴더 아래에 Projects라는 폴더를 생성할게요. 이곳에 모듈에 관한 Project.swift 들을 만들어줄 거예요. 그리고 Projects 폴더 안에 Application 폴더를 만들고 그 하위에 Project.swift 파일을 만들겠습니다. 다음처럼 되겠습니다.<br><img src=\"https://blog.kakaocdn.net/dn/Jq0wH/btr7gy3Kjpl/7LRPMwWPXYkhAY7NAzjnak/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">// Project.swift (Application 폴더) import Foundation\nimport ProjectDescription\nimport ProjectDescriptionHelpers\nimport MyPlugin let project = Project.project( name: \"Application\", product: .app, dependencies: [ Dep.Project.Feature.Main ]\n)\n이렇게 하면 모듈 하나의 메타데이터를 작성한 것이고 tuist generate를 하게 되면 모듈 하나를 생성할 수 있게 됩니다. 여기까지 오는데 플러그인도 만들고 힘들었지만 그 대가로 앞으로 엄청 편하게 모듈을 확장할 수 있게 되었어요.&nbsp; 같은 방식으로 Main 기능 모듈을 만들겠습니다.// Project.swift (Projects/Features/Main 안에) import Foundation\nimport ProjectDescription\nimport ProjectDescriptionHelpers\nimport MyPlugin let project = Project.project( name: \"Main\", product: .framework, dependencies: [ ]\n)\n이번에는 product가 .framework 입니다. 이것은 개발에 따라 달라지는 거라 적절히 선택해 주시면 되겠습니다. 그러면 Project.swift 파일에 메타데이터들을 다 입력했으니 generate를 하면 되겠네요. 그전에. xcodeproj를 한 번에 관리하고 싶으니 xcworkspace부터 만들어주도록 하겠습니다. tuist edit을 해서 Manifests 폴더 아래에 Projects, Tuist 폴더와 같은 레벨로 Workspace.swift를 생성해 주시면 됩니다.import Foundation\nimport ProjectDescription let workspace = Workspace( name: \"Application\", projects: [ \"Projects/Application\" ], generationOptions: .options( enableAutomaticXcodeSchemes: false, autogeneratedWorkspaceSchemes: .disabled, lastXcodeUpgradeCheck: nil, renderMarkdownReadme: false )\n)\n그러고 나서 이제 어플리케이션을 생성해 보도록 할게요. 'tuist generate'를 입력하면The target Application has the following invalid source files globs:\n- The directory \"/tuist-template-for-scalable-app/Projects/Application/Sources\" defined in the glob pattern \"/tuist-template-for-scalable-app/Projects/Application/Sources/**\" does not exist.\nConsider creating an issue using the following link: https://github.com/tuist/tuist/issues/new/choose\n이런 에러가 발생할 거예요. 왜냐하면 모듈을 생성할 때, 소스 파일들이 필요하고 그것들의 위치를 정했는데 해당 Path에 소스파일들이 없어서입니다. 해당 Path로 가서 파일들을 붙여 넣기 하면 해결되는 문제입니다. 다만 모듈이 엄청 많다고 가정하면 일일이 붙여넣기 하는 게 귀찮을 수가 있어요. 그래서 tuist가 제공하는 scaffold 기능을 이용하면 됩니다. scaffold 기능을 이용하면 템플릿을 만들어놓고 터미널 명령어로 인자를 받아서 해당 path에 원하는 파일들을 생성할 수가 있습니다.먼저 템플릿부터 만들어야 합니다. Tuist 폴더 아래에 Templates 폴더를 만들고 그 아래에 어떤 단어로 명령어를 만들지 정해서 .swift 파일을 만들면 되겠습니다. 저는 dummy라는 명령어로 만들겠습니다. tuist scaffold dummy -name// Templates/dummy/dummy.swift\nimport ProjectDescription let nameAttribute: Template.Attribute = .required(\"name\") let template = Template( description: \"Custom template\", attributes: [ nameAttribute ], items: [ .file( path: \"Projects/Features/\\(nameAttribute)/Sources/dummy.swift\", templatePath: \"dummy.stencil\" ), .file( path: \"Projects/Features/\\(nameAttribute)/Resources/dummy.swift\", templatePath: \"dummy.stencil\" ), .file( path: \"Projects/Features/\\(nameAttribute)/\\(nameAttribute)Tests/\\(nameAttribute)Tests.swift\", templatePath: \"Tests.stencil\" ), ]\n)\nAttribute는 인자값 설정입니다. required는 필수로 입력해줘야 하고, optional은 말 그대로 해도 되고 안 해도 되는데, 여기에서는 required로 하나만 사용하겠습니다. items에 생성할 file들의 path, 어떤 template를 사용할지 해당 stencil file의 Path를 작성합니다.&nbsp; {{ name }}이 아까 인자로 받은 그 값을 여기에 넣어주겠다는 것을 의미해요. 단! stencil file에 어떤 것이라도 입력해야 scaffold 할 때 생성되는 것 같아요.&nbsp; import XCTest final class {{ name }}Tests: XCTestCase { override func setUpWithError() throws { // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDownWithError() throws { // Put teardown code here. This method is called after the invocation of each test method in the class. } func testExample() throws { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. // Any test you write for XCTest can be annotated as throws and async. // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error. // Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards. } func testPerformanceExample() throws { // This is an example of a performance test case. self.measure { // Put the code you want to measure the time of here. } } }\n이제 scaffold를 위한 작업을 끝마쳤으니 파일들을 생성해 보도록 할게요.tuist scaffold dummy -name Main\n<br><img src=\"https://blog.kakaocdn.net/dn/370tB/btr7hyCUiWz/H8kgsejIf3Ztky0jNTMkzk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">다음과 같이 잘 생성되었어요. Application도 비슷한 방식으로 만들어주겠습니다. 이번에는 인자를 넣지 않았어요.// Template/app/app.swift import ProjectDescription let template = Template( description: \"Custom template\", attributes: [ ], items: [ .file( path: \"Projects/Application/Sources/AppDelegate.swift\", templatePath: \"AppDelegate.stencil\" ), .file( path: \"Projects/Application/Resources/dummy.swift\", templatePath: \"../dummy/dummy.stencil\" ), .file( path: \"Projects/Application/ApplicationTests/ApplicationTests.swift\", templatePath: \"AppDelegateTest.stencil\" ), ]\n)\n// Template/app/AppDelegate.stencil import UIKIt\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil ) -&gt; Bool { let vc = UIViewController() let window = UIWindow(frame: UIScreen.main.bounds) window.rootViewController = vc window.makeKeyAndVisible() self.window = window return true }\n} // Template/app/AppDelegateTests.stencil import XCTest final class AppDelegateTests: XCTestCase { override func setUpWithError() throws { // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDownWithError() throws { // Put teardown code here. This method is called after the invocation of each test method in the class. } func testExample() throws { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. // Any test you write for XCTest can be annotated as throws and async. // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error. // Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards. } func testPerformanceExample() throws { // This is an example of a performance test case. self.measure { // Put the code you want to measure the time of here. } } }\n$ tuist scaffold app\n<br><img src=\"https://blog.kakaocdn.net/dn/xfbnE/btr7C2JhRaS/eqQZlpsYTkp8W7WclmKlXk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">잘 생성되었네요. 이제 정말로 프로젝트들을 생성할 수 있어요.$ tuist generate\n<br><img src=\"https://blog.kakaocdn.net/dn/cFwBVJ/btr7s4OwCrR/cZy3vU0LGv5iZeYmMiab4K/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">프로젝트가 제대로 만들어졌고, 이제 이것을 바탕으로 Scalable Application을 설계하고 개발할 수 있게 되었습니다.정말 많은 것들을 했는데 한번 잘 만들어놓으면 다른 개발을 할 때 빠르게 시작할 수 있을 것 같습니다. 최대한 상세히 적다 보니 포스팅이 꽤 길어진 것 같아요. 저도 제 지식을 점검할 수 있어서 좋았고 scaffold 기능을 좀 더 잘 이용해 봐야겠다는 생각이 듭니다.&nbsp;<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/tuist-template-for-scalable-app\" target=\"_self\">https://github.com/psychehose/tuist-template-for-scalable-app</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"What is Tuist?","level":4,"id":"What_is_Tuist?_0"},{"heading":"Tuist를 사용하는 이유","level":3,"id":"Tuist를_사용하는_이유_0"},{"heading":"Tuist 시작하기","level":3,"id":"Tuist_시작하기_0"},{"heading":"Plugins","level":3,"id":"Plugins_0"},{"heading":"Manifests","level":3,"id":"Manifests_0"},{"heading":"tuist scaffold","level":4,"id":"tuist_scaffold_0"},{"heading":"GitHub","level":4,"id":"GitHub_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/DBaUZ/btr7gSU98iI/dM9KZsQN5ZAAnhkZXErBSK/img.png","fullURL":"ios/scalable-application-설계부터-구현까지-(1)-tuist.html","pathToRoot":"..","attachments":[],"createdTime":1735623139117,"modifiedTime":1739278187152,"sourceSize":24074,"sourcePath":"iOS/Scalable Application 설계부터 구현까지 - (1) Tuist.md","exportPath":"ios/scalable-application-설계부터-구현까지-(1)-tuist.html","showInTree":true,"treeOrder":350,"backlinks":[],"type":"markdown"},"ios/swift,-objective-c-interoperability.html":{"title":"Swift, Objective - C interoperability","icon":"","description":"Objective - C는 아직도 시장에서 꽤 큰 점유율을 가지고 있음\nSwift와 C++의 interoperability 가능 (WWDC23 - Mix Swift and C++) 신기능이라 아직 레퍼가 부족?Swift 코드베이스에 Objc 쓰기 -&gt; Objective-C Bridging Header\nObjc 코드베이스에 Swift 쓰기 -&gt; public과 open 키워드가 있는 객체들 자동으로 헤더로 생성framework를 개발할 때 공개해야할 API를 잘 설정해야함.Swift 코드 베이스에서 Objc를 사용할 것. 프레임워크 내부에서 ObjC API를 보고 사용할 수 있지만 이 프레임워크를 사용하는 외부는 Objc 코드를 볼 수 있음엄브렐라 헤더에 Objc 해더를 임포트하고 Build phrase에서 public으로 바꾸기그런 다음에 xcframework로 뽑기\n## Framework 아카이브 - iphoneOS\nxcodebuild archive -project ObjcIntoSwiftFramework.xcodeproj \\\n-scheme ObjcIntoSwiftFramework \\\n-sdk iphoneos \\\n-destination \"generic/platform=iOS\" \\\n-archivePath archives/ObjcIntoSwiftFramework-iOS.xcarchive ## Framework 아카이브 - iphone simulator\nxcodebuild archive -project ObjcIntoSwiftFramework.xcodeproj \\\n-scheme ObjcIntoSwiftFramework \\\n-sdk iphonesimulator \\\n-destination \"generic/platform=iOS Simulator\" \\\n-archivePath archives/ObjcIntoSwiftFramework-iOS_Simulator.xcarchive ## xcframework 추출\nxcodebuild -create-xcframework \\\n-archive archives/ObjcIntoSwiftFramework-iOS.xcarchive -framework ObjcIntoSwiftFramework.framework \\\n-archive archives/ObjcIntoSwiftFramework-iOS_Simulator.xcarchive -framework ObjcIntoSwiftFramework.framework \\\n-output xcframeworks/ObjcIntoSwiftFramework.xcframework\nxcframework을 확인 해보면 헤더에 모든 헤더가 노출되어 있음<img alt=\"allpublic.png\" src=\"images/allpublic.png\" target=\"_self\">이제 해야할 것은 xcframework에서 internal objective - c 헤더를 제거하는 것 이를 위해서엄블레라 헤더에서 Internal 주석 이하 모두 삭제xcframework 경로를 파라미터로 받는 스크립트를 실행해서 처리함#! /bin/sh -e # # removeInternalHeaders.sh # ## 1 XCFRAMEWORK_DIR=$1 INTERNAL_MARK=\"__INTERNAL__\" ## 2 function removeInternalHeadersInUmbrellaHeader { local framework_name=\"$(basename $1 .framework)\" local headers_dir=\"$1/Headers\" local umbrella_header_file=\"$headers_dir/$framework_name.h\" local internal_mark_found=false local internal_headers=() ## 2.1 while read -r line; do if $internal_mark_found; then if [[ $line == \"#import\"* ]]; then local filename=$(sed 's/.*\\\"\\(.*\\)\\\".*/\\1/' &lt;&lt;&lt; $line) internal_headers[${#internal_headers[@]}]=$filename fi elif [[ $line == *$INTERNAL_MARK* ]]; then internal_mark_found=true fi done &lt; $umbrella_header_file ## 2.2 echo \"${#internal_headers[@]} files will be removed\" for filename in ${internal_headers[@]}; do local file=\"$headers_dir/$filename\" if [ -f \"$file\" ]; then rm $file echo \"Removed file: $file\" else echo \"Tried to remove file but it does not exist: $file\" fi done ## 2.3 sed -i \"\" '/'$INTERNAL_MARK'/,$d' $umbrella_header_file } ## 3 for directory in ${XCFRAMEWORK_DIR}/**/*.framework; do [ -d \"$directory\" ] || continue removeInternalHeadersInUmbrellaHeader $directory done # $HOME = 내 Users Path\n$ ./removeInternalHeaders.sh $HOME/Labs/ObjcIntoSwiftFramework/xcframeworks/ObjcIntoSwiftFramework.xcframework\n결과<br><img alt=\"removedinternal.png\" src=\"images/removedinternal.png\" target=\"_self\"><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.fleksy.com/blog/developing-an-ios-framework-in-unison-with-swift-objective-c/\" target=\"_self\">https://www.fleksy.com/blog/developing-an-ios-framework-in-unison-with-swift-objective-c/</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Importing Objective - C code into Swift internally for a framework","level":3,"id":"Importing_Objective_-_C_code_into_Swift_internally_for_a_framework_0"},{"heading":"Importing \bSwift code into Objective - C internally for a framework","level":3,"id":"Importing_\bSwift_code_into_Objective_-_C_internally_for_a_framework_0"}],"links":[],"author":"","coverImageURL":"images/allpublic.png","fullURL":"ios/swift,-objective-c-interoperability.html","pathToRoot":"..","attachments":["images/allpublic.html","images/removedinternal.html"],"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":3835,"sourcePath":"iOS/Swift, Objective - C interoperability.md","exportPath":"ios/swift,-objective-c-interoperability.html","showInTree":true,"treeOrder":351,"backlinks":[],"type":"markdown"},"ios/swift에서-다형성을-달성하는-방법.html":{"title":"Swift에서 다형성을 달성하는 방법","icon":"","description":"이번 글은 WWDC 2022 Embrace Swift generics와 같은 년도인 Design Protocol interfaces in Swift를 보고 포스팅하게 되었습니다.이 포스팅에서 다음과 같은 내용을 다룹니다. Ad - Hoc 다형성과 Subtype 다형성을 설명하고 코드 구현, 그리고 이 구조들에서 발생하는 문제점 제네릭을 이용한 파라미터릭 다형성을 달성하는 법. 이 부분에서 some 키워드와 any 키워드를 설명하고 interface를 설계하고 코드를 작성하는 방법 다형성(多形性,&nbsp;polymorphism; 폴리모피즘)은 그 프로그래밍 언어의&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C%ED%98%95_%EC%B2%B4%EA%B3%84\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C%ED%98%95_%EC%B2%B4%EA%B3%84\" target=\"_self\">자료형 체계</a>의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EC%83%81%EC%88%98\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EC%83%81%EC%88%98\" target=\"_self\">상수</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)\" target=\"_self\">변수</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EC%8B%9D\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EC%8B%9D\" target=\"_self\">식</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8\" target=\"_self\">오브젝트</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98\" target=\"_self\">함수</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C\" target=\"_self\">메소드</a>&nbsp;등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다.\n즉 하나의 코드로 여러 행동을 하게 해주는 것이 다형성이라고 생각하면 될 것 같아요. 다형성은 다양한 방식으로 달성할 수 있는데요.&nbsp;WWDC 2022에서는 3가지로 설명하고 있습니다. ad-hoc 다형성 - 오버로딩 Subtype 다형성 - 오버라이딩 파라미터릭 다형성 using Generic 그러면 하나씩 살펴보도록 하겠습니다.설명하기에 앞서 코딩을 해야 하기 때문에, 요구사항을 먼저 정하겠습니다. 다음과 같은 프로그램을 개발해야 합니다.\n농장 시뮬레이팅 만들기!\nFarm (농장)에는&nbsp;Cow(소),Horse(말),Chicken(닭)이 있습니다.\n소는&nbsp;Hay(건초), 말은&nbsp;Carrot(당근), 닭은 Grain(사료)을 먹습니다.\n농장은 동물들에게 밥을 줘야 하기 때문에, Hay, Carrot, Grain을 수확해야 함. Alfalfa가 자라서 Hay가 되고, Root는 Carrot,&nbsp;Wheat가 자라서 Grain이 됩니다.\n// Animal.swift struct Cow { func eat(_ food: Hay) { print(\"\\(Self.self) eat \\(food)\") }\n} struct Horse { func eat(_ food: Carrot) { print(\"\\(Self.self) eat \\(food)\") }\n} struct Chicken { func eat(_ food: Grain) { print(\"\\(Self.self) eat \\(food)\") }\n}\n// AnimalFeed.swift // 재료 -&gt; 음식\n// 소는 Alfalfa가 자라서 수확된 Hay를 먹음\n// 말은 Root가 자라서 수확된 Carrot을 먹음\n// 닭은 Wheat가 자라서 수확된 Grain을 먹음 struct Hay { static func grow() -&gt; Alfalfa { return Alfalfa() }\n} struct Alfalfa { func harvest() -&gt; Hay { return Hay() }\n} struct Carrot { static func grow() -&gt; Root { return Root() }\n} struct Root { func harvest() -&gt; Carrot { return Carrot() }\n} struct Grain { static func grow() -&gt; Wheat { return Wheat() }\n} struct Wheat { func harvest() -&gt; Grain { return Grain() }\n}\n// Farm.swift struct Farm { func feed(_ animal: Cow) { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food) } func feed(_ animal: Horse) { let root = Carrot.grow() let food = root.harvest() animal.eat(food) } func feed(_ animal: Chicken) { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food) }\n}\n// FarmSimulator.playgroud import Foundation let farm = Farm() let cow = Cow()\nlet horse = Horse()\nlet chicken = Chicken() farm.feed(cow) // Print: Cow eat Hay()\nfarm.feed(horse) // Print: Horse eat Carrot()\nfarm.feed(chicken) // Print: Chicken eat Grain()\nAd-Hoc 다형성을 이용해서 요구사항을 만족하는 코드를 작성했습니다. 코드를 보면 유형에 따라 구체적인 feed() 함수가 결정되고 실행되는 것을 볼 수 있습니다. 이것은 함수 오버로딩 (Function overloading)을 통해서 작동하고 있어요(파라미터의 타입을 다르게 동일한 함수를 작성하는 것)<br><img src=\"https://blog.kakaocdn.net/dn/bad809/btskUMGVFT1/3Wfq3cbT9hTwOGWwsvBIk0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이 방식의 문제점은 무엇일까요? 오버로딩은 반복적인 구현, 즉 보일러 플레이트를 유발합니다. 코드를 너무 많이 작성해야 한다는 것이죠. 그리고 요구사항 변경에 매우 취약합니다. 한 가지 예를 들어보도록 할게요.요구사항 변경\n농장에 새로운 동물 돼지가 들어왔어요. 돼지는 GrainForPig를 먹습니다. 그리고 돼지가 먹는 GrainForPig는 옥수수 Corn으로 만들어집니다.\n// Animal.swift 에 추가해야함\nstruct Pig { func eat(_ food: GrainForPig) { print(\"\\(Self.self) eat \\(food)\") }\n} // AnimalFeed.swift\nstruct GrainForPig { static func grow() -&gt; GrainForPig { return GrainForPig() }\n} struct Corn { func harvest() -&gt; GrainForPig { return GrainForPig() }\n} // Farm.swift func feed(_ animal: Pig) { let corn = GrainForPig.grow() let food = corn.harvest() animal.eat(food)\n} // FarmSimulator.playgroud let pig = Pig()\nfarm.feed(pig) // Print: Chicken eat Grain()\n변경된 요구사항을 만족하기 위해서 위의 코드를 추가로 작성해야 합니다. 새로운 기능이 추가된 것도 아닌데 작성할 코드가 너무 많아 보입니다. 그리고 더 중요한 건&nbsp;컴파일러는 이러한 요구사항에 일절 관여하지 않기 때문에&nbsp;코딩할 때 feed 함수를 오버로딩 해야 한다는 것을 깜빡해도 경고를 하지 않는다는 것입니다. 디버깅 비용이 높아지고 있어요. 딱 봐도 안 좋은 방식인 것 같습니다.Subtype 다형성이 작동하는 메커니즘은&nbsp;class를 이용한 상속입니다. 한 Super Class가 있고 이를&nbsp;상속해서&nbsp;관련 함수를&nbsp;오버라이딩(overriding)&nbsp;합니다. 여기에서는 Animal이라는 Super Class를 만들고, Cow, Horse, Chicken은 Animal을 상속하게 합니다.import Foundation // Animal.swift class Animal { func eat(_ food: Any) { fatalError(\" Subclass implements 'eat' \") }\n} class Cow: Animal { override func eat(_ food: Any) { guard let food = food as? Hay else { fatalError(\"소는 \\(food) 를 먹을 수 없습니다.\") } print(\"\\(Self.self) eat \\(food)\") }\n} class Horse: Animal { override func eat(_ food: Any) { guard let food = food as? Carrot else { fatalError(\"말은 \\(food) 를 먹을 수 없습니다.\") } print(\"\\(Self.self) eat \\(food)\") } } class Chicken: Animal { override func eat(_ food: Any) { guard let food = food as? Grain else { fatalError(\"닭은 \\(food) 를 먹을 수 없습니다.\") } print(\"\\(Self.self) eat \\(food)\") }\n} // Farm.swift\nstruct Farm { func feed(_ animal: Animal) { if animal is Cow { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food) return } if animal is Horse { let root = Carrot.grow() let food = root.harvest() animal.eat(food) return } if animal is Chicken { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food) return } fatalError(\"올바른 동물 타입이 아닙니다.\") }\n} // AnimalFeed.swift는 변경 안함\n// FarmSimulator.playground도 변경 안함\n소, 닭, 말은 다른 먹이 타입을 먹기 때문에 eat()의 파라미터 food가 구체적일 수가 없습니다. 따라서 Animal 클래스에서의 eat의 파라미터인 food의 타입을 구체적인 타입이 아니라&nbsp;유연한 Any 타입으로 변경해야 합니다.이제 각각의 구체적인 동물 클래스(소, 닭, 말)에서 eat 메서드를 구현합시다. 이때 주의할 점이 있습니다. eat()을 구현할 때 guard let을 이용해서 타입 검사를 해야 합니다. 왜냐하면 eat의 파라미터가 Any이기 때문에 모든 타입이 전달인자(argument)로 들어올 수 있기 때문이에요.(예를 들면 Cow의 eat에 Hay 말고 다른 것이 들어오면 안 됨!)다음으로 Farm을 보면 \bfeed() 구현현도 조금 바뀌었죠? 함수 오버로딩을 사용하지 않고 진정한 의미의 함수 하나가 되었습니다.동물에게 밥을 주기 위해서 인자로 받은 동물의 타입 검사를 하고 동물 타입에 맞게 밥을 주는 코드가 완성되었습니다.이제 실행을 해볼까요? FarmSimulator.playground 파일을 수정하지 않고도 잘 실행되는 것을 확인할 수 있습니다.<br><img src=\"https://blog.kakaocdn.net/dn/bTBLKV/btskSn2eIaz/N9VlHTbYzVAiKOu4p4qXVk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/vdJ0q/btskRekEX7G/RC4a2SzXov76lkcMoEtv9k/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 하나의 코드로 여러 행동을 할 수 있게 되었습니다. 짝짝 😀좋습니다. 하지만 이 코드도 확실히 문제점이 존재합니다. 위처럼 새로운 동물 Pig가 추가될 때, Pig 내부에 eat을 구현하지 않으면 컴파일 타임에 에러 검출을 하지 못합니다. 앱이 실행되고 나서 런타임에 Pig가 eat을 구현하지 않았다는 에러를 발견할 수 있습니다.마찬가지로, eat 메서드에서 전달인자로 올바른 타입이 왔는지 검사하는 것도 모두 다 런타임에서 일어납니다.즉, 이 코드 역시 보일러플레이트를 생성할 뿐만 아니라, 에러 검출이 런타임에서 이뤄지기 때문에 디버깅 난이도가 올라갑니다. 그리고 Any 타입을 사용하기 때문에 코드 파악이 어려운 단점도 존재합니다.문제점을 정리해 볼게요.\n런타임시에 에러 검출\n구체적인 동물 타입 구현시에 파라미터 타입이 Any → 코드 파악 어려움\n여기서 새로운 개념을 하나만 더 도입하면 문제점 2번은 해결할 수 있을 것 같아요. 조금 더 나아가보도록 할게요.타입파라미터를 도입할게요!class Animal&lt;Food&gt; { func eat(_ food: Food) { fatalError(\" Subclass implements 'eat' \") }\n} class Cow: Animal&lt;Hay&gt; { override func eat(_ food: Hay) { print(\"\\(Self.self) eat \\(food)\") }\n} class Horse: Animal&lt;Carrot&gt; { override func eat(_ food: Carrot) { print(\"\\(Self.self) eat \\(food)\") } } class Chicken: Animal&lt;Grain&gt; { override func eat(_ food: Grain) { print(\"\\(Self.self) eat \\(food)\") }\n} // Farm.swift\nstruct Farm { func feed&lt;T&gt;(_ animal: Animal&lt;T&gt;) where T: Any { if animal is Cow { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food as! T) return } if animal is Horse { let root = Carrot.grow() let food = root.harvest() animal.eat(food as! T) return } if animal is Chicken { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food as! T) return } fatalError(\"올바른 동물 타입이 아닙니다.\") }\n}\n이 방법으로 2번의 문제를 조금 해결할 수 있네요. 하지만 근본적인 문제는 해결되지 않았습니다. Farm의 feed()에서, 각 동물들의 eat을 실행하기 위해서 역시 유연한 Any 타입을 사용해야 합니다. 그리고 실제 eat 코드를 실행할 때, T로 캐스팅을 해줘야 한다는 점이 불편해 보여요.즉, 코드 누락 시에 컴파일러는 알려주지 않고, 런타임 시에 에러가 검출되겠네요. 역시 1번 문제는 해결하지 못했습니다.문제가 이것뿐만이 아닙니다. 이 밖에도 다음과 같은 문제가 발생합니다!!동물의 주요 행위가 꼭 먹는 것이라고 할 수 없는데, class에 타입 파라미터를 지정해줘야 한다는 것입니다. 동물의 행위에는 여러 가지가 있고 eat은 그중 하나일 뿐인데요! (예를 들면 동물 메서드에 run(), sleep() 등등이 있는데 이것은 AnimalFeed와 무관합니다.)그리고 만약 Food 같이 다른 파라미터도 다형성을 구현하기 위해서 아래 코드처럼 보일러 플레이트를 생성하게 될 것입니다.class Animal&lt;Food, Habitat, Commodity&gt; { func eat(_ food: Food) { fatalError(\" Subclass implements 'eat' \") }\n} class Cow: Animal&lt;Hay, Barn, Milk&gt; { override func eat(_ food: Hay) { }\n} // 말 같은 경우에 얻을 Commodity가 없는데, 상위 클래스인 Animal에 타입파라미터로\n// Commodity가 있기 때문에 Never 같은 보일러 플레이트가 발생함\nclass Horse: Animal&lt;Carrot, Stable, Never&gt; { override func eat(_ food: Carrot) { } } class Chicken: Animal&lt;Grain, Coop, Egg&gt; { override func eat(_ food: Grain) { }\n}\nSubtype 다형성에서 가장 큰 문제점은 바로 Super Type이 Data Type이라는 겁니다.지금까지 다형성을 달성하는 방법 2가지를 찾아봤는데 단점이 너무 명백해 보입니다. 이제 우리가 원하는 것을 생각해 보고 새로운 단계로 나아가봅시다!!우리가 원하는 것은 다음과 같아요.\n기능이 작동하는 방식에 대한 세부 정보 없이 유형의 기능을 나타내길 원함\n컴파일러가 좀 더 엄격하게 버그를 찾아줬으면 좋겠음(누락된 코드나 잘못 작성하면 컴파일 타임에 알려줘!)\n이때 우리에게 한 줄기의 빛이 되는 것이 바로 interface입니다. 현대 언어에서는 위에서 살펴본 문제들을 interface를 통해 해결하고 있어요. swift에서는 protocol로 선언할 수 있습니다.// 구현체 Animal.swift\n// Interface\nprotocol Animal { func eat(_ food: AnimalFeed)\n} struct Cow: Animal { func eat(_ food: AnimalFeed) { print(\"\\(Self.self) eats \\(food)\") }\n} struct Horse: Animal { func eat(_ food: AnimalFeed) { print(\"\\(Self.self) eats \\(food)\") }\n} struct Chicken: Animal { func eat(_ food: AnimalFeed) { print(\"\\(Self.self) eats \\(food)\") }\n} // AnimalFeed.swift\n// interface\nprotocol AnimalFeed { }\nstruct Hay: AnimalFeed { static func grow() -&gt; Alfalfa { return Alfalfa() }\n} struct Alfalfa { func harvest() -&gt; Hay { return Hay() }\n} struct Carrot: AnimalFeed { static func grow() -&gt; Root { return Root() }\n} struct Root { func harvest() -&gt; Carrot { return Carrot() }\n} struct Grain: AnimalFeed { static func grow() -&gt; Wheat { return Wheat() }\n} struct Wheat { func harvest() -&gt; Grain { return Grain() }\n} // Farm.swift\nstruct Farm { func feed(_ animal: Animal) { if animal is Cow { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food) return } if animal is Horse { let root = Carrot.grow() let food = root.harvest() animal.eat(food) return } if animal is Chicken { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food) return } }\n}\n만약 여기에서 Pig가 추가되었다는 기획의 요청을 받으면, Pig 구현체를 만들 때 Animal을 컨펌하면 되겠습니다. 그러면 eat 메서드를 누락하면 컴파일러가 이를 알아채고 고치라고 합니다!&nbsp;아무래도 컴파일러가 알려주니 좀 뇌를 빼고 개발해도 되겠죠?좋습니다. 좋아요. 하지만 위의 코드에도 문제점을 그만 찾고 싶은데 당연히 문제점이 있습니다. Cow, Horse, Chicken과 같은 구현체에서 eat 메서드의 파라미터를 보니 AnimalFeed입니다. 타입이 인터페이스죠? 말은 Hay를 먹고, Horse는 Carrot, Chicken은 Grain을 먹는다는 사실은 자명합니다. 이 구현체에서 매개변수를&nbsp;인터페이스로 은닉할 필요가 없다는 뜻입니다! 이때&nbsp;associatedtype&nbsp;(연관타입)을 사용하면 됩니다. Animal에&nbsp;&nbsp;associatedtype을&nbsp;추가합시다.protocol Animal { associatedtype Feed: AnimalFeed func eat(_ food: Feed)\n}\n<br><img src=\"https://blog.kakaocdn.net/dn/ldB46/btskRomUwNB/4Kays19TdOCR4Qcgd1cgnk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그러면 위처럼 각 동물을 구현할 때 Animal을 컨펌하라고 컴파일러가 알려줍니다. 이제 _ food: AnimalFeed를 구체적인 타입으로 변경합시다.struct Cow: Animal { func eat(_ food: Hay) { print(\"\\(Self.self) eats \\(food)\") }\n} struct Horse: Animal { func eat(_ food: Carrot) { print(\"\\(Self.self) eats \\(food)\") }\n} struct Chicken: Animal { func eat(_ food: Grain) { print(\"\\(Self.self) eats \\(food)\") }\n}\nFarm의 feed() 메서드를 봤을 때, 조금 복잡해 보입니다. if 문으로 분기처리를 하지 않고, 조금 명료한 하나의 동작을 코드로 작성하고 싶습니다. 타입 파라미터를 이용해 제네릭 코드를 작성해 봅시다. feed 메서드를 작성할 때, animal의 타입을 지정해줘야 합니다. 매개변수의 타입은 Concrete 타입이어야 합니다. (소, 닭, 말 같은 구현체) 그렇기 때문에 매개변수는 직접적인 protocol이 아니라 아래처럼 제네릭을 이용해서 작성해야 합니다.(두 함수는 표현만 다를 뿐 같은 함수입니다.)struct Farm { func feed&lt;A: Animal&gt;(_ animal: A) { } func feed&lt;A&gt;(_ animal: A) where A: animal { }\n}\n이 제네릭 코드를 이해해 볼까요?A에는 특정한 Concrete 타입이 들어가고, 이 Concrete 타입은 Animal Protocol을 컨펌한다는 뜻입니다.위의 두 메서드와 같은 함수를 하나 더 작성해 보겠습니다. 바로&nbsp;some&nbsp;키워드를 이용하는 것입니다. some 이용하면 좀 더 의미 있게 표현이 되는 것 같습니다. some 키워드에 대해 알아봅시다.struct Farm { func feed(_ animal: some Animal) { }\n}\nsome 키워드를 이해하기 전에 약간의 개념 정립과 용어 정리가 필요한 것 같습니다.메서드의 매개변수에 specific concrete 타입이 와야 한다고 말했습니다. some 키워드가 붙은 것도 역시 specific concrete 타입일 것입니다. 하지만 정말 명료한 concrete 타입은 아닐 겁니다. 왜냐하면 프로토콜을 컨펌하는 어떤 구현체가 들어가도 되니깐요. 맞나요? 맞습니다. 하나가 딱 정확히 정해져있지 않다는 뜻입니다. 이러한 것을&nbsp;opaque&nbsp;타입이라고 합니다.(some 단어로 유추할 수 있죠) 즉 특정한 concrete 타입에 대한 추상적인 placeholder를 opaque 타입이라고 부르는 것입니다. 그래서 애플 문서나 WWDC에서 some 키워드가 붙으면 opaque 타입이라고 부릅니다. 좋아요. 이 opaque 타입은 컴파일 타임에 실제 완전 명료한 concrete type으로 대체가 될 것입니다. 이것을 기저에 깔려있는 즉 underlying 타입이라고 합니다. 이제 의미에 대해 생각해 볼게요. 제네릭 코드를 이용하거나 파라미터 변수에 some을 붙인 것은 어떤 의미가 있을까요? 이러한 코드들이 의미하는 바는 컴파일러에게 이 메서드는&nbsp;‘specific concrete 타입으로&nbsp;작업할 거야’라고 알리는 것과 마찬가지입니다. 즉 컴파일 시점에 이 opaque 타입의 underlying 타입은 고정되어야만 한다는 것을 의미합니다. 그렇기 때문에 재할당도 불가능합니다. 코드를 보면 알 수 있습니다.// 컴파일 성공\nlet animals: [some Animal] = [ Cow(), Cow(), Cow(),\n] // Print: Compile error: Cannot convert value of type 'Horse' to expected element type 'Cow'\nlet vehicles: [some Animal] = [ Cow(), Cow(), Horse(),\n] // 컴파일 성공\nfunc createCow() -&gt; some Animal { return Cow()\n} // Print: Compile error: Function declares an opaque return type 'some Animal', but the return statements in its body do not have matching underlying types\nfunc createSomeAnimal(number: Int) -&gt; some Animal { if number == 0 { return Cow() } else if number == 1{ return Horse() } else { return Chicken() }\n} var animal: some Animal = Cow()\nanimal = Horse() // 불가능\nanimal = Cow() // 이것도 불가능\n이제 다시 돌아와서 Farm의 feed 메서드를 작성해 볼까요? some 키워드에 대해 알아보느라 우리의 목표를 잠깐 까먹었을 수도 있기 때문에 리마인드 하겠습니다.feed 메서드를 여러 유형에게 공통으로 작동하는 코드로 작성하는 것어떻게 작성하면 될까요? 설계를 해봅시다.protocol Animal { associatedtype Feed: AnimalFeed func eat(_ food: Feed)\n}\nAnimal은 연관타입으로 Feed (AnimalFeed)을 가지고 있습니다. 자동완성으로 확인해 볼게요.<br><img src=\"https://blog.kakaocdn.net/dn/m1JBl/btsk4N6CzrV/s9MFR67PU2a2lF9B77xs11/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">AnimalFeed는 프로토콜이고, concrete 타입으로는 동물들이 먹는 Hay, Carrot, Grain입니다.위에서 이것을 만들기 위해서 어떻게 했나요? Hay 안에 static 메서드 grow()를 사용했습니다.간단하게 리뷰를 하면 아래와 같습니다. (소를 예로 들게요.)let crop = Hay.grow() (crop의 타입은 Alfalfa) → let food = crop.harvest() (food의 타입은 Hay)opaque 타입은 concrete한 타입이기 때문에, type 메서드를 사용할 수 있어요. type을 이용해 코드를 작성해 볼게요. 그러면, 위의 코드를 type(of: animal). Feed.grow()라고 하면 될 것 같아요.<br><img src=\"https://blog.kakaocdn.net/dn/bbkEzr/btsk1clWC60/jg1GIMpA2zttu9aXmggnh0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">당연히 뜨지 않겠죠. 왜냐하면 grow() 메서드는 concrete 타입(Hay, Carrot, Grain)에 직접 구현했으니깐요. 따라서 자연스럽게 AnimalFeed 프로토콜에 에 static grow()가 추가되어야 합니다. grow()는 Alfalfa, Root, Wheat 같은 작물을 리턴해야 하기 때문에 이와 관련된 인터페이스(Crop)를 만들고 연관타입으로 가지고 있어야 합니다. 그리고 Crop 프로토콜에는 당연히 harvest()가 있어야 하겠죠? 이 메서드의 리턴은 역시 연관 타입으로 AnimalFeed를 가지고 있어야 할 겁니다.코드 작성을 해볼게요.protocol AnimalFeed { associatedtype CropType: Crop static func grow() -&gt; CropType\n} protocol Crop { associatedtype Feed: AnimalFeed func harvest() -&gt; Feed\n} struct Hay: AnimalFeed { static func grow() -&gt; Alfalfa { return Alfalfa() }\n} struct Alfalfa: Crop { func harvest() -&gt; Hay { return Hay() }\n} struct Carrot: AnimalFeed { static func grow() -&gt; Root { return Root() }\n} struct Root: Crop { func harvest() -&gt; Carrot { return Carrot() }\n} struct Grain: AnimalFeed { static func grow() -&gt; Wheat { return Wheat() }\n} struct Wheat: Crop { func harvest() -&gt; Grain { return Grain() }\n}\nstruct Farm { func feed(_ animal: some Animal) { let crop = type(of: animal).Feed.grow() let food = crop.harvest() animal.eat(food) }\n}\n정말 깔끔한 코드가 작성되었습니다. 다형성을 구현했습니다. 하지만 이 코드는 아래처럼 빌드에 실패할 거예요ㅠ<br><img src=\"https://blog.kakaocdn.net/dn/ds9HYU/btsk1Bsk9Wf/lL1qYwrMh7YhkKAwAETPL1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">왜냐하면 프로토콜 관계에&nbsp;꼬리에 꼬리를 무는 관계가 있기 때문이에요. (back - and - forth) AnimalFeed 프로토콜을 한번 봐볼까요.모든 프로토콜은 Self 타입을 가지고 있습니다.AnimalFeed는 concrete conforming type인 CropType을 가지고 있습니다.Crop 역시 concrete conforming type인 FeedType을 가지고 있습니다.Self: AnimalFeed → Self.CropType: Crop → Self.CropType.FeedType: AnimalFeed → …위와 같이 무한반복이 될 거예요.Crop 프로토콜도 이와 마찬가지고요. 따라서 이 (back - and - forth)를 끊어주면 되겠습니다. AnimalFeed 프로토콜에서 CropType이 가지고 있는 Feed는 바로 자신이라고 알려주고, 마찬가지로 Crop 프로토콜에서 FeedType이 가지고 있는 Crop은 자기 자신이라는 것을 알려주면 됩니다. 어떻게? where을 이용해서!protocol AnimalFeed { associatedtype CropType: Crop where CropType.Feed == Self static func grow() -&gt; CropType\n} protocol Crop { associatedtype Feed: AnimalFeed where Feed.CropType == Self func harvest() -&gt; Feed\n}\n여기까지 작성하면, feed에서 나는 에러가 사라지게 됩니다. FarmSimulating.playground로 돌아가서 실행을 하면 잘 작동합니다.지금까지 .playground을 단 한 번도 수정한 적이 없습니다. 그럼에도 불구하고 같은 결과를 보여주는 게 정말 멋지네요.FarmSimulating.playground에서 각 동물 인스턴스와 농장 인스턴스를 만들어서 작업을 하고 있어요. 여기에 요구사항을 약간 변경해 보도록 할게요. 그리고 요구사항에 맞게 코드를 변경해 봅시다.\n농장은 배고픈 동물들에게 밥을 줄 책임이 있습니다. 배고픈 동물들에게 밥을 주는 기능을 추가하세요.\n요구사항을 읽었을 때, 바뀌거나 추가되어야 할 부분들은 다음과 같습니다.\n동물은 자기가 배고픈지 아닌지를 알 수 있어야 합니다. → 동물은 배고픔을 나타내는 프로퍼티를 가지고 있어야 함\n농장은 배고픈 동물들을 판별할 수 있어야 함 → Farm 구현체에 프로퍼티로 동물들을 가지고 있어야 함\n// 1번 요구사항 충족\n// Animal 인터페이스에 isHungry를 프로퍼티를 추가하고\n// 동물 인터페이스를 컨펌하는 concrete 객체에 isHungry를 추가함.\nprotocol Animal { associatedtype Feed: AnimalFeed func eat(_ food: Feed) var isHungry: Bool { get }\n} struct Cow: Animal { var isHungry: Bool func eat(_ food: Hay) { print(\"\\(Self.self) eats \\(food)\") }\n} // ...\n1번 요구사항을 충족시키는 것은 매우 쉽습니다! 2번도 만족시켜볼까요?struct Farm { var animals: [some Animal] func feed(_ animal: some Animal) { let crop = type(of: animal).Feed.grow() let food = crop.harvest() animal.eat(food) }\n}\n<br><img src=\"https://blog.kakaocdn.net/dn/kxFNx/btskZsJ6zyL/xKuqodcdpKxuO4oxPn3P60/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">빌드할 수가 없습니다. 왜 그럴까요? some에서 봤듯이, 컴파일 타임에 opaque type의 underlying type을 유추할 수 있어야 하기 때문입니다. 그러면 다음 코드들은 어떨까요?// case 1 (성공) // underlying type이 고정되어 있음\nvar animals: [some Animal] = [Cow(isHungry: false), Cow(isHungry: false)] //case 2 (실패) - underlying type이 고정되어 있지 않음\nvar animals: [some Animal] = [Horse(isHungry: false), Cow(isHungry: false)]\n농장에는 다른 유형의 동물들이 있어야 합니다. 우리가 원하는 건 case 2입니다. 컴파일러는 고정된 underlying type을 요구합니다. 우리는 이걸 좀 유연하게 가져가고 싶어요. [Cow(), Horse(), Chicken() … ] 이런 식으로요어떻게 타입을 지우는 법이 없을까요? 이때 필요한 키워드가 바로&nbsp;any입니다.any 키워드는&nbsp;existential type를&nbsp;생성하기 위해 도입되었어요. 사실 existential type는 새로운 게 아닙니다. 그냥 프로토콜을 타입으로 사용할 때, 존재 유형으로 부릅니다.var cow: Animal = Cow() // 이 코드에서 Animal이 존재 유형임.\n// Swift 5.7에서는 위 코드는 var cow: any Animal = Cow() 가 되어야만 함.\nany 키워드를 사용한다는 것은 Apple은 concrete 타입을 박스로 싸는 것에 비유합니다. ㅎ<br><img src=\"https://blog.kakaocdn.net/dn/1tIyb/btsk2fP5Zek/tlhdodbWyyLohnGMOAQkHk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">즉 박스에 특정한 프로토콜을 준수하는 concrete 타입을 넣는 겁니다. 그렇다면 concrete 타입( Cow, Chicken, Horse)은 숨겨집니다. 그래서 이것을 type erasure라고 합니다! 즉 upper bound로 퉁치는 거입니다. (수학 공부할 때 정말 많이 나오는 그 upper bound 맞아요) 그래서 any를 사용하게 되면 heterogeneous한 컬렉션([Cow(), Horse()] 같은 컬렉션들)을 만들 수 있게 되는 것입니다. 이해하고 나니까 별로 어려운 것이 아니네요.^^<br>any 키워드에 주의점을 마지막으로 any에 대한 설명을 끝내겠습니다. ‘Donny Wals라는 개발자는&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.donnywals.com/what-is-the-any-keyword-in-swift/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.donnywals.com/what-is-the-any-keyword-in-swift/\" target=\"_self\">‘*<strong></strong></a>*What is the “any” keyword in Swift?**’라는 아티클에서 any 키워드는 some보다 덜 효율적이고 비용을 더 많이 초래하기 때문에 기본적으로 some을 사용하고 필요할 때, any 키워드를 사용하라고 권고합니다. 그리고 역시 WWDC 2022에서도 some을 디폴트로 사용하라고 언급해요.이제 any에 대한 이해가 끝났으니 코드 작성을 해봅시다.struct Farm { var animals: [any Animal] func feedAnimals() { animals.filter(\\.isHungry).map { animal in animal.eat(???) } }\n} // FarmSimulating.playground import Foundation let farm = Farm(animals: [ Cow(isHungry: true), Cow(isHungry: false), Chicken(isHungry: true), Horse(isHungry: true)\n]) farm.feedAnimals()\n위의 코드는 작동하지 않을 것입니다. 왜일까요? 답은 간단합니다. 닭은 Grain을 먹어야 하고, 소는 Hay를 먹어야 합니다. 이때 animal.eat()에서 어떠한 방식으로 Parameter를 넘겨야 할지 문제가 생깁니다. Animal 프로토콜과 관련된 FeedTye의 upper bound는 'any AnimalFeed'입니다. any AnimalFeed가 닭인 경우에 Grain, 소인 경우에 Hay를 정적으로 보장할 방법이 없습니다. 따라서 위 코드처럼 Type erasure를 허용해서는 안됩니다. 즉 정적으로 보장하기 위해서 existential 타입을 언박싱해야 합니다. 언박싱하는 방법은 opaque 타입인 some 키워드를 매개변수로 하는 함수를 호출하면 됩니다. 바로 아래처럼요!struct Farm { var animals: [any Animal] private func feed(_ animal: some Animal) { let crop = type(of: animal).Feed.grow() let food = crop.harvest() animal.eat(food) } func feedAnimals() { animals.filter(\\.isHungry).map { animal in feed(animal) } }\n} // FarmSimulating.playground import Foundation let farm = Farm(animals: [ Cow(isHungry: true), Cow(isHungry: false), Chicken(isHungry: true), Horse(isHungry: true)\n]) farm.feedAnimals()\n드디어 모든 코드 구현이 완료되었습니다. some과 any 키워드를 사용하고 인터페이스를 잘 설계함으로써 제네릭을 이용한 파라미터릭 다형성을 달성했습니다.&nbsp;제가 이해한 것을 바탕으로 최대한 이해하기 쉽게 풀어쓰려고 노력했는데 잘 와닿을까 모르겠네요. 제네릭은 참 어려운 것 같습니다.상당히 긴 호흡의 글을 읽어주셔서 감사합니다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/FarmSimulating\" target=\"_self\">https://github.com/psychehose/FarmSimulating</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://swiftsenpai.com/swift/understanding-some-and-any/\" target=\"_self\">https://swiftsenpai.com/swift/understanding-some-and-any/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.donnywals.com/what-is-the-any-keyword-in-swift/\" target=\"_self\">https://www.donnywals.com/what-is-the-any-keyword-in-swift/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.apple.com/videos/play/wwdc2022/110352/\" target=\"_self\">https://developer.apple.com/videos/play/wwdc2022/110352/</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.apple.com/videos/play/wwdc2022/110353/\" target=\"_self\">https://developer.apple.com/videos/play/wwdc2022/110353/</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"다형성","level":4,"id":"다형성_0"},{"heading":"1. Adhoc 다형성","level":4,"id":"1._Adhoc_다형성_0"},{"heading":"2. Subtype 다형성","level":4,"id":"2._Subtype_다형성_0"},{"heading":"3. 파라미터릭 다형성","level":4,"id":"3._파라미터릭_다형성_0"},{"heading":"some 키워드","level":4,"id":"some_키워드_0"},{"heading":"some 키워드와 where 절을 통해 feed 메서드 다형성 달성하기","level":4,"id":"some_키워드와_where_절을_통해_feed_메서드_다형성_달성하기_0"},{"heading":"Type Erasure","level":4,"id":"Type_Erasure_0"},{"heading":"any 키워드","level":4,"id":"any_키워드_0"},{"heading":"전체 Source Code","level":3,"id":"전체_Source_Code_0"},{"heading":"Ref.","level":4,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bad809/btskUMGVFT1/3Wfq3cbT9hTwOGWwsvBIk0/img.png","fullURL":"ios/swift에서-다형성을-달성하는-방법.html","pathToRoot":"..","attachments":[],"createdTime":1735623216854,"modifiedTime":1735623315641,"sourceSize":31720,"sourcePath":"iOS/Swift에서 다형성을 달성하는 방법.md","exportPath":"ios/swift에서-다형성을-달성하는-방법.html","showInTree":true,"treeOrder":352,"backlinks":[],"type":"markdown"},"ios/tuist-기본적인-사용법.html":{"title":"Tuist 기본적인 사용법","icon":"","description":"&nbsp;요즘 회사에서 Tuist를 사용하고 있다. 왜냐하면 iOS는 보일러 플레이트 코드가 거의 없다시피 하기 때문에 새로운 프로젝트를 할 때 상당히 귀찮기 때문이다. info.plist도 원하는대로 설정할 수 있고 3rd Party Library를 멋지게 관리할 수 있기 때문이다. Tuist는 이외에도 엄청나게 많은 기능을 제공하는 것 같다. 물론 많은 기능을 제공하는 만큼 제대로 사용하기 위해서는 학습이 필요하다. 어차피 설정은 프로젝트 동안에 거의 한번만 하면 되는데 Project 생성 도구를 학습 해야 하나 싶기도 하지만 이것은 Mono Project일 때이고 앱 규모가 크고 모듈화를 염두에 두고 있다면 Tuist는 매우 강력한 도구가 될 것 같다.&nbsp;개발을 Module 단위로 진행하고 있다면, 많은 Project를 만들어야 하는데 Xcode에서 Project 만들기는 너무 번거롭고 해야할 것이 많다. 가령 iOS deployment target을 13으로 잡았는데 생성시 최신버전으로 생성 되기때문에 Target Setting에서 바꿔야 한다거나 Framework 생성시 default가 dynamic framework이기 때문에 static으로 바꿔줘야 한다던가 매우 번거롭다. 이 때 Tuist를 사용할 경우 코드로 Project를 생성하기 때문에 한번 만들어 놓으면 재사용이 가능하고 훨씬 더 효율적으로 Project를 생성하고 유지보수가 가능해진다. 아무튼 그렇다고 한다.$ curl -Ls &lt;https://install.tuist.io&gt; | bash\n먼저 Tuist 부터 설치를 하자.Terminal을 열고 위 명렁어를 입력하면 Tuist를 설치할 수 있다. 그리고 Tuist로 Project를 생성한다.$ mkdir 'TuistPractice' #폴더 생성\n$ cd 'TuistPractice'\n$ tuist init --platform ios # 이렇게 하면 tuist로 Project를 관리할 수 있는 환경이 만들어짐.\n$ tuist generate # tuist로 project 생성\n그러면 프로젝트가 생성된다. 아주 멋지게 잘 생성된 거 같다. App을 실행해보면 나오는 ㅂ구조가 Tuist가 제공하는 기본 Template이다. 그러면 어떻게 우리만의 Project 세팅을 할 수 있을까?$ tuist edit\n명령어를 입력하면 mainfests.xcodeproj가 열린다. 이건 Package.swift 같은 역할을 한다. 즉 Manifest.xcodeproj를 자기 입맛에 맞게 수정한 다음에 ‘tuist generate’를 하면 우리가 원하는 구조, 형태로 Project들을 세팅하고 생성할 수 있게 된다.<img src=\"https://blog.kakaocdn.net/dn/HL4gh/btrH1bsSD2d/gPuie03lbnXlZPqRGLKFA1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Tuist가 제공하는 기본 templateProject.swift에 Project.app()이 있는데 이 app() method는 Project + template.swift에 extension에 작성되어 있다. return 값은 Project (Tuist에서 정의된 Type)이다. 문자 그대로 Project다.Tuist는 Project.swift를 찾아서 그 안에 작성되어 있는 대로 Project를 생성한다.즉 우리는 Project.swift에 우리가 원하는 프로젝트 코드를 작성하면 된다.보통 Project 코드를 작성할 때 템플릿처럼 Extension을 만들어서 사용하는 것 같다. 물론 나도 Extension을 만들어놓고 필요한 부분에서 바로 사용한다. 하지만 처음이니까 Extenstion을 만들지 않고 바로 사용해보자.Project는 생성자는 다음과 같다.\nname: String\norganizationName: String\noptions: Project.Options\npackages: [Package]\nsettings: Settings?\ntargets: [Target]\nschemes: [Scheme]\nfileHeaderTemplate: FileHeaderTemplate?\nadditionalFiles: [FileElement]\nresourceSynthesizers: [ResourceSynthesizer]\n생성자에 관한 자세한 설명은 Tuist Docs에서 확인 할 수 있다. Tuist는 이렇듯 코드로 많은 것들을 설정할 수 있게 한다. 이 부분은 아직 내 수준에서 그렇게까지 만질 필요가 없을 것 같기도 해서 정확하게 공부 해보지는 않았다.우리에게 필요한 것은3번 Options에 있는 Indent와 tab의 width 설정을 2로 바꾸는 것이었고 (xcode 기본설정은 4임!)4번에서는 사용법을 알기 위해서 Alamofire를 넣도록 하고5번에서는 Project 단위로 Project Settings를 사용하지는 않을 것이다.7번 개발 앱과 상용앱을 나누기 위해서 필요한 기능이지만 여기서는 사용하지 않을 것이다.8번, 9번, 10번은 잘 모르겠다. 어떻게 사용하는 지.다만 내가 생각하기에 가장 중요한 것은 6번이라고 생각한다. 왜냐하면 우리는 실제로 여기서 작업을 하고 이것을 실행하기 때문이다.따라서 우리는 간단하게 살펴보기 위해서 대부분 다 기본값으로 설정하고 필요한 부분만 작성해서 생성할 것이다.이제 Project를 생성해보자// Project.swift let project = Project( name: \"TuistPractice\", organizationName: \"com.yourCompany\", packages: [], settings: .settings(), targets: [ ]\n)\npackage는 swift package다. 사용법을 알기 위해서 예시로 가장 유명한 라이브러리 중 하나인 Alamofire를 fetch 해봤다. 위에서 언급한 것처럼 가장 중요한 것은 target이다. targets 안에 target Target Type instance를 넣으면 되는데 보통 Main Target과, Test Target을 넣는데 Main Target만 넣도록 하자.// Project.swift let plist: [String: InfoPlist.Value] = [ \"CFBundleShortVersionString\": \"1.0\", \"CFBundleVersion\": \"1\", \"UIMainStoryboardFile\": \"\", \"UILaunchStoryboardName\": \"LaunchScreen\", \"NSAppTransportSecurity\": .dictionary([ \"NSAllowsArbitraryLoads\": .boolean(true) ])\n] let appTarget = Target( name: \"TuistPractice\", platform: .iOS, product: .app, bundleId: \"YourBudleID\", deploymentTarget: .iOS(targetVersion: \"14.0\", devices: [.iphone, .ipad]), infoPlist: .extendingDefault(with: plist), sources: [\"Sources/**/*.swift\"], resources: [\"Resources/**\"], settings: .settings( configurations: [ .debug( name: \"Development\", settings: [:], xcconfig: .init(\"Configuration/TuistPractice-Development.xcconfig\") ), .debug( name: \"Staging\", settings: [:], xcconfig: .init(\"Configuration/TuistPractice-Staging.xcconfig\") ), .release( name: \"Release\", settings: [:], xcconfig: .init(\"Configuration/TuistPractice-Production.xcconfig\") ) ] ) Target Type도 마찬가지로 엄청나게 많은 생성자를 가지고 있는데 역시 이것도 자세한 설명은Tuist Docs에서 확인할 수 있다. Project에서 가장 중요한 것은 Target 이라고 했는데, Target에서 가장 중요한 것들은 product인 것 같다.product에는 app, staticLibrary, staticFramework, framework, dynamic framework 등등이 있다. Tusit를 이용 하는 이유 중 하나는 모듈화 때문이기도 한데, 모듈화를 하기 위해서는 보통 모듈화 프로젝트 Main Target의 product를 static Library, staticFramework, framework로 만든다. 우리는 모듈화를 하기에 앞서, App Project를 만들어야 하기 때문에 product를 app으로 설정한다.$ tuist fetch // 3rd party를 사용하고 있다면 프로젝트를 생성 하기전에 이 명령어를 입력해줘야 한다\n$ tuist generate\n<br><img src=\"https://blog.kakaocdn.net/dn/zl8Ah/btrH5fngRIJ/gJUyyvffudGvDKtJW1p5W1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">여기까지 했다면 다음과 같이 뜨면서 생성이 안될텐데 저 에러메세지를 잘 읽어보고 해결하면 된다. 우리가 Target을 만들 때 Source 파일들을 [\"Sources/*/.swift\"] 이렇게 입력했기 때문에 이 path에 .swift 파일이 있어야 한다. 당연히 .xcconfig 파일도 마찬가지다.<br><img src=\"https://blog.kakaocdn.net/dn/bbpiHp/btrH1Brklij/zTJSdTvBtBbQjZQRljnQk0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/cqPBIG/btrH2hTEqBE/wqX37LiYkoGGsEMn54TPi0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/nEBrR/btrH5d33ZBv/ylruykXbWknTH3KQWdlYC0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">$ tuist generate\n<br><img src=\"https://blog.kakaocdn.net/dn/JgeLu/btrH6Hqi4LS/Mar5lLKlsYblYtqRTqedSK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Project가 아주 잘 생성되었다. 참고로 Sources 폴더 안에 있는 것들은 프로젝트 생성 후 잘되는 지 테스트하기 위해 만든 것이다.AppDelegate.swift, ViewController.swift 파일을 만들고 실행을 해보면// AppDelegate.swift\nimport UIKit @main\nclass AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil ) -&gt; Bool { let window = UIWindow(frame: UIScreen.main.bounds) window.backgroundColor = .white window.rootViewController = ViewController() window.makeKeyAndVisible() self.window = window return true }\n} // ViewController.swift import UIKit final class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() print(\"Hello Tuist\") view.backgroundColor = .purple }\n} ![](Build Setting 중 만난 에러프로젝트를 진행하면서 나중에 개발서버와 상용서버를 나눌 필요가 생길 거 같아서 빌드 세팅을 진행했다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ios-development.tistory.com/660\" target=\"_self\">https://ios-development.tistory.com/660</a>&nbsp;을 따라가며 진행했는데, 이런 오류를 만났다. 이것은, 실기기로 빌드 했을 때 뜨는 것이고, (기억 상) 시뮬레이터로 빌드를 하게 되면 Could not find module ‘Alamofire’ for target ‘i386-apple - ios - simulator가 떴다.<br><img src=\"https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">// podfile post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end\nend\npodfile에 다음과 같이 적으면 에러 해결!문제는 Alamofire다.위 스크린 샷의 에러가 Moya + Alamofire에서 발생하고, Alamofire를 사용하는 모든 Library에서 Compile error가 발생했다. (KakaoSDK, 커스텀한 Auth library ( inner DevPods))빌드 세팅을 하기 전에는 발생하지 않았던 오류인데 빌드 세팅을 하고나서 오류가 발생했다는 점에서 일단 매우 이상했다. 아무튼 이 에러를 해결 하기 위해, 무수한 삽질을 했다.Alamofire.framework를 /library/developer ~ /Alamofire/~ 뭐 이런 경로를 쭉 타고 가서 target을 확인 해봤는데 ‘x86_64’와 ‘arm64’ 두개가 있었다. 즉 armv7-apple-ios가 없어서 오류가 발생한 것이 맞다. (빌드 세팅을 하기 전에 단일 세팅일 떄는 왜 오류가 안났는 지는 아직도 의문이다.)그래서, 네비게이션 영역을 통해서 Pods project로 들어가서 Alamofire의 Architecture 부분을 확인하였다.Architectures의 부분이 $(ARCHS_STANDADRD_64_BIT)로 되어 있었다. 이 부분은을 STANDARD ARCH(arm7, arm64)로 고쳤을 때, 에러는 해결되었다. 다만 이렇게 설정했을 때, pod install을 다시하게 되면 본래대로 $(ARCHS_STANDADRD_64_BIT)로 바뀌어서 같은 에러가 발생한다.그래서 pod install 할 때, architecture setting을 지워주는 코드를 추가 했다.post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end\nend\n그리고 나서 Pod project의 Alamofire를 들어갔을 때, Architectures가 사라졌고 에러는 해결되었다.확실하진 않지만, 심증으로는 애플에서 디버그 용도는 32bit 아키텍쳐 ( 배포용도는 64bit도 )만을 지원하기 때문인 것 같다. 위에서 말한 것과 같이, 초기 세팅은 ARCHS_STANDARD_64_BIT 였기 때문이다.)아주 잘 작동한다. 가장 기본적인 사용 방식은 이렇듯 매우 간단하다. 실제 진행하는 프로젝트에서는 모듈화를 하기 때문에 이것보다 더 복잡한 방식으로 사용하지만 기본적인 사용방식을 벗어나지는 않는다. 많은 iOS 개발자들이 Tuist를 사용해 봤으면 좋겠다.끝.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TL; DR","level":3,"id":"TL;_DR_0"},{"heading":"Procedure","level":3,"id":"Procedure_0"},{"heading":"Why?","level":3,"id":"Why?_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/HL4gh/btrH1bsSD2d/gPuie03lbnXlZPqRGLKFA1/img.png","fullURL":"ios/tuist-기본적인-사용법.html","pathToRoot":"..","attachments":[],"createdTime":1735622304353,"modifiedTime":1735622371219,"sourceSize":12470,"sourcePath":"iOS/Tuist 기본적인 사용법.md","exportPath":"ios/tuist-기본적인-사용법.html","showInTree":true,"treeOrder":353,"backlinks":[],"type":"markdown"},"ios/tuist에서-ribs-fetch하기.-(carthage).html":{"title":"Tuist에서 RIBs Fetch하기. (Carthage)","icon":"","description":"Tuist를 이용해서 새로운 프로젝트를 시작했다. 어떤 방식으로 프로젝트를 설계할까에 대해 고민을 하고 많은 블로그들을 읽었고, 고민을 거듭한 끝에 다음 같이 구성했다.&nbsp;처음에 설계한 방식은 그래프에 나와있지는 않지만 CoreKit 아래에 RxPackage를 가지고 있었다.<img src=\"https://blog.kakaocdn.net/dn/yMkiy/btrBJMGgTgu/nkPRqkuukxwk7EW5249F1k/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">// Package.swift\n// swift-tools-version: 5.5\n// The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( name: \"RxPackage\", products: [ // Products define the executables and libraries a package produces, and make them visible to other packages. .library( name: \"RxPackage\", targets: [\"RxPackage\"]), ], dependencies: [ .package(url: \"https://github.com/ReactiveX/RxSwift.git\", from: \"6.5.0\"), .package(url: \"https://github.com/uber/RIBs.git\", from: \"0.9.0\"), ], targets: [ // Targets are the basic building blocks of a package. A target can define a module or a test suite. // Targets can depend on other targets in this package, and on products in packages this package depends on. .target( name: \"RxPackage\", dependencies: [ \"RxSwift\", \"RIBs\" ]), .testTarget( name: \"RxPackageTests\", dependencies: [\"RxPackage\"]), ]\n)\nRIBs는 RxSwift와 RxRelay에 의존성을 가지기 때문에 Package에서 url을 통해 fetch 하고 의존성을 해결하였다. 여기서 문제가 발생했다.Feature RIBs에서 RxCocoa의 rx.tap과 같은 기능들을 사용할 수가 없었다. 왜냐하면 RxPackage는 dependency로 RxCocoa를 가지고 있지 않기 때문. 위의 Package.swift를 다음처럼 조금만 더 수정하면 되지 않을까?// Package.swift\n// swift-tools-version: 5.5\n// The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( targets: [ // 생략 .target( name: \"RxPackage\", dependencies: [ \"RxSwift\", \"RIBs\", .product(name: \"RxCocoa\", package: \"RxSwift\") ]), // 생략 ]\n)\nimport RxCocoa가 되고 RxCocoa의 기능을 사용할 수 있었다.(자동완성) 그런데 빌드를 하고 나면 Missing required module RxCocoaRuntime이라는 Error가 발생하고 앱이 죽었다. 검색을 통해서 RxSwift Issue에서 관련된 두 가지 질문을 찾을 수 있었다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/ReactiveX/RxSwift/issues/2210\" target=\"_self\">https://github.com/ReactiveX/RxSwift/issues/2210</a>&nbsp;이 이슈에서는 UITest target에서 발생한 Issue이고 해당 답변에서 SPM Bug라고 한다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/ReactiveX/RxSwift/issues/2057\" target=\"_self\">https://github.com/ReactiveX/RxSwift/issues/2057</a>다음은 아래와 같은 해결책을 제시하였는데, 적용을 해봤지만 해결이 되지 않았다.<br><img src=\"https://blog.kakaocdn.net/dn/bxMQPw/btrBLVChZ5D/0NKg3NZ18iPPgW5nyq8dw0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">왜 안되는 지 정확하게 원인을 파악할 수 없었기 때문에 과감하게 Package를 이용해서 RIBs를 사용하는 방식을 포기하고 다른 방법을 모색하기 시작했다.많은 iOS 개발자들이 Carthage를 사용하기 때문에 tuist도 Carthage를 아주 잘 지원한다. (CocoaPod은 이제 지원 안 한다고 한다. 많은 사람들이 아직 많이 사용하는데...)Carthage를 이용하기 위해서 tuist edit 명렁어를 입력하고 Dependencies 파일에 Rx와 RIBs를 추가했다.그러고 나서 RxPackageKit이라는 Project를 만들고 이것은 ‘RxSwift’, ‘RIBs’ Dependencies를 가지고 있다.\n(Project.dynamicFramework()는 extension 입니다.)\n//\n// Dependencies.swift\n// ProjectDescriptionHelpers\n//\n// Created by // import ProjectDescription let dependencies = Dependencies( carthage: [ // ... .github(path: \"ReactiveX/RxSwift\", requirement: .exact(\"6.5.0\")), .github(path: \"uber/RIBs\", requirement: .branch(\"main\")), // ... ], swiftPackageManager: [ ], platforms: [.iOS]\n)\n/\n// Project.swift\n// ProjectDescriptionHelpers\n//\n// Created by 김호세 on 2022/05/09.\n// import ProjectDescription\nimport ProjectDescriptionHelpers let project = Project( name: \"RxPackageKit\", organizationName: \"com.jstock\", packages: [], targets: Project.dynamicFramework( name: \"RxPackageKit\", frameworkDependencies: [ .external(name: \"RxSwift\"), .external(name: \"RxCocoa\"), .external(name: \"RIBs\") ], testDependencies: [] ), schemes: []\n)\n다음으로 ‘Tuist 디렉토리가 있는’ 디렉토리에서 tuist fetch를 한다.$ tuist fetch\n<br><img src=\"https://blog.kakaocdn.net/dn/xrHws/btrBLGle4wn/SIKUMuTPcciFSVCFzTzB81/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">빌드에 실패하게 된다. 다음과 같은 오류를 뱉었으면, Tuist/Dependencies/Carthage/Build를 확인하자.<br><img src=\"https://blog.kakaocdn.net/dn/A8iOt/btrBKwbHofk/jSOA0SKLWhs8yMNVsNcfwk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">위처럼 Build 폴더에 Rx~.xcframework들이 있으면 성공이다.이렇지 못한 경우가 있는데 개인 노트북(M1 - XCode 12)으로 작업하는 경우 Carthage Bug(?)가 있어서 Build를 할 수 없다. 이때 Scirpt를 만들어서 carthage를 빌드해줘야 한다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md\" target=\"_self\">https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md</a>&nbsp;을 참고해서 carthage.sh를 생성하고 (./는 스크립트 생성한 위치)$ ./carthage.sh build RxSwift Tuist/Dependencies --platform iOS --use-xcframeworks --no-use-binaries --use-netrc --cache-builds --verbose\n$ ./carthage.sh build RIBs Tuist/Dependencies --platform iOS --use-xcframeworks --no-use-binaries --use-netrc --cache-builds --verbose\n를 입력하면 Rx~.xcframework들이 생성된다이제 Tuist/Dependencies/Carthage/Checkouts/RIBs/ios/RIBs.xcodeproj를 열고 RIBs Target을 확인해보면 RxRelay.framework, RxSwfit.framework에 의존성을 가지는데 RxSwift를 우리는 xcframework로 받았기 때문에 이것을 xcframework로 교체한다.(왼쪽 아래에서 add 하면 됨)<br><img src=\"https://blog.kakaocdn.net/dn/b38Nya/btrBOuwTj1G/uZgenHeGp6646RqN3gt6Ik/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/Ok2FB/btrBMa0ecow/f2cATHbznLXv4vVF9O6GeK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그런 다음에 RIBs를 다시 Build 한다.( Xcode 12인 경우 위처럼 스크립트로 실행해야 함.)$ carthage build RIBs --project-directory Tuist/Dependencies --platform iOS --use-xcframeworks --no-use-binaries --use-netrc --cache-builds --verbose\n<br><img src=\"https://blog.kakaocdn.net/dn/bBe8s0/btrBJMzw2Zw/agb4OgqaPAntmpqKJMfTaK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그러면 빌드에 성공한다. 프로젝트를 생성해주고$tuist generate\n<br><img src=\"https://blog.kakaocdn.net/dn/c5YQHD/btrBOup9phI/tabJrFaHT48lhlhKcyRRyk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">다음과 같은 예쁜 모양을 만들 수 있다. 그래프로 출력하게 되면 (-t 옵션은 테스트 타겟들 제외) 그래프가 예쁘게 나온다.$ tuist graph -t\n<br><img src=\"https://blog.kakaocdn.net/dn/bUUrsq/btrBMg0JE4a/V0Klqw0WIxAoPgJBcjXgyK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">프로젝트를 열고 App을 실행하면 RxCocoa도 성공적으로 import 할 수 있고, 빌드도 할 수 있게 된다.<br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-2\" target=\"_self\">http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-2</a>&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-1\" target=\"_self\">http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-1</a>&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/minsOne/iOSApplicationTemplate\" target=\"_self\">https://github.com/minsOne/iOSApplicationTemplate</a>&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md\" target=\"_self\">https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md</a>&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://okanghoon.medium.com/xcode-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-tuist-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-6a92950780be\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://okanghoon.medium.com/xcode-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-tuist-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-6a92950780be\" target=\"_self\">https://okanghoon.medium.com/xcode-프로젝트-관리를-위한-tuist-알아보기-6a92950780be</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제점 1. Module에서 RxCocoa를 import 할 수 없다.","level":2,"id":"문제점_1._Module에서_RxCocoa를_import_할_수_없다._0"},{"heading":"문제점 2. Missing required module RxCocoaRuntime","level":2,"id":"문제점_2._Missing_required_module_RxCocoaRuntime_0"},{"heading":"Carthage로의 이주","level":2,"id":"Carthage로의_이주_0"},{"heading":"Xcode 12? Bug?","level":3,"id":"Xcode_12?_Bug?_0"},{"heading":"Source","level":3,"id":"Source_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/yMkiy/btrBJMGgTgu/nkPRqkuukxwk7EW5249F1k/img.png","fullURL":"ios/tuist에서-ribs-fetch하기.-(carthage).html","pathToRoot":"..","attachments":[],"createdTime":1735621880078,"modifiedTime":1735621898262,"sourceSize":8804,"sourcePath":"iOS/Tuist에서 RIBs Fetch하기. (Carthage).md","exportPath":"ios/tuist에서-ribs-fetch하기.-(carthage).html","showInTree":true,"treeOrder":354,"backlinks":[],"type":"markdown"},"ios/ui-update-cycle.html":{"title":"UI Update Cycle","icon":"","description":"iOS 개발에서 UI 업데이트는 Run Loop를 기반으로 동작한다.각 Run Loop 사이클마다 순서대로 UI를 업데이트 한다.\n이벤트 처리(터치, 타이머 ...)\n레이아웃 업데이트\n디스플레이 업데이트\n// 터치 이벤트\noverride func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) // 제스처 이벤트 @objc func buttonTapped(_ sender: UIButton) // 타이머 이벤트\nTimer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in } // 네트워크 콜백\nURLSession.shared.dataTask(with: url) { data, response, error in } // 노티피케이션\nNotificationCenter.default.post(name: .dataUpdated, object: nil)\n이벤트 핸들링 흐름\n이벤트 큐에서 이벤트 수신\nHit Testing\nResponder Chain을 통한 이벤트 전달\n이벤트 핸들러 실행\n상태 변경\n레이아웃 메서드 함수들.\nsetNeedsLayout()\nview.setNeedsLayout() // 다음 업데이트 사이클에서 레이아웃 갱신! 즉시 실행 되지 않음. 다음 업데이트 사이클에서 레이아웃 갱신을 예약\n여러번 호출해도 한번만 실행됨 layoutIfNeeded()\nview.layoutIfNeeded() 예약된 레이아웃 작업을 즉시 실행\n보통 애니메이션과 함께 사용할 때 유용함 sizeThatFits(_:)\nlet size = view.sizeThatFits(CGSize(width: , height:)) 주어진 크기에 맞는 최적의 크기를 계산하여 변환\n실제 크기 변경 X\n직접 호출 or 시스템이 자동으로 호출 layoutSubviews()\noverride func layoutSubviews() { super.layoutSubviews() // 하위 뷰들의 프레임 설정\n} 실제 하위 뷰들의 위치와 크기를 설정\n직접 호출 X, setNeedsLayout()으로 예약 해야함\n시스템이 필요할 때 자동으로 호출 viewDidLayoutSubviews()\noverride func viewDidLayoutSubviews() { super.viewDidLayoutSubviews() // 레이아웃 완료 후 추가 작업\n} 뷰 컨트롤러의 뷰와 하위 뷰들의 레이아웃이 완료된 후 호출\n레이아웃 기반으로 추가 계신이나 설정을 할 때 사용\n1. setNeedsLayout() 호출 (레이아웃 갱신 예약) ↓\n2. 다음 Run Loop 사이클에서... ↓\n3. sizeThatFits() (필요한 경우) ↓\n4. layoutSubviews() ↓\n5. viewDidLayoutSubviews() (뷰 컨트롤러에서)\n오토레이아웃을 사용할 때 순서\nLayout 예약 확인 (setNeedsLayout()으로 예약된 뷰들을 수집)\nAutoLayout 제약 조건 확인 및 해결, 우선순위에 따른 제약 조건 적용\nsizeThatFits가 필요한 경우에 호출 - AutoLayout이 아닌 경우 주로 사용함\nlayoutSubviews() 호출 - 현재 뷰의 하위 뷰들 프레임 설정됨, 상위 뷰 -&gt; 하위 뷰 재귀적으로 호출됨.\nviewDidLayoutSubviews - 모든 하위 뷰의 레이아웃이 완료된 후 호출\n1. setNeedsLayout() 예약 처리\n2. Auto Layout Engine 동작 ├── 제약 조건 수집 ├── 제약 조건 해결 (Linear Programming) └── 프레임 계산\n3. sizeThatFits() 호출 (필요시)\n4. 뷰 계층 구조를 따라 layoutSubviews() 재귀 호출 ├── 상위 뷰 → 하위 뷰 순서 └── 각 뷰의 프레임 최종 결정\n5. viewDidLayoutSubviews() 호출 layoutSubviews()를 직접 호출하지 말고 setNeedsLayout()이나 layoutIfNeeded() 사용\n무한 루프 방지: layoutSubviews() 내에서 setNeedsLayout() 호출 주의\n성능을 위해 불필요한 레이아웃 갱신은 피하기\nAuto Layout 사용 시에는 대부분 자동으로 처리됨\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Event Handling","level":3,"id":"Event_Handling_0"},{"heading":"Layout cycle","level":3,"id":"Layout_cycle_0"},{"heading":"구체화","level":4,"id":"구체화_0"},{"heading":"주의사항","level":3,"id":"주의사항_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ios/ui-update-cycle.html","pathToRoot":"..","attachments":[],"createdTime":1751291409476,"modifiedTime":1751292660903,"sourceSize":3770,"sourcePath":"iOS/UI Update Cycle.md","exportPath":"ios/ui-update-cycle.html","showInTree":true,"treeOrder":355,"backlinks":[],"type":"markdown"},"ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html":{"title":"Unit Test와 TDD - 근데 이게 async await를 곁들인","icon":"","description":"유닛 테스트는 테스트 케이스를 작성하는 절차로써 특정 모듈이 정확히 작동하는지 검증하는 절차입니다.\n문제점을 발견하기 쉽다\n-&gt; 프로그램을 독립적인 작은 단위로 쪼개서 검사하기 때문에 잘못된 점을 빠르게 발견할 수 있다. → 디버깅 시간의 단축\n변경이 쉽다.\n-&gt; 코드 리팩토링시에 유용하다. 리팩토링 후에도 의도대로 작동하고 있음을 유닛 테스트를 통해 확신할 수 있다.\n통합이 쉽다.\n-&gt; 유닛 테스트는 유닛 자체의 불확실성을 제거해 준다. 그렇기 때문에 유닛들의 통합들을 검증하는 Integration Test에서 유용하다.\nTesting 할 때, 가장 좋은 관행(Practice)은 FIRST이다.\nFast:&nbsp;테스트들은 빠르게 실행되어야만 한다.\nIndependent / Isolated:&nbsp;테스트들은 서로 state를 공유해서는 안된다. (독립적)\nRepeatable:&nbsp;검사를 할 때마다 동일한 결과를 얻어야 한다.\nSelf-validating:&nbsp;테스트들은 automated 여야 한다. 결과는 \"Pass or Fail\" 이여야 한다.\nTimely:&nbsp;이상적으로 Production Code를 만들기 전에, Test Code부터 작성해야 한다.(TDD)\nTDD는 테스트 주도 개발이라는 뜻으로, 테스트를 먼저 작성하고 그것이 통과하는 코드를 작성하는 개발 방법론입니다. TDD는 다음과 같은 기본적인 원칙에 따라 개발됩니다.<img src=\"https://blog.kakaocdn.net/dn/SLAXa/btr3XzeOz6m/jHDqIOdvfH0lcWCpgrOKBK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">\n자동화된 테스트 케이스를 작성한다.\n&lt; RED &gt;: 테스트를 실행하면 실패하는 것을 확인한 후 코드를 작성한다.\n&lt; GREEN &gt;: 작성한 코드를 테스트를 통과시킨다.\n&lt; REFATOR&gt;: 리팩토링을 통해 중복 코드를 제거하고 더 나은 코드를 만든다.\n장점\n코드의 품질을 높일 수 있고, 버그를 줄일 수 있다\n기능 추가나 수정을 할 때 기존 코드에 영향을 미치지 않도록 하며 코드의 유지보수가 용이해진다.\n단점\n초기에 작성하는 테스트 케이스와 코드의 품질이 좋지 않을 경우, 전체적인 개발 프로세스가 더욱 지연될 수 있다.\n프로그램 개발 전에, 테스트 코드부터 작성하므로 전체적인 생산성이 저하할 수 있다\n아이디 유효성 검증을 하는 Validator를 구현해야 한다고 합시다. 먼저&nbsp;요구사항을 살펴보고 Validator를 구현하도록 합시다.\n요구사항: 아이디는 반드시 알파벳 소문자로 시작해야 하며, 알파벳 소문자와 숫자를 포함하여 5자 이상 12자 이하로 한다.\nValidator를 쉽게 테스트하기 위해서 객체로 만듭니다. 그리고 유효성 검증 패턴을 정규 표현식으로 작성해 주고 이에 어긋날 시 false, 만족하면 true를 리턴하는 함수를 만듭니다. 우리는 이 Validator 객체를 신뢰하기 위해서 함수를 테스트하면 됩니다.// Validator.swift import Foundation public struct Validator { public init() { } private let idValidationPattern: String = \"^[a-z]{1}[a-z0-9]{4,11}$\"\n} public extension Validator { func idValidateByClient(_ input: String) -&gt; Bool { guard let regex = try? NSRegularExpression( pattern: idValidationPattern, options: [] ) else { assertionFailure(\"Regex not valid\") return false } let regexFirstMatch = regex .firstMatch( in: input, options: [], range: NSRange(location: 0, length: input.count) ) return regexFirstMatch != nil }\n}\nProject에서 command + 6을 누르고 왼쪽 하단에 + 버튼을 클릭해서 유닛 테스트를 추가합니다.테스트하고 싶은 모듈을 @testable Import 하고 setUpWithError에서 테스트하고 싶은 객체를 선언해 줍니다.import XCTest\n@testable import Validator final class ValidatorTests: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() sut = Validator() } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() }\n}\nTDD 방법론에 따라서 먼저 실패하는 케이스를 적용해 보면 되겠습니다. 어떤 케이스가 실패를 할까요? TDD의 핵심은 바로 이런 테스트 시나리오를 짜는 것이라고 생각합니다.테스트 시나리오를 쉽게 생각하기 위해서는&nbsp;Given,&nbsp;When,&nbsp;Then으로 나눠서 생각하는 것이 좋다고 합니다.다음과 같은 테스트 케이스(Given)는 테스트시에(When) 실패(Then)해야만 합니다.\n1psychehose → 숫자로 시작함\n_psychehose → 특수문자로 시작함\nPsychehose → 대문자로 시작함\n김psychehose → 한글로 시작함\npsychehose! → 특수문자 포함\na → 1글자\nabcd → 4글자\nabcde12345678 → 13글자\n테스트 함수 코드는&nbsp;무조건 앞에 test가 붙어야 합니다. 그리고 테스트 결과를 알기 위해&nbsp;XCTAssertEqual&nbsp;함수를 이용할 건데, 사용하기 정말 쉽습니다. 매개변수 1과 매개변수 2를 비교해서 같으면 성공, 다르면 실패합니다. 따라서 실패 케이스를 작성할 때&nbsp;XCTAssertEqual(result, true)는 실패해야 합니다. 그러면 위의 실패하는 테스트 케이스를 바탕으로 코드를 작성해 보겠습니다.import XCTest\n@testable import Validator final class ValidatorTests: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() sut = Validator() } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func testFailFirstNumberID() throws { // Given let id = \"1psychese\" // When let result = sut.idValidateByClient(id) // Then XCTAssertEqual(result, true) } func testFailFirstSpecialSymbolID() throws { let id = \"_psychehose\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailFirstCaptialID() throws { let id = \"Psychehose\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailFirstKoreanID() throws { let id = \"김psychehose\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailOneLetterID() throws { let id = \"p\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailFourLetterLetterID() { let id = \"abcd\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailThirteenLetterID() throws { let id = \"abcde12345678\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailIDWithSymbol() throws { let id = \"ab!cdef\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) }\n}\n<br><img src=\"https://blog.kakaocdn.net/dn/8lEPE/btr3WaTHqhQ/P30kT6HEIA3m5KweKrzusk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">원하는 대로 실패하는 결과값이 잘 나온 것 같습니다. 만약 여기에서, 원하는 결과값이 나오지 않는다면 코드 리팩토링을 진행하면 되겠습니다. 그러면 이제 통과하는 케이스를 바탕으로 코드를 작성하겠습니다.다음과 같은 테스트 케이스(Given)는 테스트시에(When) 성공(Then)해야만 합니다.\nabcde\npsychehose\nabcdeabcdeab\nabcd1234\na1b2c3d4\nimport XCTest\n@testable import Validator final class ValidatorTests: XCTestCase { // ... // ... func testSuccessFiveLetterID() throws { let id = \"abcde\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessID() throws { let id = \"psychehose\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessTwelveLetterID() throws { let id = \"abcdeabcdeab\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessIDWithNumber1() throws { let id = \"abcd1234\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessIDWithNumber2() throws { let id = \"a1b2c3d4\" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) }\n}\n<br><img src=\"https://blog.kakaocdn.net/dn/bqktVJ/btr35EePQWY/sOPslnmvnaKImxBXk1xLv0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이번에도 원하는 대로 성공하는 결괏값이 잘 나온 것 같습니다. 만약 여기에서 실패한다면 코드 리팩토링을 해야만 합니다. 그리고 다시 실패 케이스 단계로 돌아가야만 합니다. 이 과정을 반복하면서 개발을 완료하도록 합니다.\n주의) 이 단락은 저의 생각을 많이 담고 있습니다. 정답이 아니고 제 개인적인 생각이니 주의해서 읽어주세요. 틀린 점이 있거나 자신의 생각과 다른 점이 있으면 알려주시면 감사하겠습니다.\n비동기처리의 대표적인 예는 서버 통신이 있습니다. 사용자가 회원가입을 하는 상황을 생각해 봅시다. 아이디란에 아이디를 입력하고 위에서 작성한 아이디 유효성 검사를 무사히 통과했습니다. 이게 끝이 아닌 걸 압니다. 앱은 이 아이디를 서버에 보내고 서버는 데이터베이스에서 조회해 아이디 중복 검사를 합니다. 우리가 중복검사를 하고자 하는 아이디를 서버에 보내고 그 결과가 올 때까지 우리는 기다려야 합니다. 즉 우리는 비동기 함수를 작성해야 합니다. 그러면 비동기 함수는 어떻게 테스트하면 될까요?&nbsp;사실 이 부분을 넣을까 고민했었습니다. 'Validator의 역할(책임)을 어디까지로 잡을 것인가' 대해 생각해 봤을 때 의문이 들었습니다.\n위의 상황처럼 Validator에서 서버 통신을 하고 백엔드에서 최종적으로 유효성 검사(아이디 중복여부, 아이디 형식)를 해서 회원가입 여부를 Response 값으로 던져준다. 즉 Validator는&nbsp;네트워크 의존성을 가지고 서버 통신 테스트를 작성해야 함\nValidator는 로컬에서 아이디 형식에 대한 유효성 검사만 한다. - 이 경우에 위의 상황 테스트는 Validator와 Network를 같이 알고 있는 상위 모듈이나 ViewModel, Interactor 같은 곳에서 테스트하게 됨.\n<br><img src=\"https://blog.kakaocdn.net/dn/boF5CY/btr5AAwdUlO/sfnmCVkgUo1ZVbZCHjKaG0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/cVpKcQ/btr5AOHJmHa/wNgkM1gMHkOhEugnQKpJ80/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">왼쪽: 1번 경우, 오른쪽: 2번 경우따라서 어떤 '구조'를 가지고 있느냐가 어떤&nbsp;테스트 코드를 작성할지&nbsp;결정하는&nbsp;것 같습니다.저는 네트워크 모듈을 따로 만들어서 사용하고 Validator는 어떠한 의존성도 가지지 않게 개발했습니다. 그렇기에 Validator에서 비동기를 처리하는 함수를 만들지 않았습니다.&nbsp;다만 이 포스팅은 유닛테스트 전반적인 것에 대해서 쓰고 싶기 때문에, 1번 경우로 가정(회원가입 여부: Boolean을 받음)을 하고 테스트 코드를 작성하겠습니다.서버 통신 테스트 방법은 두 가지가 있어요.&nbsp;\n앱에서 만든 가짜 서버와 통신하는 것 - Mock Test\n실제 서버와 통신하는 것 - Slow Test\n실제 작업을 할 때,&nbsp; 프로젝트 시작 단계에서 기획 문서 하나만 있는 경우가 있을 수도 있습니다. 이때 Mock을 만들어서 서버 통신을 테스트할 수 있습니다. 먼저 Validator에 코드 추가를 하겠습니다.Response 결과는 [Bool] type으로 받겠습니다.&nbsp;(key 이름 짓기 귀찮아서)// Validator.swift\nimport Foundation public struct Validator { public init(configuration: URLSessionConfiguration = .default) { self.configuration = configuration } private let configuration: URLSessionConfiguration private let idValidationPattern: String = \"^[a-z]{1}[a-z0-9]{4,11}$\" private var session: URLSession { return URLSession(configuration: self.configuration) }\n} public extension Validator { func isValidationFromServer(_ url: URL) async throws -&gt; Bool { let url = url let urlRequest = URLRequest(url: url) let (data, _) = try await session.data(for: urlRequest) guard let isValidate = try JSONDecoder().decode([Bool].self, from: data).first else { throw NSError(domain: \"No Data\", code: -1) } return isValidate }\n}\nValidator에서 서버 통신을 할 것이기 때문에, Validator가 URLSession을 가지고 있어야 해요. 이 때 Session Configuration을 주입받을 수 있게 해 주세요.이제&nbsp;isValidationFromServer&nbsp;함수를 한번 살펴볼게요. 다른 함수와 다르게 async 키워드가 매개변수 오른쪽에 붙어있는 것을 확인할 수 있습니다. 이것은 비동기 함수라는 뜻입니다.let (data, _) = try&nbsp;await&nbsp;session.data()를 보면 await 키워드를 확인할 수 있어요. await는 무엇일까요?&nbsp; 애플이 구현해놓은 session.data() 함수를 한번 확인하면 알 수 있습니다. public func data( for request: URLRequest, delegate: URLSessionTaskDelegate? = nil ) async throws -&gt; (Data, URLResponse) /// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally. /// /// - Parameter url: The URL for which to load data. /// - Parameter delegate: Task-specific delegate. /// - Returns: Data and response.\nawai는 문자 그대로&nbsp; '기다린다'라는 뜻입니다. 그러면 무엇을 기다릴까요? 애플이 구현해놓은 .data(for:)에서&nbsp;async&nbsp;키워드가 보이시나요? await는 async를 기다린다고 할 수 있겠네요.Mock으로 Test를 진행해야 하는데요. 이것은 Validator를 생성할 때 주입하는&nbsp;URLSessionConfiguration의 property인&nbsp;protocolClasses&nbsp;값을 설정하면 값을 하이재킹 할 수 있습니다. MockURLProtocol을 구현하도록 하겠습니다.&nbsp;// MockURLProtocol.swift import Foundation\ntypealias CustomResponse = Result&lt;Data, Error&gt; class MockURLProtocol: URLProtocol { static var responseHandler: ((URLRequest) throws -&gt; (response: HTTPURLResponse, data: CustomResponse))? override class func canInit(with request: URLRequest) -&gt; Bool { return true } override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest { return request } override func startLoading() { guard let handler = MockURLProtocol.responseHandler else { return } do { let result = try handler(request) let httpResponse = result.response let customResponse = result.data switch customResponse { case .success(let data): client?.urlProtocol(self, didReceive: httpResponse, cacheStoragePolicy: .notAllowed) client?.urlProtocol(self, didLoad: data) client?.urlProtocolDidFinishLoading(self) case .failure(let error): client?.urlProtocol(self, didFailWithError: error) } } catch { client?.urlProtocol(self, didFailWithError: error) } } override func stopLoading() { debugPrint(\"Stop Loading\") }\n}\n여기까지 구현하면 드디어 Mock으로 Unit Test를 할 수 있게 됩니다.유닛테스트 파일을 생성하고 테스트 코드를 작성하면 되겠습니다. 저는 ValidatorMockTest.swift로 파일을 만들게요.import Foundation\nimport XCTest\n@testable import Validator final class ValidatorMockTest: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() let config = URLSessionConfiguration.ephemeral config.protocolClasses = [MockURLProtocol.self] sut = Validator(configuration: config) } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func test_available_from_mock() async throws { // Mock을 생성 -&gt; 이것이 우리가 받을 결과임 MockURLProtocol.responseHandler = { request in let response = HTTPURLResponse( url: request.url!, statusCode: 200, httpVersion: nil, headerFields: nil )! let mockResult: [Bool] = [true] let mockResponseData = try! JSONEncoder().encode(mockResult) let responseData = CustomResponse.success(mockResponseData) return (response, responseData) }\n// URL에 \"https://\" 이런식으로 말이 되는 URL 넣으면 됩니다. scheme host 다 있어야함 let testTargetValue = try await sut.isValidationFromServer(URL(string: \"https://www.test11111.com\")!) XCTAssertEqual(testTargetValue, true) } func test_no_available_from_mock() async throws { MockURLProtocol.responseHandler = { request in let response = HTTPURLResponse( url: request.url!, statusCode: 200, httpVersion: nil, headerFields: nil )! let mockResult: [Bool] = [false] let mockResponseData = try! JSONEncoder().encode(mockResult) let responseData = CustomResponse.success(mockResponseData) return (response, responseData) } let testTargetValue = try await sut.isValidationFromServer(URL(string: \"https://www.test11111.com\")!) XCTAssertEqual(testTargetValue, false) } func test_empty_error_from_mock() async throws { MockURLProtocol.responseHandler = { request in let response = HTTPURLResponse( url: request.url!, statusCode: 404, httpVersion: nil, headerFields: nil )! let mockResult: [Bool] = [] let mockResponseData = try! JSONEncoder().encode(mockResult) let responseData = CustomResponse.failure(NSError(domain: \"No data. Empty\", code: -10)) return (response, responseData) } let testTargetValue = try await sut.isValidationFromServer(URL(string: \"https://www.test11111.com\")!) XCTAssertEqual(testTargetValue, false) }\n}\n이제 코드 보시면 완전히 이해가 갈 것에요. 주의할 점은 setupWithError에서 Validator를 생성할 때 Configuration의 protocolClassese에&nbsp;[MockURLProtocol.self]를 꼭 넣어줘야 합니다. 그래야 값을 Mock Response 값을 받을 수 있어요.<br><img src=\"https://blog.kakaocdn.net/dn/dY99TU/btr5N3StqIK/mklb1GFX0duc6c1T3qR9Ek/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">마지막으로 실제 서버로 하는 테스트 코드를 작성해 볼게요. 자신이 가지고 있는 실제 서버가 없으면 Postman을 통해서 Mock Server를 손쉽게 만들 수 있습니다. 'postman mock server'로 검색하면 다양한 포스팅을 확인할 수 있을 거예요.<br><img src=\"https://blog.kakaocdn.net/dn/6BdrF/btr5N3LLvql/fXd4uG18FlgqUnRlOOSXK1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">저는 총 세 가지 경우를 테스트할 거예요.(실제 API 테스트이기 때문에 config의 protocolClassess 넣는 코드를 주석처리 하거나 삭제해야 합니다. 그리고 아래 코드에서 url에 자신의 서버 URL을 입력하시면 됩니다.)\n&nbsp;회원가입 가능: endpoint - available, 결과 - [true]\n&nbsp;회원가입 불가능: endpoint - noavailable, 결과 - [false]\n&nbsp;에러: endpoint - empty, 결과 - []\nimport Foundation\nimport XCTest\n@testable import Validator final class ValidatorSlowTest: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() let config = URLSessionConfiguration.ephemeral sut = Validator(configuration: config) } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func test_available_api_test() async throws{ guard let url = URL( string: \"\" ) else { return } let result = try await sut.isValidationFromServer(url) XCTAssertEqual(result, true) } func test_no_available_api_test() async throws{ guard let url = URL( string: \"\" ) else { return } let result = try await sut.isValidationFromServer(url) XCTAssertEqual(result, false) } func test_empty_api_test() async throws{ guard let url = URL( string: \"\" ) else { return } let result = try await sut.isValidationFromServer(url) XCTAssertEqual(result, true) }\n}\n<br><img src=\"https://blog.kakaocdn.net/dn/b7vDo2/btr5PbWC4Zu/3igzX1RKFfgQUyGKAjRgxk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">&nbsp;Unit Test에 대해 전반적으로 알아봤습니다. GitHub을 구경하거나, 회사 공고를 보면 대부분 MVVM, VIPER(RIBs) 패턴을 사용하고 있는 것 같습니다. 그렇기 때문에 저것들을 공부했었는데요. 왜 사용하냐고 물어보면 로직이 분리되어 있어서 코드 관리가 용이하다, 테스트가 용이하다 같은 말들을 하곤 했습니다. 그러다가 실제로 테스트 코드를 작성해야 할 일이 생겼는데 '테스트 코드를 대체 어떻게 작성해야 하지?' 같은 생각이 들어 멘탈이 나간 적이 있어요. 그때 중요한 걸 놓쳤다는 생각이 들었습니다. 이번 포스팅을 통해서, 테스트 코드와 조금 친해진 거 같아서 꽤나 뿌듯합니다. 테스트와 베스트 프렌드가 되고 싶기 때문에 조만간 MVVM 테스트에 대해 공부하고 포스팅해보고 싶습니다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/UnitTestForValidator\" target=\"_self\">https://github.com/psychehose/UnitTestForValidator</a>Reference<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.apple.com/videos/play/wwdc2018/417/\" target=\"_self\">https://developer.apple.com/videos/play/wwdc2018/417/</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://swiftsenpai.com/swift/async-await-network-requests/\" target=\"_self\">https://swiftsenpai.com/swift/async-await-network-requests/</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.swiftbysundell.com/articles/unit-testing-code-that-uses-async-await/\" target=\"_self\">https://www.swiftbysundell.com/articles/unit-testing-code-that-uses-async-await/</a><br><a data-tooltip-position=\"top\" aria-label=\"https://xtring-dev.tistory.com/entry/Postman-Postman-Mock-Server%EB%A5%BC-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-Front-end-%EC%84%A0%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0%ED%98%91%EC%97%85\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://xtring-dev.tistory.com/entry/Postman-Postman-Mock-Server%EB%A5%BC-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-Front-end-%EC%84%A0%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0%ED%98%91%EC%97%85\" target=\"_self\">https://xtring-dev.tistory.com/entry/Postman-Postman-Mock-Server를-구축하기-Front-end-선개발하기협업</a><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.kodeco.com/21020457-ios-unit-testing-and-ui-testing-tutorial\" target=\"_self\">https://www.kodeco.com/21020457-ios-unit-testing-and-ui-testing-tutorial</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"What is Unit Test?","level":2,"id":"What_is_Unit_Test?_0"},{"heading":"What is advantages of Unit Test?","level":2,"id":"What_is_advantages_of_Unit_Test?_0"},{"heading":"Unit Test 시 좋은 습관","level":3,"id":"Unit_Test_시_좋은_습관_0"},{"heading":"TDD (Test Driven Development)란?","level":2,"id":"TDD_(Test_Driven_Development)란?_0"},{"heading":"iOS Programming에서 Testing을 적용하는 방법","level":2,"id":"iOS_Programming에서_Testing을_적용하는_방법_0"},{"heading":"(Optional) 비동기 처리 테스트와 고찰","level":3,"id":"(Optional)_비동기_처리_테스트와_고찰_0"},{"heading":"Validator에 서버 통신 코드 추가하기","level":3,"id":"Validator에_서버_통신_코드_추가하기_0"},{"heading":"Mock Unit Test를 위해 MockURLProtocol 생성 및 테스트 코드 작성","level":3,"id":"Mock_Unit_Test를_위해_MockURLProtocol_생성_및_테스트_코드_작성_0"},{"heading":"API 테스트 코드 작성","level":3,"id":"API_테스트_코드_작성_0"},{"heading":"고찰","level":4,"id":"고찰_0"},{"heading":"","level":4,"id":"_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/SLAXa/btr3XzeOz6m/jHDqIOdvfH0lcWCpgrOKBK/img.png","fullURL":"ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html","pathToRoot":"..","attachments":[],"createdTime":1735622595968,"modifiedTime":1735622725013,"sourceSize":22950,"sourcePath":"iOS/Unit Test와 TDD - 근데 이게 async await를 곁들인.md","exportPath":"ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html","showInTree":true,"treeOrder":356,"backlinks":[],"type":"markdown"},"ios/wwdc-2023-parameter-pack.html":{"title":"WWDC 2023 Parameter pack","icon":"","description":"WWDC 2023 Generalize APIs with parameter pack을 보고 알게된 것을 정리하기 위해 포스팅 하게 되었습니다. 모바일 애플리케이션을 만들 때 Swift로 Variadic Function을 사용하는 경우가 많이는 있을 것 같지 않지만, Swift 언어 자체 관점에서 보면 참 매력적인 피쳐라고 생각해요. 얼른 실험이 끝나고 swift 메인에 병합되었으면 좋겠네요.Generalize APIs with parameter pack을 보기 위해서는 제네릭에 대한 이해를 어느 정도 요구하고 이 포스팅도 마찬가지로 영상을 따라가기 때문에 제네릭에 대한 선수적인 지식이 조금 필요할 것 같아요. 하지만 쉽게 풀어쓰도록 최선을 다하겠습니다.파라미터 팩에 대한 영상을 볼 때 계속 나오는 단어가 있습니다.&nbsp;Variadic argument&nbsp;한글로 뜻 풀이하면 가변 전달인자입니다. 우리가 흔히 함수를 작성할 때 파라미터 영역과 리턴타입을 선언부에 작성하고 body에 함수 내용을 작성합니다.// 선언부\nfunc sum(_ operand1: Int, _ operand2: Int) -&gt; Int { // Body return operand1 + operand2\n} // main.swift sum(3, 4)\n위 코드에서 3, 4가 바로 argument(전달인자)입니다. 지금처럼 함수 파라미터 개수가 2개인 경우도 있지만, 상황이 바뀌어 세 수를 더하고 싶습니다. 그러면 어떻게 하면 될까요? 배열을 만들어 루프를 돌아 처리 하는 방법이 있겠지만 저장할 필요가 없기 때문에 배열을 사용하고 싶지 않습니다. 그렇다면 함수 오버로딩을 통해서 구현하면 됩니다.// 함수 오버로딩 func sum(_ operand1: Int, _ operand2: Int, _ operand3: Int) -&gt; Int { // Body return operand1 + operand2 + operand3\n} // main.swift sum(3, 4, 5)\n또 상황이 바뀌어 6개의 수를 더하고 싶습니다… 함수 오버로딩을 이용하게 되면 반복적인 패턴이 나타나게 되고 로직이 바뀌면 유지보수가 쉽지 않습니다. 그럴 때 가변 인수개수를 허용하는 것입니다. 이것이 바로&nbsp;Variadic&nbsp;function 입니다.func sum(_ operands: Int...) -&gt; Int { var sum = 0 for op in operands { sum += op } return sum\n} print(sum(1,2,3,4,5,6,7,8)) // 36\n이런 Variadic function은 확실히 유용합니다. 하지만 한계점이 명확합니다.\n여러개의 인자를 받고 이걸 tuple로 만들어서 return 하는 함수를 만든다고 가정합시다. 그렇다면 어떤 타입을 리턴 해야할까요?\nfunc tuplify(_ numbers: Int...) -&gt; ??? { } Variadic parameter는 다양한 타입을 사용할 수 없습니다. 여러 타입을 사용하려면 type erasure를 고려해야합니다. 하지만 이 방법을 사용하게 된다면 전달인자의 specific한 타입에 대한 정보를 사용할 수 없습니다. 이 말은 캐스팅을 해서 사용해야 하기 때문에 런타임에러가 발생할 확률이 높습니다. (디버깅 비용을 낮추기 위해서는 컴파일러를 최대한 이용해야 합니다.)&nbsp;\nfunc testFunc(objects: Any...) { // 컴파일러는 일을 안한다. // object들은 type information을 이용할 수 없음 -&gt; 캐스팅 해야함 -&gt; 런타임에러\n}\n&nbsp;즉 현재까지의 Swift로는 제네릭과 Variadic parameter로 type information을 보존할 수가 없고 여러개의 전달인자를 사용할 수 없었습니다. 이것을 하는 방법은 overloading 밖에 없었습니다. 하지만 Swift 5.9에서 Parameter Pack이 도입되었고 제네릭과 함께 전달인자 길이에 대해 추상화가 가능해졌습니다.파라미터 팩은 영단어 그대로 해석하면 됩니다. 파라미터를 담는 팩입니다. 타입 또는 값을 가지고 있고 (holds) 그것을 싸서 (packs) 전달인자로 넘겨줄 수 있습니다.\nBool, Int, String 이 세가지 individual type을 한꺼번에 묶어서 처리함 → type pack\ntrue, 10, “” 위의 type pack에 대응하는 value pack\n파라미터 팩은 생각보다 친숙한 개념입니다. 데이터를 담는 바구니 같은 것이기 때문에요. 마치 컬렉션처럼요. 다만 컬렉션은 동일한 타입만을 다룰 수 있는데 반해 파라미터 팩은 각각의 아이템들이 different 타입일 수 있다는 점입니다. 즉 파라미터 팩을 이용하면 type - level에서 작동할 수 있으며 이는 각각의 유형을 쉽게 처리할 수 있다는 뜻입니다.좋아요. 파라미터 팩이 뭔지 어느정도 알 거 같죠? 그러면 코드를 통해서 어떻게 작동하는 지 살펴보도록 할게요.오버로딩 패턴으로 이뤄진 기존의 코드를 파라미터 팩을 이용해서 리팩토링 하겠습니다. item들을 받아서 이것을 튜플로 리턴하는 함수입니다.// Query // 아래 코드를 리팩토링 할 것입니다\nfunc query&lt;Payload&gt;( _ item: Request&lt;Payload&gt;\n) -&gt; Payload func query&lt;Payload1, Payload2&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;\n) -&gt; (Payload1, Payload2) func query&lt;Payload1, Payload2, Payload3&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;, _ item3: Request&lt;Payload3&gt;\n) -&gt; (Payload1, Payload2, Payload3) func query&lt;Payload1, Payload2, Payload3, Payload4&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;, _ item3: Request&lt;Payload3&gt;, _ item4: Request&lt;Payload4&gt;\n) -&gt; (Payload1, Payload2, Payload3, Payload4)\n실제 코드로 살펴봐야하니 약간 구현을 하도록 하겠습니다.struct Request&lt;Payload&gt; { var payload: Payload init(payload: Payload) { self.payload = payload }\n} func query&lt;Payload1, Payload2, Payload3&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;, _ item3: Request&lt;Payload3&gt;\n) -&gt; (Payload1, Payload2, Payload3) { return (item1.payload, item2.payload, item3.payload)\n} print(query(Request(payload: true), Request(payload: 10), Request(payload: \"\")))\n// Print: (true, 10, \"\")\n파라미터 팩을 이용한 코드는 each 키워드를 사용해 작성되고 repeat 키워드를 사용해 repetition 패턴을 이용합니다.repeat (Requset&lt;each Payload&gt;)\n위 코드의 뜻은 패턴이 반복되고, each Payload 자리가 각 반복동안 concrete 타입으로 대체된다는 것을 의미 합니다. 우리가 만든 예시는 Request&lt;Bool&gt;, Request&lt;Int&gt;, Request&lt;String&gt;, Request&lt;Bool&gt;, Request&lt;Int&gt;가 될 거에요.(Request&lt;Bool&gt;, Request&lt;Int&gt;, Request&lt;String&gt;) == (repeat Reqeust&lt;each Payload&gt;)\n그러면 아래처럼 함수를 바꿀 수 있게 됩니다.func query&lt;each Payload&gt;( _ item: repeat (Request&lt;each Payload&gt;)\n) -&gt; (repeat (each Payload)) { return (repeat (each item).payload)\n} let result = query( Request(payload: true), Request(payload: 10), Request(payload: \"\")\n) print(result) // Print: (true, 10, \"\")\n제네릭 Payload에 Equatable 프로토콜을 컨펌하는 타입만 허용하게 하고 싶어요. 그러면 평소 제네릭을 쓰는 것처럼&nbsp;제네릭 &lt;&gt;에 제약조건을 추가하거나,&nbsp;where&nbsp;을 이용하면 됩니다.// MARK: - 제네릭에 제약 조건 추가 // 1. 제네릭 선언부에 제약조건 func query&lt;each Payload: Equatable&gt;( _ item: repeat (Request&lt;each Payload&gt;)\n) -&gt; (repeat (each Payload)) { return (repeat (each item).payload)\n} // 2. where Clause 제약조건 func query&lt;each Payload&gt;( _ item: repeat (Request&lt;each Payload&gt;)\n) -&gt; (repeat (each Payload)) where repeat (each Payload): Equatable { return (repeat (each item).payload)\n} let result = query( Request(payload: true), Request(payload: 10), Request(payload: \"\")\n) print(result) class TestClass { } // Complie Error: 클래스는 Equatable 만족안함. Equatable 직접 구현하면 컴파일 성공!!\nlet result2 = query( Request(payload: true), Request(payload: 10), Request(payload: \"\"), Request(payload: TestClass())\n)\nfunc query&lt;each Payload&gt;( _ item: repeat (Request&lt;each Payload&gt;)\n) -&gt; (repeat (each Payload)) where repeat (each Payload): Equatable { return (repeat (each item).payload)\n} var test: () = query() // 컴파일 성공!\n경우에 따라, 최소한 한개의 길이 보장을 하고 싶어요. 함수 body에 분기코드를 작성해 구현할 수 있으나, 그렇게 되면 런타임 에러에 좀 취약해질 수 있겠죠? 별 차이는 없겠지만 속도가 더 느릴테고요. 이 경우에는 제네릭 선언부에 한개를 더 선언함으로써 쉽게 구현할 수 있습니다. 항상 컴파일러에게 일을 할당해주는 게 좋다고 생각해요.func query&lt;FirstPayload, each Payload&gt;( _ first: Request&lt;FirstPayload&gt;, _ item: repeat Request&lt;each Payload&gt;\n) -&gt; (FirstPayload, repeat each Payload) where FirstPayload: Equatable, repeat each Payload: Equatable { return (first.payload, repeat (each item).payload)\n}\n<img src=\"https://blog.kakaocdn.net/dn/S1EJQ/btslw8Cx1gx/cD5Zal2xo39GRSuZpgNau1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">&nbsp;파라미터 팩의 마지막 부분은 Generic에 파라미터 팩을 사용하는 방법입니다. WWDC 영상에서는 이 부분까지 다루긴 합니다. 그런데 아직은 사용하는 것은 시기상조인 것 같습니다. Generic에 파라미터 팩을 사용하는 것은 아직 swift main에 병합되지 않았기 때문입니다. 그래서 코드를 작성하게 되면 아직 실험 단계에 있다고 경고메세지가 뜹니다.\n현재기준: 2023년 6월 25일 10:00 PM\nXcode version: Xcode-15.0.0-Beta.2, Swift Complier version: 5.9\n$ /Applications/Xcode-15.0.0-Beta.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift --version #swift-driver version: 1.82.2 Apple Swift version 5.9 (swiftlang-5.9.0.114.10 clang-1500.0.29.1) Target: arm64-apple-macosx13.0\n<br><img src=\"https://blog.kakaocdn.net/dn/bXQUgQ/btsljhIAoYC/m1T6ErQISBbTPPIZJKJBRk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">실험 Swift를 사용하려면, Swift Setting을 변경해줘야 합니다. 가장 간단하게 할 수 있는 방법은 SPM을 만들어서 package.swift을 수정하는 거에요!// swift-tools-version: 5.9\n// The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( name: \"VariadicGenerics\", products: [ // Products define the executables and libraries a package produces, making them visible to other packages. .library( name: \"VariadicGenerics\", targets: [\"VariadicGenerics\"]), ], targets: [ // Targets are the basic building blocks of a package, defining a module or a test suite. // Targets can depend on other targets in this package and products from dependencies. .target( name: \"VariadicGenerics\", swiftSettings: [.enableExperimentalFeature(\"VariadicGenerics\")] ), .testTarget( name: \"VariadicGenericsTests\", dependencies: [\"VariadicGenerics\"]), ]\n)\n그러면 Package 내에서 파일을 생성하고 코드를 작성하면 Generic types with parameter packs are experimental 에러는 나오지 않게 됩니다.추가로 확장하고 싶은 기능은 다음과 같아요.\n상태를 저장하는 프로퍼티를 추가하는 것\n전달인자로 넘겨주는 타입과 리턴 타입을 다르게 하고 싶음 (differ input type and output type)\nmanage control flow during parameter pack iteration - 파라미터 팩을 사용하는 것은 반복이기 때문에 반복을 조기에 종료했을 때 처리하는 방법\n따라서 완성 코드 (애플 제공)는 다음과 같습니다!rotocol RequestProtocol {\n// 2번 요구사항 충족 associatedtype Input associatedtype Output func evaluate(_ input: Input) -&gt; throws Output\n} struct Evaluator&lt;each Request: RequestProtocol&gt; { var item: (repeat each Request) // 1번 요구사항 충족 func query(_ input: repeat (each Request).Input) -&gt; (repeat (each Request).Output)? {\n// 3번 요구사항 충족 do { return (repeat try (each item).evaluate(each input)) } catch { return nil } }\n}\n그러나, 현재도 Generic Parameter pack에 대한 많은 논의가 이뤄지고 있습니다. 애플이 제공하는 코드도 현재는 에러가 나와서 빌드가 되지 않습니다. 이 부분은 추후 Swift에 이 기능이 정식으로 릴리즈 되면 다시 다뤄봐야 할 것 같습니다.읽어주셔서 감사합니다!","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Variadic","level":4,"id":"Variadic_0"},{"heading":"Parameter Pack","level":4,"id":"Parameter_Pack_0"},{"heading":"파라미터 팩에 프로토콜 제약조건 추가하기","level":4,"id":"파라미터_팩에_프로토콜_제약조건_추가하기_0"},{"heading":"파라미터 팩에 최소한 한개 전달인자를 보장하는 방법","level":4,"id":"파라미터_팩에_최소한_한개_전달인자를_보장하는_방법_0"},{"heading":"Struct<code>&lt;Generic&gt;</code>에 parameter pack 사용하기&nbsp;(현재기준: 2023년 6월 25일 10:00 PM 빌드 안됨)","level":4,"id":"Struct`<Generic>`에_parameter_pack_사용하기 (현재기준_2023년_6월_25일_1000_PM_빌드_안됨)_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/S1EJQ/btslw8Cx1gx/cD5Zal2xo39GRSuZpgNau1/img.png","fullURL":"ios/wwdc-2023-parameter-pack.html","pathToRoot":"..","attachments":[],"createdTime":1735623352028,"modifiedTime":1735623599141,"sourceSize":12900,"sourcePath":"iOS/WWDC 2023 Parameter pack.md","exportPath":"ios/wwdc-2023-parameter-pack.html","showInTree":true,"treeOrder":357,"backlinks":[],"type":"markdown"},"ios/단위테스트와-product_module_name.html":{"title":"단위테스트와 PRODUCT_MODULE_NAME","icon":"","description":"작년부터 진행했던 사이드 프로젝트가 있습니다. 최근에 버전 2를 만들기 위해서 기획 &amp; 디자이너 친구들이 앱 업데이트 요청을 했어요. 그래서 과거에 짰던 코드를 보면서 Dev 설정으로 애플리케이션을 살펴보고 있었습니다. 근데 카카오톡으로 로그인하기를 눌렀는데 권한요청 alert 떴어요. 여기에 타겟이름이 그대로 있다는 것을 발견했습니다.<img src=\"https://blog.kakaocdn.net/dn/dpQuzW/btslZ5NKkqr/n9zrpFvuy6sENHXX9QE0UK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이 문제를 해결하는 방법은&nbsp;빌드 환경을 단일 타겟과 스킴으로 나누지 않았다면&nbsp;PRODUCT_NAME을 수정하면 됩니다.근데 저희 팀이 작업했던 빌드 환경은 달라서 언급을 먼저 하겠습니다.애플리케이션의&nbsp;Configuration은 Debug(Development), Debug(Staging), Debug(Production), Release(Development), Release(Staging), Release(Production)로 구성되어 있어요.그리고&nbsp;단일 Target에,&nbsp;세가지 Scheme(Dev, Staging, Prod)로 구성되어 있고 xcconfig 파일을 이용해 Build Setting 값을 넣었습니다. xcconfig 파일에서 CFBundleDisplayName를 설정했기 때문에 단일 타겟으로 다른 이름으로 세 가지 앱을 빌드할 수 있었어요. (각각 Hous-, Hous-Dev, Hous-Staging)그래서, 앱을 처음 실행하자마자 나오는 푸시알림 권한요청 팝업, 그리고 애플로 로그인하기 팝업은 CFBundleDisplayName을 CFBundleDisplayName을 바라보기 때문에 해당 값이 잘 뜹니다.<br><img src=\"https://blog.kakaocdn.net/dn/bhUESq/btsl0jrs0xY/rUbDYOsHMKawDmWPiW8AgK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그러나, 카카오톡으로 로그인하기는 CFBundleDisplayName을 바라보는 것이 아니었고, PRODUCT_NAME(=CFBundleName)이 뜨는 상태였습니다. 처음에 이걸 봤을 때, 마음 편하게 Build Setting 값을 확인했고 ProductName = $(TARGET_NAME)이었기 때문에 각 xcconfig에서 TARGET_NAME을 환경에 맞게 수정했었어요. 결과는 성공적이었고 이렇게 해결된 줄 알았습니다.문제는 단위테스트에서 발생했어요. Command + U를 눌렀는데 세상에서 가장 보기 싫은 에러가 떴습니다.<br><img src=\"https://blog.kakaocdn.net/dn/c8zoME/btsl1WPOda7/0raQoWTD67KqOF4HVsgnOk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">stackoverflow에 나오는 여러가지 해결 방법을 시도해 봤는데 대부분 안되었지만, 어떤 글에서 지나가듯이 import 하는 모듈의 이름이 PRODUCT_MODULE_NAME이라는 것을 알게 되었습니다. 그래서, PRODUCT_MODULE_NAME을 플래그 봤는데 ($PROUDCT_NAME:c99extidentifier)였습니다. 이것을 보고, 테스트 클래스로 가서 자동완성은 안되지만, PRODUCT_MODULE_NAME을 그대로 @testable import를 했습니다. 그리고 Command + U를 눌렀는데<br><img src=\"https://blog.kakaocdn.net/dn/TjEGd/btsl0Xn8JPf/JuuQyn8AT9LNWnXkMwIzJ1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">놀랍게도 No such module 에러는 계속 떴지만, 테스트는 진행 되었어요.ㅋㅋ 하지만 자동완성은 안되었어요. 근데 여기서 조금 더 발전해서 PRODUCT_MODULE_NAME을 xcconfig로 다루면 해결할 수 있지 않을까 싶어서 시도해 봤습니다. 그전에 문제점을 다시 정리하고 가겠습니다.\n빌드환경 구성을 단일타겟과 세 가지 스킴, xcconfig로 했다.\n카카오톡 로그인 Alert에 뜨는 앱이름을 바꾸기 위해서는 PRODUCT_NAME을 고쳐야 한다.\n따라서 PRODUCT_MODULE_NAME(이 플래그는 PRODUCT_NAME을 참조하고 있음)이 변경되어서 기존의 Target NAME을 import 할 수 없다.\nxcconfig에서 PRODUCT_MODULE_NAME_FIX 라는 플래그를 선언하고 적당한 값(이게 모듈 이름이 될 거예요)을 넣었어요. 그리고 Build Setting으로 가서 PRODUCT_MODULE_NAME에 PRODUCT_MODULE_NAME_FIX를 넣었습니다.<br><img src=\"https://blog.kakaocdn.net/dn/bAaFdy/btslZF9Womg/mkM2xJM0tHL3ICyazbzWQK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그리고 위에서 적당한 값을 넣었잖아요? @testable import를 해줍시다. 그리고 Command + U를 누르면 테스트가 진행되네요.&nbsp;<br><img src=\"https://blog.kakaocdn.net/dn/ET2As/btslZSOHOL6/XlcRMxk0xt7DTw0TuAjFDk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">왜 카카오 로그인의 Alert는 CFBundleDisplay가 아닌 CFBundleName을 보고 있을까? 혹시 카카오SDK에서 이것을 다루는 프로퍼티가 있을까 싶어서 카카오 SDK 코드 구경을 했었습니다.&nbsp;public func presentationAnchor(for session: ASWebAuthenticationSession) -&gt; ASPresentationAnchor\n사용자가 카카오로 로그인을 누를 때 위의 함수를 호출(애플도 같은 함수를 호출하지만 파라미터가 다름) 하게 되는데 파라미터가 ASWebAuthenticationSession입니다. 이 부분에서 버그가 있다고 다른 레포에서 이슈가 올라왔었습니다.&nbsp;&nbsp;사실 문제는 아닌 거 같고 그냥 업데이트를 안 하고 있는 것 같아요.아무튼 끝. 읽어주셔서 감사합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"해결방법","level":4,"id":"해결방법_0"},{"heading":"번외","level":4,"id":"번외_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/dpQuzW/btslZ5NKkqr/n9zrpFvuy6sENHXX9QE0UK/img.png","fullURL":"ios/단위테스트와-product_module_name.html","pathToRoot":"..","attachments":[],"createdTime":1735623639381,"modifiedTime":1735623667317,"sourceSize":4997,"sourcePath":"iOS/단위테스트와 PRODUCT_MODULE_NAME.md","exportPath":"ios/단위테스트와-product_module_name.html","showInTree":true,"treeOrder":358,"backlinks":[],"type":"markdown"},"ios/동기,-비동기.html":{"title":"동기, 비동기","icon":"","description":"Concurrency allows us to execute different tasks at the same time, or it appears to us at the same time.\nCPU는 Time Slicing과 Context Switching으로 Concurrency를 달성\nCPU는 각 task가 처리되는 시간을 정확히 예상할 수 없음 그러므로, 하나씩 TimeSlicing과 Context Switching을 통해서 task를 처리함\n즉 작업을 분산하자가 목표임iOS에서 Concurrency를 달성하는 법\nManual Thread Creation (직접 쓰레드 생성)\nclass Thread: NSObject { } // https://developer.apple.com/documentation/foundation/thread GCD ( Grand Central Dispatch) <a data-tooltip-position=\"top\" aria-label=\"https://developer.apple.com/documentation/DISPATCH\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.apple.com/documentation/DISPATCH\" target=\"_self\">GCD</a>&nbsp;is a queue-based API that allows executing closures on worker's pools in the FIFO (First in first out) order.\nFIFO Order로 Task를 수행함\n추상화 → 쓰레드를 얼마나 사용하고 있는 지 같은 것들을 신경쓰지 않아도 됨 (세부구현요소 배제)\norder와 manner로 Data Consistent를 달성할 수 있음. → Data Consistency를 저해하는 요소 - Deadlock, Race Conditon.\n그러니까 iOS에서는 Queue에 잘 넣으면 쓰레드에 알아서 넣어줌. 언리얼에도 있을까? TGraph 같은 거 있던데\n우리가 해야할 것은 Queue 잘 보내는 것(직접적으로 쓰레드를 관리하지 않음)\nSerial Queue - one task at a time\n<br><img alt=\"serial.png\" src=\"images/serial.png\" target=\"_self\">\nConcurrent Queue - multiple tasks at a time<br>\n<img alt=\"concurrent.png\" src=\"images/concurrent.png\" target=\"_self\"> Synchronous 다른 execution이 완료 되기전까지 현재 쓰레드를 Block 함. Asynchronous 현재 스레드를 Block 하지 않고, 다른 some task later, simultaneously하게 execution 함.\nasynchronous를 사용하면 program이 즉시 block에서 빠져나감 Main Queue\n따로 큐를 지정하지 않으면 Main Queue에서 돌아감\n시리얼 큐임\ntask가 synchronous 하게 실행됨\nUI를 update 하는 큐임 Single Serial Queue with Multiple Asynchronous Dispatch. 시리얼 큐안에서 async execution만 존재하면 serial Order를 따른다. Single Serial Queue with Multiple Asynchronous Dispatch &amp; Synchronous codes. 시리얼 큐이기 때문에 line by line으로 코드를 읽음\nsync는 block 하고 async는 제어권을 넘겨줌 Single Concurrent Queue with Multiple Asynchronous Dispatch. 런할 때마다 바뀜. Single Concurrent Queue with Multiple Asynchronous and Synchronous Dispatch. 가장 헷갈리는 예임\n모두 다 4개의 task를 concurrent 큐에다가 넣고, 두번째는 sync 나머지를 async일 때 3번째랑, 4번째는 무조건 두번째 코드가 다 끝난 이후에 나옴. 왜냐하면 첫번째 큐가 들어가고 탈출하고, 두번째 큐가 들어가는데 여기에서 블락됨 다만, concurrent 큐라서 두번째 task와 첫번째 task가 실행될 수 있음. 두번째 task가 끝나면 세,네번째 task 가능. a Serial Queue alongside a Concurrent Queue with Multiple Asynchronous Dispatch. 랜덤하게 나올 수 있으나 Serial 1, 2, 3의 순서는 지켜져야 한다.(연속은 안해도 됨) SerialQueue에서 sync와 async의 차이점 let queue = DispatchQueue(label: \"com.example.serialQueue\")\nqueue.async { print(\"Async task 1\")\n}\nqueue.async { print(\"Async task 2\")\n}\nprint(\"Outside of queue\")\n결과Async task 1\nOutside of queue\nAsync task 2\nlet queue = DispatchQueue(label: \"com.example.serialQueue\")\nqueue.sync { print(\"Async task 1\")\n}\nqueue.sync { print(\"Async task 2\")\n}\nprint(\"Outside of queue\")\nAsync task 1\nAsync task 2\nOutside of queue\n동기는 일의 제어권을 꽉 잡고 있음. (흔히 Block 한다고 함)\n비동기는 일의 제어권을 넘겨줌동기와 비동기는 제어권을 넘겨주냐, 넘겨주지 않느냐로 판단하는 것\nMainQueue에서 sync 사용금지\n현재 큐에서 sync로 작업을 보내지 말자 DispatchQueue.global().async { DispatchQueue.global().sync { }\n} // 오래 걸리는 함수\npublic func tiltShift(image: UIImage?) -&gt; UIImage? { guard let image = image else { return nil } sleep(1) let mask = topAndBottomGradient(size: image.size) return image.applyBlur(radius: 6, maskImage: mask) } func asyncTiltShift(_ inputImage: UIImage?, runQueue: DispatchQueue, completionQueue: DispatchQueue, completion: @escaping (UIImage?, Error?) -&gt; ()) { runQueue.async { var error: Error? error = .none let outputImage = tiltShift(image: inputImage) completionQueue.async { completion(outputImage, error) } }\n} // 사용 예시 let imageNames = [\"dark_road_small\", \"train_day\", \"train_dusk\", \"train_night\"]\nlet images = imageNames.compactMap { UIImage(named: \"\\($0).jpg\") } // 변형한 이미지 저장하기 위한 배열 생성 var tiltShiftedImages = [UIImage]() // 동시큐 만들기 let workerQueue = DispatchQueue(label: \"com.inflearn.concurrent\", attributes: .concurrent) let appendQueue = DispatchQueue(label: \"com.inflearn.append.serial\") for image in images { asyncTiltShift(image, runQueue: workerQueue, completionQueue: appendQueue) { image, error in guard let image = image else { return } tiltShiftedImages.append(image) } }\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"What is Concurrency?","level":2,"id":"What_is_Concurrency?_0"},{"heading":"Concurrency in iOS","level":2,"id":"Concurrency_in_iOS_0"},{"heading":"Order of Execution (Serial vs Concurrency)","level":2,"id":"Order_of_Execution_(Serial_vs_Concurrency)_0"},{"heading":"Manner of Execution (Synchronous vs Asynchronous)","level":2,"id":"Manner_of_Execution_(Synchronous_vs_Asynchronous)_0"},{"heading":"이해를 위한 Example","level":3,"id":"이해를_위한_Example_0"},{"heading":"주의사항","level":3,"id":"주의사항_0"},{"heading":"동기함수를 비동기함수처럼 만드는 방법","level":3,"id":"동기함수를_비동기함수처럼_만드는_방법_0"}],"links":[],"author":"","coverImageURL":"images/serial.png","fullURL":"ios/동기,-비동기.html","pathToRoot":"..","attachments":["images/serial.html","images/concurrent.html"],"createdTime":1710855209770,"modifiedTime":1710855209770,"sourceSize":5755,"sourcePath":"iOS/동기, 비동기.md","exportPath":"ios/동기,-비동기.html","showInTree":true,"treeOrder":359,"backlinks":[],"type":"markdown"},"ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html":{"title":"드래그가 가능한 BottomSheet를 만들어보자(DraggableBottomSheet )","icon":"","description":"&nbsp;Ounce를 개발할 때, 버튼을 누르면 밑에서 present modal 방식으로 올라오는 뷰를 만든 적이 있습니다. 다만 그때 시간이 촉박해서 애플이 기본적으로 제공하는 방식으로 구현했습니다.잠깐 코드를 가져와보겠습니다.let targetVC = ViewController()\ntargetVC.modalPresentationStyle = .popover\nself.present(targetVC, animated: true, completion: nil)\n이제는 좀 더 나아가서 드래그가 가능하고 이전의 뷰가 백그라운드 처리가 되어 있는 뷰를 만들어보겠습니다.&nbsp;뷰의 전환은 ViewController → BottomCardViewController입니다.먼저 구현에 필요한 extension을 추가하겠습니다. 화면 전환을 할 때 현재 화면(ViewController)의 스냅샷을 찍어서 화면 전환한 후 (BottomSheetViewController)의 배경화면으로 사용할 겁니다. 그리고 ViewController에서 사용할 화면전환 함수를 만들 것인데 저는 tapGestureRecognizer를 이용하도록 할게요.// UIView+Snapshot.swift extension UIView { // render the view within the view's bounds, then capture it as image func asImage() -&gt; UIImage { let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image(actions: { rendererContext in layer.render(in: rendererContext.cgContext) }) }\n}\n//UIViewController.swift let tapGesture = UITapGestureRecognizer(target: self, action: #selector(self.tapImageView(_:))) @objc func tapImageView(_ sender:UITapGestureRecognizer) { let bottomCardViewController = BottomCardViewController() bottomCardViewController.modalPresentationStyle = .fullScreen bottomCardViewController.backgroundImage = view.asImage() self.present(bottomCardViewController, animated: false, completion: nil) }\n여기까지 작성하면 ViewController에서 해야 할 일은 끝났습니다.이제 BottomCardViewController를 만들겠습니다. BottomCardViewController는 다음과 같은 UIComponet와 Property들이 필요하다.\n배경을 투명하게 만들어 주는&nbsp;dimmerView: UIView\ncardView: UIView\nbackgroundImage: UIImage - 스냅샷 이미지\n스냅샷으로 넘겨받은 이미지를 담는 UIImageView\ncardViewTopConstraints: NSLayoutConstraint - 드래그를 할 때 이 값의 변화에 따라 실제로 뷰가 움직입니다.\n처음에 화면 전환을 할 때, 아래에서부터 cardView가 올라와야 하기 때문에 viewDidLoad에 다음과 같이 레이아웃을 잡았습니다. cardView의 Top Constraint를 잡은 것을 보면 카드뷰의 Top이 우리가 화면에서 보는 뷰 바로 아래에 위치하는 것을 알 수 있습니다.func setupViews() { if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint = cardView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: safeAreaHeight + bottomPadding) } cardView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true cardView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true cardView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true NSLayoutConstraint.activate([cardViewTopConstraint])\n}\n그러고 나서 viewDidAppear에서&nbsp;카드뷰를 올라오게 하는 함수를 사용하면 되겠네요.카드뷰를 올라오게 하는 함수 showCard()를 어떻게 구현하면 될까요?\ndimmerView의 alpha 값을 조절\ncardView의 topConstraint의 값을 조절\nprivate func showCard() { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication .shared .windows.first? .safeAreaLayoutGuide .layoutFrame .size .height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2 } let showCard = UIViewPropertyAnimator(duration: 1, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) showCard.addAnimations({ self.dimmerView.alpha = 0.7 }) showCard.startAnimation() }\ncardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2를 통해서&nbsp; 카드뷰의 위치를 중간쯤으로 위치시켰습니다. 이렇게 딱 끝나면 좋을 것 같은데 끝이 아닙니다. topConstraint의 값은 변했지만 UI 변화는 실시간으로 반영되지 않습니다. 저는 애니메이션을 주고 싶기 때문에 카드 뷰의 위치를 실시간으로 업데이트해주고 싶어요. 뷰의 위치를 업데이트하는 방법은 layoutIfNeeded()를 이용하는 것입니다. 저는 애니메이션을 실행시키는 여러 방법 중 하나인 UIViewPropertyAnimator를 사용해서 카드뷰 위치를 업데이트하겠습니다. 그리고 화면 Dim 처리 역시 UIViewPropertyAnimator에게 넘겨주겠습니다.이제는 바텀시트를 닫아주는 함수를 만들게요. showCard()를 이해했다면, 쉽게 알 수 있어요. 거의 똑같은 함수라서요. 차이점은 카드뷰가 내려갔을 때 BottomSheetViewControll를 dismiss 해주면 됩니다.private func hideAndDismiss() { self.view.layoutIfNeeded() if let window = UIApplication.shared.windows.first { let safeAreaHeight = window.safeAreaLayoutGuide.layoutFrame.size.height let bottomPadding = window.safeAreaInsets.bottom cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) } let hideAndDismiss = UIViewPropertyAnimator(duration: 1, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) hideAndDismiss.addAnimations({ self.dimmerView.alpha = 0.0 }) hideAndDismiss.addCompletion({ position in if position == .end { if(self.presentingViewController != nil) { self.dismiss(animated: false, completion: nil) } } }) hideAndDismiss.startAnimation()\n}\n여기까지 완료 했으면, 다음과 같이 작동합니다. gif 변환 과정에서 바텀시트가 올라오는 모습이 좀 어색해졌네요.<img src=\"https://blog.kakaocdn.net/dn/b19Hpt/btr3XzquX1H/gL1rnkKKReXJ3e2dikVml1/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">여기까지 구현한거면 큰 뼈대는 다 구현한 것이니 사실 다 만든 것이나 다름없다고 생각해요. 이제는 드래그가 가능하게 만들 겁니다.단순히 핸들 뷰를 만들고 이것을 드래그할 때 cardViewTopConstraint가 변하는 것을 구현하면 됩니다.어떤 것이든 상태가 있는 경우에는 대부분 Enum을 통해서 관리하는 것이 편하다고 생각해요. 그래서 cardView의 위치 또한 Enum으로 관리하도록 할게요.enum CardViewState { case expanded // Safe Area Top에서 30pt 떨어진 상태 case normal // (Safe Area Height + Safe Area Bottom Inset) / 2 }\nexpanded를 어떻게 처리할까요? 이미 구현했던 showCard를 재사용하면 될 것 같습니다. 그러기 위해서 showCard를 리팩토링 하겠습니다.&nbsp;showCard의 매개변수는 void인데 재사용을 위해서 atState: CardViewState를 매개변수로 추가하겠습니다.&nbsp;그리고나서 if문이나 switch문을 통해서 atState의 값에 따라 분기처리 하면 됩니다.private func showCard(atState: CardViewState = .normal) { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { if atState == .expanded { cardViewTopConstraint.constant = 30.0 } else { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2 } cardPanStartingTopConstant = cardViewTopConstraint.constant } let showCard = UIViewPropertyAnimator(duration: 0.3, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) showCard.addAnimations({ self.dimmerView.alpha = 0.7 }) showCard.startAnimation() }\nCard View를 드래그하기 위해서는, UIPanGestureRecognizer를 등록해야 합니다.GestureRecognizer는 사용자가 뷰에 행동을 취하는 것을 트랙킹 할 수 있도록 도와줍니다. 예를 들면 사용자가 뷰를 길게 터치하는 것, 뷰를 드래그하는 것들을 알 수 있고 그에 맞게 우리가 하고 싶은 행동(스크롤을 한다던가, 다른 뷰를 보여준다던가)을 취할 수 있게 됩니다.&nbsp;func panViewGesture() { let viewPan = UIPanGestureRecognizer(target: self, action: #selector(viewPanned(_: ))) // iOS는 기본적으로 touch를 감지 (recode) 하기 전에 약간의 딜레이를 준다. 즉시 반응해야 하기 때문에 false viewPan.delaysTouchesBegan = false viewPan.delaysTouchesEnded = false cardView.addGestureRecognizer(viewPan) handleView.addGestureRecognizer(viewPan) } @objc func viewPanned(_ panRecognizer: UIPanGestureRecognizer) { // 구현하면 될 것 }\n이제 viewPanned 함수를 구현해보도록 하겠습니다. UIPanGestureRecognize의 state라는 property를 이용하면 돼요. 이 state에 따라서 cardViewTopConstaraint를 변화시켜 주면 되겠죠?코드 구현에 앞서 각 state를 어떻게 구현해야 할 지에 대해서 생각해 봅시다..began\n드래그를 처음 시작했을 때의 topConstraint 값을 저장\n.changed\n드래그를 하고 있는 상태 (cardViewTopConstarint가 바뀌는 중)\ntopConstraint가 expanded mode(30) 보다 작아서는 안됨\n드래그를 따라서, dimmer View의 alpha 값 조절\n.ended\n드래그가 끝난 후 액션 처리\n그리고 추가적으로 만약 사용자가 아래로 드래그를 빠르게 했을 때 (Snap) 바텀시트를 닫으면 사용자 관점에서 엄청 편할 거예요. 얼마나 빠르게&nbsp;뷰를 드래그했는지 velocity라는 변수를 통해서 알 수 있습니다. 그래서 이것을 감지한다면 바텀시트를 닫아주면 돼요.@objc func viewPanned(_ panRecognizer: UIPanGestureRecognizer) { let translation = panRecognizer.translation(in: view) let velocity = panRecognizer.velocity(in: view) switch panRecognizer.state { case .began: cardPanStartingTopConstant = cardViewTopConstraint.constant case .changed: if cardPanStartingTopConstant + translation.y &gt; 30.0 { cardViewTopConstraint.constant = cardPanStartingTopConstant + translation.y } case .ended: if velocity.y &gt; 1500.0 { hideAndDismiss() return } if let safeAreaHeight = UIApplication .shared.windows .first? .safeAreaLayoutGuide .layoutFrame .size.height, let bottomPadding = UIApplication. shared.windows. first?. safeAreaInsets. bottom { if cardViewTopConstraint.constant &lt; (safeAreaHeight + bottomPadding) * 0.25 { showCard(atState: .expanded) } else if cardViewTopConstraint.constant &lt; safeAreaHeight - 70 { showCard(atState: .normal) } else { hideAndDismiss() } } default: break }\n}\n여기까지 따라오셨으면, 다음과 같은 결과물을 얻을 수 있습니다.<br><img src=\"https://blog.kakaocdn.net/dn/K8K6s/btr3ICC7PYS/9aMTgKNES93blUUkqi2tC0/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">//\n// BottomCardViewController.swift\n// DraggableBottomCard\n//\n// Created by psychehose on 2021/06/19.\n// import UIKit class BottomCardViewController: UIViewController { enum CardViewState { case expanded case normal } var cardViewState: CardViewState = .normal private var imageView: UIImageView = { let imageView = UIImageView() imageView.translatesAutoresizingMaskIntoConstraints = false return imageView }() var dimmerView: UIView = { let dimmerView = UIView() dimmerView.alpha = 0.0 dimmerView.backgroundColor = .gray dimmerView.translatesAutoresizingMaskIntoConstraints = false return dimmerView }() var cardView: UIView = { let cardView = UIView() cardView.translatesAutoresizingMaskIntoConstraints = false cardView.backgroundColor = .white cardView.clipsToBounds = true cardView.layer.cornerRadius = 10.0 cardView.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner] return cardView }() var handleView: UIView = { let handleView = UIView() handleView.layer.cornerRadius = 3.0 handleView.clipsToBounds = true handleView.translatesAutoresizingMaskIntoConstraints = false handleView.backgroundColor = .gray return handleView }() var cardViewTopConstraint: NSLayoutConstraint! var cardPanStartingTopConstant: CGFloat = 30.0 var backgroundImage: UIImage? override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white imageView.image = backgroundImage configureLayout() tapBackgroundImageGesture() panViewGesture() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) showCard() } } // MARK: - Gesture extension BottomCardViewController { func tapBackgroundImageGesture() { let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapImageView(_: ))) imageView.addGestureRecognizer(tapGesture) imageView.isUserInteractionEnabled = true } @objc func tapImageView(_ sender: UITapGestureRecognizer) { hideAndDismiss() } func panViewGesture() { let viewPan = UIPanGestureRecognizer(target: self, action: #selector(viewPanned(_: ))) // iOS는 기본적으로 touch를 감지 (recode) 하기 전에 약간의 딜레이를 준다. 즉시 반응해야 하기 때문에 false viewPan.delaysTouchesBegan = false viewPan.delaysTouchesEnded = false cardView.addGestureRecognizer(viewPan) handleView.addGestureRecognizer(viewPan) } @objc func viewPanned(_ panRecognizer: UIPanGestureRecognizer) { let translation = panRecognizer.translation(in: view) let velocity = panRecognizer.velocity(in: view) switch panRecognizer.state { case .began: cardPanStartingTopConstant = cardViewTopConstraint.constant case .changed: if cardPanStartingTopConstant + translation.y &gt; 30.0 { cardViewTopConstraint.constant = cardPanStartingTopConstant + translation.y } self.dimmerView.alpha = dimmerAlphaWithTopConstant(value: cardViewTopConstraint.constant) case .ended: if velocity.y &gt; 1500.0 { hideAndDismiss() return } if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { if cardViewTopConstraint.constant &lt; (safeAreaHeight + bottomPadding) * 0.25 { showCard(atState: .expanded) } else if cardViewTopConstraint.constant &lt; safeAreaHeight - 70 { showCard(atState: .normal) } else { hideAndDismiss() } } default: break } }\n} // MARK: - UILayout extension BottomCardViewController { func configureLayout() { view.addSubview(imageView) imageView.addSubview(dimmerView) view.addSubview(cardView) view.addSubview(handleView) imageView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true imageView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true imageView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true imageView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true dimmerView.topAnchor.constraint(equalTo: imageView.topAnchor).isActive = true dimmerView.bottomAnchor.constraint(equalTo: imageView.bottomAnchor).isActive = true dimmerView.leadingAnchor.constraint(equalTo: imageView.leadingAnchor).isActive = true dimmerView.trailingAnchor.constraint(equalTo: imageView.trailingAnchor).isActive = true if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint = cardView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: safeAreaHeight + bottomPadding) } cardView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true cardView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true cardView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true NSLayoutConstraint.activate([cardViewTopConstraint]) handleView.centerXAnchor.constraint(equalTo: cardView.centerXAnchor).isActive = true handleView.widthAnchor.constraint(equalToConstant: 60).isActive = true handleView.heightAnchor.constraint(equalToConstant: 6).isActive = true handleView.bottomAnchor.constraint(equalTo: cardView.topAnchor, constant: -10).isActive = true } } extension BottomCardViewController { private func showCard(atState: CardViewState = .normal) { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { if atState == .expanded { cardViewTopConstraint.constant = 30.0 } else { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2 } cardPanStartingTopConstant = cardViewTopConstraint.constant } let showCard = UIViewPropertyAnimator(duration: 0.3, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) showCard.addAnimations({ self.dimmerView.alpha = 0.7 }) showCard.startAnimation() } private func hideAndDismiss() { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) } let hideAndDismiss = UIViewPropertyAnimator(duration: 0.3, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) hideAndDismiss.addAnimations({ self.dimmerView.alpha = 0.0 }) hideAndDismiss.addCompletion({ position in if position == .end { if(self.presentingViewController != nil) { self.dismiss(animated: false, completion: nil) } } }) hideAndDismiss.startAnimation() }\n} extension BottomCardViewController { private func dimmerAlphaWithTopConstant(value: CGFloat) -&gt; CGFloat { let fullDimAlpha: CGFloat = 0.7 guard let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom else { return fullDimAlpha } let fullDimPosition = (safeAreaHeight + bottomPadding) / 2.0 let noDimPosition = safeAreaHeight + bottomPadding if value &lt; fullDimPosition { return fullDimAlpha } if value &gt; noDimPosition { return 0.0 } return fullDimAlpha * 1 - ((value - fullDimPosition) / fullDimPosition) }\n}\n<br><a data-tooltip-position=\"top\" aria-label=\"https://fluffy.es/facebook-draggable-bottom-card-modal-2/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://fluffy.es/facebook-draggable-bottom-card-modal-2/\" target=\"_self\">https://fluffy.es/facebook-draggable-bottom-card-modal-1/</a>&nbsp;[Replicating Facebook's Draggable Bottom Card using Auto Layout - Part 2/2In Part 1, we have managed to implement the show and hide card animation when user tap on button or the dimmer view. In this part, we are going to implement the card dragging animation. This post assume that you already knew about Auto Layout and Delegate.<br>fluffy.es](<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://fluffy.es/facebook-draggable-bottom-card-modal-2/\" target=\"_self\">https://fluffy.es/facebook-draggable-bottom-card-modal-2/</a>)<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://fluffy.es/facebook-draggable-bottom-card-modal-2/\" target=\"_self\">https://fluffy.es/facebook-draggable-bottom-card-modal-2/</a>&nbsp;[Replicating Facebook's Draggable Bottom Card using Auto Layout - Part 2/2In Part 1, we have managed to implement the show and hide card animation when user tap on button or the dimmer view. In this part, we are going to implement the card dragging animation. This post assume that you already knew about Auto Layout and Delegate.<br>fluffy.es](<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://fluffy.es/facebook-draggable-bottom-card-modal-2/\" target=\"_self\">https://fluffy.es/facebook-draggable-bottom-card-modal-2/</a>)","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"들어가기 전에","level":3,"id":"들어가기_전에_0"},{"heading":"구현","level":3,"id":"구현_0"},{"heading":"전체코드 및 레퍼런스","level":3,"id":"전체코드_및_레퍼런스_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/b19Hpt/btr3XzquX1H/gL1rnkKKReXJ3e2dikVml1/img.gif","fullURL":"ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html","pathToRoot":"..","attachments":[],"createdTime":1735622483665,"modifiedTime":1735622504946,"sourceSize":22120,"sourcePath":"iOS/드래그가 가능한 BottomSheet를 만들어보자(DraggableBottomSheet ).md","exportPath":"ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html","showInTree":true,"treeOrder":360,"backlinks":[],"type":"markdown"},"network/01.-network.html":{"title":"01. Network","icon":"","description":"L7 - Http\nL6 - 안중요\nL5 - SSL (TLS)\nL4 - TCP / UDP\nL3 - 인터넷\nL2 - 이더넷\nL1 - X 물리적인 영역MAC: L2 계층 (이더넷)의 식별자 - 즉 랜카드(NIC)의 식별자IP주소: L3 계층 (인터넷)의 식별자 - 즉 호스트의 식별자Port 번호: 관점에 따라 식별할 수 있음 L2 계층: 인터페이스 식별자 L3, L4: Service 식별자 (네트워크 수준)\n* 엔드포인트: Process 식별자정의: 네트워크에 연결된 컴퓨터Host를 지칭할 때 둘로 나눔 Switch: Network 그 자체를 이루는 Host (인프라) Router\nIPS .. End-Point: 인프라를 써먹는 이용 주체 클라이언트\n서버\nPeer 비유 패킷: 자동차\n네트워\b크: 고속도로망\n스위치(라우터): 교차로\n인터페이스를 선택한다 (스위칭) -&gt; 교차로에서 경로 선택\n이정표: 라우팅테이블 용어가 아래처럼 만들어짐\nMac 주소로 스위칭한다 -&gt; L2 스위치\u001e\nHttp 정보로 스위치한다 -&gt; L7 스위치비용이 낮은쪽으로 패킷이 이동함.\n비용은 Matric이라 함","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. Network","level":1,"id":"1._Network_0"},{"heading":"OSI 7 Layer","level":3,"id":"OSI_7_Layer_0"},{"heading":"식별자","level":3,"id":"식별자_0"},{"heading":"Host","level":3,"id":"Host_0"},{"heading":"스위치가 하는 일","level":3,"id":"스위치가_하는_일_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/01.-network.html","pathToRoot":"..","attachments":[],"createdTime":1724571717941,"modifiedTime":1724571717941,"sourceSize":1200,"sourcePath":"Network/01. Network.md","exportPath":"network/01.-network.html","showInTree":true,"treeOrder":362,"backlinks":[],"type":"markdown"},"network/02.-l2.html":{"title":"02. L2","icon":"","description":"NIC + (L2) Frame + LAN card + MACNIC = Network Interface Card .\n랜(LAN (Local Area Network))카드랑 같음.\nNIC은 HW이면 MAC주소를 갖는다. MAC주소는 NIC의 식별자임.Packet: L2 수준에서 언급하는 인터넷에서의 단위\nL2 수준의 데이터 단위는 프레임L2 Acess Switch라고 불림\nEnd - point와 직접 연결되는 스위치\nMAC 주소를 근거로 스위칭\n랜 케이블이 연결되고 정상 작동한다(녹색불) - Link up\n랜 케이블이 연결이 빠졌다 - Link down호스트에 랜 케이블을 꽂았는데 상위 L3로 나아가는 것 - 업 링크\n쉽게 생각하면 L2 Access 스위치를 위한 스위치\nVLAN(Virtual LAN) 기능 제공\nUnicast는 하나에 알리는 것 -&gt; 효율 높\nBroadcast는 전체에 알리는 것 -&gt; 효율 떨어짐Broadcast의 주소라는 특별한 주소가 존재함 (MAC, IP 둘다 존재)MAC은 48Bit로 이루어져있는데, 모든 비트가 1이면 그게 바로 MAC의 브로드캐스트 주소임\nFF:FF:FF:FF:FF:FFL2 수준에서의 데이터 단위가 프레임이라고 했는데 프레임에는 헤더가 있음\n헤더에는 주소 두개가 있음 출발지, 목적지만약 목적지가 FF:FF:FF:FF:FF:FF다? 그럼 브로드캐스팅 한다는거겠지?브로드캐스팅은 매우 값 비싼 행동임 일단 한 호스트가 브로드캐스팅이 되면 브로드캐스팅\b 끝날 때까지 통신을 못함 -&gt; 그러니까 브로드캐스팅은 최소화 해야함예시)\nL브로드캐스팅의 범위를 축소하면 됨\n브로드 캐스팅 범위는 IP 주소상에서 어떤 레인지로 제\b한\n정확한 개념은 아니지만 LAN은 물리적으로 설명 가능 (랜 카드, 무선신호 등) L2까지 커버할 수 있음WAN은 주로 인터넷인데 이것들부터는 실체가 존재하지 않는 Logical(virtual)임 L3부터는 소프트웨어 영역임","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2. L2","level":1,"id":"2._L2_0"},{"heading":"L2 스위치","level":4,"id":"L2_스위치_0"},{"heading":"L2 Distribution switch","level":5,"id":"L2_Distribution_switch_0"},{"heading":"LAN과 WAN의 경계 그리고 Broadcast","level":3,"id":"LAN과_WAN의_경계_그리고_Broadcast_0"},{"heading":"브로드캐스트","level":4,"id":"브로드캐스트_0"},{"heading":"LAN 과 WAN?","level":4,"id":"LAN_과_WAN?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/02.-l2.html","pathToRoot":"..","attachments":[],"createdTime":1724571717941,"modifiedTime":1724571717942,"sourceSize":2052,"sourcePath":"Network/02. L2.md","exportPath":"network/02.-l2.html","showInTree":true,"treeOrder":363,"backlinks":[],"type":"markdown"},"network/03.-l3.html":{"title":"03. L3","icon":"","description":"\nHost의 식별자\n32bit 주소체계\nex) 192.168.0.10 ( 8bit * 4 = 32bit) 앞 24 bit는 Network ID\n뒤 8 bit는 Host ID Packet 이라고하면 L3 IP Packet을 떠올리자.\nHeader와 Payload (Header에는 출발지(src) 목적지(dst) 정보가 있음)로 구성\nHeader + Payload 의 최대 크기 = MTU MTU는 보통 1500byte임 마트료시카 인형을 떠올리자\nL2 Frame은 = Header + Payload\nL2의 Payload에 L3 Packet(Header + Payload)가 있음\nL3의 Payload에 L4의 Header + Payload가 있겠지?\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"3. L3","level":1,"id":"3._L3_0"},{"heading":"IPv4 주소 구조","level":4,"id":"IPv4_주소_구조_0"},{"heading":"L3 Packet","level":4,"id":"L3_Packet_0"},{"heading":"Encapsulation &amp; Decapsulation","level":4,"id":"Encapsulation_&_Decapsulation_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/03.-l3.html","pathToRoot":"..","attachments":[],"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":620,"sourcePath":"Network/03. L3.md","exportPath":"network/03.-l3.html","showInTree":true,"treeOrder":364,"backlinks":[],"type":"markdown"},"network/04.-패킷의-생성과-전달.html":{"title":"04. 패킷의 생성과 전달","icon":"","description":"<img alt=\"packet.png\" src=\"images/packet.png\" target=\"_self\">상황: 철수가 영희에게 책을 택배로 전달하기 원함.\n철수, 영희: Process\n책: Data\n택배: Packet\n택배 기사: Gateway\n송장: Packet Header src: IPv4\ndst: IPv4\n이름: 영희 (port) 집: Host\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"4. 패킷의 생성과 전달","level":1,"id":"4._패킷의_생성과_전달_0"},{"heading":"비유 상황","level":4,"id":"비유_상황_0"}],"links":[],"author":"","coverImageURL":"images/packet.png","fullURL":"network/04.-패킷의-생성과-전달.html","pathToRoot":"..","attachments":["images/packet.html"],"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":278,"sourcePath":"Network/04. 패킷의 생성과 전달.md","exportPath":"network/04.-패킷의-생성과-전달.html","showInTree":true,"treeOrder":365,"backlinks":[],"type":"markdown"},"network/05.-계층별-데이터-단위.html":{"title":"05. 계층별 데이터 단위","icon":"","description":"User Mode\nProcess: 크롬 같은 데이터를 Write, Read함\nSocket: 유저 모드에서 TCP에 W/R 하는 인터페이스 (파일) 데이터 덩어리 (Stream) 관리함 Kernel mode (OS) TCP 데이터 단위: Segment\n데이터 한번에 받는 최대치: MSS (Maximum Segment Size)\nStream을 분할해서 Segment로 만듬 (Segmentation) IP 데이터 단위: Packet\n데이터 한번에 받는 최대치: MTU (보통 1500bytes) L2 (Driver) 데이터 단위: Frame ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"5. 계층별 데이터 단위","level":1,"id":"5._계층별_데이터_단위_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/05.-계층별-데이터-단위.html","pathToRoot":"..","attachments":[],"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":525,"sourcePath":"Network/05. 계층별 데이터 단위.md","exportPath":"network/05.-계층별-데이터-단위.html","showInTree":true,"treeOrder":366,"backlinks":[],"type":"markdown"},"network/06.-tcp-ip-송수신-구조.html":{"title":"06. TCP IP 송수신 구조","icon":"","description":"<img alt=\"data_transfer_struct.png\" src=\"images/data_transfer_struct.png\" target=\"_self\">A.bmp 파일을 서버에서 다운로드 받는 상황을 가정 서버 사이드 Process에서 HDD / SDD에 있는 A.bmp를 Copy 함 -&gt; Process의 버퍼 위에 올라감 Process는 이를 Socket을 이용해서 I/O Buffer에 Copy 함. (Send) 이때의 데이터 덩어리를 Stream 이라고함 Stream을 분해해서 Segment로 만듦 Sement를 Packet으로 만듦 (Encapsulation) Packet을 Frame 만든 (Encapsulation) 후에 전송 시작 Frame은 수시로 바뀜 (내용물인 Packet은 유지됨) 클라이언트 사이드에서 L2 단계에서 Frame으로 전달 받음 Decapsulation -&gt; Packet을 얻음 Decapsulation -&gt; Segment을 얻음 L4 TCP (Network) 단계에서 Segment를 Stream으로 변환 후에, 이를 I/O 버퍼에 채움 애플리케이션은 I/O buffer에 있는 데이터 덩어리를 Read(Receive)함. 이렇게 데이터를 송수신 하다가, 서버는 클라이언트가 데이터를 잘 받았는지 기다리기 때문에\n서버는 어느 순간 데이터를 보내지 않고 Acknowledgement를 기다림 (wait for ACK)클라이언트가 Server에 ACK# (number) + 여유 버퍼 (window size) 보냄(데이터를 잘 받았으니 다음 거 보내달라는 요청) 그러면 서버사이드는 다시 미리 준비된 패킷을 클라이언트에게 보냄.이러한 순서를 반복함.\nLoss - 데이터 유실 (Network 이슈)\nRe-transmission -&gt; ACK 중복 (네트워크 or 엔드포인트 이슈)\nOut of order - 순서가 이상함 Ex. 1 -&gt; 2 -&gt; 4 -&gt; 3 (보통 네트워크 이슈)\nZero Window - I/O 버퍼 여유 공간 없음 (엔드포인트 이슈)\nTCP 보고 한번 더 보자","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"6. TCP IP 송수신 구조","level":1,"id":"6._TCP_IP_송수신_구조_0"},{"heading":"Network 장애","level":4,"id":"Network_장애_0"}],"links":[],"author":"","coverImageURL":"images/data_transfer_struct.png","fullURL":"network/06.-tcp-ip-송수신-구조.html","pathToRoot":"..","attachments":["images/data_transfer_struct.html"],"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":1732,"sourcePath":"Network/06. TCP IP 송수신 구조.md","exportPath":"network/06.-tcp-ip-송수신-구조.html","showInTree":true,"treeOrder":367,"backlinks":[],"type":"markdown"},"network/07.-ipv4-header-형식.html":{"title":"07. IPv4 Header 형식","icon":"","description":"\nMTU: 1500 bytes\nHeader: 20 bytes\nPayload: 1500 - 20 bytes\n<img alt=\"ip4v_header.png\" src=\"images/ip4v_header.png\" target=\"_self\"> Version IPv4는 항상 4\n4비트 IHL 헤더의 길이를 나타냄. 최소값은 5행(20bytes)임. 위의 스샷에서 20bytes가 헤더 길이임.\n4비트 QOS(Quality of Service) or TOS QOS, TOS 정보를 포함\n8비트 Total Length 헤더와 데이터를 포함한 전체 패킷의 길이 (bytes)\n16비트 Identification 패킷 조각들을 구분하는 데 사용\n16비트 Flag 패킷의 단편화와 관련된 제어 플래그\n3비트 Fragment offset 원본 패킷에서의 데이터 오프셋을 8바이트 단위로 나타냄\n13비트 TTL (Time To Live) 패킷의 수명을 제한\n8비트 Protocol 위 계층 프로토콜(예: TCP, UDP)을 식별\n8비트 Header checksum 헤더의 무결성을 검증\n16비트 Source address 송신자의 IP 주소\n32비트 Destination Address 수신자의 IP 주소\n32비트 Options 선택적 필드로, 추가 기능을 제공\n가변 길이 0 ~ 40 bytes Data Up to 65515 bytes까지지만 대부분의 경우 MTU - Header 길이를 넘지 않음! ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"7. IPv4 Header 형식","level":1,"id":"7._IPv4_Header_형식_0"},{"heading":"복습","level":4,"id":"복습_0"}],"links":[],"author":"","coverImageURL":"images/ip4v_header.png","fullURL":"network/07.-ipv4-header-형식.html","pathToRoot":"..","attachments":["images/ip4v_header.html"],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":1220,"sourcePath":"Network/07. IPv4 Header 형식.md","exportPath":"network/07.-ipv4-header-형식.html","showInTree":true,"treeOrder":368,"backlinks":[],"type":"markdown"},"network/08.-서브넷-마스크와-cidr.html":{"title":"08. 서브넷 마스크와 CIDR","icon":"","description":"IP 주소에서 Net ID와 Host ID는 Subnet mask와 함께 고려해야 함.\n192.168.23.5 이라는 IP 주소가 있다고 가정\nSubnet Mask가 255.255.255.0임\n192.168.23 은 Net ID\n5은 Host ID\n즉 Subnet Mask란, IP주소에서 NetID와 Host ID를 구분하기 위한 용도 Class A -&gt;Network ID는 8비트\nClass B-&gt; Network ID는 16비트\nClass C -&gt; Network ID는 24비트 서브넷 마스크와 IP 주소를 AND 연산하면 Net ID는 본래의 값이 나오고 Host ID는 0이 나옴 -&gt; Host ID 마스킹 함\nNet ID 구분이 중요한 이유 패킷이 올 때, 네트워크 ID가 같으면 우리쪽으로 유입하는 것임을 알 수 있음. <img alt=\"subnetmask.png\" src=\"images/subnetmask.png\" target=\"_self\"> 요즘은 CIDR 표기방식을 사용함. 서브넷마스크를 이용\n192.168.23.5\n255.255.255.0 CIDR 이용\n192.168.23.5 / 24 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"8. 서브넷 마스크와 CIDR","level":1,"id":"8._서브넷_마스크와_CIDR_0"},{"heading":"Subnet mask","level":4,"id":"Subnet_mask_0"},{"heading":"CIDR (Classless inter-domain Routing)","level":4,"id":"CIDR_(Classless_inter-domain_Routing)_0"}],"links":[],"author":"","coverImageURL":"images/subnetmask.png","fullURL":"network/08.-서브넷-마스크와-cidr.html","pathToRoot":"..","attachments":["images/subnetmask.html"],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":908,"sourcePath":"Network/08. 서브넷 마스크와 CIDR.md","exportPath":"network/08.-서브넷-마스크와-cidr.html","showInTree":true,"treeOrder":369,"backlinks":[],"type":"markdown"},"network/09.-broadcast-ip-주소-&-loopback-주소.html":{"title":"09. Broadcast IP 주소 & Loopback 주소","icon":"","description":"\n패킷을 보낼때 dst를 보고 Gateway로 전달을 함.\nGateway는 Internet으로 보냄\ndst가 특정 IP면 Unicast임 (콕 집어서 보내는 거)\n<img alt=\"broadcastip_address.png\" src=\"images/broadcastip_address.png\" target=\"_self\">\nNet ID를 제외한 Host ID를 모두 1로 채우면 Broadcast IP 주소임\ndst가 Broadcast 주소면 전체한테 다 보냄\n브로드캐스팅은 효율성이 떨어짐 Host ID가 0 인 경우 -&gt; 서브넷 마스크와 일치\nHost ID가 255인 경우 -&gt; 브로드캐스트 주소 IP 주소를 사용해 통신하는 주체는 Process임.\n내 Process간의 통신 이뤄질 때 사용하는 주소: Loopback address -&gt; 127.0.0.1\n이 주소를 사용하면 패킷을 H/W영역에 보내지 않아도 됨\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"9. Broadcast IP 주소 &amp; Loopback 주소","level":1,"id":"9._Broadcast_IP_주소_&_Loopback_주소_0"},{"heading":"Unicast","level":4,"id":"Unicast_0"},{"heading":"Broadcast","level":4,"id":"Broadcast_0"},{"heading":"사용할 수 없는 IP 주소","level":4,"id":"사용할_수_없는_IP_주소_0"},{"heading":"Host 자신을 가리키는 IP 주소","level":4,"id":"Host_자신을_가리키는_IP_주소_0"}],"links":[],"author":"","coverImageURL":"images/broadcastip_address.png","fullURL":"network/09.-broadcast-ip-주소-&-loopback-주소.html","pathToRoot":"..","attachments":["images/broadcastip_address.html"],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":828,"sourcePath":"Network/09. Broadcast IP 주소 & Loopback 주소.md","exportPath":"network/09.-broadcast-ip-주소-&-loopback-주소.html","showInTree":true,"treeOrder":370,"backlinks":[],"type":"markdown"},"network/10.-ttl과-단편화.html":{"title":"10. TTL과 단편화","icon":"","description":"인터넷은 라우터와 DNS의 집합체임.Router의 역할은 라우터 테이블을 보고 패킷을 포워딩하는 것. (물류센터, 택배 기사 역할)\nRouter에서 Router로 이동하는 걸 Hop(깡총)이라고 함.\nHop을 하게 되면 TTL 값이 1씩 감소함.\nTime To Live\nIP 패킷 수명을 제한하는 메커니즘\n라우터를 통과할 때마다 TTL 값 1씩 감소\n수명을 제한 하지 않는다면 패킷이 네트워크를 무한 순회 -&gt; 좀비 패킷\n대부분 패킷의 최대 사이즈 (MTU = 1500 bytes)임. 간혹 서로 다른 네트워크 구간의 MTU 차이가 발생할 수 있음 (어떤 건 1400bytes, 1500 bytes) 이럴 때 패킷을 보내기 위해 쪼개는 걸 단편화라고 함.\n쪼개진 단편들은 수신자(Endpoint)에서 조립함.\n단편화된 패킷은 각각 다른 경로로 전송될 수 있음 (TTL이 만료되어 폐기 가능성 있음)\n단편화는 비효율적 -&gt; 처음부터 패킷을 보낼 때 하향 표준화해서 보내는 방법도 있음(처음부터 작은 사이즈 패킷을 보냄)\nVPN 터널링 기술에서 단편화 발생할 가능성 높음\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"TTL","level":4,"id":"TTL_0"},{"heading":"단편화 (Fragmentation)","level":4,"id":"단편화_(Fragmentation)_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/10.-ttl과-단편화.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":1196,"sourcePath":"Network/10. TTL과 단편화.md","exportPath":"network/10.-ttl과-단편화.html","showInTree":true,"treeOrder":371,"backlinks":[],"type":"markdown"},"network/11.-인터넷-자동-설정-dhcp.html":{"title":"11. 인터넷 자동 설정 - DHCP","icon":"","description":"인터넷을 사용하려면 해야할 게 있음.\nIP 주소\nSubnet mask\nGateway IP\nDNS 서버\n일반 사용자는 이러한 설정을 하지 않음. 그럼 누가 해주나?DHCP가 해준다. Dynamic Host Configuration Protocol 기능 IP 주소 할당: 네트워크에 연결된 장치에 고유한 IP 주소를 자동으로 할당\n서브넷 마스크 제공: IP 네트워크의 범위를 정의하는 서브넷 마스크를 제공\n기본 게이트웨이 설정: 로컬 네트워크 외부와 통신하기 위한 게이트웨이 주소를 제공\nDNS 서버 정보: 도메인 이름을 IP 주소로 변환하는 DNS 서버의 주소를 제공 DHCP는 내가 사용할 위의 네가지 것들을 DHCP 서버가 알려주는 것임 DHCP 작동 과정 클라이언트가 네트워크에 연결되면 DHCP 서버를 찾아야함 -&gt; 브로드캐스트\nDHCP 서버가 위의 정보들을 보내줌 (IP주소, 서브넷마스크 등등)\n클라이언트가 수락하고 요청 보냄\nDHCP 서버가 최종 승인함. 즉 DHCP 서버는 주소값을 관리하는 pool이라고 할 수 있음 DHCP는 브로드캐스트 도메인에 묶여있음. 브로드캐스트 도메인: 브로드캐스트 패킷이 도달할 수 있는 네트워크 범위 DHCP 브로드 캐스트 메세지는 Gateway를 넘을 수 없음. DHCP는 기본적으로 로컬 브로드캐스트 도메인 내에서 작동하며, 브로드캐스트 트래픽은 일반적으로 라우터를 통과X 라우터는 주로 다른 네트워크 범위로 트래픽을 이동 시키는데 사용.\n같은 네트워크면 ARP or 스위치나 허브를 통해 직접 통신 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"DHCP","level":3,"id":"DHCP_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/11.-인터넷-자동-설정-dhcp.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":1710,"sourcePath":"Network/11. 인터넷 자동 설정 - DHCP.md","exportPath":"network/11.-인터넷-자동-설정-dhcp.html","showInTree":true,"treeOrder":372,"backlinks":[],"type":"markdown"},"network/12.-arp.html":{"title":"12. ARP","icon":"","description":"Address Resolution Protocol\n브로드 캐스팅\nIP 주소로 게이트웨이의 MAC 주소를 알아내려할 때 활용.\nDHCP로 먼저 게이트웨이의 IP를 알고 ARP Request를 보내고 Reply로 게이트웨이의 MAC 주소를 얻음\n왜? 인터넷을 연결하기 위해서는 게이트웨이의 MAC 주소를 알아야함.인터넷 저 너머의 호스트(네이버 같은)에 접속할 때 L2 수준의 Frame에서 Header에 MAC 주소가 적혀있다. Packet에는 네이버의 IP가 적혀있겠지만, Header의 도착 정보에는 Gateway의 MAC 주소가 적혀있음.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"network/12.-arp.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":599,"sourcePath":"Network/12. ARP.md","exportPath":"network/12.-arp.html","showInTree":true,"treeOrder":373,"backlinks":[],"type":"markdown"},"network/13.-ping과-rtt.html":{"title":"13. Ping과 RTT","icon":"","description":"\nPing은 RTT(Round To Time)를 측정할 목적으로 사용되는 프로그램임\n핑은 ICMP 프로토콜을 이용해서 RTT를 측정함.\nDos 공격용을 악용되기도 함.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"network/13.-ping과-rtt.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":185,"sourcePath":"Network/13. Ping과 RTT.md","exportPath":"network/13.-ping과-rtt.html","showInTree":true,"treeOrder":374,"backlinks":[],"type":"markdown"},"network/14.-tcp와-udp-개요.html":{"title":"14. TCP와 UDP 개요","icon":"","description":"\nTCP는 연결 개념이 있음\nTCP는 기본적으로 Client / Server가 있음.\nClient는 연결을 시도하는 주체.\nPID를 가진 프로세스가 Socket를 오픈함. 운영체제가 TCP 포트를 열어줌Server는 연결을 기다리는 객체\nSocket을 오픈함. 운영체제가 TCP 포토를 열어놓고 대기함 (Listen)즉 연결하기 위해서는 서버의 IP 주소와 포트 번호를 알아야함.연결대기 상태도 아닌데, TCP 쪽에서 연결하자고 오면 운영체제 수준에서 연결을 못받아준다는 응답을 보내줌.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"network/14.-tcp와-udp-개요.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":579,"sourcePath":"Network/14. TCP와 UDP 개요.md","exportPath":"network/14.-tcp와-udp-개요.html","showInTree":true,"treeOrder":375,"backlinks":[],"type":"markdown"},"network/15.-tcp-연결-과정.html":{"title":"15. TCP 연결 과정","icon":"","description":"\n3-way handshaking\n통신되는 데이터 단위는 segment\n클라이언트에서 랜덤 sequence number를 SYN으로 서버에 보냄\n서버는 이를 받고 받은 숫자에 + 1을 더해 Ack르 클라에 보냄\n또한 서버는 랜덤 sequence number를 SYN으로 보낸다.\n클라는 Ack와 서버의 seq number을 받고 연결되었다고 판단함\n또한 클라는 서버의 seq number에 + 1을 더해 ack를 보냄\n서버는 이를 받고 연결되었다고 판단\nTCP 연결 과정에서\nSequence number 교환\n정책 교환: Maximum segment size (MSS) 사이즈가 다르다면 클라가 서버에 맞춤 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"network/15.-tcp-연결-과정.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":644,"sourcePath":"Network/15. TCP 연결 과정.md","exportPath":"network/15.-tcp-연결-과정.html","showInTree":true,"treeOrder":376,"backlinks":[],"type":"markdown"},"network/16.-tcp-연결-종료-과정.html":{"title":"16.  TCP 연결 종료 과정","icon":"","description":"\n4-way handshaking\n클라가 FIN + ACK를 보냄\n서버가 ACK를 보냄 그리고 다음 스텝에서 FIN + ACK를 보냄\n클라이언트가 FIN + ACK를 받고 ACK를 보냄\n서버가 ACK를 받음 -&gt; 종료완료\n클라이언트가 Active하게 종료해야함\n서버는 Passive하게 종료해야함\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"16. TCP 연결 종료 과정","level":1,"id":"16._TCP_연결_종료_과정_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"network/16.-tcp-연결-종료-과정.html","pathToRoot":"..","attachments":[],"createdTime":1730808631670,"modifiedTime":1730808631671,"sourceSize":317,"sourcePath":"Network/16.  TCP 연결 종료 과정.md","exportPath":"network/16.-tcp-연결-종료-과정.html","showInTree":true,"treeOrder":377,"backlinks":[],"type":"markdown"},"network/17.-dns.html":{"title":"17. DNS","icon":"","description":"Domain name\nwww - 호스트 네임\nnaver.com - 도메인 네임naver.com의 www 호스트를 찾아라ISP ( KT, LG , SK etc)에 호스트가 붙어있음.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.naver.com\" target=\"_self\">http://www.naver.com</a> 라고 씀<br>DNS 서버한테 질의를 함 - <a data-tooltip-position=\"top\" aria-label=\"http://www.naver.com\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.naver.com\" target=\"_self\">www.naver.com</a> ip 주소를 알려줘ip 받으면 접속하기질의 했을 때 응답으로 유효시간이 옮.\n한번이라도 질의 하면 pc가 DNS 캐싱함. (DNS 캐시)DNS Cache, host 파일, 공유기 DNS 포워딩 기능은 DNS 서버에 직접 질의하는 걸 줄여줌.<br>DNS에 질의를 했는데 모를수도 있음. (예를들어 <a data-tooltip-position=\"top\" aria-label=\"http://www.naver.com\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.naver.com\" target=\"_self\">www.naver.com</a>)\n그러면, Root DNS한테 요청함\nRoot DNS는 com 담당하는 DNS 목록을 알려줌.\nnaver 목록을 알려줘\nnaver 목록을 알려줌\nwww인 호스트 알려줘\nnaver 목록을 알려줌","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"network/17.-dns.html","pathToRoot":"..","attachments":[],"createdTime":1733748909718,"modifiedTime":1733749688993,"sourceSize":802,"sourcePath":"Network/17. DNS.md","exportPath":"network/17.-dns.html","showInTree":true,"treeOrder":378,"backlinks":[],"type":"markdown"},"network/18.-http.html":{"title":"18. HTTP","icon":"","description":"HTTP는 문자열으로 날라옴헤더 + Payload헤더\n일반\n요청\n응답\n엔티티\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"network/18.-http.html","pathToRoot":"..","attachments":[],"createdTime":1733749713419,"modifiedTime":1733749848142,"sourceSize":99,"sourcePath":"Network/18. HTTP.md","exportPath":"network/18.-http.html","showInTree":true,"treeOrder":379,"backlinks":[],"type":"markdown"},"opencv/video-capture.html":{"title":"Video Capture","icon":"","description":"cv::VideoCapture 클래스는 OpenCV에서 카메라 장치나 비디오 파일을 처리하기 위한 클래스다.생성자는 다양한 비디오 소스에 연결하는 기능을 제공VideoCapture(); // Camera 연결\nexplicit VideoCapture(int index, int apiPreference = CAP_ANY); // 파일\nexplicit VideoCapture(const String&amp; filename, int apiPreference = CAP_ANY); VideoCapture(const Ptr&lt;IStreamReader&gt;&amp; source, int apiPreference, const std::vector&lt;int&gt;&amp; params); apiPreference - API 백엔드 용도: 비디오 캡처에 사용할 특정 백엔드 API를 지정합니다.\n주요 옵션: cv::CAP_ANY: 자동 선택 (기본값)\ncv::CAP_DSHOW: Windows DirectShow\ncv::CAP_AVFOUNDATION: macOS AVFoundation\ncv::CAP_V4L2: Linux Video4Linux2\ncv::CAP_GSTREAMER: GStreamer 프레임워크\ncv::CAP_FFMPEG: FFmpeg 라이브러리 const Ptr&lt;IStreamReader&gt;&amp; source Ptr&lt;&gt;: OpenCV에서 사용하는 스마트 포인터 클래스입니다. 자동 메모리 관리를 제공\nIStreamReader: 데이터 스트림을 읽기 위한 인터페이스 클래스\n용도: 사용자 정의 데이터 소스에서 비디오 프레임을 읽을 수 있게 합니다 OpenCV에서 비디오 파일을 생성하고 인코딩하기 위한 클래스CV_WRAP VideoWriter(const String&amp; filename, int fourcc, double fps, Size frameSize, bool isColor = true); CV_WRAP VideoWriter(const String&amp; filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor = true); CV_WRAP VideoWriter(const String&amp; filename, int fourcc, double fps, const Size&amp; frameSize, const std::vector&lt;int&gt;&amp; params); CV_WRAP VideoWriter(const String&amp; filename, int apiPreference, int fourcc, double fps, const Size&amp; frameSize, const std::vector&lt;int&gt;&amp; params); int fourcc Four Character Code - 비디오 코덱을 4개의 문자로 식별하는 방법\na','v','c','1' : H.264 코덱\n'M','J','P','G': Motion JPEG 'X','V','I','D': XVID MPEG-4\n'm','p','4','v': MPEG-4\n'D','I','V','X': DIVX MPEG-4 double fps: Frame rate Size&amp; frameSize: 해상도\n예시cv::VideoWriter writer(videoFilename, cv::VideoWriter::fourcc('a', 'v', 'c', '1'), FPS, frame.size());\nfor (const auto&amp; f : allFrames) { writer.write(f); // 쓰기\n} writer.release(); // 닫기\n// 창 미리 생성\ncv::namedWindow(\"카메라\", cv::WINDOW_NORMAL); while (true) { // 카메라에서 새 프레임 읽기 camera.read(frame); // \"카메라\" 창에 새 프레임 표시/업데이트 cv::imshow(\"카메라\", frame); // GUI 이벤트 처리 및 키 입력 대기 int key = cv::waitKey(1); if (key == 'q') break; // q키 누르면 종료\n} #include &lt;deque&gt;\n#include &lt;mutex&gt;\n#include &lt;opencv2/opencv.hpp&gt;\n#include &lt;vector&gt; class VideoBuffer { private: std::deque&lt;cv::Mat&gt; frames; const int maxFrames; std::mutex mtx; public: VideoBuffer(int capacity) : maxFrames(capacity) {} void addFrame(const cv::Mat&amp; frame) { std::lock_guard&lt;std::mutex&gt; lock(mtx); frames.push_back(frame.clone()); if (frames.size() &gt; maxFrames) { frames.pop_front(); } } std::vector&lt;cv::Mat&gt; getAllFrames() { std::lock_guard&lt;std::mutex&gt; lock(mtx); return std::vector&lt;cv::Mat&gt;(frames.begin(), frames.end()); } size_t size() { std::lock_guard&lt;std::mutex&gt; lock(mtx); return frames.size(); }\n};\n#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt; #include \"VideoBuffer.h\" int main() { // 설정값 const int FPS = 30; const int PRE_SECONDS = 3; const int POST_SECONDS = 3; const int BUFFER_SIZE = FPS * PRE_SECONDS; // OpenCV 카메라 초기화 (메인 스레드에서) cv::VideoCapture camera(0); if (!camera.isOpened()) { std::cerr &lt;&lt; \"카메라를 열 수 없습니다.\" &lt;&lt; std::endl; return -1; } // 윈도우 생성 (메인 스레드에서) cv::namedWindow(\"카메라\", cv::WINDOW_NORMAL); // 링 버퍼 초기화 VideoBuffer preBuffer(BUFFER_SIZE); std::vector&lt;cv::Mat&gt; postBuffer; // 상태 변수 std::atomic&lt;bool&gt; isRecording(false); std::atomic&lt;bool&gt; shouldQuit(false); std::atomic&lt;int&gt; postFrameCount(0); bool videoSaved = false; std::string videoFilename = \"captured_video.mp4\"; std::cout &lt;&lt; \"시작되었습니다. 's'를 눌러 캡처, 'q'를 눌러 종료, 'p'를 눌러 재생\" &lt;&lt; std::endl; // 메인 루프 (UI 작업을 포함) cv::Mat frame; while (!shouldQuit) { // 카메라에서 프레임 읽기 if (!camera.read(frame)) { std::cerr &lt;&lt; \"프레임을 읽을 수 없습니다.\" &lt;&lt; std::endl; break; } // 현재 프레임을 미리 버퍼에 추가 preBuffer.addFrame(frame); // 녹화 중이면 사후 버퍼에 추가 if (isRecording) { postBuffer.push_back(frame.clone()); postFrameCount++; // 사후 녹화 완료 확인 if (postFrameCount &gt;= FPS * POST_SECONDS) { isRecording = false; // 비디오 저장 std::vector&lt;cv::Mat&gt; preFrames = preBuffer.getAllFrames(); std::vector&lt;cv::Mat&gt; allFrames; allFrames.insert(allFrames.end(), preFrames.begin(), preFrames.end()); allFrames.insert(allFrames.end(), postBuffer.begin(), postBuffer.end()); cv::VideoWriter writer(videoFilename, cv::VideoWriter::fourcc('a', 'v', 'c', '1'), FPS, frame.size()); if (!writer.isOpened()) { std::cerr &lt;&lt; \"비디오 파일을 저장할 수 없습니다.\" &lt;&lt; std::endl; } else { for (const auto&amp; f : allFrames) { writer.write(f); } writer.release(); std::cout &lt;&lt; \"비디오가 저장되었습니다: \" &lt;&lt; videoFilename &lt;&lt; std::endl; videoSaved = true; } postBuffer.clear(); postFrameCount = 0; } } // 프레임 표시 (메인 스레드에서) cv::imshow(\"카메라\", frame); // 키 입력 처리 int key = cv::waitKey(1); if (key == 'q' || key == 'Q') { shouldQuit = true; } else if (key == 's' || key == 'S') { if (!isRecording) { std::cout &lt;&lt; \"캡처 시작됨...\" &lt;&lt; std::endl; isRecording = true; postBuffer.clear(); postFrameCount = 0; } } else if (key == 'p' || key == 'P' &amp;&amp; videoSaved) { std::cout &lt;&lt; \"녹화된 비디오 재생 중...\" &lt;&lt; std::endl; cv::VideoCapture player(videoFilename); if (!player.isOpened()) { std::cerr &lt;&lt; \"비디오 파일을 재생할 수 없습니다.\" &lt;&lt; std::endl; } else { cv::namedWindow(\"재생\", cv::WINDOW_NORMAL); cv::Mat playFrame; while (player.read(playFrame)) { cv::imshow(\"재생\", playFrame); if (cv::waitKey(1000 / FPS) &gt;= 0) { break; } } cv::destroyWindow(\"재생\"); player.release(); } } } // 정리 camera.release(); cv::destroyAllWindows(); return 0;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Video Capture","level":3,"id":"Video_Capture_1"},{"heading":"생성자","level":4,"id":"생성자_0"},{"heading":"VideoWriter","level":3,"id":"VideoWriter_0"},{"heading":"생성자","level":4,"id":"생성자_1"},{"heading":"파일에 프레임 쓰기 &amp; 닫기","level":4,"id":"파일에_프레임_쓰기_&_닫기_0"},{"heading":"화면에 프레임 업데이트","level":3,"id":"화면에_프레임_업데이트_0"},{"heading":"Full code","level":3,"id":"Full_code_0"},{"heading":"VideoBuffer.h","level":4,"id":"VideoBuffer.h_0"},{"heading":"main.cpp","level":4,"id":"main.cpp_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"opencv/video-capture.html","pathToRoot":"..","attachments":[],"createdTime":1742132450645,"modifiedTime":1742132450645,"sourceSize":7590,"sourcePath":"opencv/Video Capture.md","exportPath":"opencv/video-capture.html","showInTree":true,"treeOrder":381,"backlinks":[],"type":"markdown"},"physics/physx.html":{"title":"physX","icon":"","description":"커스텀 물리를 적용하기 위해서 해야할 것?\n물리 시뮬레이션 중 onAdvance()을 하이재킹 한 후 그곳에 코드를 작성해야함.PhysX는 물리 시뮬레이션 - 실행단계 - 적용(인터그레이션)를 가짐. // 예시코드 PxScene scene; scene-&gt;simulate(timestep); scene-&gt;fetchResults(true); 시뮬레이션 준비 단계 시뮬레이션 실행 실제 물리 계산 수행\n충돌 해결 및 제약 조건 처리\n힘과 토크 적용 통합 단계 계산된 물리 상태를 게임 객체에 반영\n이벤트 처리 (충돌 콜백 등) PhysScene은 Unreal Engine에서 물리 시뮬레이션이 실행되는 독립된 공간 -&gt; 게임 월드의 물리적 표현PhysScene은 템플릿 클래스로 추상화 되어있음.구현체: PhysScene_Chaos, PhysScene_PhysX[1. 기본 초기화 및 업데이트 함수]void Init()\nvoid Tick(float InDeltaSeconds)\nInit(): 물리 씬의 초기 설정을 담당. 메모리 할당, 기본 파라미터 설정 등의 초기화 작업\nTick(): 매 프레임마다 호출되어 물리 시뮬레이션을 업데이트. InDeltaSeconds는 이전 프레임과의 시간 간격입니다.[2. 키네마틱 및 프레임 관련 함수]void SetKinematicUpdateFunction(...)\nvoid SetStartFrameFunction(...)\nvoid SetEndFrameFunction(...)\nSetKinematicUpdateFunction:\n키네마틱 객체들의 움직임을 제어하는 함수를 설정\n애니메이션이나 스크립트로 제어되는 물리 객체의 업데이트를 담당\n매개변수: 데이터, 델타 시간, 누적 시간, 반복 횟수SetStartFrameFunction:\n각 물리 시뮬레이션 프레임 시작 시 실행될 함수 설정\n초기 상태 설정, 데이터 준비 등을 수행SetEndFrameFunction:\n각 물리 시뮬레이션 프레임 종료 시 실행될 함수 설정\n결과 처리, 상태 저장 등을 수행[3. 물리 객체 생성 및 파라미터 관리]void SetCreateBodiesFunction(...)\nvoid SetParameterUpdateFunction(...)\nSetCreateBodiesFunction:\n물리 객체(강체, 파티클 등)를 생성하는 함수 설정\n새로운 물리 객체가 필요할 때 호출됨\n매개변수: 물리 데이터 구조체 참조SetParameterUpdateFunction:\n물리 시뮬레이션 파라미터 업데이트 함수 설정\n질량, 마찰, 탄성 등의 물리 속성 업데이트\n매개변수: 데이터, 델타 시간, 반복 횟수[4. 충돌 및 제약조건 관리]void SetDisableCollisionsUpdateFunction(...)\nvoid AddPBDConstraintFunction(...)\nSetDisableCollisionsUpdateFunction:\n특정 객체 쌍 간의 충돌을 비활성화하는 함수 설정\n매개변수: 충돌 비활성화할 객체 쌍의 인덱스 집합AddPBDConstraintFunction:\nPosition Based Dynamics 제약조건 추가 함수\n물리 기반 애니메이션, 천 시뮬레이션 등에 사용\n매개변수: 데이터, 델타 시간[5. 힘 적용 및 구현 접근]void AddForceFunction(...)\nImplType&amp; GetImpl()\nAddForceFunction:\n물리 객체에 힘을 적용하는 함수 추가\n중력, 바람, 폭발 등의 외력 시뮬레이션\n매개변수: 데이터, 델타 시간, 반복 횟수GetImpl():\n실제 구현체에 대한 접근자\n템플릿 구현체의 세부 기능 접근에 사용Unreal Engine에서 사용하는 PhysScene 구현체임. 물리 엔진은 PhysX를 사용.NVIDIA APEX는 PhysX 엔진을 확장한 물리 시뮬레이션 미들웨어[주요 기능]\n파괴 시뮬레이션\n건물이나 구조물의 사실적인 파괴 효과\n동적인 파편(debris) 생성의류 시뮬레이션\n캐릭터의 옷감 물리\n실시간 의류 변형입자 시스템\n연기, 불, 폭발 효과\n대규모 입자 시뮬레이션CCD(Continuous Collision Detection, 연속 충돌 감지)\n[핵심 개념]\nCCD는 고속으로 움직이는 물체들의 충돌을 정확하게 감지하기 위한 물리 시뮬레이션 기술[장점]\n정확한 충돌 감지\n빠른 물체의 충돌도 놓치지 않음\n얇은 물체 통과 현상 방지\n더 나은 게임플레이 경험\n물리 기반 게임에서 중요\n총알, 발사체 등의 정확한 처리\n[단점]\n성능 오버헤드\n더 많은 계산이 필요\n모든 물체에 적용하면 성능 저하\nISimEventCallbackFactory를 상속받은 CallbackFactory 구현\n실제 콜백 클래스도 구현\n팩토리 등록 및 사용\n// 커스텀 시뮬레이션 이벤트 콜백 팩토리\nclass FMySimEventCallbackFactory : public ISimEventCallbackFactory\n{\npublic: // Create 메서드 구현 virtual physx::PxSimulationEventCallback* Create(FPhysScene_PhysX* PhysScene) override { // 새로운 콜백 객체 생성 return new FMySimulationCallback(PhysScene); } // Destroy 메서드 구현 virtual void Destroy(physx::PxSimulationEventCallback* Callback) override { // 콜백 객체 정리 delete Callback; }\n}; // 커스텀 시뮬레이션 콜백\nclass FMySimulationCallback : public physx::PxSimulationEventCallback\n{\npublic: FMySimulationCallback(FPhysScene_PhysX* InPhysScene) : PhysScene(InPhysScene) {} // 충돌 이벤트 처리 virtual void onContact(const physx::PxContactPairHeader&amp; PairHeader, const physx::PxContactPair* Pairs, PxU32 NumPairs) override { // 충돌 처리 로직 UE_LOG(LogPhysics, Log, TEXT(\"충돌 발생!\")); } // 다른 필요한 이벤트 메서드들도 구현 virtual void onConstraintBreak(...) override { } virtual void onWake(...) override { } virtual void onSleep(...) override { } // ... private: FPhysScene_PhysX* PhysScene;\n}; // 엔진 초기화 시점에서\nvoid InitializePhysics()\n{ // 전역 팩토리 설정 FPhysScene_PhysX::SimEventCallbackFactory = MakeShared&lt;FMySimEventCallbackFactory&gt;();\n} Aggregate - 집합체Aggregate(집합체)는 여러 개의 Actor들을 하나의 그룹으로 관리하는 PhysX의 개념[차이점]성능 최적화\nAggregate: 여러 물체를 하나의 broad-phase 영역으로 처리\nActor: 개별적으로 broad-phase 검사 수행메모리 관리\nAggregate: 그룹 단위로 메모리 관리 가능\nActor: 개별적인 메모리 관리 필요메서드 안에서 PhysScene에 대한 플래그를 설정함.PxSceneFlagActive Actors/Transform 관련\neENABLE_ACTIVE_ACTORS // 활성화된 액터 알림 기능\neENABLE_ACTIVETRANSFORMS // 활성화된 트랜스폼 알림 기능\n움직이는 물체들의 상태를 추적할 때 사용\n성능에 영향을 줄 수 있으므로 필요한 경우에만 활성화\n충돌 감지 관련\neENABLE_CCD // 연속 충돌 감지(CCD) 활성화\neDISABLE_CCD_RESWEEP // CCD 재스윕 비활성화\neENABLE_PCM // GJK 기반 거리 충돌 감지\nCCD는 고속 이동 물체의 터널링을 방지\nPCM은 더 정확한 충돌 감지를 제공\n키네마틱 상호작용\neENABLE_KINEMATIC_STATIC_PAIRS // 키네마틱-정적 물체 간 상호작용\neENABLE_KINEMATIC_PAIRS // 키네마틱 물체들 간 상호작용\n키네마틱 물체들의 충돌 필터링을 제어\n기본적으로는 비활성화\n[중요한 성능 관련 플래그]\n캐시와 버퍼\neDISABLE_CONTACT_CACHE // 접촉 캐시 비활성화\neDISABLE_CONTACT_REPORT_BUFFER_RESIZE // 접촉 보고 버퍼 크기 조정 비활성화\n메모리 사용량과 성능 사이의 균형을 조절\n안정성 향상\neENABLE_STABILIZATION // 추가적인 안정화 패스 활성화\neENABLE_AVERAGE_POINT // 접촉 매니폴드의 평균점 활성화PxSceneFlag::eENABLE_ACTIVE_ACTORS; 플래그를 켜야 onAdvance() 하이재킹 가능","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UE 물리 파이프라인","level":3,"id":"UE_물리_파이프라인_0"},{"heading":"주요 개념","level":4,"id":"주요_개념_0"},{"heading":"PhysScene","level":4,"id":"PhysScene_0"},{"heading":"PhysScene_PhysX","level":4,"id":"PhysScene_PhysX_0"},{"heading":"APEX","level":4,"id":"APEX_0"},{"heading":"CCD","level":4,"id":"CCD_0"},{"heading":"CallbackFactory","level":4,"id":"CallbackFactory_0"},{"heading":"Actor와 Aggregate의 차이점","level":3,"id":"Actor와_Aggregate의_차이점_0"},{"heading":"void FPhysScene_PhysX::InitPhysScene(const AWorldSettings* Settings)","level":4,"id":"void_FPhysScene_PhysXInitPhysScene(const_AWorldSettings*_Settings)_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"physics/physx.html","pathToRoot":"..","attachments":[],"createdTime":1733748900822,"modifiedTime":1735554755753,"sourceSize":8288,"sourcePath":"physics/physX.md","exportPath":"physics/physx.html","showInTree":true,"treeOrder":383,"backlinks":[],"type":"markdown"},"physics/untitled.html":{"title":"Untitled","icon":"","description":"root cmake - interface\nVC++ -&gt; std Modern C++\nPlatform 처리, 리소스 관리, Logger, 파일 IO 유틸 모듈\nPhysics 설정, 파라미터 정의, 좌표계 정의 등 모듈\n테이블 로드 및 이중 선형보간 모듈 (항력, 양력, 측력, 스핀)\n시뮬레이팅 및 각 step마다 pos, vel, rot 등 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"physics/untitled.html","pathToRoot":"..","attachments":[],"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":333,"sourcePath":"physics/Untitled.md","exportPath":"physics/untitled.html","showInTree":true,"treeOrder":384,"backlinks":[],"type":"markdown"},"qt/opengl/opengl-sphere-그리기.html":{"title":"OpenGL Sphere 그리기","icon":"","description":"3D 공간에서 골프공을 표현하기 위한 구(sphere) 지오메트리를 생성하는 방법\n구의 파라미터 설정 (반지름, 분할 수)\n정점(vertex) 데이터 생성\n인덱스(index) 데이터 생성\nOpenGL 버퍼 객체 설정 (VAO, VBO, EBO)\n3D 공간에서 구는 다음과 같은 매개변수 방정식으로 표현됩니다: x = r × cos(theta) × cos(phi) y = r × cos(theta) × sin(phi) z = r × sin(theta) r은 반지름 theta는 수직각(latitude): -π/2(하단) ~ π/2(상단) phi는 수평각(longitude): 0 ~ 2π float stackAngle = PI / 2 - i * stackStep; // theta 계산\nfloat xy = radius * cosf(stackAngle); // r × cos(theta) 계산\nfloat z = radius * sinf(stackAngle); // r × sin(theta) 계산 float sectorAngle = j * sectorStep; // θ 계산\nfloat x = xy * cosf(sectorAngle); // r × cos(theta) × cos(phi)\nfloat y = xy * sinf(sectorAngle); // r × cos(theta) × sin(phi)\n구는 두 가지 방향으로 분할\nstackCount: 위에서 아래로 분할 (위도 분할)\nsectorCount: 수평 방향 분할 (경도 분할)\nconst float radius = 0.3f; // 골프공 반지름\nconst int sectorCount = 36; // 수평 분할 수 (경도)\nconst int stackCount = 18; // 수직 분할 수 (위도)\nconst QVector3D ballColor(1.0f, 1.0f, 1.0f); // 흰색 설정\nconst float PI = M_PI;\nconst float sectorStep = 2.0f * PI / sectorCount; // 각 섹터(경도) 사이의 각도\nconst float stackStep = PI / stackCount; // 각 스택(위도) 사이의 각도 for (int i = 0; i &lt;= stackCount; ++i) { float stackAngle = PI / 2 - i * stackStep; // 시작: π/2(상단), 끝: -π/2(하단) // ... for (int j = 0; j &lt;= sectorCount; ++j) { // ... }\n}\n이 중첩 루프는 구의 모든 정점을 생성\ni 는 위에서 아래로 각 스택(위도)을 순회\nj 는 각 스택에서 수평 방향(경도)으로 순회\n각 정점에 대해:\n위치(x, y, z) 계산\n색상(r, g, b) 설정 (모든 정점은 흰색)\nfor (int i = 0; i &lt; stackCount; ++i) { int k1 = i * (sectorCount + 1); // 현재 스택의 시작 인덱스 int k2 = k1 + sectorCount + 1; // 다음 스택의 시작 인덱스 for (int j = 0; j &lt; sectorCount; ++j, ++k1, ++k2) { // 각 섹터에 2개의 삼각형 추가 if (i != 0) { // 첫 번째 스택이 아닐 경우 indices.append(k1); indices.append(k2); indices.append(k1 + 1); } if (i != (stackCount - 1)) { // 마지막 스택이 아닐 경우 indices.append(k1 + 1); indices.append(k2); indices.append(k2 + 1); } }\n}\n인덱스 생성은 구를 삼각형 메쉬로 변환하는 과정\n각 스택과 섹터의 교차점마다 사각형 영역이 생성됨\n각 사각형은 두 개의 삼각형으로 분할됨\n특별 케이스 처리: 첫 번째 스택(i=0): 상단 극점만 처리\n마지막 스택(i=stackCount-1): 하단 극점만 처리 각 삼각형은 세 개의 인덱스로 구성되며, 이 인덱스는 먼저 정의된 정점 배열을 참조한다.// VAO(Vertex Array Object) 생성 및 바인딩\nm_ballVAO.create();\nm_ballVAO.bind(); // VBO(Vertex Buffer Object) 생성 및 데이터 할당\nm_ballVBO.create();\nm_ballVBO.bind();\nm_ballVBO.allocate(vertices.constData(), vertices.size() * sizeof(float)); // EBO(Element Buffer Object) 생성 및 데이터 할당\nm_ballEBO.create();\nm_ballEBO.bind();\nm_ballEBO.allocate(indices.constData(), indices.size() * sizeof(GLuint));\n이 부분은 OpenGL의 핵심 개념인 버퍼 객체를 설정\nVAO(Vertex Array Object): 정점 속성 포인터의 상태를 저장하는 컨테이너\nVBO(Vertex Buffer Object): 정점 데이터(위치, 색상 등)를 저장하는 버퍼\nEBO(Element Buffer Object): 인덱스 데이터를 저장하는 버퍼\n// 속성 설정 - 셰이더의 aPos 및 aColor 속성과 연결\nint posAttr = m_program-&gt;attributeLocation(\"aPos\");\nint colorAttr = m_program-&gt;attributeLocation(\"aColor\"); // 위치 속성 설정\nm_program-&gt;enableAttributeArray(posAttr);\nm_program-&gt;setAttributeBuffer(posAttr, GL_FLOAT, 0, 3, 6 * sizeof(float)); // 색상 속성 설정\nm_program-&gt;enableAttributeArray(colorAttr);\nm_program-&gt;setAttributeBuffer(colorAttr, GL_FLOAT, 3 * sizeof(float), 3, 6 * sizeof(float));\n이 부분은 셰이더 프로그램에 전달할 정점 속성을 설정 위치 속성(aPos): 시작 오프셋: 0 (정점 데이터의 시작)\n요소 개수: 3 (x, y, z)\n스트라이드: 6 * sizeof(float) (한 정점의 전체 크기) 색상 속성(aColor): 시작 오프셋: 3 * sizeof(float) (위치 다음)\n요소 개수: 3 (r, g, b)\n스트라이드: 6 * sizeof(float) (한 정점의 전체 크기) 각 정점은 다음과 같은 형식으로 저장됩니다:[x, y, z, r, g, b] 처음 3개 값(x, y, z)은 정점의 위치\n다음 3개 값(r, g, b)은 정점의 색상\n인덱스를 사용하는 이유:\n메모리 효율성: 같은 정점을 여러 삼각형에서 재사용할 수 있어 메모리 사용량 감소\n성능 향상: 중복된 정점 처리를 줄여 GPU 효율 증가\n<img alt=\"구(Sphere)의 인덱스 생성 시각화\" src=\"images/sphere-indexing-screenshot.png\" target=\"_self\">for (int i = 0; i &lt; stackCount; ++i) { int k1 = i * (sectorCount + 1); // 현재 스택의 시작 인덱스 int k2 = k1 + sectorCount + 1; // 다음 스택의 시작 인덱스 for (int j = 0; j &lt; sectorCount; ++j, ++k1, ++k2) { // 각 섹터에 2개의 삼각형 추가 if (i != 0) { // 첫 번째 스택이 아닐 경우 indices.append(k1); indices.append(k2); indices.append(k1 + 1); } if (i != (stackCount - 1)) { // 마지막 스택이 아닐 경우 indices.append(k1 + 1); indices.append(k2); indices.append(k2 + 1); } }\n} k1: 현재 스택(i)의 시작 인덱스\nk2: 다음 스택(i+1)의 시작 인덱스\n이 값들은 다음과 같이 계산됩니다:k1 = i * (sectorCount + 1);\nk2 = k1 + sectorCount + 1;\n예를 들어, sectorCount가 36인 경우:\ni=0일 때: k1=0, k2=37\ni=1일 때: k1=37, k2=74\ni=2일 때: k1=74, k2=111\n각 스택과 섹터 사이의 사각형 영역을 두 개의 삼각형으로 분할한다. 상단 삼각형 (i != 0일 때만):\nindices.append(k1); // 현재 스택, 현재 섹터\nindices.append(k2); // 다음 스택, 현재 섹터\nindices.append(k1 + 1); // 현재 스택, 다음 섹터 하단 삼각형 (i != stackCount-1일 때만):\nindices.append(k1 + 1); // 현재 스택, 다음 섹터\nindices.append(k2); // 다음 스택, 현재 섹터\nindices.append(k2 + 1); // 다음 스택, 다음 섹터 첫 번째 스택 (i=0): 상단 극점에 해당\n여기서는 하단 삼각형만 생성 (상단 삼각형 생략)\nif (i != 0) 조건으로 처리 마지막 스택 (i=stackCount-1): 하단 극점에 해당\n여기서는 상단 삼각형만 생성 (하단 삼각형 생략)\nif (i != (stackCount - 1)) 조건으로 처리 구의 수학적 방정식을 사용하여 정점 위치 계산\n정점 간 관계를 정의하는 인덱스 데이터 생성\nOpenGL 버퍼 객체 설정(VAO, VBO, EBO)\n셰이더 프로그램에 정점 속성 전달\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 전체 기능 개요","level":2,"id":"1._전체_기능_개요_0"},{"heading":"2. 구 모델링의 수학적 이론","level":2,"id":"2._구_모델링의_수학적_이론_0"},{"heading":"2.1 구의 수학적 표현","level":3,"id":"2.1_구의_수학적_표현_0"},{"heading":"2.2 구의 분할 방법","level":3,"id":"2.2_구의_분할_방법_0"},{"heading":"3. 코드 분석","level":2,"id":"3._코드_분석_0"},{"heading":"3.1 구 파라미터 설정","level":3,"id":"3.1_구_파라미터_설정_0"},{"heading":"3.2 정점 데이터 생성","level":3,"id":"3.2_정점_데이터_생성_0"},{"heading":"3.3 인덱스 생성","level":3,"id":"3.3_인덱스_생성_0"},{"heading":"3.4 OpenGL 버퍼 설정","level":3,"id":"3.4_OpenGL_버퍼_설정_0"},{"heading":"3.5 정점 속성 설정","level":3,"id":"3.5_정점_속성_설정_0"},{"heading":"4. 주요 개념 설명","level":2,"id":"4._주요_개념_설명_0"},{"heading":"4.1 정점 데이터 구조","level":3,"id":"4.1_정점_데이터_구조_0"},{"heading":"4.2 인덱스 기반 렌더링의 이점","level":3,"id":"4.2_인덱스_기반_렌더링의_이점_0"},{"heading":"5. 인덱스 생성 시각화","level":2,"id":"5._인덱스_생성_시각화_0"},{"heading":"5.1 인덱스 생성 알고리즘 분석","level":3,"id":"5.1_인덱스_생성_알고리즘_분석_0"},{"heading":"5.2 인덱스 계산 방법","level":3,"id":"5.2_인덱스_계산_방법_0"},{"heading":"5.3 사각형을 삼각형으로 분할","level":3,"id":"5.3_사각형을_삼각형으로_분할_0"},{"heading":"5.4 특별 케이스 처리","level":3,"id":"5.4_특별_케이스_처리_0"},{"heading":"6. 요약","level":2,"id":"6._요약_0"}],"links":[],"author":"","coverImageURL":"images/sphere-indexing-screenshot.png","fullURL":"qt/opengl/opengl-sphere-그리기.html","pathToRoot":"../..","attachments":["images/sphere-indexing-screenshot.html"],"createdTime":1743691206980,"modifiedTime":1743691206980,"sourceSize":8113,"sourcePath":"Qt/opengl/OpenGL Sphere 그리기.md","exportPath":"qt/opengl/opengl-sphere-그리기.html","showInTree":true,"treeOrder":387,"backlinks":[],"type":"markdown"},"qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html":{"title":"OpenGL 인덱스 순서와 면 컬링 관계","icon":"","description":"그라운드를 생성했는데, 렌더링이 되지 않아서 볼 수 없는 문제가 발생했었다. 삼각형의 인덱스 순서를 변경하니 해결되었는데 그 이유를 자세히 알아보도록 한다.삼각형의 Winding Order이란 삼각형의 정점들이 어떤 순서로 연결되는지를 의미한다. 3D 그래픽스에서는 이 순서를 통해 삼각형의 앞면과 뒷면을 구분합니다.\n반시계 방향(Counter-Clockwise, CCW): 삼각형의 정점들이 반시계 방향으로 연결될 때\n시계 방향(Clockwise, CW): 삼각형의 정점들이 시계 방향으로 연결될 때\nOpenGL의 기본 설정에서는 반시계 방향으로 정의된 삼각형을 앞면으로 간주한다.그라운드(바닥 평면)는 보통 사각형으로 구현되며, 두 개의 삼각형으로 나뉘어 렌더링된다. 이 과정에서 인덱스 순서가 중요하다.// 원래 인덱스 (시계 방향)\nconst GLuint indices[] = { 0, 1, 2, // 첫 번째 삼각형 0, 2, 3 // 두 번째 삼각형\n};\n0 --- 1\n| / |\n| / |\n3 --- 2\n이 인덱스 배열은 두 개의 삼각형을 시계 방향(CW)으로 정의합니다:\n첫 번째 삼각형: 정점 0 → 1 → 2 (시계 방향)\n두 번째 삼각형: 정점 0 → 2 → 3 (시계 방향)\nOpenGL의 기본 설정에서는 시계 방향으로 정의된 삼각형은 뒷면으로 간주되고,glEnable(GL_CULL_FACE)를 사용하면 뒷면은 렌더링되지 않는다. 따라서 보이지 않는다.// 수정된 인덱스 (반시계 방향)\nconst GLuint indices[] = { 0, 2, 1, // 첫 번째 삼각형 (방향 변경) 0, 3, 2 // 두 번째 삼각형 (방향 변경)\n};\n0 --- 1\n| / |\n| / |\n3 --- 2\n이렇게 변경된 인덱스 배열은:\n첫 번째 삼각형: 정점 0 → 2 → 1 (반시계 방향)\n두 번째 삼각형: 정점 0 → 3 → 2 (반시계 방향)\n반시계 방향으로 정의된 삼각형들은 OpenGL에 의해 앞면으로 간주되어 면 컬링이 활성화되어도 정상적으로 렌더링된다.법선 벡터가 관찰자를 향하면 삼각형은 반시계 방향, 반대 방향이면 시계 방향이다.인덱스 순서를 변경하는 것 외에도 다음 방법으로 문제를 해결할 수 있음.\n앞면 정의 변경\nglFrontFace(GL_CW); // 시계 방향을 앞면으로 정의 컬링 모드 변경\nglCullFace(GL_FRONT); // 앞면을 컬링하고 뒷면을 렌더링 면 컬링 비활성화 (최적화 포기):\nglDisable(GL_CULL_FACE);\n하지만 인덱스 순서를 변경하는 것이 가장 표준적인 방법이며, OpenGL의 기본 설정(반시계 방향)을 준수하는 것이 좋음.면 컬링은 중요한 성능 최적화 기법이다. 면 컬링 활성화는 보이지 않는 면을 렌더링을 건너 뛰어서 렌더링 시간을 줄일 수 있고 프래그먼트 쉐이더 연산과 래스터화를 더 효율적으로 수행할 수 있다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. Winding Order의 기본 개념","level":2,"id":"1._Winding_Order의_기본_개념_0"},{"heading":"2. 그라운드(사각형) 렌더링 문제","level":2,"id":"2._그라운드(사각형)_렌더링_문제_0"},{"heading":"문제가 있는 인덱스 순서 (시계 방향)","level":3,"id":"문제가_있는_인덱스_순서_(시계_방향)_0"},{"heading":"해결된 인덱스 순서 (반시계 방향)","level":3,"id":"해결된_인덱스_순서_(반시계_방향)_0"},{"heading":"4. 법선 벡터와의 관계","level":2,"id":"4._법선_벡터와의_관계_0"},{"heading":"5. 다른 해결 방법","level":2,"id":"5._다른_해결_방법_0"},{"heading":"6. 컬링의 성능 이점","level":2,"id":"6._컬링의_성능_이점_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html","pathToRoot":"../..","attachments":[],"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":3313,"sourcePath":"Qt/opengl/OpenGL 인덱스 순서와 면 컬링 관계.md","exportPath":"qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html","showInTree":true,"treeOrder":388,"backlinks":[],"type":"markdown"},"qt/opengl/qt-opengl-in-macos.html":{"title":"Qt OpenGL in macOS","icon":"","description":"Qt에서 OpenGL을 사용할 때 QSurfaceFormat을 통해 버전을 설정 해야 한다.// main.cpp\nQSurfaceFormat format;\nformat.setVersion(3, 3); // OpenGL 3.3 사용\nformat.setProfile(QSurfaceFormat::CoreProfile); // Core 프로파일 사용\nformat.setDepthBufferSize(24);\nformat.setStencilBufferSize(8);\nformat.setSamples(4); // 멀티샘플링 설정\nQSurfaceFormat::setDefaultFormat(format); // 중요: 전역 설정으로 지정 기본 지원: macOS는 기본적으로 OpenGL 2.1(레거시 프로파일)을 지원함.\n확장 지원: macOS 10.9 (Mavericks) 이상에서는 OpenGL 3.3 Core 프로파일 및 최대 4.1까지 지원\nQOpenGLContext context;\nif (context.create()) { qDebug() &lt;&lt; \"OpenGL Version:\" &lt;&lt; context.format().majorVersion() &lt;&lt; \".\" &lt;&lt; context.format().minorVersion(); qDebug() &lt;&lt; \"Profile:\" &lt;&lt; (context.format().profile() == QSurfaceFormat::CoreProfile ? \"Core\" : \"Compatibility\");\n}\nmacOS에서 OpenGL 3.3으로 설정했는데 실제로는 4.1이 표시되는 현상이 있을 수 있다. 왜냐하면 OpenGL은 하위 호환성이 있는 API로, 요청한 버전보다 높은 버전이 지원된다면 드라이버는 보통 지원되는 가장 높은 버전을 선택한다. 하위 호환성을 거의 보장하므로 3.3 코드는 4.1에서도 문제없이 작동한다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"OpenGL 버전 설정","level":2,"id":"OpenGL_버전_설정_0"},{"heading":"macOS의 OpenGL 지원","level":2,"id":"macOS의_OpenGL_지원_0"},{"heading":"OpenGL 버전 확인","level":4,"id":"OpenGL_버전_확인_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"qt/opengl/qt-opengl-in-macos.html","pathToRoot":"../..","attachments":[],"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":1452,"sourcePath":"Qt/opengl/Qt OpenGL in macOS.md","exportPath":"qt/opengl/qt-opengl-in-macos.html","showInTree":true,"treeOrder":389,"backlinks":[],"type":"markdown"},"qt/opengl/qt-opengl-코드.html":{"title":"Qt OpenGL 코드","icon":"","description":"Qt 프레임워크와 OpenGL을 사용하여 기본 그라운드를 렌더링하는 코드에 대한 설명이다.OpenGL 그래픽 파이프라인은 3D 객체를 2D 화면에 표시하기 위한 일련의 단계를 말함\n정점 데이터 준비: 3D 공간에서의 점(정점)들을 정의\n정점 쉐이더(Vertex Shader): 각 정점의 위치 변환 처리\n프리미티브 조립(Primitive Assembly): 정점들을 삼각형 등의 기본 도형으로 조립\n래스터화(Rasterization): 3D 기본 도형을 2D 픽셀로 변환\n프래그먼트 쉐이더(Fragment Shader): 각 픽셀의 최종 색상 계산\n프레임 버퍼에 출력: 계산된 픽셀을 화면에 표시\n바닥(그라운드)을 표현하기 위한 데이터를 준비한다.void GLWidget::createGeometry()\n{ // 그라운드 크기 설정 constexpr float size = 10.0f; // 기본 색상 설정 (그린) const QVector3D green(0.0f, 0.5f, 0.1f); // 정점 데이터 (위치와 색상 정보) const float vertices[] = { // 위치(x, y, z) // 색상(r, g, b) -size, 0.0f, -size, green.x(), green.y(), green.z(), // 좌상단 size, 0.0f, -size, green.x(), green.y(), green.z(), // 우상단 size, 0.0f, size, green.x(), green.y(), green.z(), // 우하단 -size, 0.0f, size, green.x(), green.y(), green.z() // 좌하단 }; 정점 데이터 정의 4개의 정점으로 이루어진 평면(사각형)을 생성한다.\n각 정점은 위치(x,y,z)와 색상(r,g,b) 정보를 가진다. // 인덱스 데이터 (삼각형 정의) const unsigned int indices[] = { 0, 1, 2, // 첫 번째 삼각형 0, 3, 2 // 두 번째 삼각형 - 면 컬링 고려 }; 인덱스 데이터 정의 사각형을 2개의 삼각형으로 나누어 표현한다.\n첫 번째 삼각형: 정점 0, 1, 2를 연결\n두 번째 삼각형: 정점 0, 3, 2을 연결 // VAO 생성 및 바인딩 m_groundVAO.create(); m_groundVAO.bind(); // VBO(정점 버퍼) 생성 및 데이터 할당 m_groundVBO.create(); m_groundVBO.bind(); m_groundVBO.allocate(vertices, sizeof(vertices)); // EBO(인덱스 버퍼) 생성 및 데이터 할당 m_groundEBO.create(); m_groundEBO.bind(); m_groundEBO.allocate(indices, sizeof(indices)); OpenGL 버퍼 생성 VAO(Vertex Array Object): 정점 데이터의 구성 방식을 저장하는 객체\nVBO(Vertex Buffer Object): 실제 정점 데이터를 GPU 메모리에 저장\nEBO(Element Buffer Object): 인덱스 데이터를 GPU 메모리에 저장 // 위치 속성 설정 (attribute 0) m_program-&gt;enableAttributeArray(0); // aPos 속성 활성화 m_program-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 3, 6 * sizeof(float)); // 색상 속성 설정 (attribute 1) m_program-&gt;enableAttributeArray(1); // aColor 속성 활성화 m_program-&gt;setAttributeBuffer(1, GL_FLOAT, 3 * sizeof(float), 3, 6 * sizeof(float)); 속성 포인터 설정 쉐이더 프로그램에 정점 데이터의 구조를 알려줍니다\n첫 번째 속성(0): 위치 데이터 (x,y,z - 3개 float)\n두 번째 속성(1): 색상 데이터 (r,g,b - 3개 float)\n매개변수 설명: 첫 번째: 속성 인덱스\n두 번째: 데이터 타입 (GL_FLOAT)\n세 번째: 데이터 시작 오프셋 (바이트 단위)\n네 번째: 구성요소 개수 (위치: 3, 색상: 3)\n다섯 번째: 다음 정점까지의 간격 (stride) (6개 float) 이 함수는 실제로 그라운드를 화면에 그려주는 역할을 합니다:void GLWidget::drawGround()\n{ // 그라운드 VAO 바인딩 m_groundVAO.bind(); // 모델 행렬 설정 (단위 행렬 - 원점에 위치) QMatrix4x4 model; m_program-&gt;setUniformValue(\"model\", model); // 그라운드 그리기 (EBO 사용) glDrawElements(GL_TRIANGLES, m_groundIndices, GL_UNSIGNED_INT, nullptr); // VAO 해제 m_groundVAO.release();\n} VAO 바인딩: 이전에 설정한 정점 데이터 구성을 활성\n모델 행렬 설정: 객체의 위치, 회전, 크기를 정의\n그리기 명령 실행: 인덱스를 이용해 삼각형을 그림 GL_TRIANGLES: 삼각형 모드로 그리기\nm_groundIndices: 인덱스 개수 (6개)\nGL_UNSIGNED_INT: 인덱스 데이터 타입\nnullptr: 인덱스 데이터가 이미 바인딩된 EBO에 있음 이 함수는 Qt의 QOpenGLWidget 클래스의 가상 함수로, 화면을 그리는 메인 렌더링 함수입니다:void GLWidget::paintGL()\n{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 쉐이더 프로그램 활성화 m_program-&gt;bind(); // 카메라 뷰 설정 QMatrix4x4 view; view.lookAt( QVector3D(0.0f, 5.0f, 5.0f), // 카메라 위치 QVector3D(0.0f, 0.0f, 0.0f), // 바라보는 지점 QVector3D(0.0f, 1.0f, 0.0f) // 상향 벡터 ); 화면 초기화: 색상 버퍼와 깊이 버퍼를 지움\n쉐이더 프로그램 활성화: 그리기에 사용할 쉐이더를 활성화\n카메라 뷰 설정 // 투영 행렬 설정 QMatrix4x4 projection; float aspectRatio = width() / static_cast&lt;float&gt;(height()); projection.perspective(45.0f, aspectRatio, 0.1f, 100.0f); // 쉐이더에 행렬 전달 m_program-&gt;setUniformValue(\"view\", view); m_program-&gt;setUniformValue(\"projection\", projection); // 그라운드 그리기 drawGround(); // 쉐이더 프로그램 비활성화 m_program-&gt;release();\n} 투영 행렬 설정: 3D 장면을 2D 화면에 투영하는 방법을 정의 45도 시야각(FOV)\n화면 비율(aspect ratio)에 맞게 조정\n근거리 절단면(near plane): 0.1\n원거리 절단면(far plane): 100.0 행렬 전달: 뷰 행렬과 투영 행렬을 쉐이더에 전달 그라운드 그리기: 앞서 정의한 drawGround() 함수 호출 쉐이더 해제: 사용 완료 후 쉐이더를 비활성화 코드에서 사용된 세 가지 주요 변환 행렬 모델 행렬(Model Matrix) 객체의 로컬 공간에서 월드 공간으로 변환\n객체의 위치, 회전, 크기를 정의\n코드에서는 기본 단위 행렬 사용(원점에 위치) 뷰 행렬(View Matrix) 월드 공간에서 카메라 공간으로 변환\n카메라의 위치와 방향을 정의\nlookAt 함수로 생성 투영 행렬(Projection Matrix) 카메라 공간에서 클립 공간으로 변환\n원근감 적용 (멀리 있는 물체는 작게 보임)\nperspective 함수로 생성 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 그래픽 파이프라인의 기본 개념","level":2,"id":"1._그래픽_파이프라인의_기본_개념_0"},{"heading":"2. 코드 분석","level":2,"id":"2._코드_분석_0"},{"heading":"createGeometry() 함수","level":3,"id":"createGeometry()_함수_0"},{"heading":"drawGround() 함수","level":3,"id":"drawGround()_함수_0"},{"heading":"paintGL() 함수","level":3,"id":"paintGL()_함수_0"},{"heading":"3. 변환 행렬","level":2,"id":"3._변환_행렬_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"qt/opengl/qt-opengl-코드.html","pathToRoot":"../..","attachments":[],"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":7066,"sourcePath":"Qt/opengl/Qt OpenGL 코드.md","exportPath":"qt/opengl/qt-opengl-코드.html","showInTree":true,"treeOrder":390,"backlinks":[],"type":"markdown"},"qt/qt-quick-3d-기본-개념-정리.html":{"title":"Qt Quick 3D - 기본 개념 정리","icon":"","description":"View3D는 Qt Quick 애플리케이션에서 3D 콘텐츠를 표시하는 핵심 컴포넌트입니다.View3D { id: view3D anchors.fill: parent environment: SceneEnvironment { clearColor: \"skyblue\" antialiasingMode: SceneEnvironment.MSAA antialiasingQuality: SceneEnvironment.Medium } // 여기에 카메라, 조명, 모델 등이 배치\n} environment: 3D 장면의 환경 설정 (배경색, 안티얼라이징 등)\nrenderMode: 렌더링 방식 설정\ncamera: 활성 카메라 지정 clearColor: 배경색 설정\nantialiasingMode: 계단 현상 방지 모드 (MSAA, SSAA 등)\nantialiasingQuality: 안티얼라이징 품질 (Low, Medium, High, VeryHigh)\nbackgroundMode: 배경 모드 (단색, 스카이박스 등)\n카메라는 3D 공간을 어떤 시점에서 볼지 결정합니다.PerspectiveCamera { id: camera position: Qt.vector3d(0, 10, 12) // (x, y, z) 위치 eulerRotation: Qt.vector3d(-20, 0, 0) // (x, y, z) 회전 각도 // 또는 lookAt 함수 사용 function lookAt(targetPosition, upVector) { // 카메라가 특정 지점을 바라보도록 설정 }\n} x: 좌/우 위치 (양수: 오른쪽, 음수: 왼쪽)\ny: 높이 (양수: 위쪽, 음수: 아래쪽)\nz: 앞/뒤 위치 (양수: 뒤쪽, 음수: 앞쪽) x축 회전: 위/아래 시선 조절 (고개 끄덕이기, '-'값은 아래 보기) - pitch\ny축 회전: 좌/우 시선 조절 (고개 좌우로 돌리기)- yaw\nz축 회전: 카메라 기울기 (머리 기울이기) - roll targetPosition: 바라볼 대상의 위치\nupVector: 카메라의 \"위쪽\" 방향 (보통 Qt.vector3d(0, 1, 0)), 법선벡터 PerspectiveCamera: 원근감 있는 일반적인 3D 시점\nOrthographicCamera: 원근감 없는 도면 같은 시점\n조명은 3D 객체를 비추어 보이게 하는 광원입니다.DirectionalLight { eulerRotation: Qt.vector3d(-30, 30, 0) // 빛의 방향 brightness: 0.7 // 밝기 (0.0 ~ 1.0) ambientColor: Qt.rgba(0.3, 0.3, 0.3, 1.0) // 주변광\n} 역할: 태양광처럼 평행한 빛을 제공 (무한히 먼 곳에서 오는 빛)\neulerRotation: 빛이 오는 방향 설정\nbrightness: 빛의 강도 (0.0 ~ 1.0)\nambientColor: 주변광의 색상과 강도\nPointLight { position: Qt.vector3d(0, 100, 0) // 광원 위치 brightness: 1.0 color: \"white\" constantFade: 1.0 linearFade: 0.0 quadraticFade: 0.0\n} 역할: 전구처럼 모든 방향으로 빛을 발산\nposition: 광원의 위치\n색상 및 감쇠: 거리에 따른 빛의 감소 설정\nSpotLight { position: Qt.vector3d(0, 100, 0) eulerRotation: Qt.vector3d(-90, 0, 0) brightness: 1.0 coneAngle: 30.0 // 빛 원뿔의 각도\n} 역할: 원뿔 형태로 특정 방향을 비추는 빛\nconeAngle: 빛 원뿔의 각도\nQt Quick 3D는 오른손 좌표계를 사용합니다. y (위) | | +----&gt; x (오른쪽) / / z (화면 안쪽) 오른손 좌표계: 오른손 엄지(x), 검지(y), 중지(z)가 서로 수직인 방향\n원점: (0, 0, 0) 좌표\n양수 방향: x: 오른쪽\ny: 위쪽\nz: 화면 안쪽(깊이) 엄지를 회전축 방향으로 향하면 나머지 손가락이 회전 방향\nx축 회전: 화면을 기준으로 상하 회전\ny축 회전: 화면을 기준으로 좌우 회전\nz축 회전: 화면을 기준으로 시계/반시계 회전\nView3D { // 1. 환경 설정 environment: SceneEnvironment { clearColor: \"skyblue\" // 하늘색 배경 antialiasingQuality: SceneEnvironment.Medium // 품질 설정 } // 2. 카메라 설정 PerspectiveCamera { id: camera position: Qt.vector3d(0, 10, 12) // 지면보다 위쪽, 약간 뒤쪽에서 바라봄 } // 3. 조명 설정 DirectionalLight { eulerRotation: Qt.vector3d(0, 0, 0) // 정면에서 비추는 빛 brightness: 0.7 // 밝기 70% ambientColor: Qt.rgba(0.3, 0.3, 0.3, 1.0) // 주변광 } // 4. 지면 모델 Model { id: ground position: Qt.vector3d(0, 0, 0) // 원점에 위치 scale: Qt.vector3d(500, 0.1, 500) // 넓고 얇은 판 source: \"#Cube\" // 내장 큐브 모델 사용 materials: DefaultMaterial { diffuseColor: \"green\" // 녹색 지면 } } // 5. 구 Model { id: ball source: \"#Sphere\" // 내장 구체 모델 scale: Qt.vector3d(0.3, 0.3, 0.3) // 크기 조정 position: Qt.vector3d(0, 5.0, 0) // 초기 위치 materials: DefaultMaterial { diffuseColor: \"white\" // 흰색 specularAmount: 0.9 // 반사도 } }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. View3D의 이해","level":2,"id":"1._View3D의_이해_0"},{"heading":"기본 구조","level":3,"id":"기본_구조_0"},{"heading":"View3D의 주요 속성","level":3,"id":"View3D의_주요_속성_0"},{"heading":"SceneEnvironment 설정","level":3,"id":"SceneEnvironment_설정_0"},{"heading":"2. 카메라 (PerspectiveCamera)","level":2,"id":"2._카메라_(PerspectiveCamera)_0"},{"heading":"기본 구조","level":3,"id":"기본_구조_1"},{"heading":"카메라 위치 설정 (position)","level":3,"id":"카메라_위치_설정_(position)_0"},{"heading":"카메라 회전 (eulerRotation)","level":3,"id":"카메라_회전_(eulerRotation)_0"},{"heading":"lookAt 함수","level":3,"id":"lookAt_함수_0"},{"heading":"카메라 종류","level":3,"id":"카메라_종류_0"},{"heading":"3. 조명 (Lighting)","level":2,"id":"3._조명_(Lighting)_0"},{"heading":"DirectionalLight (방향성 광원)","level":3,"id":"DirectionalLight_(방향성_광원)_0"},{"heading":"PointLight (점광원)","level":3,"id":"PointLight_(점광원)_0"},{"heading":"SpotLight (스포트라이트)","level":3,"id":"SpotLight_(스포트라이트)_0"},{"heading":"4. 3D 좌표계 이해","level":2,"id":"4._3D_좌표계_이해_0"},{"heading":"좌표계 이해하기","level":3,"id":"좌표계_이해하기_0"},{"heading":"회전과 오른손 법칙","level":3,"id":"회전과_오른손_법칙_0"},{"heading":"5. 실제 적용 예시 (골프공 시뮬레이터)","level":2,"id":"5._실제_적용_예시_(골프공_시뮬레이터)_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"qt/qt-quick-3d-기본-개념-정리.html","pathToRoot":"..","attachments":[],"createdTime":1743691206980,"modifiedTime":1743691206980,"sourceSize":5503,"sourcePath":"Qt/Qt Quick 3D - 기본 개념 정리.md","exportPath":"qt/qt-quick-3d-기본-개념-정리.html","showInTree":true,"treeOrder":391,"backlinks":[],"type":"markdown"},"qt/자주-사용하는-단축키.html":{"title":"자주 사용하는 단축키","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"qt/자주-사용하는-단축키.html","pathToRoot":"..","attachments":[],"createdTime":1748530578248,"modifiedTime":1748530578248,"sourceSize":1431,"sourcePath":"Qt/자주 사용하는 단축키.md","exportPath":"qt/자주-사용하는-단축키.html","showInTree":true,"treeOrder":392,"backlinks":[],"type":"markdown"},"robotics/ros-2-핵심-통신-개념.html":{"title":"ROS 2 핵심 통신 개념","icon":"","description":"ROS 2(Robot Operating System 2)는 로봇 소프트웨어 개발을 위한 프레임워크로, 분산 시스템을 효율적으로 구축할 수 있게 해준다. ROS 2 Humble의 핵심 통신 개념과 관련 명령어를 정리한다.노드는 ROS의 기본 실행 단위이다. 각 노드는 특정 기능을 수행하는 독립적인 프로세스로, 다른 노드들과 통신하며 전체 시스템을 구성한다.\n독립적으로 실행되는 프로세스임\n단일 목적을 가지는 모듈화된 코드임\n다른 노드와 토픽, 서비스, 액션을 통해 통신함\nrclcpp(C++) 또는 rclpy(Python) 라이브러리로 구현함\n# 실행 중인 모든 노드 목록 표시\nros2 node list # 특정 노드에 대한 정보 표시\nros2 node info /노드_이름 # 노드 실행\nros2 run 패키지_이름 실행_파일\n토픽은 노드 간 비동기식 단방향 통신을 위한 메커니즘이다. 발행자(Publisher)와 구독자(Subscriber) 모델을 사용한다.\n지속적인 데이터 스트림에 적합함\n일대다(one-to-many) 통신 지원함\n비동기적으로 작동하여 발행자는 구독자의 존재 여부에 관계없이 메시지를 보낼 수 있음\n센서 데이터, 로봇 상태 등 지속적인 정보 공유에 주로 사용함\n# 모든 토픽 목록 표시\nros2 topic list # 토픽과 그 메시지 타입 함께 표시\nros2 topic list -t # 특정 토픽에 대한 정보 표시\nros2 topic info /토픽_이름 # 토픽에 발행되는 메시지 실시간 출력\nros2 topic echo /토픽_이름 # 토픽에 메시지 발행\nros2 topic pub /토픽_이름 메시지_타입 메시지_내용 # 토픽의 발행 주기 측정\nros2 topic hz /토픽_이름\n서비스는 동기식 요청-응답 통신 방식이다. 클라이언트-서버 모델을 사용하며, 클라이언트가 요청하면 서버가 응답한다.\n일회성 작업에 적합함\n요청이 완료될 때까지 클라이언트는 대기함\n동기적으로 작동하여 응답을 받을 때까지 블로킹됨\n상태 쿼리, 파라미터 설정, 간단한 계산 등에 사용함\n# 사용 가능한 모든 서비스 목록 표시\nros2 service list # 서비스와 타입 함께 표시\nros2 service list -t # 서비스의 타입 표시\nros2 service type /서비스_이름 # 특정 타입의 서비스 찾기\nros2 service find 서비스_타입 # 서비스 호출\nros2 service call /서비스_이름 서비스_타입 요청_내용\n액션은 장기 실행 작업을 위한 고수준 통신 방식이다. 목표(Goal), 피드백(Feedback), 결과(Result)의 세 가지 통신 채널을 사용한다.\n취소 가능한 장기 실행 작업에 적합함\n실행 중 상태 피드백을 제공할 수 있음\n비동기적으로 작동하여 클라이언트가 다른 작업을 계속할 수 있음\n로봇 내비게이션, 물체 조작 등 복잡한 작업에 사용함\n# 모든 액션 목록 표시\nros2 action list # 액션과 타입 함께 표시\nros2 action list -t # 특정 액션에 대한 정보 표시\nros2 action info /액션_이름 # 액션 목표 전송\nros2 action send_goal /액션_이름 액션_타입 목표_내용\nROS 2의 통신 메커니즘은 각기 다른 용도에 최적화되어 있다.\n노드: 모듈화된 기능 단위\n토픽: 지속적인 데이터 스트림에 적합한 비동기 통신\n서비스: 일회성 요청-응답에 적합한 동기 통신\n액션: 피드백이 필요한 장기 실행 작업에 적합한 비동기 통신\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 노드(Node)","level":2,"id":"1._노드(Node)_0"},{"heading":"특징","level":3,"id":"특징_0"},{"heading":"관련 명령어","level":3,"id":"관련_명령어_0"},{"heading":"2. 토픽(Topic)","level":2,"id":"2._토픽(Topic)_0"},{"heading":"특징","level":3,"id":"특징_1"},{"heading":"관련 명령어","level":3,"id":"관련_명령어_1"},{"heading":"3. 서비스(Service)","level":2,"id":"3._서비스(Service)_0"},{"heading":"특징","level":3,"id":"특징_2"},{"heading":"관련 명령어","level":3,"id":"관련_명령어_2"},{"heading":"4. 액션(Action)","level":2,"id":"4._액션(Action)_0"},{"heading":"특징","level":3,"id":"특징_3"},{"heading":"관련 명령어","level":3,"id":"관련_명령어_3"},{"heading":"정리","level":2,"id":"정리_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"robotics/ros-2-핵심-통신-개념.html","pathToRoot":"..","attachments":[],"createdTime":1748530578256,"modifiedTime":1748530578256,"sourceSize":3807,"sourcePath":"robotics/ROS 2 핵심 통신 개념.md","exportPath":"robotics/ros-2-핵심-통신-개념.html","showInTree":true,"treeOrder":394,"backlinks":[],"type":"markdown"},"robotics/ros2-명령어.html":{"title":"ros2 명령어","icon":"","description":"ros2 run [패키지_이름] [노드_이름]ros2 run rqt_grqph rqt_graph$ ros2 node list # 현재 실행중인 노드\n$ ros2 node info {/turtlesim} # 노드 정보 확인\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"기본 구성","level":4,"id":"기본_구성_0"},{"heading":"rpg_graph 열기","level":4,"id":"rpg_graph_열기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"robotics/ros2-명령어.html","pathToRoot":"..","attachments":[],"createdTime":1741189701478,"modifiedTime":1741189701478,"sourceSize":228,"sourcePath":"robotics/ros2 명령어.md","exportPath":"robotics/ros2-명령어.html","showInTree":true,"treeOrder":395,"backlinks":[],"type":"markdown"},"rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html":{"title":"asdf를 이용한 Rust 설치와 IntelliJ가 Path를 못 찾는 이슈 및 해결","icon":"","description":"Rust를 공부하기 위해서는 Rust를 설치해야 합니다. 저는 개발도구나, 환경은 asdf를 이용합니다. asdf는 도구 버전 관리자입니다. 플러그인을 통해서 정말 많은 것들을 가상환경으로 구성할 수 있게 도와줘요 python, node, jdk 등 우리가 사용하는 거의 대부분을 지원하고 있습니다. Rust 역시 지원하기 때문에 asdf를 사용해서 설치하도록 하겠습니다.asdf가 더 알고 싶으신 분은 공식 홈페이지를 참고해주세요.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://asdf-vm.com/guide/introduction.html\" target=\"_self\">https://asdf-vm.com/guide/introduction.html</a># 러스트 플러그인을 먼저 설치합니다.\n$ asdf plugin add rust # 설치 가능한 러스트 버전을 확인합니다.\n$ asdf list all rust # 자기에게 알맞은 버전을 설치해주세요.\n# 러스트 공홈 release 버전을 확인해서 받으셔도 될 것 같습니다.\n# https://www.rust-lang.org/\n$ asdf install rust 1.67.1 # 설치된 러스트 버전을 확인합니다.\n$ asdf list rust # global 또는 local을 이용해서 환경을 적용합니다.\n$ asdf global rust 1.67.1\n그러고 나서 버전을 확인합니다.$ rustc --version\n$ cargo --version\ncargo는 러스트 프로젝트를 관리하는 빌드시스템 및 패키지 매니지입니다. 여기까지 하면 러스트 설치가 끝났습니다.저는 개발을 좀 더 편하게 하기 위해서 IDE를 사용하는데요. IntelliJ를 사용하고 있습니다. IntelliJ에 러스트 플러그인을 설치만 하면 바로 사용할 수 있습니다. (CLion도 같은 방식으로 플러그인을 추가할 수 있습니다.) 그런데, asdf를 사용해서 그런가 IntelliJ가 프로젝트를 생성할 때, rust를 찾지 못하는 것 같아요. 이를 어떻게 해결했는지 쓰겠습니다.&nbsp;1. Plugins에서 Rust 검색 후 다운로드<br><img src=\"https://blog.kakaocdn.net/dn/l1BXk/btsbQRluIcE/gKu7klUAuMUvwEKUzNyiIk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">&nbsp;2.&nbsp; Toolchain location을 바로 찾을 수 없음.\nasdf로 설정한 러스트 경로를 찾지 못해서, 아래 스크린샷 왼쪽처럼, 프로젝트를 만들 수 없습니다. 이 경로를 직접 설정하면 되지 않을까 해서, bin이 있는 곳을 찾아서, 경로를 넣었습니다. 그러면 아래 스크린샷 오른쪽처럼, 정상적으로 작동합니다. 하지만 매번 프로젝트마다, 직접 경로를 찾아서 넣어주는 것은 불편합니다. 이것은 어떻게 해결할 수 있을까요?$ cd ~/.asdf/installs/rust/1.67.1/toolchains/1.67.1-aarch64-apple-darwin/bin\npwd # pwd에 나온 결과를 붙여 넣기\n# 예시\n#/Users/psychehose/.asdf/installs/rust/1.67.1/toolchains/1.67.1-aarch64-apple-darwin/bin\n<br><img src=\"https://blog.kakaocdn.net/dn/b7tjcf/btsbSK6Uj6N/tk3lzlsDrgkaXmrPl5F0n0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/uvzmo/btsbSfGaREc/vKJt2xgIqDD7eyDMiV0WlK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">&nbsp;3. Tool-chain location 디폴트 설정 바꾸기저는 이것을 asdf-shims와 IntelliJ 기본 설정을 바꿔서 해결했습니다.&nbsp;\n(IntelliJ의) Preference -&gt; Languages &amp; Frameworks -&gt; Rust\n<br><img src=\"https://blog.kakaocdn.net/dn/bkUIU0/btsbSgd77OO/oiBzpVLOCvck39evdMPYe0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">&nbsp;그러면 항상 새로운 프로젝트에 들어갔을 때,&nbsp; 기본설정으로 들어가 있게 됩니다. 이제 IntelliJ로 러스트 프로젝트를 시작할 수 있게 되었어요.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/intellij-rust/intellij-rust/issues/5315\" target=\"_self\">https://github.com/intellij-rust/intellij-rust/issues/5315</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"asdf","level":3,"id":"asdf_0"},{"heading":"Rust 설치","level":3,"id":"Rust_설치_0"},{"heading":"IntelliJ에서 Rust 사용하기 그리고 asdf 사용 시에 IntelliJ가 Path를 못 찾는 이슈","level":3,"id":"IntelliJ에서_Rust_사용하기_그리고_asdf_사용_시에_IntelliJ가_Path를_못_찾는_이슈_0"},{"heading":"Ref.","level":3,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/l1BXk/btsbQRluIcE/gKu7klUAuMUvwEKUzNyiIk/img.png","fullURL":"rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html","pathToRoot":"..","attachments":[],"createdTime":1735623775678,"modifiedTime":1735623798130,"sourceSize":3672,"sourcePath":"rust/asdf를 이용한 Rust 설치와 IntelliJ가 Path를 못 찾는 이슈 및 해결.md","exportPath":"rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html","showInTree":true,"treeOrder":397,"backlinks":[],"type":"markdown"},"rust/cargo.html":{"title":"Cargo","icon":"","description":"Cargo는 러스트 프로젝트에서 아주 중요한 것 같습니다. 러스트를 시작한 지 며칠 안되었기 때문에 Cargo에 대해 아는 게 몇 개 없습니다. 러스트 기본 공부가 끝나는 대로 러스트를 사용해서 작은 사이드 프로젝트를 할 예정입니다. 아마 그때 Cargo에 대해서 공부할 것 같아요. 그때 내용 보충을 더 해서 업데이트하겠습니다.Cargo는&nbsp; 러스트의 빌드 시스템 및 패키지 매니저로 프로젝트를 관리합니다. 좀 더 상세하게 풀어서 이야기하면 Cargo가 코드를 우리가 작성한 코드를 빌드하면서, 코드가 의존하고 있는 라이브러리들도 다운로드하고 빌드합니다. Cargo의 버전확인은 아래 명령어를 터미널에 입력하면 확인할 수 있습니다.$ cargo --version\nCargo의 환경 설정은 Cargo.toml을 확인하면 알 수 있어요.&nbsp;# Cargo.toml [package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"] [dependencies]\n[package]는 패키지 환경 설정이라는 섹션의 시작지점입니다. 여기에 정보를 추가할 수 있고, 수정할 수 있습니다.[dependency]는 프로젝트의 의존성들의 리스트를 적을 수 있는 섹션의 시작점입니다. 러스트에서는 코드의 패키지를 크레이트(crate)라고 부르는데, 여기에 크레이트를 추가하면 해당 코드를 사용할 수 있게 됩니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Cargo란 무엇인가","level":3,"id":"Cargo란_무엇인가_0"},{"heading":"Cargo.toml","level":3,"id":"Cargo.toml_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"rust/cargo.html","pathToRoot":"..","attachments":[],"createdTime":1735623817216,"modifiedTime":1735623822420,"sourceSize":1533,"sourcePath":"rust/Cargo.md","exportPath":"rust/cargo.html","showInTree":true,"treeOrder":398,"backlinks":[],"type":"markdown"},"rust/rust-기초-control,-연습-문제.html":{"title":"Rust 기초 - Control, 연습 문제","icon":"","description":"&nbsp;조건의 상태가 참인지에 따라 어떤 코드의 실행 여부를 결정하거나 조건이 만족되는 동안 반복 수행을 하는 것은 대부분의 프로그래밍 언어의 기초 문법입니다. 대다수의 언어처럼 if, for, while을 러스트에서도 사용합니다.fn main() { let number = 6; if number % 4 == 0 { println!(\"number is divisible by 4\"); } else if number % 3 == 0 { println!(\"number is divisible by 3\"); } else if number % 2 == 0 { println!(\"number is divisible by 2\"); } else { println!(\"number is not divisible by 4, 3, or 2\"); }\n}\nif 뒤에 오는 코드의 조건은 반드시 boolean 타입이어야 합니다. 러스트에서 많은 else if가 많으면 ‘match’를 이용하길 권합니다. match 키워드는 나중에! 포스팅하겠습니다.또 let 구문을 if, else를 이용해서 사용할 수 있습니다. 만약 다음과 같이 let 구문에서 if 블록을 사용하려면, if 블록과 else 블록은 같은 타입을 반환해야 합니다.fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {}\", number);\n}\n아래의 코드는 에러를 발생시킵니다. 이유는 변수가 가질 수 있는 타입이 오직 하나이기 때문이에요. 러스트는 컴파일 시에 변수의 타입이 뭔지 확실하게 정의해야 합니다. 그래야 number가 사용되는 모든 곳에서 유효한지 검증할 수 있으니까요. 즉, number의 타입을 런타임에 정의할 수 없습니다. 이는 컴파일러가 보증할 수 있는 것을 많이 가져가고 복잡해지는 것을 방지하기 위함입니다.fn main() { let condition = true; let number = if condition { 5 } else { \"six\" }; println!(\"The value of number is: {}\", number);\n}\n&nbsp;러스트가 제공하는 반복문은 loop, while, for가 있습니다.loop&nbsp;loop는 무한루프를 생성합니다. loop를 탈출하기 위해서는 if break와 같이 탈출 코드를 작성하면 됩니다.fn main() { loop { println!(\"again!\"); }\n}\nwhile&nbsp;while은 대다수의 언어에 존재하는 while과 같습니다. 조건이 true인 동안 코드가 실행되고, 그렇지 않으면 루프에서 탈출합니다. while을 사용하게 되면 loop, if, else와 break를 사용할 때 발생하는 {&nbsp; }를 줄일 수 있기 때문에, 더 깔끔해요.&nbsp;for&nbsp;역시 while과 마찬가지로 많이 익숙한 for입니다. for문은 while과 다르게, 조건 검사를 수행하는 코드가 없기 때문에 while보다 더 빠르고 안전합니다. for in 문법을 사용합니다.fn main() { let a = [10, 20, 30, 40, 50]; //\t그냥 for element in a { } 도 가능 for element in a.iter() { println!(\"the value is: {}\", element); }\n}\nfor 반복문이 안전하고 간결하기 때문에 러스트에서 가장 보편적으로 사용한다고 하네요. 정확히 몇 번 반복을 해야 하는 경우에도, 기본 라이브러리로 제공하는 Range를 사용합니다. Range는 한 숫자에서 다른 숫자 전까지 모든 숫자를 차례로 생성합니다.fn main() { for number in (1..4).rev() { println!(\"{}!\", number); } println!(\"LIFTOFF!!!\");\n}\n연습 문제를 한번 풀어보도록 하겠습니다.\n화씨와 섭씨를 상호 변환.\nn번째 피보나치수열 생성.\n크리스마스 캐롤 “The Twelve Days of Christmas”의 가사를 반복문을 활용해 출력.\nfn main() { println!(\"섭씨: {} -&gt; 화씨: {}\", 0, c_to_f(0.0)); println!(\"화씨: {} -&gt; 섭씨: {}\", 32.0, f_to_c(32.0)); let n = 7; println!(\"{}번째 피보나칠 수열의 값 = {}\", n, fibo(n)); let string = \"The Twelve Days of Christmas\"; for c in string.chars() { print!(\"{}\", c); } println!(); for i in string.char_indices() { print!(\"{}\", string.chars().nth(i.0).unwrap()); } println!(); for i in string.char_indices() { print!(\"{}\", i.1); } } fn c_to_f(c: f64) -&gt; f64 { (9.0/5.0) * c + 32.0\n} fn f_to_c(f: f64) -&gt; f64 { (f - 32.0) * (5.0/9.0)\n} fn fibo(n: i32) -&gt; i32 { if n &lt;= 2 { 1 } else { fibo(n-1) + fibo(n-2) }\n} /* 1. 화씨와 섭씨를 상호 변환. -&gt; // 배운것: f64로 타입 맞춰줄 것 f to c -&gt; (x°F − 32) × 5/9 c = (f - 32) (5/9) c to f -&gt; f = (9/5)c + 32 2. n번째 피보나치 수열 생성. 3. 크리스마스 캐롤 “The Twelve Days of Christmas”의 가사를 반복문을 활용해 출력. // 배운것: nth(x), .chars() string 인스턴스 함수\n.chars() -&gt; 요소 값\n.char_indices() -&gt; index랑 요소\n.nth() -&gt; n번째 요소 출력(에러 가능성이 있으므로, unwrap()을 사용하거나, expect를 이용해서 에러 핸들 해야함) */\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/rust_basic_problem\" target=\"_self\">https://github.com/psychehose/rust_basic_problem</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"제어문","level":3,"id":"제어문_0"},{"heading":"반복문과 반복","level":3,"id":"반복문과_반복_0"},{"heading":"Github","level":4,"id":"Github_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"rust/rust-기초-control,-연습-문제.html","pathToRoot":"..","attachments":[],"createdTime":1735623896644,"modifiedTime":1735623917039,"sourceSize":5206,"sourcePath":"rust/Rust 기초 - Control, 연습 문제.md","exportPath":"rust/rust-기초-control,-연습-문제.html","showInTree":true,"treeOrder":399,"backlinks":[],"type":"markdown"},"rust/rust-기초-data-type.html":{"title":"Rust 기초 - Data Type","icon":"","description":"true와 false를 다루는 값입니다.fn main() { let t = true; let f: bool = false; // with explicit type annotation\n}\n&nbsp;char는 string과 다르게 ‘ ‘ 를 사용합니다. 그리고 러스트에서는 Unicode 스칼라를 표현하는 값입니다. Unicode는 ASCII 보다 많은 표현이 가능합니다. 예를 들면 이모티콘, 한글을 표현할 수 있습니다.fn main() { let c = 'z'; let z = 'ℤ'; let heart_eyed_cat = '😻';\n}\n컴파운드 타입은 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있습니다. Rust는 기본적으로 튜플과 배열이 있습니다.&nbsp;튜플은 일반적으로 다양한 타입의 숫자를 집합시켜서 컴파운드 타입으로 만듭니다. 괄호 안에 콤마로 구분되는 값들의 목록을 작성하면 됩니다. 각 값의 타입이 동일한 필요가 없습니다. 저는 보통 좌표를 표현할 때 사용하는 것 같아요.fn main() { let tup = (500, 6.4, 1); let five_hundred = tup.1 let (x, y, z) = tup; println!(\"The value of y is: {}\", y);\n}\n위의 코드에서 let (x, y, z) = tup 처럼 값을 분리해서 할당할 수 있습니다. 이를 구조 해체 (destructurize)라고 합니다. 다른 언어들도 많이 가지고 있는 특징입니다. (Swift, JavaScript 등등)또는 let five_hundred = tup.1처럼 tup에서 마침표(.)를 이용해서 튜플의 요소에 직접 접근할 수 있습니다.튜플과 다르게 배열의 모든 요소는 같은 타입이여야 합니다.다른 언어랑 구별되는 특징이 있습니다. Rust에서 배열은 고정된 길이를 가진다는 것입니다. 한번 선언되면 크기는 변할 수 없습니다. c처럼 동적 할당하는 것이 아니라, 아예 길이가 정해져야만 합니다.fn main() { let a = [1, 2, 3, 4, 5]; let index = 3 // let index = 10; let element = a[index]; println!(\"The value of element is: {}\", element);\n}\n배열의 끝을 넘어선 요소에 접근하려고 하면 컴파일시에 에러를 발생시키진 않지만, 런타임 때 에러가 발생합니다. 이때 런타임에러가 발생하면서 프로그램이 종료될 때 패닉(panic) 한다고 합니다. 그렇기 때문에 배열은 heap 보다 stack에 할당될 때 즉, 고정된 길이를 보장해야 할 때 사용됩니다. 만약 길이가 가변적이라면 표준 라이브러리에서 제공하는 Vector 타입을 사용해야 한다고 합니다.\n스칼라 - 하나의 값으로 표현되는 타입 정수형\n- u:&nbsp; 양수\n- i: 음수, 양수\n- isize, usize:&nbsp; 프로그램 동작하는 환경에 따라 64bit, 32bit\n- 기본 타입: i32 부동소수점 - 기본타입 f64 boolean 문자 - 유니코드, 작은 따옴표로 표현 컴파운드 튜플 - 집합, 구조 해체 배열 - 고정된 길이 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"boolean 타입","level":4,"id":"boolean_타입_0"},{"heading":"문자 타입","level":4,"id":"문자_타입_0"},{"heading":"컴파운드 타입","level":3,"id":"컴파운드_타입_0"},{"heading":"튜플","level":4,"id":"튜플_0"},{"heading":"배열","level":4,"id":"배열_0"},{"heading":"정리","level":4,"id":"정리_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"rust/rust-기초-data-type.html","pathToRoot":"..","attachments":[],"createdTime":1735623842533,"modifiedTime":1735623866268,"sourceSize":3126,"sourcePath":"rust/Rust 기초 - Data Type.md","exportPath":"rust/rust-기초-data-type.html","showInTree":true,"treeOrder":400,"backlinks":[],"type":"markdown"},"rust/rust-기초-function.html":{"title":"Rust 기초 - Function","icon":"","description":"러스트에서 함수 선언은 fn 키워드를 이용합니다.fn main() { another_function(5);\n} fn another_function(x: i32) { println!(\"The value of x is: {}\", x);\n}\n&nbsp;위처럼 같은 파일 내에서, 함수의 위치는 중요하지 않습니다. 역시 다른 언어와 마찬가지로 매개변수를 갖는 형식으로 상수를 전달 인자로 제공합니다. 이때 매개변수의 타입을 꼭 명시해줘야 합니다.&nbsp;다른 함수와 다르게 함수 본문은&nbsp;구문과&nbsp;표현식으로 구성될 수 있어요. 구문은 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행을 합니다.표현식은 결과 값을 산출해 냅니다.&nbsp;표현식은 구문의 부분일 수 있습니다. 함수를 호출하는 것은 표현식, 매크로를 호출하는 것도 표현식, 새로운 범위를 생성하는 데 사용하는 { } 도 표현식입니다.&nbsp;쉽게 생각하면 값을 반환하면 ;을 안붙여야합니다. 뭔가 좀 헷갈립니다. 예를 보고 한번 뜯어볼게요.fn main() { let x = 5; let y = { let x = 3; x + 1 }; // 표현식 // { // let x = 3 // x+1 //\t} println!(\"The value of y is: {}\", y); let y = five();\n} fn five() -&gt; i32 { 5\n}\n'let x = 5;' 이 부분이&nbsp;표현식은 구문의 부분이 될 수 있다의 예입니다.&nbsp; 전체적으로 봤을 때 let x = 3은 어떠한 값을 리턴하지 않기 때문에 구문입니다. 그러나, '3'인 부분은 어떠한 값을 반환하기 때문에 표현식입니다. 그래서 전체적으로 봤을 때 ;이 붙어 있어야 합니다. 이제 같은 맥락에서 주석처리한 {&nbsp; } 블록이 왜 표현식인지, 그리고 블록이 끝난 후에 세미콜론을 붙는지 이해할 수 있을 것 같아요.반환값 설정은 five()와 같이 매개변수 오른쪽에 ‘ → i32 ‘ 처럼 작성하면 됩니다. '→(반환타입)'five() 함수를 보면 조금 특징적인 것이 있습니다. 값을 반환할 때, return 키워드가 없습니다. return을 사용해서 함수로부터 값을 일찍 반환 할 수 있지만 대부분의 함수들은 암묵적으로 마지막 값을 반환합니다. 사실 Swift도 return을 생략할 수 있어요. 근데 가독성 때문에 잘 안 하는 것 같은데, 러스트에서는 return을 생략하나 봐요. 다음으로 함수의 반환 값에 ; 세미콜론이 붙지 않습니다. 위에서 언급한 것처럼 5라는 값을 반환하기 때문에 표현식이기 때문이에요. 따라서 ;이 없어야 합니다. 만약 반환값에 ;을 붙이면 아래와 같은 에러를 출력합니다.\nerror[E0308]: mismatched types\n함수 선언에서 i32 값을 반환한다고 했는데, 구문은 값을 반환하지 않기 때문에 ()라는 비어 있는 튜플을 반환하기 때문에&nbsp;mismatched 에러가 발생하게 됩니다.<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://rinthel.github.io/rust-lang-book-ko/ch03-03-how-functions-work.html\" target=\"_self\">https://rinthel.github.io/rust-lang-book-ko/ch03-03-how-functions-work.html</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"함수 본문","level":4,"id":"함수_본문_0"},{"heading":"Ref.","level":4,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"","fullURL":"rust/rust-기초-function.html","pathToRoot":"..","attachments":[],"createdTime":1735623877030,"modifiedTime":1735623892347,"sourceSize":3155,"sourcePath":"rust/Rust 기초 - Function.md","exportPath":"rust/rust-기초-function.html","showInTree":true,"treeOrder":401,"backlinks":[],"type":"markdown"},"rust/rust-기초-variable.html":{"title":"Rust 기초 - Variable","icon":"","description":"&nbsp;러스트는 다른 언어와 다르게 기본적으로 Immutable(불변)입니다. 이것은 안전성과 동시성이라는 장점을 얻을 수 있도록 코드를 강제하는 요소 중 하나라고 합니다.&nbsp;fn main() { let x = 5; println!(\"The value of x is: {}\", x); x = 6; println!(\"The value of x is: {}\", x);\n}\n위처럼 작성하게 되면 immutable variable에 값을 재할당할 수 없다는 에러메시지를 출력합니다.\nerror[E0384]: re-assignment of immutable variable x\n만약 mutable 하게 사용하고 싶으면 ‘mut’ keyword를 사용하면 됩니다.fn main() { let mut x = 5; println!(\"The value of x is: {}\", x); x = 6; println!(\"The value of x is: {}\", x);\n}\n&nbsp;Rust에서 이런 정책을 채택한 이유는 컴파일러가 변경되지 않은 값에 대해서 보증을 하기 때문에, 버그 예방에 효율적입니다.하지만 mut 키워드를 사용하는 것이 효율적인 경우가 있습니다. 예를 들면 대규모 데이터 구조체를 다루는 경우입니다. 기존의 인스턴스를 변경하는 것이 새로 인스턴스를 만들고 값을 사용하는 것보다 더 효율적이기 때문입니다. trade - off를 잘 고려해서 코드를 작성하면 될 것 같습니다.상수는 mut을 사용하는 것이 허용되지 않고 불변 그 자체입니다. 상수 선언할 때는 타입을 무조건 지정해줘야 합니다.const MAX_POINTS: u32 = 100_000;\n&nbsp;러스트는 shadowing을 허용합니다. 같은 이름의 변수를 선언하면 기존의 값은 가려지게 됩니다.fn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\"The value of x is: {}\", x);\n}\nmut과 차이점은 새 변수를 선언하고, 값의 유형을 변경하면서도 같은 이름을 사용할 수 있다는 것이 장점입니다.let spaces = \" \";\nlet spaces = spaces.len(); // mut 사용시에 이것은 타입을 변경했기 때문에\n// 에러를 발생시킵니다. let mut spaces = \" \";\nspaces = spaces.len();\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://rinthel.github.io/rust-lang-book-ko/ch03-01-variables-and-mutability.html\" target=\"_self\">https://rinthel.github.io/rust-lang-book-ko/ch03-01-variables-and-mutability.html</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Immutable, Mutable","level":4,"id":"Immutable,_Mutable_0"},{"heading":"Constant (상수)","level":4,"id":"Constant_(상수)_0"},{"heading":"Shadowing","level":4,"id":"Shadowing_0"},{"heading":"Ref.","level":3,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"","fullURL":"rust/rust-기초-variable.html","pathToRoot":"..","attachments":[],"createdTime":1735623825170,"modifiedTime":1735623841631,"sourceSize":2351,"sourcePath":"rust/Rust 기초 - Variable.md","exportPath":"rust/rust-기초-variable.html","showInTree":true,"treeOrder":402,"backlinks":[],"type":"markdown"},"rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html":{"title":"Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵)","icon":"","description":"컬렉션은 내장된 배열과 튜플 타입과는 다르게 힙에 저장됩니다. 이것은 데이터량이 런타임에서 변경될 수 있다는 뜻입니다. 러스트 표준 라이브러리가 제공하는 컬렉션은 다음과 같습니다.\nsequence 타입: Vec, VecDeque, LinkedList\nmap 타입: HashMap, BTreeMap\nSets 타입: HashSet, BTreeSet\nMisc 타입: BinaryHeap\n그중에서 자주 사용되는 세 가지 컬렉션을 알아보겠습니다.\nVec는 여러 개의 값을 서로 붙어 있게 저장합니다.\nString은 문자의 모음입니다.\nHashMap은 키-값으로 저장합니다.\nlet v: Vec&lt;i32&gt; = Vec::new();\n벡터는 제네릭을 이용해서 구현되어있습니다. 그래서 어떠한 종류의 값도 저장할 수 있습니다.let v = vec![1,2,3];\nlet v = Vec::from([1,2,3,4]);\nlet v = vec![0; 5]; // [0,0,0,0,0]\n초기값이 있는 벡터를 생성하는 것은 흔한 일이기 때문에 러스트에서는 vec! 매크로를 제공하고 있습니다. Vec의 static method인 from을 이용해서도 배열을 생성할 수 있습니다. 길이가 n인 배열을 생성하고 0으로 초기화할 수 있습니다.let mut v = Vec:new();\nv.push(5);\nv.push(6);\nv.push(7);\nv.pop();\nv.pop(); // insert(index, value)\n// remove(index)\nv.insert(1,4)\nv.remove(1) // let mut vec = vec![1, 2, 3];\nlet mut vec2 = vec![4, 5, 6];\nvec.append(&amp;mut vec2);\nassert_eq!(vec, [1, 2, 3, 4, 5, 6]);\nassert_eq!(vec2, []);\n컬렉션 변수에 대해서 그 변수가 담고 있는 값이 변경되게 하려면 mut 키워드를 사용합니다. push &amp; pop을 사용해서 벡터 값을 자료구조 스택처럼 사용할 수 있습니다.특정한 인덱스에 값을 넣고 빼기 위해서는 insert &amp; remove를 사용하면 됩니다. Insert &amp; remove는 인덱스를 직접 사용하기 때문에 인덱스 범위를 넘어가면 패닉을 일으키게 됩니다.배열과 배열의 연산에는 append를 이용합니다. 특이한 점이 append를 하게 되면 추가 하는 항목들이 있는 배열에서 요소들이 사라집니다.let v = vec![1, 2, 3, 4, 5]; let third: i32 = v[2];\nlet third: Option&lt;&amp;i32&gt; = v.get(2);\n벡터 요소를 읽기 위해서는 []과 get 함수를 이용하는 방법입니다. []를 이용하는 경우 존재하지 않는 요소를 참조하게 되면 패닉을 일으키게 되겠죠?get 함수를 사용하면 벡터 범위를 벗어난 인덱스를 사용하면 퍄닉 없이 None이 반환됩니다.let v = vec![100, 32, 57];\nfor i in &amp;v { println!(\"{}\", i);\n} /// let mut v = vec![100, 32, 57];\nfor i in &amp;mut v { *i += 50;\n}\n인덱스를 명시하지 않아도, Swift나 Python처럼 반복문을 돌면서 요소에 접근할 수 있습니다. 요소들을 변경시키길 원한다면 역참조연산자(*)를 사용하면 됩니다.String은 문자들의 모음입니다. 러스트에서 스트링은 세 가지 특징적인 개념을 가집니다.\n에러를 꼭 명시해줘야 합니다.\n복잡한 데이터 구조를 가지고 있습니다.&nbsp;\nUTF-8이라는 점입니다.\nlet mut s = String::new();\n// let data = \"initial contents\";\nlet s = data.to_string(); // the method also works on a literal directly:\nlet s = \"initial contents\".to_string(); let s = String::from(\"initial contents\");\n스트링 생성은 String 타입의 new() 정적 메소드를 이용해서 할 수 있습니다. 그리고 스트링 리터럴(&amp;str)을 생성하고. to_string() 메서드를 이용해서 생성할 수도 있습니다.let mut s = String::from(\"foo\");\ns.push_str(\"bar\"); let mut s1 = String::from(\"foo\");\nlet s2 = \"bar\"; // 참조자를 사용하기 때문에 소유권을 넘기지 않음.\ns1.push_str(&amp;s2);\nprintln!(\"s2 is {}\", s2);\n스트링에 스트링을 추가하기 위해서 push_str 메소드를 사용할 수 있습니다.&nbsp; 문자 한 개를 추가하길 원하면 push() 메서드를 사용할 수 있습니다.&nbsp;let s1 = String::from(\"Hello, \");\nlet s2 = String::from(\"world!\");\nlet s3 = s1 + &amp;s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요 연산자를 이용해서 문자열끼리 접합할 수 있습니다. 위의 코드를 보면 let s3 = s1 + &amp;s2; 입니다. s1에는 참조자가 붙지 않고 s2에 참조자가 붙어 있는 것을 볼 수 있는데요. 이것은 스트링에서 + 연산자는 add 메서드를 이용하기 때문입니다.\nfn add(self, s: &amp;str) -&gt; String {\nadd()를 자세하게 보고 s3의 코드를 보면 조금 당황할 수도 있습니다. 왜냐하면, add의 파라미터는 &amp;str 타입인데 &amp;s2의 타입은 &amp;String이기 때문입니다. 하지만 컴파일러는 이를 컴파일 할 수 있습니다. 왜 그럴까요? &amp;String인자는 &amp;str로 강제될 수 있기 때문입니다. 이를 러스트에서는 역참조 강제(deref coercion)라고 합니다.위에서 보듯 +의 동작은 다루기가 불편한 것처럼 보입니다. 어떤 것은 String이고, 붙여지는 건 &amp;str인 것처럼요. 왜냐하면 이는 소유권에 대해서 더 신경을 써야한다는 것을 의미하니까요. 그래서 러스트는 format! 매크로를 제공합니다. 이를 이용하면 어떠한 파라미터의 소유권도 가져오지 않고 보기 쉽게 스트링을 합칠 수 있습니다.&nbsp;let s1 = String::from(\"tic\");\nlet s2 = String::from(\"tac\");\nlet s3 = String::from(\"toe\"); let s = s1 + \"-\" + &amp;s2 + \"-\" + &amp;s3;\n// let s1 = String::from(\"tic\");\nlet s2 = String::from(\"tac\");\nlet s3 = String::from(\"toe\"); let s = format!(\"{}-{}-{}\", s1, s2, s3);\nlet s1 = String::from(\"hello\");\nlet h = s1[0];\n다른 언어처럼 스트링에 인덱스로 접근하고 싶습니다. 위의코드는 컴파일이 될까요? 접근하면 어떻게 될까요? 러스트에서 스트링 인덱스 접근은 지원하지 않습니다. 이것을 이해하기 위해서 스트링이 어떻게 메모리에 저장되는지 확인해봐야 합니다.String은 Vec을 감싼 것입니다.&nbsp;let len = String::from(\"Hola\").len(); // 1 let len = String::from(\"Здравствуйте\").len(); len은 4입니다. 이건 4byte 길이라는 뜻입니다.\nlen은 24입니다. 글자는 12개지만, 이 문자 각각의 유니코드 스칼라 값이 2입니다. 12* 2 = 24\n이 말은 스트링의 바이트들 안의 인덱스는 유니코드 스칼라 값과 항상 대응되지 않는다는 것을 의미합니다.그리고 인덱스 연산은 언제나 상수 시간에 실행될 것으로 기대를 받는데, String으로 그러한 성능을 보장하는 것은 불가능입니다. 왜냐하면 스트링 내에 얼마나 많은 문자가 있는지 알아내기 위해 시작지점부터 인덱스로 지정된 곳까지 살펴봐야 하기 때문입니다.만약 스트링 슬라이스를 만들기 위하고 인덱스를 사용하길 원한다면 구체적으로 지정해야 합니다.let hello = \"Здравствуйте\"; let s = &amp;hello[0..4]; // Зд\n// let s = &amp;hello[0..1]; // 패닉 발생!\n반복문을 돌면서 바이트에 관계 없이 유니코드 스칼라 값(글자)에 대한 연산을 하길 원하면 chars를 사용하면 됩니다.for c in \"नमस्ते\".chars() { println!(\"{}\", c);\n} for b in \"नमस्ते\".bytes() { println!(\"{}\", b);\n}\n즉 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 확실히 기억해야만 합니다.''use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50); // let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\nlet initial_scores = vec![10, 50]; let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();\n추가적으로 튜플의 벡터에 대해 collect 메서드를 사용해서 생성할 수 있습니다collect 메소드는 데이터를 모아서 컬렉션 타입으로 만들어줍니다.let field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\"); let mut map = HashMap::new();\nmap.insert(field_name, field_value);\ninsert 할 때, field_name과 field_value의 소유권은 map으로 이동합니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50); let team_name = String::from(\"Blue\");\nlet score = scores.get(&amp;team_name);\n..use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50); for (key, value) in &amp;scores { println!(\"{}: {}\", key, value);\n}\n반목문 접근은 다른 컬렉션과 마찬가지로 &amp;를 이용해서 접근할 수 있습니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25); println!(\"{:?}\", scores);\n위의 코드는 키에 대한 값이 있어도 덮었어 집니다.&nbsp;만약 키에 할당된 값이 없을 경우에만 삽입하고 싶으면 다음 entry API를 이용하면 됩니다.entry의 리턴 값은 Enum 타입 Entry인데 있는지 없는 지를 반환합니다.Entry의 or_insert 메소드는 해당 키가 존재하는 경우는 Entry 키에 대한 값을 반환하고 아닌 경우에는 새 값을 삽입하고 수정된 Entry에 대한 값을 반환합니다.se std::collections::HashMap; let mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10); scores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry(String::from(\"Blue\")).or_insert(50); println!(\"{:?}\", scores);\n이걸로 러스트의 콜렉션 타입 중 가장 자주 쓰이는 Vec, String, HashMap에 대해 알아보았습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"컬렉션","level":2,"id":"컬렉션_0"},{"heading":"Vec","level":3,"id":"Vec_0"},{"heading":"String","level":3,"id":"String_0"},{"heading":"해쉬맵","level":4,"id":"해쉬맵_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html","pathToRoot":"..","attachments":[],"createdTime":1735624011804,"modifiedTime":1735624026451,"sourceSize":10040,"sourcePath":"rust/Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵).md","exportPath":"rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html","showInTree":true,"treeOrder":403,"backlinks":[],"type":"markdown"},"tip/git.html":{"title":"Git","icon":"","description":"리모트 저장소에서 히스토리 지우기$ git rm -r --cached {path}\n$ git commit -m \"deleted\" # 현재 해시에서 삭제함.\n$ git filter-branch --force --index-filter \\\n\"git rm -r --cached --ignore-unmatch {path}\" \\\n--prune-empty --tag-name-filter cat -- --all # 리모트 저장소 히스토리에서 삭제\nreset 커밋 복구git reflog\ngit reset --hard 복구하려는커밋해시 git reset --hard 현재 작업 중인 변경사항을 모두 삭제하므로 주의하기 작업 중인 변경사항을 보존: --soft 사용하기\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"tip/git.html","pathToRoot":"..","attachments":[],"createdTime":1737289663889,"modifiedTime":1737289772479,"sourceSize":585,"sourcePath":"Tip/Git.md","exportPath":"tip/git.html","showInTree":true,"treeOrder":405,"backlinks":[],"type":"markdown"},"tip/linux-명령어.html":{"title":"Linux 명령어","icon":"","description":"sudo chmod o+x # 쓰기 권한 cd sudo chmod o+r # 읽기 권한 ls\n$ gg # 첫번째 줄로 이동\n$ dG # 현재부터 끝까지 지움\n$ dd #한줄삭제\n$ 5dd #현재위치부터 5줄 삭제 v 눌러서 visual mode 진입\n주석할 라인 선택\nnorm i# (normal mode에서 i -&gt; edit 모드 -&gt; # 삽입) 입력 v 눌러서 visual mode 진입\n주석 해제할 라인 선택\nnorm 1x (맨 앞에서 한글자 지우기) 입력\n$ tail -n {몇라인 볼 지 = 수} {log_path}\n$ ps -ef f | grep p4d\n$ ps aux | grep p4d ps -ef: 전체 형식(FULL format)으로 표시, 프로세스 간의 부모-자식 관계를 트리 구조(f 옵션)로 보여줌\nps aux: BSD 스타일 출력, CPU/메모리 사용량 등 더 자세한 리소스 정보 표시 kill -1 (SIGHUP): 프로세스 재시작\nkill -2 (SIGINT): Ctrl+C와 동일, 정상 종료 요청\nkill -9 (SIGKILL): 강제 종료, 즉시 종료\nkill -15 (SIGTERM): 기본값, 정상 종료 요청\nkill -18 (SIGCONT): 중지된 프로세스 재개\nkill -19 (SIGSTOP): 프로세스 일시 중지\nkill -20 (SIGTSTP): Ctrl+Z와 동일, 일시 중지\n권장 사용 순서:\n4. kill -15 (SIGTERM) 시도\n5. kill -2 (SIGINT) 시도\n6. 마지막 수단으로 kill -9 (SIGKILL) 사용 sed 's/^... test'//' 시작부터 ... test\" 문자열을 찾음 -&gt; 빈문자열로 치환(//)\n^ = 라인의 시작 sed \"s|$|@$changelist_number|\" s|pattern|replacement|: 여기서는 구분자로&nbsp;/&nbsp;대신&nbsp;|&nbsp;사용 (경로에&nbsp;/가 있어서)\n$: 라인의 끝을 의미\n@$changelist_number: 라인 끝에 \"@\"와 changelist 번호를 추가 sed 's/.$//' .: 아무 문자 하나를 의미\n$: 문자열의 끝을 의미\n따라서&nbsp;.$는 문자열의 마지막 문자 하나를 의미\ns/pattern//: pattern과 매칭되는 부분을 빈 문자열로 치환 (= 삭제) sed 's/..$//' 맨 마지막 문자 2개를 삭제 터미널과 출력과 파일에 입력을 동시에 할 수 있는 명령어.$ echo test | tee tee-test-file.txt\ntest\n$ cat tee-test-file.txt\ntest\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"읽기, 쓰기 권한을 다른사용자 (others)에게 부여","level":4,"id":"읽기,_쓰기_권한을_다른사용자_(others)에게_부여_0"},{"heading":"리눅스 전체 삭제 및 파일 내용 지우기","level":4,"id":"리눅스_전체_삭제_및_파일_내용_지우기_0"},{"heading":"vim 라인 주석 / 해제","level":4,"id":"vim_라인_주석_/_해제_0"},{"heading":"로그 보는 방법","level":4,"id":"로그_보는_방법_0"},{"heading":"linux 프로세스 확인","level":4,"id":"linux_프로세스_확인_0"},{"heading":"linux kill 명령어","level":4,"id":"linux_kill_명령어_0"},{"heading":"sed","level":4,"id":"sed_0"},{"heading":"tee","level":4,"id":"tee_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"tip/linux-명령어.html","pathToRoot":"..","attachments":[],"createdTime":1739539459930,"modifiedTime":1739539459931,"sourceSize":2456,"sourcePath":"Tip/Linux 명령어.md","exportPath":"tip/linux-명령어.html","showInTree":true,"treeOrder":406,"backlinks":[],"type":"markdown"},"tip/mcp-setting.html":{"title":"MCP Setting","icon":"","description":"\nFilesystem MCP Server Node.js server implementing Model Context Protocol (MCP) for filesystem operations\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem\" target=\"_self\">https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem</a> Memory A basic implementation of persistent memory using a local knowledge graph. This lets Claude remember information about the user across chats.\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/modelcontextprotocol/servers/tree/main/src/memory\" target=\"_self\">https://github.com/modelcontextprotocol/servers/tree/main/src/memory</a> obsidian-mcp An&nbsp;MCP server that enables AI assistants to interact with Obsidian vaults, providing tools for reading, creating, editing and managing notes and tags.\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/modelcontextprotocol/servers?tab=readme-ov-file\" target=\"_self\">https://github.com/modelcontextprotocol/servers?tab=readme-ov-file</a> sequential-thinking An MCP server implementation that provides a tool for dynamic and reflective problem-solving through a structured thinking process.\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/modelcontextprotocol/servers/tree/main/src/sequentialthinking\" target=\"_self\">https://github.com/modelcontextprotocol/servers/tree/main/src/sequentialthinking</a> brave-search An MCP server implementation that integrates the Brave Search API, providing both web and local search capabilities.\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search\" target=\"_self\">https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search</a> { \"mcpServers\": { \"filesystem\": { \"command\": \"npx\", \"args\": [ \"-y\", \"@modelcontextprotocol/server-filesystem\", \"{path1}\", \"{path2}\" ] }, \"memory\": { \"command\": \"npx\", \"args\": [ \"-y\", \"@modelcontextprotocol/server-memory\" ] }, \"obsidian-mcp\": { \"command\": \"npx\", \"args\": [ \"-y\", \"obsidian-mcp\", \"{path}\" ] }, \"sequential-thinking\": { \"command\": \"npx\", \"args\": [ \"-y\", \"@modelcontextprotocol/server-sequential-thinking\" ] }, \"brave-search\": { \"command\": \"npx\", \"args\": [ \"-y\", \"@smithery/cli@latest\", \"run\", \"@smithery-ai/brave-search\", \"--key\", \"{key}\" ] } }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"JSON","level":4,"id":"JSON_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"tip/mcp-setting.html","pathToRoot":"..","attachments":[],"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":1996,"sourcePath":"Tip/MCP Setting.md","exportPath":"tip/mcp-setting.html","showInTree":true,"treeOrder":407,"backlinks":[],"type":"markdown"},"tip/tip.html":{"title":"Tip","icon":"","description":"UnrealPak.exe {추출할 pak 파일 경로} -Extract {추출 되는 경로}\n현재 디렉토리와 하위 디렉토리들에서 읽기 전용이 아닌 파일을 찾는 방법Get-ChildItem -Recurse | Where-Object { !$_.PSIsContainer -and !$_.Attributes.HasFlag([System.IO.FileAttributes]::ReadOnly) } | Select-Object FullName\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Unreal Engine pak 내용물 추출","level":4,"id":"Unreal_Engine_pak_내용물_추출_0"},{"heading":"윈도우 읽기 전용 아닌 파일 찾기","level":4,"id":"윈도우_읽기_전용_아닌_파일_찾기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"tip/tip.html","pathToRoot":"..","attachments":[],"createdTime":1739539459931,"modifiedTime":1739539459931,"sourceSize":445,"sourcePath":"Tip/Tip.md","exportPath":"tip/tip.html","showInTree":true,"treeOrder":408,"backlinks":[],"type":"markdown"},"tip/vscode-clang++-설정.html":{"title":"vscode clang++ 설정","icon":"","description":"{ \"workbench.colorTheme\": \"Default Dark Modern\", \"cmake.configureOnOpen\": true, \"terminal.external.osxExec\": \"iTerm.app\", \"editor.fontSize\": 15, \"workbench.iconTheme\": \"material-icon-theme\", \"cmake.showOptionsMovedNotification\": false, \"git.openRepositoryInParentFolders\": \"always\", \"workbench.startupEditor\": \"none\", \"windsurf.autocompleteSpeed\": \"default\", \"editor.defaultFormatter\": \"llvm-vs-code-extensions.vscode-clangd\", \"editor.formatOnSave\": true, \"C_Cpp.clang_format_fallbackStyle\": \"{BasedOnStyle: Google, IndentWidth: 2, ColumnLimit: 0, UseTab: Never}\", \"editor.tabSize\": 2, \"editor.insertSpaces\": true, \"editor.detectIndentation\": false, \"windsurf.autoExecutionPolicy\": \"off\", \"windsurf.chatFontSize\": \"default\", \"clangd.fallbackFlags\": [ \"-std=c++17\", \"-I/Users/psyche95/.asdf/installs/java/zulu-17.56.15/zulu-17.jdk/Contents/Home/include\", \"-I/Users/psyche95/.asdf/installs/java/zulu-17.56.15/zulu-17.jdk/Contents/Home/include/darwin\" ], \"C_Cpp.intelliSenseEngine\": \"disabled\"\n} { \"workbench.colorTheme\": \"Default Dark Modern\", \"git.openRepositoryInParentFolders\": \"always\", \"cmake.configureOnOpen\": false, \"cmake.pinnedCommands\": [ \"workbench.action.tasks.configureTaskRunner\", \"workbench.action.tasks.runTask\" ], \"editor.defaultFormatter\": \"llvm-vs-code-extensions.vscode-clangd\", \"editor.formatOnSave\": true, \"C_Cpp.intelliSenseEngine\": \"disabled\", \"clangd.fallbackFlags\": [ \"--std=c++17\", \"-I//Users/psychehose/.asdf/installs/java/zulu-17.42.19/zulu-17.jdk/Contents/Home/include\", \"-I//Users/psychehose/.asdf/installs/java/zulu-17.42.19/zulu-17.jdk/Contents/Home/include/darwin\" ], \"windsurf.autocompleteSpeed\": \"default\", \"windsurf.enableAutocomplete\": true, \"windsurf.enableSupercomplete\": true, \"windsurf.enableTabToJump\": true,\n} 프로젝트 루트에 .clang-formatBasedOnStyle: Google\nIndentWidth: 2\nColumnLimit: 0\nUseTab: Never\nAlwaysBreakTemplateDeclarations: Yes\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"tip/vscode-clang++-설정.html","pathToRoot":"..","attachments":[],"createdTime":1739065650848,"modifiedTime":1739115423857,"sourceSize":2080,"sourcePath":"Tip/vscode clang++ 설정.md","exportPath":"tip/vscode-clang++-설정.html","showInTree":true,"treeOrder":409,"backlinks":[],"type":"markdown"},"tip/비트-다루기.html":{"title":"비트 다루기","icon":"","description":"LeetCode에서 Bit Manipulation(231, 191, 190, 136)을 풀면서, 잊어버렸던 내용을 복습하게 되었다.컴퓨터가 정수를 표현하는 방법은 위의 문제와 직접적인 연관은 없습니다. 문제에 대한 코드는 Swift로 작성합니다.\n부호비트와 절댓값\n1의 보수\n2의 보수\n최상위 1비트로 부호를 표시한다. 최상위 비트가 0인 경우에 양수, 1인 경우에 음수를 나타낸다.&nbsp;\n0000 0000 → +0\n0000 0001 → +1\n...\n0111 1111 → +127 1000 0000 → -0\n1000 0001 → -1\n…\n1111 1111 → -127 이 방법을 사용할 경우에 -0과 +0이 존재하게 된다. 그리고 컴퓨터로 처리할 때 연산이 불편하다. 왜냐하면 8비트를 다룰 때 최상위 비트와 절댓값 부분을 따로 다뤄야 하기 때문이다. 불편함은 1의 보수를 사용하면 해소된다.1의 보수법은 해당 양수의 모든 비트를 반전하여 음수를 표현하는 방법이다. 음수를 NOT 연산으로 표현할 수 있기 때문에 간단하다. 그러나 부호비트와 절댓값을 이용한 방법과 마찬가지로 +0, -0이 존재하게 된다.&nbsp;2의 보수법은 해당 양수의 모든 비트를 반전한&nbsp;1의 보수에 1을 더하여&nbsp;음수를 표현하는 방법이다. 0에 1의 보수를 취하고 1을 더하면, 오버플로가 발생하기 때문에 맨 앞의 값은 버려져서 0이 된다. 즉 2의 보수는 +0과 -0을 가지는 문제점이 발생하지 않는다.231. Power of Twoclass Solution { func isPowerOfTwo(_ n: Int) -&gt; Bool { if n &lt;= 0 { return false } var int32number = Int32(n) var valueCount = int32number.nonzeroBitCount return valueCount == 1 }\n}\nn이 주어질 때, n이 2의 거듭제곱이면 true 아니면 false이다. 0은 거듭제곱으로 나타낼 수 없고 2의 음수 거듭제곱은 정수가 아니다.값이 2의 거듭제곱이려면, 2진수 표현방식에서 1이 한 번만 있어야 한다.0000 0001 -&gt; 2^00000 0010 -&gt; 2^1&nbsp;0000 0100 -&gt; 2^2191.&nbsp;Number of 1 Bitsclass Solution { func hammingWeight(_ n: Int) -&gt; Int { var unsignedNumber = UInt32(n) return unsignedNumber.nonzeroBitCount }\n}\n위의 문제와 같다.190. Reverse Bitsclass Solution { func reverseBits(_ n: Int) -&gt; Int { var int32number = UInt32(n) var bitInt32Number = String(int32number, radix: 2) var zerolen = 32 - bitInt32Number.count var zeroArray: [String] = Array(repeating: \"0\", count: zerolen) var zeros = zeroArray.joined() var bits = zeros + bitInt32Number var newBits = String(bits.reversed()) var result = Int(newBits, radix: 2) return result ?? 0 }\n}\n입력받은 값을 String으로 변화시킨다. (예를 들면 32bit 이므로 10 -&gt; 0000 0000 0000 0000 0000 0000&nbsp; 0000 1010)Swift에서는 1010만 출력하기 때문에 앞에 0들을 붙여줘야 한다. 그리고 뒤집어 준 후에, Int로 변환시킨다.136.&nbsp;Single Numberclass Solution { func singleNumber(_ nums: [Int]) -&gt; Int { var result = 0 for num in nums { result ^= num } return result }\n}\n위의 코드를 이해하기 위해서는 XOR 연산을 알고, XOR의 특징을 알아야 한다.\n\b자기 자신과 XOR 연산을 하면 0(False)이다.\nXOR 연산은 교환법칙과 결합법칙이 성립한다\nXOR은 Exclusive OR 연산이다. 수리 논리학에서 주어진 2개의 명제 가운데 1개만 참일 경우를 판단하는 논리 연산이다. 비트연산에서의 XOR 연산은 비트끼리 연산을 해서 같으면 0(=False), 다르면 1(= True)이다.&nbsp; 예를 들어 10과 12 XOR 연산을 해보자.10 = 1010(b)12 = 1100(b)1010(b)^1100(b) = 0110(b)우리는 어떤 정수 x가 주어질 때, 자기 자신과 XOR 연산을 하게 되면 0이 나온다.XOR 연산은 교환법칙과 결합법칙이 성립한다.<img src=\"https://blog.kakaocdn.net/dn/Duemc/btsdefZuIKt/KQl30T41JOe2akmKqEBaqK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9\" target=\"_self\">https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"컴퓨터가 정수를 표현하는 방법.","level":3,"id":"컴퓨터가_정수를_표현하는_방법._0"},{"heading":"부호비트와 절댓값","level":4,"id":"부호비트와_절댓값_0"},{"heading":"1의 보수","level":4,"id":"1의_보수_0"},{"heading":"2의 보수","level":4,"id":"2의_보수_0"},{"heading":"문제","level":3,"id":"문제_0"},{"heading":"Ref","level":4,"id":"Ref_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/Duemc/btsdefZuIKt/KQl30T41JOe2akmKqEBaqK/img.png","fullURL":"tip/비트-다루기.html","pathToRoot":"..","attachments":[],"createdTime":1735623937724,"modifiedTime":1735623984477,"sourceSize":4746,"sourcePath":"Tip/비트 다루기.md","exportPath":"tip/비트-다루기.html","showInTree":true,"treeOrder":410,"backlinks":[],"type":"markdown"},"tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html":{"title":"터미널 명령어로 원하는 .gitignore를 빠르게 생성하기","icon":"","description":"어떤 프로젝트를 시작하든 버전관리를 위해 Git을 사용하는 것은 좋은 선택이라고 생각해요. 저 같은 경우에는 기능을 추가할 때 바로 앱에 적용하는 경우도 종종 있지만, 보통의 경우에는 기능이 있는 샘플 앱을 먼저 만들어 보고 적용하는 걸 선호합니다. 그렇기 때문에 프로젝트를 자주 만드는데요. 저는 당연히 항상 깃을 사용합니다.&nbsp;저는 주로 iOS 개발을 하기 때문에 Xcode를 통해서 프로젝트를 생성하는데 작업을 마치고 GitHub에 푸시하면 올리기 싫은 파일들이 정말 많이 올라갑니다. 예를 들면 .xcodeproj의 하위 폴더에 있는 xcuserdata, MacOS의 .DS_Store 같은 파일들입니다. 이러한 개인적인 것들을&nbsp;깃에 Staging 하지 않도록&nbsp;도와주는 것이 바로&nbsp;.gitignore&nbsp;입니다.$ vim .gitignore\n&nbsp;위와 같이 입력하면 빈 .gitignore 파일이 생성되는데 여기에 자신이 트래킹 하길 원하지 않는 파일이나, 폴더를 작성해 주면 됩니다. 무엇을 작성해야 하는지 잘 모르겠다면 아래의 웹페이지에서 쉽게 확인할 수 있습니다<a data-tooltip-position=\"top\" aria-label=\"https://www.toptal.com/developers/gitignore\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.toptal.com/developers/gitignore\" target=\"_self\">.gitignore 생성하러 가기 </a>이렇게 편리한 툴이 있음에도 불구하고, 매번 .gitignore를 생성하고 웹페이지에 들어가서 복사 붙여 넣기 하는 것도 귀찮았습니다. 그래서 터미널에서 한 줄만 입력하면 내가 원하는 .gitignore 파일이 생성되게 하고 싶었어요. 저는 이것을&nbsp;alias를&nbsp;이용해서 해결했습니다. 항상 이 명령어를 사용하고 싶기 때문에 셀에 아예 등록을 했습니다.vim ~/.zshrc\nignore 변수를 선언하고 Staging 하고 싶지 않은 파일들을 작성하면 됩니다.## ~/.zshrc ignore=\"\n# Mac OS X\n*.DS_Store\n# Xcode\n*.xcuserstate\nproject.xcworkspace/\nxcuserdata/\n\"\n그러고 나서 alias 명령어를 걸면 되겠습니다. 저는 genignore라는 명령어로 .gitignore를 생성하고 싶었어요. 그리고 파일에 쓰고 생성하는데 큰 도움을 주는 명령어&nbsp;cat를 사용할 거예요. 아래의 커맨드라인을 간단하게 말하자면, 'EOF를 만날 때까지 텍스트를 .gitignore에 쓰고 저장할 것이다.'입니다.&nbsp;중간에 있는 $ignore는 위에서 선언한 변수입니다.(셀에서 변수를 사용하려면 $을 붙여줘야 해요)## ~/.zshrc alias genignore=\"cat &lt;&lt;'EOF'&gt;&gt; .gitignore\n$ignore\nEOF\n\"\n터미널에서 만든 명령어를 입력하면 다음과 같이 .gitignore 생성되는 것을 확인할 수 있습니다.<br><img src=\"https://blog.kakaocdn.net/dn/edQGEd/btr33x7VXuV/MXJKPqyXmKq7AhkjCfu5YK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/dwqIHD/btr3U4MvMCZ/YKwKIGSJEYCPoq7xGHUAXK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/edQGEd/btr33x7VXuV/MXJKPqyXmKq7AhkjCfu5YK/img.png","fullURL":"tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html","pathToRoot":"..","attachments":[],"createdTime":1735622526976,"modifiedTime":1737704262981,"sourceSize":2863,"sourcePath":"Tip/터미널 명령어로 원하는 .gitignore를 빠르게 생성하기.md","exportPath":"tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html","showInTree":true,"treeOrder":411,"backlinks":[],"type":"markdown"},"ue/network-프레임워크/02.html":{"title":"02","icon":"","description":"스탠드얼론: 로컬 플레이어클라이언트: 프록시만 보여주는 리슨 서버: 로컬 플레이어를 서버에 직접 배치, 자기 자신도 플레이어임데디케이티드서버: 로컬 플레이어 없음. 대규모 멀티플레이 게임에 사용리슨서버 예시: 스타크래프트 정도? 서버와 클라가 결합리슨서버 구동방식\n로그인 플로우 리슨서버가 될 호스트가 스탠드얼론으로 게임모드 + 플레이어컨트롤러 생성\n게임 서비스 시작 (스탠드얼론 -&gt; 리슨서버로 변경)\n클라이언트가 리슨서버에게 요청\n리슨 서버의 콘텐츠가 클라이언트에게 콘텐츠 복제 게임모드의 주요함수\nPreLogin: 클라이언트의 접속 요청을 처리하는 함수 - 받아들일까 말까 (서버에서는 이 과정 없음)\nLogin: 접속을 허용한 클라에 대응하는 플레이어 컨트롤러 만듬\nPostLogin: 플레이어 입장을 위해 플레이어에 필요한 기본 설정을 모두 마무리함\nStartPlay: 게임 시작 지시\nBeginPlay: 게임이 시작할 때 레벨에 있는 모든 액터에서 호출하는 함수\n클라이언트에 게임모드가 없음 그럼 어떻게 \b게임 시작?\n-&gt; 게임 스테이트 엑터를 사용함 (서버와 클라 둘 다 존재)게임모드가 StartPlay() -&gt; 게임스테이트한테 명령 내림 -&gt; HandleBeginPlay() // 이건 서버로직임\nOnRep_ReplicatedHasBegunPlay()는 클라가 호출함","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"게임의 시작","level":4,"id":"게임의_시작_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/network-프레임워크/02.html","pathToRoot":"../..","attachments":[],"createdTime":1724571717963,"modifiedTime":1724571717963,"sourceSize":1541,"sourcePath":"UE/Network 프레임워크/02.md","exportPath":"ue/network-프레임워크/02.html","showInTree":true,"treeOrder":414,"backlinks":[],"type":"markdown"},"ue/network-프레임워크/03.-커넥션과-오너십.html":{"title":"03. 커넥션과 오너십","icon":"","description":"\n원격 엑터 초기화 이해\n네트워크 처리 방식\n오너십 개념 게임과 무관한 액터 설정 초기화 -&gt; PostInitializeComponents\n원격 클라에서 네트워크 관련 설정 초기화 -&gt; PostNetInit\n게임 진행에 필요한 초기화 -&gt; BeginPlay\n네트워크 통신을 담당하는 주요 클래스\nPlayerController: 네트워크 통신에 접근 가능한 게임 내 대표 엑터\nUNetConnection: 주고 받는 패킷 데이터의 인코딩, 디코딩, 네트워크 통신량 조절, 채널 관리\nUNetDriver: 로우 레벨에서의 소켓 관리와 패킷 처리 및 네트워크 통신 설정\n넷드라이버는 다수의 커넥션을 관리하고, 서버와 클라이언트에 따라 다르게 동작함.\n클라이언트에서의 넷드라이버는 항상 하나의 서버 커넥션을 가진다.\n서버에서의 넷드라이버는 다수의 클라이언트 커넥션을 가진다.'GameMode PostLogin()에서 다수의 클라이언트 커넥션을 확인할 수 있었고,void AABGameMode::PostLogin(APlayerController* NewPlayer)\n{ AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"Begin\")); Super::PostLogin(NewPlayer); UNetDriver* NetDriver = GetNetDriver(); if (NetDriver) { if (NetDriver-&gt;ClientConnections.Num() == 0) { AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"No Client Connection\")); } else { for (const auto&amp; Connection : NetDriver-&gt;ClientConnections) { AB_LOG(LogABNetwork, Log, TEXT(\"Client Connection: %s\"), *Connection-&gt;GetName()); } } } else { AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"No NetDriver\")); } AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"End\"));\n}\nPlayerController PostNetInit()에서 서버 커넥션을 확인할 수 있었다.\n(네트워크로부터 속성 값을 전달받은 상황이기 떄문에 PostNetInit에서 확인할 수 있었다.)void AABPlayerController::PostNetInit()\n{ AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"Start\")); Super::PostNetInit(); UNetDriver* NetDriver = GetNetDriver(); if (NetDriver) { AB_LOG(LogABNetwork, Log, TEXT(\"Server Connection: %s\"), *NetDriver-&gt;ServerConnection-&gt;GetName()); } else { AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"No NetDriver\")); } AB_LOG(LogABNetwork, Log, TEXT(\"%s\"), TEXT(\"End\"));\n} 아래와 같은 작업을 거침 커넥션: 모든 데이터를 전달하는 네트워크 통로\n패킷: 네트워크를 통해 전달되는 단위 데이터. 숫자 혹은 문자로 구성\n채널: 구분된 데이터를 전달하는 논리적인 통로(음성, 액터 정보 etc ..)\n번치: 채널의용도에 맞게 묶인 데이터 데이터 통신을 관리하기 위한 대표 액터 - 플레이어 컨트롤러 커넥션을 담당하는 대표 액터는 커넥션에 대한 오너십을 가진다고 표현 어떤 액터가 통신을 하기 위해서는 자신을 소유한 액터가 커넥션을 소유하고 있어야함.\n일반적으로 플레이어 컨트롤러는 넷커넥션을 소유하고 있음.\n넷커넥션도 플레이어 컨트롤러를 소유하고 있음.\nAACtor::GetNetConnection()\nAPlayerController::GetNetConnection()\nPostLogin이 시작된 후 빙의가 시작됨LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Start\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner: No Owner\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner : BP_ABPlayerController_C_0\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy End\nLogABNetwork: [SERVER] AABPlayerController::OnPossess End\nPlayer 액터는 슈퍼 호출 이전에는 오너가 설정되어 있지 않지만, 이후에 오너가 컨트롤러로 설정됨클라이언트를 추가하면LogABNetwork: [SERVER] AABGameMode::PreLogin Begin\nLogABNetwork: [SERVER] AABGameMode::PreLogin End\nLogABNetwork: [SERVER] AABGameMode::Login Begin\nLogABNetwork: [SERVER] AABPlayerController::PostInitializeComponents Start\nLogABNetwork: [SERVER] AABPlayerController::PostInitializeComponents End\nLogABNetwork: [SERVER] AABGameMode::Login End\nLogABNetwork: [SERVER] AABGameMode::PostLogin Begin\nLogABNetwork: [SERVER] AABPlayerController::OnPossess Start\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Start\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner: No Owner\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner : BP_ABPlayerController_C_1\nLogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy End\nLogABNetwork: [SERVER] AABPlayerController::OnPossess End\nLogABNetwork: [SERVER] AABGameMode::PostLogin Client Connection: IpConnection_1\nLogABNetwork: [SERVER] AABGameMode::PostLogin End\nLogABNetwork: [Client0] AABPlayerController::PostInitializeComponents Start\nLogABNetwork: [Client0] AABPlayerController::PostInitializeComponents End\nLogABNetwork: [Client0] AABPlayerController::PostNetInit Start\nLogABNetwork: [Client0] AABPlayerController::PostNetInit Server Connection: IpConnection_0\nLogABNetwork: [Client0] AABPlayerController::PostNetInit End\n역시 오너가 설정되지만 서버에서만 오너가 설정 로그가 찍힘\n클라이언트에서도 오너가 설정되어야 함 -&gt; PostNetInit()에서 오너가 설정될거라고 예상플레이어는 언제 오너가 바뀔까? 플레이어는 스스로 빙의를 하지 않음.\n클라이언트에서는 빙의가 일어나지 않음. OnPossess가 호출되지 않음플레이어가 가지고 있는 오너의 값이 복제가 됨OnRep_Owner()에 의해서 오너값이 동기화가 됨플레이어가 복제될 때 클라이언트의 플레이어도 복제가 되겠지만, 서버의 플레이어도 복제가 되어야함 서버의 플레이어는 오너가 리플리케이션 되지 않는 상태로 초기화가 됨.하지만 클라이언트는 서버에서 생성된 플레이어 오너값이 복제가 되면서 OnRep_Owner()가 호출됨.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"3. 커넥션과 오너십","level":1,"id":"3._커넥션과_오너십_0"},{"heading":"목차","level":3,"id":"목차_0"},{"heading":"원격 엑터 초기화","level":4,"id":"원격_엑터_초기화_0"},{"heading":"네트워크 처리 방식","level":4,"id":"네트워크_처리_방식_0"},{"heading":"언리얼엔진에서의 데이터 관리","level":4,"id":"언리얼엔진에서의_데이터_관리_0"},{"heading":"액터와 플레이어 컨트롤러의 넷커넥션","level":4,"id":"액터와_플레이어_컨트롤러의_넷커넥션_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/network-프레임워크/03.-커넥션과-오너십.html","pathToRoot":"../..","attachments":[],"createdTime":1724571717963,"modifiedTime":1724571717963,"sourceSize":6112,"sourcePath":"UE/Network 프레임워크/03. 커넥션과 오너십.md","exportPath":"ue/network-프레임워크/03.-커넥션과-오너십.html","showInTree":true,"treeOrder":415,"backlinks":[],"type":"markdown"},"ue/agde와-ue연동.html":{"title":"AGDE와 UE연동","icon":"","description":"<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.android.com/games/agde?hl=ko\" target=\"_self\">https://developer.android.com/games/agde?hl=ko</a><br>\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developer.android.com/games/agde/quickstart?hl=ko\" target=\"_self\">https://developer.android.com/games/agde/quickstart?hl=ko</a>AGDE: Android Game Development Extension.\nVisual Studio 다운로드\n.NET CORE SDK 2.2 다운\nAndroid SDK 및 NDK 설치\nAGDE 설치\nAGDE 버전에 맞게 JDK 설정\nAndroid 게임 개발 확장 프로그램은 MSBuild를 호출하여 공유 라이브러리(.so)와 정적 라이브러리(.a)에 C/C++ 소스 코드를 빌드를 함.\nAndroid 플랫폼을 추가\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"AGDE와 UE 연동","level":2,"id":"AGDE와_UE_연동_0"},{"heading":"AGDE 설치 및 기본 환경설정","level":3,"id":"AGDE_설치_및_기본_환경설정_0"},{"heading":"게임 프로젝트 구성","level":3,"id":"게임_프로젝트_구성_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/agde와-ue연동.html","pathToRoot":"..","attachments":[],"createdTime":1735579487357,"modifiedTime":1735579487358,"sourceSize":583,"sourcePath":"UE/AGDE와 UE연동.md","exportPath":"ue/agde와-ue연동.html","showInTree":true,"treeOrder":416,"backlinks":[],"type":"markdown"},"ue/audio_stream_caching.html":{"title":"Audio_Stream_caching","icon":"","description":"Audio Stream Caching은 Unreal Engine에서 오디오 성능을 최적화하기 위한 기능\n메모리 최적화: 전체 오디오 파일을 메모리에 로드하는 대신 필요한 부분만 캐시에 저장\n스트리밍 성능 향상: 자주 사용되는 오디오 데이터를 캐시에 유지하여 디스크 액세스를 줄입니다. When this feature is enabled at cook time, almost all compressed audio data is separated from the USoundWave asset and placed at the end of the .pak file. This makes it possible for audio to be loaded into memory at any point, and released again when it has not been recently used. 전체 오디오 파일 로드 X -&gt; 메모리 사용량 감소\n전체 오디오 파일 로드 X -&gt; 로딩 시간 단축\n대용량 오디오 파일 처리 효율 증가 SoundWave가 로드되었다고, 오디오가 즉시 재생 가능하다고 보장 X -&gt; 재생이 재연될 수 있음.\n스트리밍 오버헤드 -&gt; 재생 중 지속적인 데이터 로딩 -&gt; CPU 연산 증가\n디스크 I/O: 디스크 성능 중요성 커짐 캐시 크기 설정에 따라 성능이 좌지우지됨 -&gt; 적절한 사이즈를 결정해야함.\n재생 지연은 캐시 크기에 따라 관련이 있을 확률이 높음 사운드 로드 후 맵에 저장하는 방식은 모든 오디오 데이터가 메모리에 상주\n오디오 스트림 캐싱 사용을 하고 맵에 저장하는 방식은 오디오 파일에 대한 참조와 메타데이터 저장 맵에 저장한다는 것이 반드시 전체 데이터를 메모리에 올린다는 의미X\n오디오 스트림 캐싱을 사용할 때, TMap에 저장되는 것은 주로 오디오 파일에 대한 참조와 메타데이터임\n실제 오디오 데이터는 디스크에 남아있고, 필요한 부분만 작은 청크(chunk) 단위로 캐시에 로드됨 스트림 캐싱을 사용하면, 대부분의 오디오 데이터는 디스크에 남아있음\n메인 메모리에는 작은 캐시와 오디오 파일 참조만 존재함 초기 로드 과정 오디오 파일의 메타데이터와 스트리밍에 필요한 정보를 로드 캐시프라이밍 - 오디오 데이터 일부를 메모리에 로드 재생을 빠르게 시작 -&gt; 재생 지연 낮춤\nPrime On Load 옵션 사용 스트리밍 준비 실제 오디오 데이터의 위치와 접근 방법에 대한 정보를 설정 런타임 로딩 오디오 재생 시, 필요한 부분을 그때그때 캐시로 로드\n백그라운드에서 비동기적으로 이뤄짐 전통적인 방식: 전체 오디오 파일을 한 번에 메모리에 로드스트림 캐싱 방식: 메타데이터와 초기 캐시 데이터만 로드하고, 나머지는 필요할 때 스트리밍 Inherited: 기본 설정\n사운드 클래스나 전역 설정에서 로딩 동작을 상속 RetainOnLoad: 사운드 전체를 메모리에 로드하고 유지\n작고 자주 사용되는 사운드에 적합 (예: UI 효과음, 짧은 캐릭터 음성)\n장점: 빠른 재생 시작, 지연 없음.\n단점: 메모리 사용량 증가. PrimeOnLoad: 사운드의 시작 부분만 메모리에 로드\n큰 사운드 파일의 빠른 초기 재생이 필요할 때 유용\n장점: 빠른 초기 재생, 상대적으로 적은 메모리 사용.\n단점: 전체 사운드가 필요할 때 추가 로딩 시간 발생 가능 LoadOnDemand: 필요할 때만 사운드 데이터를 로드\n큰 사운드 파일이나 자주 사용되지 않는 사운드에 적합\n장점: 메모리 사용 최소화.\n단점: 초기 재생 시 약간의 지연 발생 가능. ForceInline: 사운드를 스트리밍 가능한 에셋 패키지에 강제로 인라인화\n특수한 경우에 사용됨(예: 패키징 요구사항이 특별한 경우). 사용시 고려사항 게임의 메모리 제약: 모바일 게임의 경우 LoadOnDemand나 PrimeOnLoad가 유용할 수 있음\n사운드의 크기와 사용 빈도: 작고 자주 사용되는 사운드는 RetainOnLoad, 큰 배경음악은 LoadOnDemand가 적합\n초기 로딩 시간 vs 런타임 성능: RetainOnLoad는 초기 로딩 시간을 증가시키지만 런타임 성능이 좋음 실제 적용 예시: UI 효과음: RetainOnLoad (빠른 반응성 필요)\n배경 음악: LoadOnDemand 또는 PrimeOnLoad (파일 크기가 크지만 즉각적인 재생 시작이 필요하지 않을 수 있음)\n레벨별 특수 효과음: LoadOnDemand (필요할 때만 로드)\n자주 사용되는 캐릭터 음성: RetainOnLoad 또는 PrimeOnLoad (반응성과 메모리 사용의 균형) ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Audio stream caching","level":2,"id":"Audio_stream_caching_0"},{"heading":"주요 특징","level":4,"id":"주요_특징_0"},{"heading":"어떻게 동작하는가?","level":4,"id":"어떻게_동작하는가?_0"},{"heading":"장점","level":4,"id":"장점_0"},{"heading":"단점","level":4,"id":"단점_0"},{"heading":"주의사항","level":4,"id":"주의사항_0"},{"heading":"사운드 로드 후 맵에 저장 vs 오디오 스트림 캐싱 사용","level":4,"id":"사운드_로드_후_맵에_저장_vs_오디오_스트림_캐싱_사용_0"},{"heading":"맵에 저장한다는 것과 메모리에 올리는 것의 차이","level":4,"id":"맵에_저장한다는_것과_메모리에_올리는_것의_차이_0"},{"heading":"메모리 사용량이 줄어드는 이유","level":4,"id":"메모리_사용량이_줄어드는_이유_0"},{"heading":"Audio Stream Caching을 사용 시 로드의 의미 변화","level":4,"id":"Audio_Stream_Caching을_사용_시_로드의_의미_변화_0"},{"heading":"ESoundWaveLoadingBehavior: enum","level":4,"id":"ESoundWaveLoadingBehavior_enum_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/audio_stream_caching.html","pathToRoot":"..","attachments":[],"createdTime":1730808631672,"modifiedTime":1730808631672,"sourceSize":5142,"sourcePath":"UE/Audio_Stream_caching.md","exportPath":"ue/audio_stream_caching.html","showInTree":true,"treeOrder":417,"backlinks":[],"type":"markdown"},"ue/blendspace와-blendspace1d-차이점.html":{"title":"BlendSpace와 BlendSpace1D 차이점","icon":"","description":" 애니메이션 블렌딩이란 하나의 캐릭터 또는 스켈레탈 메시에 둘 이상의 애니메이션이 부드럽게 전환되도록 만드는 것.언리얼엔진에서 블렌딩 하는 방법은 두 가지.\n애님그래프에서 블루프린트로 블렌딩\n블렌드스페이스 사용 블렌드 스페이스는 애님그래프에서 샘플링할 수 있는 특수 애셋 두 입력값에 따라서 애니메이션을 블렌딩시켜주는 것.블렌드스페이스와 블렌드스페이스1D의 차이점은 입력값의 차이 1D는 가로축 하나라서 기준이 단일 입력값으로 블렌딩을 하는 반면에 2D는 가로, 세로축이 존재해 두 입력에 따라 애니메이션을 블렌딩할 수 있습니다.언리얼엔진5에서 Legacy에 BlendSpace1D가 들어가있는 이유는 블렌드스페이스와 차이는 단순히 축뿐이기 때문입니다. 세로축을 사용하지 않으면 그게 바로 Blendspace1D이기 때문입니다.<img alt=\"Blendspace.png\" src=\"images/blendspace.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/blendspace.png","fullURL":"ue/blendspace와-blendspace1d-차이점.html","pathToRoot":"..","attachments":["images/blendspace.html"],"createdTime":1735577788845,"modifiedTime":1735577922469,"sourceSize":1015,"sourcePath":"UE/BlendSpace와 BlendSpace1D 차이점.md","exportPath":"ue/blendspace와-blendspace1d-차이점.html","showInTree":true,"treeOrder":418,"backlinks":[],"type":"markdown"},"ue/bool-vs-uint8.html":{"title":"bool vs uint8","icon":"","description":"Unreal Engine의 리플렉션 시스템에서 bool 대신 uint8을 사용하는 것은 주로 효율성과 일관성을 위한 선택입니다. 여기에는 몇 가지 상세한 이유가 있습니다:\n메모리 효율성: C++에서 bool 타입은 일반적으로 1바이트를 차지합니다. 하지만, 이는 표준에 의해 보장되는 것은 아닙니다. 따라서, 다른 컴파일러나 플랫폼에서 bool의 크기가 달라질 수 있습니다. uint8은 명확하게 1바이트 크기를 갖기 때문에 플랫폼 간 일관성을 보장합니다. 이러한 일관성은 특히 크로스-플랫폼 게임 개발에 있어 중요합니다.\n리플렉션과 직렬화: Unreal Engine의 리플렉션 시스템은 객체의 프로퍼티를 자동으로 식별하고 처리하는 데 사용됩니다. 이 시스템은 uint8과 같은 명확하게 정의된 크기를 가진 데이터 타입을 더 잘 처리할 수 있습니다. 이는 직렬화(데이터를 네트워크를 통해 전송하거나 디스크에 저장하는 과정)에서 중요합니다. bool이 다른 크기를 가질 수 있다면, 직렬화 과정에서 데이터의 정확한 해석이 어려울 수 있습니다.\n비트 필드 사용: Unreal Engine은 종종 비트 필드를 사용하여 메모리 사용을 최적화합니다. uint8은 이러한 목적으로 사용하기에 적합한 타입입니다. 비트 필드에서 각 비트는 별도의 플래그나 설정을 나타낼 수 있으며, 이는 bool보다 메모리를 더 효율적으로 사용하는 방법입니다.\n컴파일러 최적화: 일부 컴파일러는 bool 타입을 특별히 최적화하지 않을 수 있습니다. uint8은 보다 일반적인 데이터 타입이므로, 컴파일러에 따라 bool보다 더 효율적으로 처리될 수 있습니다.\n확장성: bool은 단순히 참/거짓만을 나타내지만, uint8을 사용하면 추가적인 정보를 동일한 메모리 공간에 저장할 수 있습니다. 예를 들어, 여러 상태나 모드를 나타내는데 uint8이 더 유용할 수 있습니다.\n네, C++ 표준에서 bool 타입의 정확한 크기는 명시하지 않고 있습니다. 표준은 단지 bool이 최소 1바이트를 차지해야 한다고 규정할 뿐입니다. 이는 bool이 다른 컴파일러나 아키텍처에서 다른 크기를 가질 수 있음을 의미합니다.예를 들어, 대부분의 현대 컴파일러와 플랫폼에서 bool은 1바이트를 차지합니다. 이는 bool을 효율적으로 처리하기 위한 최소 크기입니다. 그러나 특정 시스템이나 컴파일러 최적화 설정에 따라 bool이 더 큰 메모리 공간을 차지할 수도 있습니다. 예를 들면:\n일부 오래된 또는 특수한 시스템: 이러한 시스템에서 bool은 1바이트보다 큰 크기를 가질 수 있습니다. 예를 들어, 일부 구형 컴퓨터 아키텍처에서는 1바이트보다 큰 단위로 메모리를 관리하는 경우가 있었습니다.\n최적화 목적: 컴파일러는 때때로 메모리 접근 속도를 개선하기 위해 bool의 크기를 늘릴 수 있습니다. 예를 들어, 특정 프로세서 아키텍처에서는 더 큰 단위의 메모리 접근이 더 효율적일 수 있어, bool을 그 크기에 맞춰 조정할 수 있습니다.\n특정 컴파일러 설정: 개발자가 특정 컴파일러 옵션을 사용해 bool의 크기를 조절할 수도 있습니다. 이런 경우는 드물지만, 성능 최적화나 특정 하드웨어 요구 사항에 의해 발생할 수 있습니다.\n이러한 상황에서 bool의 크기가 1바이트가 아닐 수 있으므로, 크로스-플랫폼 애플리케이션 개발 시 bool의 크기에 대해 가정하지 않는 것이 중요합니다. 대신, 명시적인 크기를 갖는 타입(예: uint8_t)을 사용하는 것이 더 안전합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Bool type의 크기가 달라질 수 있음?","level":3,"id":"Bool_type의_크기가_달라질_수_있음?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/bool-vs-uint8.html","pathToRoot":"..","attachments":[],"createdTime":1714816620141,"modifiedTime":1714816620141,"sourceSize":4061,"sourcePath":"UE/bool vs uint8.md","exportPath":"ue/bool-vs-uint8.html","showInTree":true,"treeOrder":419,"backlinks":[],"type":"markdown"},"ue/build-system.html":{"title":"Build System","icon":"","description":"\nSource 폴더 -&gt; Unreal Build Tool (C#) -&gt; 각 플랫폼 컴파일러 실행\n실제 Build를 하는 것은 C#으로 진행함 그래서 닷넷을 설치하는 것Source 폴더 구조Source\n- Module 폴더 (보통 Project 이름)\n- 소스코드(.h, .cpp)\n- {모듈이름}.Build.cs\n- 타겟 설정 파일: 전체 솔루션이 다룰 빌드 대상 지정\n&gt; {프로젝트 이름}.Target.cs: 게임 빌드 설정\n&gt; {프로젝트 이름}Editor.Target.cs: 에디터 빌드 설정Build.cs는 모듈마다 들어가는 모듈 설정 파일모듈.cpp, 모듈.cpp로 지정매크로를 이용해서 모듈의 뼈대를 제작\nIMPLEMENT_MODULE: 일반 모듈\nIMPLEMENT_GAME_MODULE: 게임 모듈\nIMPLEMENT_PRIMARY_GAME_MODULE: 주 게임 모듈\n외부로 공개할 클래스 선언에는 {모듈이름}_DLL 매크로를 붙임\nBuild.cs에서 참조 관계 설정\n서브 모듈을 플러그인으로 분리할 수 있음","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"모듈의 공개와 참조","level":3,"id":"모듈의_공개와_참조_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/build-system.html","pathToRoot":"..","attachments":[],"createdTime":1710855209753,"modifiedTime":1710855209753,"sourceSize":983,"sourcePath":"UE/Build System.md","exportPath":"ue/build-system.html","showInTree":true,"treeOrder":420,"backlinks":[],"type":"markdown"},"ue/console_command-등록-하는-법.html":{"title":"Console_Command 등록 하는 법","icon":"","description":"\nIConsoleCommand: 콘솔 명령어\nIConsoleManager: 콘솔 명령어를 실행하는 주체\nRegisterConsoleCommand: 콘솔 명령어 등록\nUnregisterConsoleObject: 콘솔 명령어 해제 virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithArgsDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldAndArgsDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldArgsAndOutputDeviceDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithOutputDeviceDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, uint32 Flags) override; virtual void UnregisterConsoleObject( IConsoleObject* Object, bool bKeepState) override; /** Console command delegate type (takes no arguments.) This is a void callback function. */\nDECLARE_DELEGATE( FConsoleCommandDelegate ); /** Console command delegate type (with arguments.) This is a void callback function that always takes a list of arguments. */\nDECLARE_DELEGATE_OneParam( FConsoleCommandWithArgsDelegate, const TArray&lt; FString &gt;&amp; ); /** Console command delegate type with a world argument. This is a void callback function that always takes a world. */\nDECLARE_DELEGATE_OneParam( FConsoleCommandWithWorldDelegate, UWorld* ); /** Console command delegate type (with a world and arguments.) This is a void callback function that always takes a list of arguments and a world. */\nDECLARE_DELEGATE_TwoParams(FConsoleCommandWithWorldAndArgsDelegate, const TArray&lt; FString &gt;&amp;, UWorld*); /** Console command delegate type (with a world arguments and output device.) This is a void callback function that always takes a list of arguments, a world and output device. */\nDECLARE_DELEGATE_ThreeParams(FConsoleCommandWithWorldArgsAndOutputDeviceDelegate, const TArray&lt; FString &gt;&amp;, UWorld*, FOutputDevice&amp;); /** Console command delegate type with the output device passed through. */\nDECLARE_DELEGATE_OneParam( FConsoleCommandWithOutputDeviceDelegate, FOutputDevice&amp; ); FConsoleCommandDelegate: 인자 없이 실행되는 가장 단순한 콘솔 명령을 위한 델리게이트입니다. FConsoleCommandWithArgsDelegate: 문자열 배열(TArray&lt;\bFString&gt;&amp;)을 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 사용자가 입력한 추가 인자를 처리할 수 있습니다. FConsoleCommandWithWorldDelegate: UWorld* 타입의 인자를 받는 콘솔 명령을 위한 델리게이트입니다. 현재 게임 월드에 접근해야 하는 명령에 유용합니다. FConsoleCommandWithWorldAndArgsDelegate: 문자열 배열과 UWorld* 포인터를 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 인자와 함께 게임 월드에 접근해야 하는 명령에 사용됩니다. FConsoleCommandWithWorldArgsAndOutputDeviceDelegate: 문자열 배열, UWorld* 포인터, 그리고 FOutputDevice&amp; 참조를 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 출력 장치를 통해 결과를 직접 제어할 수 있는 고급 명령에 사용됩니다. FConsoleCommandWithOutputDeviceDelegate: FOutputDevice&amp; 참조만을 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 출력 제어가 필요하지만 다른 인자는 필요 없는 명령에 사용됩니다. enum EConsoleVariableFlags\n{ /* Mask for flags. Use this instead of ~ECVF_SetByMask */ ECVF_FlagMask = 0x0000ffff, /** * Default, no flags are set, the value is set by the constructor */ ECVF_Default = 0x0, /** * Console variables marked with this flag behave differently in a final release build. * Then they are are hidden in the console and cannot be changed by the user. */ ECVF_Cheat = 0x1, /** * Console variables cannot be changed by the user (from console). * Changing from C++ or ini is still possible. */ ECVF_ReadOnly = 0x4, /** * UnregisterConsoleObject() was called on this one. * If the variable is registered again with the same type this object is reactivated. This is good for DLL unloading. */ ECVF_Unregistered = 0x8, /** * This flag is set by the ini loading code when the variable wasn't registered yet. * Once the variable is registered later the value is copied over and the variable is destructed. */ ECVF_CreatedFromIni = 0x10, /** * Maintains another shadow copy and updates the copy with render thread commands to maintain proper ordering. * Could be extended for more/other thread. * Note: On console variable references it assumes the reference is accessed on the render thread only * (Don't use in any other thread or better don't use references to avoid the potential pitfall). */ ECVF_RenderThreadSafe = 0x20, /* ApplyCVarSettingsGroupFromIni will complain if this wasn't set, should not be combined with ECVF_Cheat */ ECVF_Scalability = 0x40, /* those cvars control other cvars with the flag ECVF_Scalability, names should start with \"sg.\" */ ECVF_ScalabilityGroup = 0x80, // ------------------------------------------------ /* Set flags */ ECVF_SetFlagMask = 0x00ff0000, // Use to set a cvar without calling all cvar sinks. Much faster, but potentially unsafe. Use only if you know the particular cvar/setting does not require a sink call ECVF_Set_NoSinkCall_Unsafe =\t0x00010000, // ------------------------------------------------ /* to get some history of where the last value was set by ( useful for track down why a cvar is in a specific state */ ECVF_SetByMask = 0xff000000, // the ECVF_SetBy are sorted in override order (weak to strong), the value is not serialized, it only affects it's override behavior when calling Set() // lowest priority (default after console variable creation) ECVF_SetByConstructor = 0x00000000, // from Scalability.ini (lower priority than game settings so it's easier to override partially) ECVF_SetByScalability = 0x01000000, // (in game UI or from file) ECVF_SetByGameSetting = 0x02000000, // project settings (editor UI or from file, higher priority than game setting to allow to enforce some setting fro this project) ECVF_SetByProjectSetting = 0x03000000, // per project setting (ini file e.g. Engine.ini or Game.ini) ECVF_SetBySystemSettingsIni =\t0x04000000, // per device setting (e.g. specific iOS device, higher priority than per project to do device specific settings) ECVF_SetByDeviceProfile = 0x05000000, // consolevariables.ini (for multiple projects) ECVF_SetByConsoleVariablesIni = 0x06000000, // a minus command e.g. -VSync (very high priority to enforce the setting for the application) ECVF_SetByCommandline = 0x07000000, // least useful, likely a hack, maybe better to find the correct SetBy... ECVF_SetByCode = 0x08000000, // editor UI or console in game or editor ECVF_SetByConsole = 0x09000000, // ------------------------------------------------\n}; ECVF_Default (0x0): 기본값으로, 아무 플래그도 설정되지 않은 상태입니다.\nECVF_Cheat (0x1): 치트 플래그입니다. 최종 릴리스 빌드에서는 콘솔에 숨겨지고 사용자가 변경할 수 없습니다.\nECVF_ReadOnly (0x4): 읽기 전용 플래그입니다. 사용자가 콘솔에서 변경할 수 없지만, C++ 코드나 ini 파일을 통해 변경 가능합니다.\nECVF_Unregistered (0x8): UnregisterConsoleObject()가 호출되어 등록 해제된 상태를 나타냅니다.\nECVF_CreatedFromIni (0x10): ini 파일에서 로드되었지만 아직 등록되지 않은 변수를 나타냅니다.\nECVF_RenderThreadSafe (0x20): 렌더 스레드에서 안전하게 사용할 수 있는 변수임을 나타냅니다.\nECVF_Scalability (0x40): 스케일러빌리티 설정과 관련된 변수임을 나타냅니다.\nECVF_ScalabilityGroup (0x80): 스케일러빌리티 그룹을 제어하는 변수임을 나타냅니다.\nECVF_Set_NoSinkCall_Unsafe (0x00010000): 콜백 없이 빠르게 설정할 수 있는 플래그입니다.\nECVF_SetByXXX 플래그들: 변수가 어디서 설정되었는지를 나타내는 플래그들입니다. 예를 들어 ECVF_SetByConsole은 콘솔에서 설정되었음을 의미합니다.\n이 플래그들은 비트 마스크로 사용되어 콘솔 변수의 특성과 동작을 제어합니다. 예를 들어, 치트 변수를 만들려면 ECVF_Cheat 플래그를, 읽기 전용 변수를 만들려면 ECVF_ReadOnly 플래그를 사용할 수 있습니다. ECVF_Default (0x0):\nstatic FConsoleVariableRef CVarDefaultExample( TEXT(\"example.Default\"), DefaultValue, TEXT(\"An example of a default console variable\"), ECVF_Default\n); 사용 사례: 특별한 제한이나 동작이 필요 없는 일반적인 콘솔 변수에 사용됩니다. ECVF_Cheat (0x1):\nstatic FConsoleVariableRef CVarInfiniteAmmo( TEXT(\"cheat.InfiniteAmmo\"), bInfiniteAmmo, TEXT(\"Enables infinite ammo\"), ECVF_Cheat\n); 사용 사례: 치트나 디버그 목적으로 사용되는 변수에 적용됩니다. ECVF_ReadOnly (0x4):\nstatic FConsoleVariableRef CVarBuildVersion( TEXT(\"game.BuildVersion\"), BuildVersion, TEXT(\"Current build version\"), ECVF_ReadOnly\n); 사용 사례: 사용자가 수정해서는 안 되는 정보를 저장하는 변수에 사용됩니다. ECVF_Unregistered (0x8):\n// This flag is typically set internally by the engine\nSomeConVar-&gt;SetFlags(SomeConVar-&gt;GetFlags() | ECVF_Unregistered); 사용 사례: 콘솔 변수가 언레지스터되었음을 나타냅니다. 주로 내부적으로 사용됩니다. ECVF_CreatedFromIni (0x10):\n// This flag is typically set internally by the engine when loading from INI\nNewConVar-&gt;SetFlags(NewConVar-&gt;GetFlags() | ECVF_CreatedFromIni); 사용 사례: INI 파일에서 생성된 콘솔 변수를 표시합니다. 주로 내부적으로 사용됩니다. ECVF_RenderThreadSafe (0x20):\nstatic FConsoleVariableRef CVarShadowQuality( TEXT(\"r.ShadowQuality\"), ShadowQuality, TEXT(\"Controls shadow quality (0-4)\"), ECVF_RenderThreadSafe\n); 사용 사례: 렌더 스레드에서 안전하게 접근할 수 있는 변수에 사용됩니다. ECVF_Scalability (0x40):\nstatic FConsoleVariableRef CVarViewDistance( TEXT(\"sg.ViewDistanceQuality\"), ViewDistanceQuality, TEXT(\"Controls view distance quality (0-3)\"), ECVF_Scalability\n); 사용 사례: 스케일러빌리티 설정의 일부로 사용되는 변수에 적용됩니다. ECVF_ScalabilityGroup (0x80):\nstatic FConsoleVariableRef CVarScalabilityGroup( TEXT(\"sg.ResolutionQuality\"), ResolutionQuality, TEXT(\"Controls the resolution quality\"), ECVF_ScalabilityGroup\n); 사용 사례: 다른 스케일러빌리티 설정을 제어하는 그룹 변수에 사용됩니다. ECVF_SetByConstructor (0x00000000):\n// This is typically handled internally by the engine\nSomeConVar-&gt;Set(InitialValue, ECVF_SetByConstructor); 사용 사례: 변수가 생성자에 의해 초기화되었음을 나타냅니다. ECVF_SetByScalability (0x01000000):\n// This would be set when loading scalability settings\nTextureQuality-&gt;Set(ScalabilityTextureQuality, ECVF_SetByScalability); 사용 사례: Scalability.ini 파일에서 설정된 값임을 나타냅니다. ECVF_SetByGameSetting (0x02000000):\n// This would be set when the user changes a setting in the game menu\nAudioVolume-&gt;Set(UserSelectedVolume, ECVF_SetByGameSetting); 사용 사례: 게임 내 설정에서 변경된 값임을 나타냅니다. ECVF_SetByProjectSetting (0x03000000):\n// This would be set when loading project settings\nMaxFPS-&gt;Set(ProjectMaxFPS, ECVF_SetByProjectSetting); 사용 사례: 프로젝트 설정에서 정의된 값임을 나타냅니다. ECVF_SetBySystemSettingsIni (0x04000000):\n// This would be set when loading from Engine.ini or Game.ini\nGravityZ-&gt;Set(IniGravityZ, ECVF_SetBySystemSettingsIni); 사용 사례: 시스템 설정 INI 파일에서 로드된 값임을 나타냅니다. ECVF_SetByDeviceProfile (0x05000000):\n// This would be set when applying device-specific settings\nMobileQualitySettings-&gt;Set(DeviceSpecificQuality, ECVF_SetByDeviceProfile); 사용 사례: 특정 디바이스 프로필에 의해 설정된 값임을 나타냅니다. ECVF_SetByConsoleVariablesIni (0x06000000):\n// This would be set when loading from ConsoleVariables.ini\nPoolSize-&gt;Set(IniPoolSize, ECVF_SetByConsoleVariablesIni); 사용 사례: ConsoleVariables.ini 파일에서 설정된 값임을 나타냅니다. ECVF_SetByCommandline (0x07000000):\n// This would be set when parsing command line arguments\nbStartInFullscreen-&gt;Set(CommandLineFullscreen, ECVF_SetByCommandline); 사용 사례: 명령줄 인자로 설정된 값임을 나타냅니다. ECVF_SetByCode (0x08000000):\n// This would be set directly in game code\nAILogicInterval-&gt;Set(CalculatedInterval, ECVF_SetByCode); 사용 사례: 코드에서 직접 설정된 값임을 나타냅니다. ECVF_SetByConsole (0x09000000):\n// This would be set when a user enters a command in the console\nDrawDebugLines-&gt;Set(UserInputDebugLines, ECVF_SetByConsole); 사용 사례: 콘솔에서 사용자가 직접 입력하여 설정된 값임을 나타냅니다. 이러한 플래그들은 콘솔 변수의 동작을 제어하고, 값이 어디서 설정되었는지를 추적하는 데 사용됩니다. 이를 통해 개발자는 게임의 다양한 설정과 동작을 효과적으로 관리하고 디버그할 수 있습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"개념","level":4,"id":"개념_0"},{"heading":"언리얼 엔진의 콘솔 변수(Console Variable) 시스템에서 사용되는 플래그들을 정의하는 열거형(enum)","level":4,"id":"언리얼_엔진의_콘솔_변수(Console_Variable)_시스템에서_사용되는_플래그들을_정의하는_열거형(enum)_0"},{"heading":"Example","level":4,"id":"Example_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/console_command-등록-하는-법.html","pathToRoot":"..","attachments":[],"createdTime":1724571717953,"modifiedTime":1735556217232,"sourceSize":14893,"sourcePath":"UE/Console_Command 등록 하는 법.md","exportPath":"ue/console_command-등록-하는-법.html","showInTree":true,"treeOrder":421,"backlinks":[],"type":"markdown"},"ue/content-cooking-&-pak-&-chunk.html":{"title":"Content Cooking & pak & chunk","icon":"","description":"게임 실행파일과 필수 에셋: pak0pak0을 설정하는 방법\nDefaultGame.ini에서 DirectoriesToAlwaysCook로 설정\nDataAsset에서 chunk id를 0로 설정한다.\n언리얼 엔진 4.27의 DataAsset에 있는 해당 옵션들\nApply Recursively (재귀적 적용): 이 옵션을 활성화하면 선택한 디렉토리 내의 모든 하위 폴더와 파일에 대해서도 변경 사항이 적용됩니다. 즉, 현재 폴더뿐만 아니라 그 안에 포함된 모든 폴더와 에셋에 대해 동일한 설정이 적용됩니다.\nLabel Assets in My Directories (내 디렉토리의 에셋 라벨링): 이 옵션을 선택하면 현재 프로젝트의 콘텐츠 디렉토리 내에 있는 에셋들에 대해서만 라벨을 적용합니다. 엔진이나 플러그인의 콘텐츠는 제외됩니다.\nIs Runtime Label (런타임 라벨 여부): 이 옵션을 활성화하면 해당 라벨이 게임 실행 중에도 사용 가능하도록 설정됩니다. 런타임에 라벨을 통해 에셋을 검색하거나 필터링해야 하는 경우에 유용합니다.\n이 옵션들은 주로 에셋 관리와 조직화, 그리고 런타임 시 에셋 접근성을 향상시키는 데 사용됩니다. 프로젝트의 규모와 요구사항에 따라 적절히 설정하면 에셋 관리를 더욱 효율적으로 할 수 있습니다.\n보완적 사용: 두 방식은 서로 보완적으로 사용될 수 있음. DirectoriesToAlwaysCook가 전체 디렉토리를 다룬다면, 0RequiredPak은 더 세밀한 제어가 필요한 개별 에셋을 관리함\n중복 가능성: 0RequiredPak에 명시된 에셋이 DirectoriesToAlwaysCook에 지정된 디렉토리 내에 있을 수 있음. 이 경우 해당 에셋은 두 번 쿠킹되지 않고, 한 번만 처리됨\n우선순위: 일반적으로 0RequiredPak의 설정이 더 구체적이므로, 충돌이 있을 경우 이 설정이 우선적으로 적용됨.\npak0 생성: 두 설정 모두 chunk id가 0인 에셋들을 지정하므로, 이들은 함께 pak0의 내용을 구성하는 데 기여 The required attribute \"Include\" is empty ...\nerror MSB4035: The required attribute \"Include\" is empty or missing from the element &lt;ModulesToBuild&gt;.\nRunUAT 실행할 때 -compile 옵션을 없앴음. RunUAT에서 선택적으로 cooking이 되는 거 같지 않음\n출처: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://forums.unrealengine.com/t/command-line-compilation-error-uat/467076/9\" target=\"_self\">https://forums.unrealengine.com/t/command-line-compilation-error-uat/467076/9</a> 현재 구조에서 맵이 없이 패키징 하는 것이 가능한가? 게임 실행 파일 + pak0만 쿠킹하고 싶음\n많은 에셋 쿠킹이 오버라이드를 통해서 진행되어서 파악이 어려움\nDefaultGame.ini와 Tables, DataAsset 여러개가 엮어있음\n예를들면 CC데이터테이블을 DefaultGame.ini에서 always cook으로 사용함 -&gt;\n맵이 패키징됨 Error: CDO Constructor (Canvas): EngineResources/WhiteSquareTexture\n-&gt; DefaultGame.ini에서 +DirectoriesToAlwaysCook=(Path=\"/Game/StarterContent\")로 변경 시간이 금.....요일 할 게 있으니까 먼저 우직하게 workspace 2개 만들고맵 없이, 맵 있는 채로먼저 해야할 것젠킨스로 s3 브라우저 자동 업로드 하는 방법 및 Manifest 생성","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Content Cooking &amp; pak &amp; chunk","level":1,"id":"Content_Cooking_&_pak_&_chunk_0"},{"heading":"DirectoriesToAlwasysCook 과 DataAsset에서 Chunk id를 0으로 설정하는 것의 관계","level":5,"id":"DirectoriesToAlwasysCook_과_DataAsset에서_Chunk_id를_0으로_설정하는_것의_관계_0"},{"heading":"ISSUE","level":4,"id":"ISSUE_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/content-cooking-&-pak-&-chunk.html","pathToRoot":"..","attachments":[],"createdTime":1722664940150,"modifiedTime":1735572667627,"sourceSize":3375,"sourcePath":"UE/Content Cooking & pak & chunk.md","exportPath":"ue/content-cooking-&-pak-&-chunk.html","showInTree":true,"treeOrder":422,"backlinks":[],"type":"markdown"},"ue/datatable_asset_ref.html":{"title":"DataTable_Asset_Ref","icon":"","description":"문제상황:\n모든 사운드 에셋 USound는 USoundDatable에서 관리한다. USoundDatable은 TSoftObjectPtr로 사운드큐를 직접 가지고 있다. 그리고 다른 특정상황에서 사용하는 데이터테이블이 있다. (CollidedSoundDataTable - 이를 C데이터테이블이라 칭함.) C데이터테이블도 마찬가지로 사운드큐를 가지고 있다. 만약 충돌 소리가 변경된다면 USoundDataTable 사운드큐도 바꿔줘야하고, C데이터테이블 사운드큐도 바꿔줘야한다.\nC데이터테이블에서 USoundDataTable의 특정 Row를 참조하면 된다.USTRUCT()\nstruct U2CLIENT_API FU2BallCollidedDataTable : public FU2TableRowBase\n{ GENERATED_USTRUCT_BODY()\npublic: UPROPERTY(EditAnywhere) ESurfaceType surfaceType = ESurfaceType::None; UPROPERTY(EditAnywhere) FDataTableRowHandle SoundRowHandle; UPROPERTY(EditAnywhere) TSoftObjectPtr&lt;UParticleSystem&gt; PS_Collided = nullptr;\n}; 결과<img src=\"images/datahandle_row_result.png\" target=\"_self\">코드에서 꺼내 쓰는 법.FU2SoundDataTable* row = resDT-&gt;SoundRowHandle.GetRow&lt;FU2SoundDataTable&gt;(TEXT(\"BallCollisionSound\")); if (row == nullptr) return; if (row-&gt;bUseSound) { UU2SoundManager::Instance()-&gt;PlaySound(row-&gt;KeyValue); }\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"데이터테이블에서 에셋을 참조하는 것을 방지하는 방법","level":1,"id":"데이터테이블에서_에셋을_참조하는_것을_방지하는_방법_0"}],"links":[],"author":"","coverImageURL":"images/datahandle_row_result.png","fullURL":"ue/datatable_asset_ref.html","pathToRoot":"..","attachments":["images/datahandle_row_result.html"],"createdTime":1724571717953,"modifiedTime":1735572709375,"sourceSize":1370,"sourcePath":"UE/DataTable_Asset_Ref.md","exportPath":"ue/datatable_asset_ref.html","showInTree":true,"treeOrder":423,"backlinks":[],"type":"markdown"},"ue/enum-vs-enum-class.html":{"title":"enum vs enum class","icon":"","description":"C++에서 enum class와 enum은 둘 다 열거형 타입을 정의하는데 사용되지만, 몇 가지 중요한 차이점이 있습니다. 스코프(Scope) 및 이름 충돌: enum: 전통적인 enum은 스코프가 제한되지 않습니다. 이는 enum의 각 값이 열거형 이름 없이 직접 접근될 수 있다는 것을 의미합니다. 이것은 다른 enum과의 이름 충돌을 야기할 수 있습니다.\nenum class: C++11에서 도입된 enum class는 강화된 스코프 규칙을 가집니다. 여기서 각 값은 열거형의 이름을 통해서만 접근할 수 있습니다. 이는 이름 충돌을 방지하고 코드의 명확성을 높입니다. 타입 안정성(Type Safety): enum: 기본적인 enum은 기본 정수 타입으로 암시적으로 변환될 수 있으며, 이는 타입 안전성 문제를 일으킬 수 있습니다.\nenum class: enum class는 더 엄격한 타입 안전성을 제공합니다. 이는 enum class 값을 그들의 열거형 타입이 아닌 다른 타입으로 암시적으로 변환하는 것을 방지합니다. 기본 타입 지정: enum: 전통적인 enum은 컴파일러에 의해 결정되는 정수 타입을 사용합니다.\nenum class: enum class에서는 개발자가 기본 타입을 명시적으로 지정할 수 있습니다 (예: enum class MyEnum : uint8_t { ... }). 포워딩(Forward Declaration): enum: 전통적인 enum은 크기가 고정되어 있지 않기 때문에, 포워드 선언이 제한적입니다.\nenum class: enum class는 포워드 선언이 가능하며, 이는 열거형의 크기가 명시적으로 정의될 때 유용합니다. 결론적으로, enum class는 더 나은 스코프 관리, 타입 안전성 및 명확성을 제공하는 반면, 전통적인 enum은 구버전의 코드와의 호환성과 간결한 문법을 제공합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ue/enum-vs-enum-class.html","pathToRoot":"..","attachments":[],"createdTime":1714816620141,"modifiedTime":1714816620141,"sourceSize":2014,"sourcePath":"UE/enum vs enum class.md","exportPath":"ue/enum-vs-enum-class.html","showInTree":true,"treeOrder":424,"backlinks":[],"type":"markdown"},"ue/etriggerevent.html":{"title":"ETriggerEvent","icon":"","description":"enum class ETriggerEvent : uint8\n{ // No significant trigger state changes occurred and there are no active device inputs None = (0x0) UMETA(Hidden), // Triggering occurred after one or more processing ticks Triggered\t= (1 &lt;&lt; 0),\t// ETriggerState (None -&gt; Triggered, Ongoing -&gt; Triggered, Triggered -&gt; Triggered) // An event has occurred that has begun Trigger evaluation. Note: Triggered may also occur this frame, but this event will always be fired first. Started = (1 &lt;&lt; 1),\t// ETriggerState (None -&gt; Ongoing, None -&gt; Triggered) // Triggering is still being processed. For example, an action with a \"Press and Hold\" trigger // will be \"Ongoing\" while the user is holding down the key but the time threshold has not been met yet. Ongoing = (1 &lt;&lt; 2),\t// ETriggerState (Ongoing -&gt; Ongoing) // Triggering has been canceled. For example, the user has let go of a key before the \"Press and Hold\" time threshold. // The action has started to be evaluated, but never completed. Canceled\t= (1 &lt;&lt; 3),\t// ETriggerState (Ongoing -&gt; None) // The trigger state has transitioned from Triggered to None this frame, i.e. Triggering has finished. // Note: Using this event restricts you to one set of triggers for Started/Completed events. You may prefer two actions, each with its own trigger rules. // Completed will not fire if any trigger reports Ongoing on the same frame, but both should fire. e.g. Tick 2 of Hold (= Ongoing) + Pressed (= None) combo will raise Ongoing event only. Completed\t= (1 &lt;&lt; 4),\t// ETriggerState (Triggered -&gt; None)\n};\nETriggerEvent는 Enum으로 6가지 타입이 있다.\nNone\nTriggered,\nStarted\nOngoing\nCanceled\nCompleted\n이 타입들은 Action에서 Triggers를 어떻게 설정한지에 따라 달라진다.Action Triggers에 Pressed를 설정했을 때ETriggerEvent는 1틱씩None -&gt; Start -&gt; Triggered -&gt; Completed 순으로 발생한다.Action Triggers에 Pressed, Release로 설정할 시에는None -&gt; Start-&gt; Trigger -&gt; Ongoing -&gt; Trigger -&gt; CompletedAction Triggers에 Hold And Release로 설정하고 Hold Time Threshold를 0.5초로 설정이벤트를 주면None -&gt; Start -&gt; Ongoing -&gt; Triggered -&gt; Completed Hold Time Threshold를 5초로 설정하고 스페이스를 2초 후에 눌렀다 떼면None -&gt; Start -&gt; Ongoing -&gt; Canceled정리하면 기본상태는 None이고, 이벤트가 취해질 때 맨 처음 Start로 상태가 한틱 변경된다. 그리고 이벤트 요구사항이 충족 되기 전까지는 Ongoing을 유지하고 충족 되면 Triggered로, 충족되지 않는다면 Canceled로 상태가 변경된다. 그리고 다시 None으로 변경됨.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ue/etriggerevent.html","pathToRoot":"..","attachments":[],"createdTime":1735577794835,"modifiedTime":1735577939666,"sourceSize":2687,"sourcePath":"UE/ETriggerEvent.md","exportPath":"ue/etriggerevent.html","showInTree":true,"treeOrder":425,"backlinks":[],"type":"markdown"},"ue/fgenricerror.html":{"title":"FGenricError","icon":"","description":"<a href=\".?query=tag:unreal\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#unreal\">#unreal</a> <a href=\".?query=tag:error\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#error\">#error</a> Crashed: Thread\n0 libsystem_kernel.dylib 0xc2ec __pthread_kill + 8\n1 libsystem_pthread.dylib 0x7c0c pthread_kill + 268\n2 libsystem_c.dylib 0x75ba0 abort + 180\n3 U2Client 0x2417084 auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()&lt;FLogCategoryLogGenericPlatformMisc, char16_t [31], bool&gt;(FLogCategoryLogGenericPlatformMisc const&amp;, char16_t const (&amp;) [31], bool const&amp;) const + 653 (GenericPlatformMisc.cpp:653)\n4 U2Client 0x24d2e54 FIOSErrorOutputDevice::Serialize(char16_t const*, ELogVerbosity::Type, FName const&amp;) + 31 (IOSErrorOutputDevice.cpp:31)\n5 U2Client 0x254cf6c FOutputDevice::LogfImpl(char16_t const*, ...) + 178 (UnrealMemory.h:178)\n6 U2Client 0x250e55c FDebug::ProcessFatalError() + 482 (AssertionMacros.cpp:482)\n7 U2Client 0x277e668 UObjectBase::~UObjectBase() + 212 (UObjectArray.h:212)\n8 U2Client 0x26d9534 FAsyncPurge::TickDestroyGameThreadObjects(bool, float, double) + 366 (GarbageCollection.cpp:366)\n9 U2Client 0x26d8f3c FAsyncPurge::TickPurge(bool, float, double) + 489 (GarbageCollection.cpp:489)\n10 U2Client 0x26ce4b4 IncrementalPurgeGarbage(bool, float) + 1783 (GarbageCollection.cpp:1783)\n11 U2Client 0x4626ef4 UEngine::ConditionalCollectGarbage() + 1378 (IConsoleManager.h:1378)\n12 U2Client 0x421ca50 UWorld::Tick(ELevelTick, float) + 1691 (LevelTick.cpp:1691)\n13 U2Client 0x41064a4 UGameEngine::Tick(float, bool) + 224 (CoreGlobals.h:224)\n14 U2Client 0x106c3c4 FEngineLoop::Tick() + 4902 (LaunchEngineLoop.cpp:4902)\n15 U2Client 0x27e4410 -[IOSAppDelegate MainAppThread:] + 429 (IOSAppDelegate.cpp:429)\n16 Foundation 0xde428 __NSThread__start__ + 732\n17 libsystem_pthread.dylib 0x606c _pthread_start + 136\n18 libsystem_pthread.dylib 0x10d8 thread_start + 8 Crashed: Thread\n0 libsystem_kernel.dylib 0x7674 __pthread_kill + 8\n1 libsystem_pthread.dylib 0x71ac pthread_kill + 268\n2 libsystem_c.dylib 0x20c8c abort + 180\n3 U2Client 0x2417084 auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()&lt;FLogCategoryLogGenericPlatformMisc, char16_t [31], bool&gt;(FLogCategoryLogGenericPlatformMisc const&amp;, char16_t const (&amp;) [31], bool const&amp;) const + 653 (GenericPlatformMisc.cpp:653)\n4 U2Client 0x24d2e54 FIOSErrorOutputDevice::Serialize(char16_t const*, ELogVerbosity::Type, FName const&amp;) + 31 (IOSErrorOutputDevice.cpp:31)\n5 U2Client 0x254cf6c FOutputDevice::LogfImpl(char16_t const*, ...) + 178 (UnrealMemory.h:178)\n6 U2Client 0x250e55c FDebug::ProcessFatalError() + 482 (AssertionMacros.cpp:482)\n7 U2Client 0x2624598 FAsyncLoadingThread::FlushLoading(int) + 7003 (AsyncLoading.cpp:7003)\n8 U2Client 0x2787174 LoadPackageInternal(UPackage*, char16_t const*, unsigned int, FLinkerLoad*, FArchive*, FLinkerInstancingContext const*) + 1147 (UObjectGlobals.cpp:1147)\n9 U2Client 0x2785ddc LoadPackage(UPackage*, char16_t const*, unsigned int, FArchive*, FLinkerInstancingContext const*) + 1469 (UObjectGlobals.cpp:1469)\n10 U2Client 0x2784960 ResolveName(UObject*&amp;, FString&amp;, bool, bool, unsigned int, FLinkerInstancingContext const*) + 791 (UObjectGlobals.cpp:791)\n11 U2Client 0x2785fe4 StaticLoadObjectInternal(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*, bool, FLinkerInstancingContext const*) + 853 (UObjectGlobals.cpp:853)\n12 U2Client 0x2774930 StaticLoadObject(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*, bool, FLinkerInstancingContext const*) + 928 (UObjectGlobals.cpp:928)\n13 U2Client 0x278662c StaticLoadClass(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*) + 1322 (UObjectGlobals.h:1322)\n14 U2Client 0x1dc2248 UUIScreenController::CreatePopupUI(EU2UIScreenLayerType, FString, bool) + 1332 (UObjectGlobals.h:1332)\n15 U2Client 0x1dc285c UUIScreenController::OpenPopupUI(FString, bool) + 294 (UIScreenController.cpp:294)\n16 U2Client 0x1dc2950 UUIScreenController::OpenPopupUI(FString, FAnchors const&amp;, FVector2D const&amp;, bool) + 306 (UIScreenController.cpp:306)\n17 U2Client 0x1bf67d8 UUIErrorPopup* UUIScreenController::OpenPopup&lt;UUIErrorPopup&gt;(EUIComponentPopup, bool) + 149 (UIScreenController.h:149)\n18 U2Client 0x1dcea48 UU2NetworkManager::MessageManagerEnum(EU2MsgType, UMsgC_Base*) + 105 (U2NetworkManager.cpp:105)\n19 U2Client 0x1e5f708 TBaseUObjectMethodDelegateInstance&lt;false, UManagerObject, void (EU2MsgType, UMsgC_Base*), FDefaultDelegateUserPolicy&gt;::ExecuteIfSafe(EU2MsgType, UMsgC_Base*) const + 598 (DelegateInstancesImpl.h:598)\n20 U2Client 0x1e5f8a8 UE4Function_Private::TFunctionRefCaller&lt;UMessageManager::SendThreadSafeMsgManager(EU2MsgType, UMsgC_Base*)::$_49, void ()&gt;::Call(void*) + 955 (DelegateSignatureImpl.inl:955)\n21 U2Client 0x1079fdc TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(TArray&lt;FBaseGraphTask*, TSizedDefaultAllocator&lt;32&gt;&gt;&amp;, ENamedThreads::Type) + 681 (Function.h:681)\n22 U2Client 0x23f7be0 FNamedTaskThread::ProcessTasksUntilIdle(int) + 711 (TaskGraph.cpp:711)\n23 U2Client 0x2bc2d9c FlushRenderingCommands(bool) + 1264 (RenderingThread.cpp:1264)\n24 U2Client 0x27eb754 invocation function for block in FIOSApplication::OrientationChanged(UIInterfaceOrientation) + 465 (SharedPointerInternals.h:465)\n25 U2Client 0x24d1fcc -[FIOSAsyncTask CheckForCompletion] + 69 (IOSAsyncTask.cpp:69)\n26 U2Client 0x24d2044 +[FIOSAsyncTask ProcessAsyncTasks] + 107 (IOSAsyncTask.cpp:107)\n27 U2Client 0x27e424c -[IOSAppDelegate MainAppThread:] + 297 (CoreGlobals.h:297)\n28 Foundation 0x5b518 __NSThread__start__ + 716\n29 libsystem_pthread.dylib 0x16cc _pthread_start + 148\n30 libsystem_pthread.dylib 0xba4 thread_start + 8 FAsyncLoadingThread\n0 libsystem_kernel.dylib 0x1268 __semwait_signal + 8\n1 libsystem_c.dylib 0x57d8 nanosleep + 220\n2 libsystem_c.dylib 0x64a4 usleep + 68\n3 U2Client 0x261e12c FAsyncLoadingThread::Run() + 4772 (AsyncLoading.cpp:4772)\n4 U2Client 0x2440214 FRunnableThreadPThread::Run() + 25 (PThreadRunnableThread.cpp:25)\n5 U2Client 0x24236a8 FRunnableThreadPThread::_ThreadProc(void*) + 186 (PThreadRunnableThread.h:186)\n6 libsystem_pthread.dylib 0x16cc _pthread_start + 148\n7 libsystem_pthread.dylib 0xba4 thread_start + 8 FAsyncPurge\n0 libsystem_kernel.dylib 0x167c __psynch_cvwait + 8\n1 libsystem_pthread.dylib 0x806c _pthread_cond_wait + 1232\n2 U2Client 0x2418fc4 FPThreadEvent::Wait(unsigned int, bool) + 443 (GenericPlatformProcess.cpp:443)\n3 U2Client 0x26d9134 FAsyncPurge::Run() + 537 (GarbageCollection.cpp:537)\n4 U2Client 0x2440214 FRunnableThreadPThread::Run() + 25 (PThreadRunnableThread.cpp:25)\n5 U2Client 0x24236a8 FRunnableThreadPThread::_ThreadProc(void*) + 186 (PThreadRunnableThread.h:186)\n6 libsystem_pthread.dylib 0x16cc _pthread_start + 148\n7 libsystem_pthread.dylib 0xba4 thread_start + 8\nTip.FAsyncPurge는 언리얼엔진에서 가비지 컬렉션을 담당하는 비동기 스레드 -더 이상 사용되지 않는 객체들을 식별하고 정리(Purge)함\n비동기 로딩 프로세스:\nStaticLoadObject\n-&gt; LoadPackage // 패키지 로딩 시작\n-&gt; AsyncLoading 큐에 작업 등록\n-&gt; FlushLoading // 로딩 완료 대기\n-&gt; 로딩된 객체 반환 FlushLoading이 필요한 이유: LoadClass는 동기(Synchronous) 함수임 - 호출한 즉시 결과(UClass*)를 반환해야 함\n하지만 실제 리소스 로딩은 비동기로 처리\n따라서 비동기 로딩이 완료될 때까지 기다려야 함\n이 \"기다림\"을 위해 FlushLoading 사용 FlushLoading의 역할:\nvoid FAsyncLoadingThread::FlushLoading(int32 PackageId)\n{ // 1. 현재 진행중인 비동기 로딩 작업들이 완료될 때까지 대기 // 2. 로딩된 객체들의 초기화/링킹 작업 // 3. 참조 관계 설정 // 4. 모든 작업이 완료되면 리턴\n} 만약 FlushLoading이 없다면:\nUClass* LoadedClass = LoadClass(...); // 비동기 로딩 시작\n// 이 시점에서 실제 로딩이 안 된 상태로 반환될 수 있음\nCreateWidget(LoadedClass); // 크래시! 아직 로딩 안 된 Class 사용 시도\nUE의 FlushLoading은:큐에 있는 모든 비동기 로딩 작업을 처리할 때까지 대기\n각 작업의 완료를 보장\n모든 작업이 완료될 때까지 호출 스레드를 블록즉, \"Flush\"는 파이프라인이나 큐에 있는 모든 작업을 강제로 처리 완료시키는 동작을 의미\n즉, FlushLoading은 비동기 로딩 시스템에서 동기적 결과가 필요할 때 사용되는 \"동기화 포인트(Synchronization Point)\"\n이는 UE의 리소스 로딩 시스템에서 필수적인 메커니즘 크래쉬 발생 경로 UUIScreenController::CreatePopupUI()\n-&gt; StaticLoadClass() -&gt; LoadPackage()\n-&gt; FAsyncLoadingThread::FlushLoading()\n-&gt; Fatal Error (Cannot Flush Async Loading while async loading is suspended) 상황:\n1. ALT Status: Suspended (작업은 있지만 실행 못하는 상태)\n[Task1] -&gt; [Task2] -&gt; [LoadClass Task] -&gt; [Task4]\n하지만 실행 불가 (Suspended) 2. CreatePopupUI에서 LoadClass 호출\n-&gt; StaticLoadObject -&gt; LoadPackage\n-&gt; FlushLoading 호출 1. 교착 상태 발생:\nFlushLoading: \"모든 작업이 완료될 때까지 기다린다\"\nALT: \"Suspended 상태라 작업을 처리할 수 없다\"\n결과: ⚠️ 영원히 대기하게 됨 이유\nAsyncLoadingThread가 suspend 상태일 때 LoadClass를 호출\nLoadClass는 내부적으로 리소스 로딩을 위해 FlushLoading 호출\nUE는 ALT가 Suspend 상태일 때 FlushLoading을 명시적으로 금지\nUE_CLOG(IsAsyncLoadingSuspendedInternal(), LogStreaming, Fatal, TEXT(\"Cannot Flush Async Loading while async loading is suspended (%d)\"), GetAsyncLoadingSuspendedCount()); UE가 이를 명시적으로 금지하는 이유\n교착 상태 방지\n리소스 로딩의 안전성 보장\n명확한 에러 메시지로 개발자에게 문제 상황 전달 해결방안\nALT 상태를 먼저 체크하고 Suspend 상태일 때 지연 로딩을 하기 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()","level":2,"id":"auto_FGenericPlatformMiscRequestExit(bool)$_27operator()_0"},{"heading":"LoadClass(StaticLoadObject) 과정에서 FlushLoading이 필요한 이유","level":4,"id":"LoadClass(StaticLoadObject)_과정에서_FlushLoading이_필요한_이유_0"}],"links":["?query=tag:unreal","?query=tag:error"],"author":"","coverImageURL":"","fullURL":"ue/fgenricerror.html","pathToRoot":"..","attachments":[],"createdTime":1732431190260,"modifiedTime":1737703718711,"sourceSize":11451,"sourcePath":"UE/FGenricError.md","exportPath":"ue/fgenricerror.html","showInTree":true,"treeOrder":426,"backlinks":[],"type":"markdown"},"ue/fiosview-inserttext-objc_msgsend.html":{"title":"FIOSView insertText - objc_msgSend","icon":"","description":"<a href=\".?query=tag:unreal\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#unreal\">#unreal</a> <a href=\".?query=tag:error\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#error\">#error</a> Crashed: com.apple.main-thread\n0 libobjc.A.dylib 0x3020 objc_msgSend + 32\n1 U2Client 0x246e35c -[FIOSView insertText:] + 636 (IOSView.cpp:636)\n2 U2Client 0x246eaac -[FIOSView unmarkText] + 811 (IOSView.cpp:811)\n3 UIKitCore 0xdc95d0 -[UIResponder(UITextInput_Internal) _unmarkText] + 68\n4 UIKitCore 0xa7d590 -[UIKBInputDelegateManager unmarkText] + 48\n5 UIKitCore 0x4d3e18 -[UIKeyboardImpl _teardownExistingDelegate:forSetDelegate:force:delayEndInputSession:] + 2180\n6 UIKitCore 0x4d2808 -[UIKeyboardImpl setDelegate:force:delayEndInputSession:] + 624\n7 UIKitCore 0x2c4b68 -[UIKeyboardSceneDelegate _reloadInputViewsForKeyWindowSceneResponder:force:fromBecomeFirstResponder:] + 2584\n8 UIKitCore 0x325d3c -[UIKeyboardSceneDelegate _reloadInputViewsForResponder:force:fromBecomeFirstResponder:] + 88\n9 UIKitCore 0x364d8c -[UIResponder _finishResignFirstResponderFromBecomeFirstResponder:] + 328\n10 UIKitCore 0x3643d0 -[UIResponder resignFirstResponder] + 352\n11 U2Client 0x246e8fc -[FIOSView resignFirstResponder] + 740 (IOSView.cpp:740)\n12 UIKitCore 0x52cfa8 -[UIView(UITextField) endEditing:] + 136\n13 U2Client 0x246e7bc 30-[FIOSView DeactivateKeyboard]_block_invoke + 102 (IOSInputInterface.h:102)\n14 libdispatch.dylib 0x213c _dispatch_call_block_and_release + 32\n15 libdispatch.dylib 0x3dd4 _dispatch_client_callout + 20\n16 libdispatch.dylib 0x125a4 _dispatch_main_queue_drain + 988\n17 libdispatch.dylib 0x121b8 _dispatch_main_queue_callback_4CF + 44\n18 CoreFoundation 0x56710 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE + 16\n19 CoreFoundation 0x53914 CFRunLoopRun + 1996\n20 CoreFoundation 0x52cd8 CFRunLoopRunSpecific + 608\n21 GraphicsServices 0x11a8 GSEventRunModal + 164\n22 UIKitCore 0x40a90c -[UIApplication _run] + 888\n23 UIKitCore 0x4be9d0 UIApplicationMain + 340\n24 U2Client 0xdb1650 main + 568 (LaunchIOS.cpp:568)\n25 ??? 0x1ac721e4c (누락)- (void)insertText:(NSString*)theText\n{ if (nil != CachedMarkedText) { [CachedMarkedText release] ; CachedMarkedText = nil; } // insert text one key at a time, as chars, not keydowns for (int32 CharIndex = 0; CharIndex &lt; [theText length]; CharIndex++) { int32 Char = [theText characterAtIndex : CharIndex]; // FPlatformMisc::LowLevelOutputDebugStringf(TEXT(\"sending key '%c' to game\\n\"), Char); if (Char == '\\n') { // send the enter keypress FIOSInputInterface::QueueKeyInput(KEYCODE_ENTER, Char); // hide the keyboard [self resignFirstResponder] ; } else { FIOSInputInterface::QueueKeyInput(Char, Char); } }\n} 원인 예상\n이미 해제한 CachedMarkedText를 접근하려고 했기 때문에\ntheText에 nil 값이 들어오기 때문에\n해결\niOS - UI 관련된 작업은 main - thread에서 실행\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["?query=tag:unreal","?query=tag:error"],"author":"","coverImageURL":"","fullURL":"ue/fiosview-inserttext-objc_msgsend.html","pathToRoot":"..","attachments":[],"createdTime":1719838659337,"modifiedTime":1737703376388,"sourceSize":3274,"sourcePath":"UE/FIOSView insertText - objc_msgSend.md","exportPath":"ue/fiosview-inserttext-objc_msgsend.html","showInTree":true,"treeOrder":427,"backlinks":[],"type":"markdown"},"ue/ftp-manager.html":{"title":"FTP Manager","icon":"","description":"\n개요 내용\n기존 Wave M에서 FTP를 사용하는 기능은 펌웨어 업데이트 하나였음. 추가되는 R1 나스모 기능은 FTP를 이용함. FTPClient는 새로운 인스턴스를 만들어도, 플러그인 코드 내부 객체는 static으로 선언 되어 있음. FTP를 연결할 때 펌웨어와 R1 나스모는 다른 Username을 가지고 로그인하고 다른 역할을 수행함. 따라서 기존의 FTP에 R1 나스모에 필요한 기능을 추가하고 FTP 연결을 관리할 필요성이 생김.// U2Define.h에 정의\nUENUM()\nenum class EFTPAddress : uint8\n{ None = 0, Firmware, SwingMotion\n};\nFTP는 Firmware , SwingMotion 두 가지 타입을 가지고 있음.\n// Connecting &amp; Disconnecting\nvoid ConnectToFTP(EFTPAddress InAddress);\nvoid DisconnectFromFTP(); // Upload &amp; Download\nvoid UploadDataToFTP(const FString&amp; LocalFilePath, const FString&amp; RemoteFilePath);\nvoid DownloadDataFromFTP(const FString&amp; LocalFilePath, const FString&amp; RemoteFilePath); // Get List\nvoid GotoDirectory(const FString&amp; Directory);\nvoid ListCurrentDirectory(); 각 함수에 대한 결과를 바인딩을 통해 Callback으로 받을 수 있음. 아래 Delegate Binding을 참고\n// U2FTPManager.h에 정의 DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FOnU2FTPConnection, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FOnU2FTPStatus, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_SevenParams(FOnU2FTPProgress, const EFTPAddress, Address, const bool, bUploaded, const bool, end, const float, megabyteLeft, const float, megabyteSent, const int32, percent, const float, speedInMegabit);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_FiveParams(FOnU2FTPGotoDirectory, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage, FString, currentDir);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnFTPList, const EFTPAddress, Address, const TArray&lt;FString&gt;&amp;, files); FOnU2FTPConnection OnU2FTPConnection;\nFOnU2FTPStatus OnU2FTPStatus;\nFOnU2FTPProgress OnU2FTPProgress;\nFOnU2FTPGotoDirectory OnU2FTPGotoDirectory;\nFOnFTPList OnU2FTPList; Connecting &amp; Disconnecting에 대한 콜백을 받고 싶음 -&gt; OnU2FTPConnection에 바인딩. Uploading &amp; Downloading에 대한 콜백을 받고 싶음 -&gt; OnU2FTPProgress에 바인딩. FTP에서 워킹 폴더를 변경에 대한 콜백을 받고 싶음 -&gt; OnU2FTPGotoDirectory에 바인딩. FTP에서 해당 폴더에 있는 파일 이름들을 가져오고 싶음 -&gt; OnU2FTPList에 바인딩 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"목차","level":2,"id":"목차_0"},{"heading":"개요","level":2,"id":"개요_0"},{"heading":"내용","level":2,"id":"내용_0"},{"heading":"FTP Connection Type","level":4,"id":"FTP_Connection_Type_0"},{"heading":"제공 함수","level":4,"id":"제공_함수_0"},{"heading":"Delegate Binding","level":4,"id":"Delegate_Binding_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/ftp-manager.html","pathToRoot":"..","attachments":[],"createdTime":1730808631709,"modifiedTime":1735577208142,"sourceSize":2834,"sourcePath":"UE/FTP Manager.md","exportPath":"ue/ftp-manager.html","showInTree":true,"treeOrder":428,"backlinks":[],"type":"markdown"},"ue/get_audiotrackinfo_umg.html":{"title":"Get_AudioTrackInfo_UMG","icon":"","description":"UMG 사운드 출력은 애니메이션에서 오디오 트랙을 추가해서 할 것이다.\n이때, UMG에서 사운드가 출력될 때 코드 처리가 필요하거나 로깅을 해야할 수 있다.UMG에서 오디오 트랙 정보를 얻고, 이 애니메이션이 재생될 때 브로드캐스팅을 받는 방법이다.\n{Project}.Build.cs에 \"MovieScene\", \"MovieSceneTracks\" 의존성 추가해야함. // Dependency header\n#include \"Tracks/MovieSceneAudioTrack.h\"\n#include \"Sections/MovieSceneAudioSection.h\" void UUCustomWidget::OnAnimationStarted_Implementation(const UWidgetAnimation* Animation)\n{ Super::OnAnimationStarted_Implementation(Animation); #if defined(WITH_EDITOR) &amp;&amp; defined(__FUNC_LOG_DETAIL_SOUND__) U2_LOG(U2Sound, Log, TEXT(\"Animation started: %s\"), *Animation-&gt;GetName()); GetAudioTrackInfo(Animation);\n#endif\n} void UUCustomWidget::GetAudioTrackInfo(const UWidgetAnimation* Animation) const\n{ if (!Animation) return; if (!Animation-&gt;GetMovieScene()) return; UMovieScene* MovieScene = Animation-&gt;GetMovieScene(); TArray&lt;UMovieSceneTrack*&gt; AudioTracks = MovieScene-&gt;GetMasterTracks(); for (UMovieSceneTrack* Track : AudioTracks) { if (UMovieSceneAudioTrack* AudioTrack = Cast&lt;UMovieSceneAudioTrack&gt;(Track)) { // Get Audio Tack info TArray&lt;UMovieSceneSection*&gt; Sections = AudioTrack-&gt;GetAllSections(); for (UMovieSceneSection* Section : Sections) { // Process Section if (UMovieSceneAudioSection* AudioSection = Cast&lt;UMovieSceneAudioSection&gt;(Section)) { if (AudioSection-&gt;HasStartFrame()) { FFrameNumber StartFrame = AudioSection-&gt;GetInclusiveStartFrame(); float StartTime = MovieScene-&gt;GetTickResolution().AsSeconds(StartFrame); U2_LOG(U2Sound, Log, TEXT(\"@@@@@@@@@@@@@@@@@@@@@@Audio Track Start Time: %f @@@@@@@@@@@@@@@@@@@\"), StartTime); USoundBase* Sound = AudioSection-&gt;GetSound(); if (Sound) { FString SoundName = Sound-&gt;GetName(); FTimerHandle LogSoundTimer; // #TDBH - will later implement LogSound in Soundmanager //GetWorld()-&gt;GetTimerManager().SetTimer(LogSoundTimer, FTimerDelegate::CreateLambda([SoundName]() //\t{ // UU2SoundManager::Instance()-&gt;LogSound(SoundName); //\t}), StartTime, false); } } } } } }\n} ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UMG에서 오디오 트랙을 정보를 얻는 방법","level":2,"id":"UMG에서_오디오_트랙을_정보를_얻는_방법_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/get_audiotrackinfo_umg.html","pathToRoot":"..","attachments":[],"createdTime":1724571717953,"modifiedTime":1735572789648,"sourceSize":2396,"sourcePath":"UE/Get_AudioTrackInfo_UMG.md","exportPath":"ue/get_audiotrackinfo_umg.html","showInTree":true,"treeOrder":429,"backlinks":[],"type":"markdown"},"ue/insight.html":{"title":"insight","icon":"","description":"insight를 위한 명령어를 넣어줘어야 함.ADB로 Trace를 위한 포트 오픈 (1980)리버스로 해야 들어온다. 포워드로 하면 반대로 가겠지Unreal Insight 실행해서 AutoStart 설정해두면 게임 실행시 Insight 프로세스가 자동실행된다.쭉 추적하고, Trace Sessions에 들어온 Insight 파일로 프로파일링 진행한다.UE4Editor.exe \"D:\\Develop\\GolfzonM\\U2Client\\U2Client.uproject\" -game -WINDOWED -ResX=1280 -ResY=720 -trace=cpu,gpu,memory,log,frame -engine=\"D:\\Develop\\GolfzonMEngine\\Engine\"\nPowerShell로 할 경우 인자 추가가 안됨 (cpu,gpu...) -&gt; Cmd로 할 것이 명령어는 언리얼 엔진 4에서 Unreal Insights를 사용하기 위한 실행 인자들입니다. 각 인자에 대해 설명 -NetTrace=1\n네트워크 트레이싱을 활성화합니다. -trace=cpu,frame,gpu,memory,log,counters\n트레이스할 데이터 유형을 지정합니다. 여기서는 CPU, 프레임, GPU, 메모리, 로그, 카운터 데이터를 수집합니다. -tracehost=127.0.0.1\n트레이스 데이터를 전송할 호스트 IP를 지정합니다. 여기서는 로컬호스트를 사용합니다. -Messaging\n메시징 시스템을 활성화합니다. Unreal Insights와의 통신에 필요합니다. -SessionId=\n세션 ID를 지정합니다. 여기서는 비어 있어 자동 생성됩니다. -SessionOwner=\"\"\n세션 소유자의 이름을 지정합니다. -SessionName=\"\"\n세션의 이름을 지정합니다. 여기서는 비어 있어 자동 생성됩니다. -iterative\n반복적 빌드 모드를 활성화합니다. 개발 중 빠른 재컴파일을 위해 사용됩니다. -fileopenlog\n파일 열기 작업에 대한 로깅을 활성화합니다. -tracefile=PathToSaveTraceTo.utrace\n트레이스 데이터를 저장할 파일 경로를 지정합니다. .utrace 확장자를 사용합니다. 이 명령어는 Unreal Insights를 사용하여 상세한 성능 데이터를 수집하고 분석하는 데 사용됩니다. CPU, GPU, 메모리 사용량, 프레임 정보 등 다양한 성능 지표를 추적하며, 네트워크 활동도 모니터링합니다. 개발자 이름(chin)을 지정하고 있어, 팀 환경에서 누가 어떤 세션을 실행했는지 추적하는 데 유용할 수 있습니다. 또한 트레이스 파일을 지정된 경로에 저장하므로, 나중에 이 데이터를 Unreal Insights 툴에서 분석할 수 있습니다.언리얼 엔진 4에서 Unreal Insights와 관련된 추가적인 명령 인자들을 알려드리겠습니다. 이 목록은 주요 인자들을 포함하고 있지만, 모든 인자를 망라하지는 않을 수 있습니다. -TraceGameThread=1\n게임 스레드의 트레이싱을 활성화합니다. -TraceRenderThread=1\n렌더링 스레드의 트레이싱을 활성화합니다. -TraceAudioThread=1\n오디오 스레드의 트레이싱을 활성화합니다. -TraceTasks=1\n태스크 시스템의 트레이싱을 활성화합니다. -TraceMemory=1\n메모리 할당 및 해제의 트레이싱을 활성화합니다. -TraceUI=1\n사용자 인터페이스 관련 활동의 트레이싱을 활성화합니다. -TraceFrames=1\n프레임 정보의 트레이싱을 활성화합니다. -TraceAnim=1\n애니메이션 시스템의 트레이싱을 활성화합니다. -TraceLoadTime=1\n자산 로딩 시간의 트레이싱을 활성화합니다. -TraceRHI=1\n렌더링 하드웨어 인터페이스(RHI) 호출의 트레이싱을 활성화합니다. -InsightsBufferSize=\nInsights 트레이스 버퍼의 크기를 설정합니다. (예: -InsightsBufferSize=100) -statnamedevents\n네임드 이벤트에 대한 통계를 활성화합니다. -NoInsightsConsole\nInsights 콘솔 출력을 비활성화합니다. -InsightsLatencyCompensation=\n네트워크 지연 보상 값을 설정합니다. (밀리초 단위) -InsightsCollectorPort=\nInsights 콜렉터가 사용할 포트 번호를 지정합니다. -InsightsCollectorHost=\nInsights 콜렉터의 호스트 주소를 지정합니다. -TraceBookmarks=1\n북마크 이벤트의 트레이싱을 활성화합니다. -TraceLiveInterval=\n라이브 트레이싱 업데이트 간격을 설정합니다. (초 단위) -TraceMaxFileSize=\n트레이스 파일의 최대 크기를 설정합니다. (MB 단위) -TraceScreenshots=1\n스크린샷 캡처를 트레이스에 포함시킵니다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ue/insight.html","pathToRoot":"..","attachments":[],"createdTime":1724571717956,"modifiedTime":1735572951591,"sourceSize":4583,"sourcePath":"UE/insight.md","exportPath":"ue/insight.html","showInTree":true,"treeOrder":430,"backlinks":[],"type":"markdown"},"ue/invalidation-box.html":{"title":"Invalidation Box","icon":"","description":"Invalidation Box는 언리얼 엔진 4의 UMG(언리얼 모션 그래픽) UI 시스템에서 사용하는 위젯입니다. UI의 렌더링과 성능을 최적화하는 데 사용됩니다. Invalidation Box의 주요 기능은 자식 위젯의 렌더링을 캐시하는 것입니다. Invalidation Box 내부의 자식 위젯이 변경될 때, Invalidation Box는 전체 UI가 아닌 변경된 부분만 다시 렌더링하여 성능을 향상시킵니다.\n성능 최적화: 자식 위젯의 렌더링을 캐시함으로써 드로우 콜 및 업데이트 수를 줄여 성능을 향상시킵니다. 특히 복잡한 UI에서 효과적입니다. 효율적인 리드로잉: 변경이 발생할 때 영향을 받은 부분만 다시 그리므로 불필요한 계산과 렌더링 과정을 최소화합니다. CPU 사용량 감소: 드로우 콜이 줄어들고 업데이트 빈도가 낮아져 CPU 사용량이 크게 감소하여 게임이나 애플리케이션이 더 부드럽게 실행됩니다. 복잡한 UI: 많은 요소가 자주 업데이트되는 UI의 경우, Invalidation Box로 감싸면 리렌더링 범위를 제한하여 성능 향상을 얻을 수 있습니다.\n정적인 콘텐츠: 자주 변경되지 않는 UI 섹션에 Invalidation Box를 사용하면 초기 렌더링을 캐시하여 중복 렌더링 사이클을 방지할 수 있습니다.\n동적인 요소: 동적인 요소에서도 콘텐츠의 작은 부분만 변경되는 경우, Invalidation Box가 필요한 부분만 업데이트하여 성능을 최적화할 수 있습니다. UI에 추가: UMG 위젯 팔레트에서 Invalidation Box를 드래그하여 UI 계층 구조에 추가합니다.\n위젯 래핑: 최적화하려는 위젯을 Invalidation Box 내부에 배치합니다.\n설정 조정: 필요에 따라 Invalidation Box 설정을 조정합니다. 기본적으로 자식 위젯을 올바르게 무효화하고 캐시하지만, 특정 성능 요구 사항에 따라 세부 조정이 가능합니다.\n테스트 및 프로파일링: 언리얼 엔진의 프로파일링 도구를 사용하여 UI에서 성능 향상을 테스트하고 확인합니다. 필요에 따라 조정합니다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"정의","level":2,"id":"정의_0"},{"heading":"역할","level":2,"id":"역할_0"},{"heading":"Invalidation Box를 사용해야 할 때:","level":3,"id":"Invalidation_Box를_사용해야_할_때_0"},{"heading":"Invalidation Box 사용 방법:","level":3,"id":"Invalidation_Box_사용_방법_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/invalidation-box.html","pathToRoot":"..","attachments":[],"createdTime":1718198160527,"modifiedTime":1718198160527,"sourceSize":2383,"sourcePath":"UE/Invalidation Box.md","exportPath":"ue/invalidation-box.html","showInTree":true,"treeOrder":431,"backlinks":[],"type":"markdown"},"ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html":{"title":"Mac에서 UE4 엔진 소스 빌드 시 유의사항","icon":"","description":"TL ;DR\n언리얼 깃헙에서 브랜치 4.27plus를 받아서 빌드하기. 그리고 윈도우에서 remote 빌드 거는 게 더 합리적인 것 같음. 어차피 Objc 자동완성 사용 불가능UE4 4.27.2 버전을 사용해서 tag가 4.27.2 버전을 다운로드 받음<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release\" target=\"_self\">https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release</a>\n<br>\nInstall&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://mac.github.com/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://mac.github.com/\" target=\"_self\">GitHub for Mac</a>&nbsp;then&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://guides.github.com/activities/forking/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://guides.github.com/activities/forking/\" target=\"_self\">fork and clone our repository</a>. To use Git from the Terminal, see the&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://help.github.com/articles/set-up-git/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://help.github.com/articles/set-up-git/\" target=\"_self\">Setting up Git</a>&nbsp;and&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://help.github.com/articles/fork-a-repo/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://help.github.com/articles/fork-a-repo/\" target=\"_self\">Fork a Repo</a>&nbsp;articles. If you'd rather not use Git, use the 'Download ZIP' button on the right to get the source directly. <br>\nInstall the latest version of&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://itunes.apple.com/us/app/xcode/id497799835\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://itunes.apple.com/us/app/xcode/id497799835\" target=\"_self\">Xcode</a>. Open your source folder in Finder and double-click on&nbsp;Setup.command&nbsp;to download binary content for the engine. You can close the Terminal window afterwards.\nIf you downloaded the source as a .zip file, you may see a warning about it being from an unidentified developer (because .zip files on GitHub aren't digitally signed). To work around it, right-click on Setup.command, select Open, then click the Open button. In the same folder, double-click&nbsp;GenerateProjectFiles.command. It should take less than a minute to complete. Load the project into Xcode by double-clicking on the&nbsp;UE4.xcworkspace&nbsp;file. Select the&nbsp;ShaderCompileWorker&nbsp;for&nbsp;My Mac&nbsp;target in the title bar, then select the 'Product &gt; Build' menu item. When Xcode finishes building, do the same for the&nbsp;UE4&nbsp;for&nbsp;My Mac&nbsp;target. Compiling may take anywhere between 15 and 40 minutes, depending on your system specs. After compiling finishes, select the 'Product &gt; Run' menu item to load the editor. MacOS에서 언리얼 엔진 소스 설치시 (4.27.2) 버그Setup.command를 클릭하면 디펜던시 설정을 함 근데remote server error가 발생함.(403)Checking dependencies...\nUpdating dependencies: 0% (0/63485)...<br>\nFailed to download '<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94\" target=\"_self\">http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94</a>': The remote server returned an error: (403) Forbidden. (WebException)<br>이 경우에 Engine/Build/Commit.gitdeps.xml을&nbsp;&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/EpicGames/UnrealEngine/tree/4.26/Engine/Build\" target=\"_self\">https://github.com/EpicGames/UnrealEngine/tree/4.26/Engine/Build</a>&nbsp;버전의 Engine/Build/Commit.gitdeps.xml으로 교체해주면 Setup.command를 해결할 수 있음.<br>참고:&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/carla-simulator/carla/issues/6486\" target=\"_self\">https://github.com/carla-simulator/carla/issues/6486</a><br><img alt=\"GitHub\" src=\"https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">GitHub<br><a data-tooltip-position=\"top\" aria-label=\"https://github.com/carla-simulator/carla/issues/6486\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/carla-simulator/carla/issues/6486\" target=\"_self\">Unreal Setup.bat (failed to download error) · Issue #6486 · carla-simulator/carla</a>&nbsp;(51kB)ShaderCompileWorker 빌드 시에 아래와 같은 버그가 발생<br><img alt=\"var_error.jpg\" src=\"images/var_error.jpg\" target=\"_self\">Xcode가 빌드할 때 컴파일 옵션을 좀 더 타이트하게 잡아서 발생 하는 이슈\n컴파일러에게 -Wno-unused-but-set-variable 설정을 하면 해결할 수 있음. UE4는 씨샾 코드를 빌드하기 때문에 { 언리얼 엔진 경로 }/Source/Programs/UnrealBuildTool/Platform/Mac/MacToolChain.cs에서GetCompileArguments_Global 함수를 찾아서 Result가 선언된 다음 라인에 코드를 작성하면 됨\tResult += \" -Wno-unused-but-set-variable\";\n여기까지 하면 ShaderCompileWorker 빌드 성공할 수 있음이제 UE4 빌드를 해야 하는데 info.plist가 없어서 빌드 실패하는 이슈가 발생이것은 UE4 Project - Build Setting에서 UE4GENERATE_INFOPLIST_FILE 옵션을 YES로 설정하기Engine/Plugins/Media/BinkMedia/Source/SDK/lib/BinkUnrealMac.a가 없다는 이슈가 발생/Users/choeseung-in/Downloads/UnrealEngine-4.27.2-release/clang:1:1: no such file or directory: '/Users/choeseung-in/Downloads/UnrealEngine-4.27.2-release/Engine/Plugins/Media/BinkMedia/Source/SDK/lib/BinkUnrealMac.a'이건 해당 경로에 static library가 없다는 이슈다.\nSetup.command와 GenerateProjectFiles.command 과정은 디펜던시를 설정하고 다운로드 해와서 필요한 경로에 넣는 역할인데 이 부분이 잘못 되어서 그런 것으로 추정된다.\n그래서 Issue를 찾아보던 중에 branch에 4.27 plus가 있는 것을 발견하였고 계속 유지보수가 이뤄지고 있어서 다시 엔진 소스를 받아서 실행하니 빌드를 할 수 있었다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"<a data-tooltip-position=\"top\" aria-label=\"https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release#mac\" rel=\"noopener nofollow\" class=\"external-link\" href=\"https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release#mac\" target=\"_blank\">Mac</a>","level":3,"id":"[Mac](https//github.com/EpicGames/UnrealEngine/tree/4.27.2-release#mac)_0"},{"heading":"첫번째 이슈","level":3,"id":"첫번째_이슈_0"},{"heading":"2번째 이슈","level":3,"id":"2번째_이슈_0"},{"heading":"3번째 이슈","level":3,"id":"3번째_이슈_0"},{"heading":"4번째 이슈","level":3,"id":"4번째_이슈_0"}],"links":[],"author":"","coverImageURL":"https://slack-imgs.com/?c=1&o1=wi32.he32.si&url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png","fullURL":"ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html","pathToRoot":"..","attachments":["images/var_error.html"],"createdTime":1710855209772,"modifiedTime":1710855209772,"sourceSize":5037,"sourcePath":"UE/Mac에서 UE4 엔진 소스 빌드 시 유의사항.md","exportPath":"ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html","showInTree":true,"treeOrder":432,"backlinks":[],"type":"markdown"},"ue/media-framework.html":{"title":"Media Framework","icon":"","description":"MediaPlayer, MediaSource, MediaTexture, UImage, UMaterialInstanceDynamic 관계 MediaSource 역할: 미디어 데이터의 원천을 정의\nUFileMediaSource, UStreamMediaSource 등 부모 클래스\n관계 MediaPlayer와 직접 연결 다른 컴포넌트들과는 직접적인 관계가 없음. MediaPlayer 역할: 미디어를 재생하고 제어합니다.\n관계 MediaSource로부터 데이터를 받아 디코딩함.\nMediaTexture에 디코딩된 비디오 프레임을 제공.\n전체 시스템의 중심 역할 MediaTexture 역할: MediaPlayer가 제공하는 비디오 프레임을 텍스처로 변환\n관계 MediaPlayer로부터 비디오 프레임을 받음\nUMaterialInstanceDynamic의 텍스처 파라미터로 사용됨 UMaterialInstanceDynamic 역할: 동적으로 변경 가능한 머티리얼 인스턴스를 제공\n관계 MediaTexture를 텍스처 파라미터로 사용\nUImage의 브러시로 사용됨 UImage 역할: UI에 이미지나 비디오를 표시\n관계 UMaterialInstanceDynamic을 브러시로 사용하여 비디오를 표시 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Media","level":2,"id":"Media_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/media-framework.html","pathToRoot":"..","attachments":[],"createdTime":1730808631672,"modifiedTime":1735573061236,"sourceSize":1153,"sourcePath":"UE/Media Framework.md","exportPath":"ue/media-framework.html","showInTree":true,"treeOrder":433,"backlinks":[],"type":"markdown"},"ue/navigation-system.html":{"title":"Navigation System","icon":"","description":"인공지능이 Path Finding을 해서 레벨을 탐색할 수 있음. 시스템은 레벨의 충돌 지오메트리로부터 내비게이션 메시를 생성하고 메시를 타일로 나눕니다. 그런 다음 이러한 타일은 다각형으로 분할되어 에이전트가 목적지로 이동할 때 사용하는 그래프를 형성합니다. 각 다각형에는 에이전트가 전체 최저 비용으로 최적의 경로를 결정하는 데 사용하는 비용이 할당됩니다.내비게이션 시스템에는 정적, 동적 및 동적 수정자 전용의 세 가지 생성 모드가 포함되어 있습니다. 이 모드는 프로젝트에서 내비게이션 메시가 생성되는 방식을 제어하고 필요에 맞는 다양한 옵션을 제공합니다.시스템은 또한 에이전트를 위한 두 가지 회피 방법, 즉 RVO(Reciprocal Velocity Obstacles)와 Detour Crowd Manager(우회 군중 관리자)를 제공합니다. 이러한 방법을 사용하면 에이전트는 게임 플레이 중에 동적 장애물과 다른 에이전트를 탐색할 수 있습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ue/navigation-system.html","pathToRoot":"..","attachments":[],"createdTime":1710855209758,"modifiedTime":1710855209758,"sourceSize":1096,"sourcePath":"UE/Navigation System.md","exportPath":"ue/navigation-system.html","showInTree":true,"treeOrder":434,"backlinks":[],"type":"markdown"},"ue/physx-ios-빌드.html":{"title":"PhysX iOS 빌드","icon":"","description":"cd {EngineSource 디렉토리}/Engine/Source/ThirdParty/PhysX3/Lib/IOS\nnm libPxFoundation.a <img alt=\"symbol_result.png\" src=\"images/symbol_result.png\" target=\"_self\">커스텀한 엔진 심볼 확인 불가 -&gt; 커스텀한 PhysX lib .a overwrite 해야함. PhysX 빌드 CMake Version: 3.28.0 (minimum: 3.0)\nXCode: 14.1\nMacOS: Ventura 13.3.1(a)\nMachine: Apple M1 Ultra Environment - Add EntryName: GW_DEPS_ROOT\nValue: {PhysX Path} - 주의사항: PhysX3.4 아님 PxShared도 가지고 있는 Root 폴더<br><img alt=\"cmake_setting.png\" src=\"images/cmake_setting.png\" target=\"_self\">Configure - Generate - Open Project\n(Configure 할 때, output 폴더에 CMakeCache 있으면 지울 것 캐싱되어서 안바뀔 수도 있음)Xcode 프로젝트가 열렸으면 타겟 All_BUILD로 변경 Edit 스킴을 눌러서 release, debug 각 config에 맞는 걸로 바꾼 후 실행하면 .a들 뽑힘. (PhysX3.4와 PxShared 라이브러리들)<br><img alt=\"change_scheme.png\" src=\"images/change_scheme.png\" target=\"_self\">해당 폴더로 가서 libPxFoundationDEBUG.a $ nm libPxFoundationDEBUG.a\n<br><img alt=\"symbol_find_result.png\" src=\"images/symbol_find_result.png\" target=\"_self\">뽑은 라이브러리들(PhysX3.4, PxShared) 엔진소스/ThirdParty/PhysX3/Lib/IOS로 가서 덮어쓰기","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/symbol_result.png","fullURL":"ue/physx-ios-빌드.html","pathToRoot":"..","attachments":["images/symbol_result.html","images/cmake_setting.html","images/change_scheme.html","images/symbol_find_result.html"],"createdTime":1710855209757,"modifiedTime":1710855209758,"sourceSize":1122,"sourcePath":"UE/PhysX iOS 빌드.md","exportPath":"ue/physx-ios-빌드.html","showInTree":true,"treeOrder":435,"backlinks":[],"type":"markdown"},"ue/pso-(pipeline-state-object)-수집.html":{"title":"PSO (Pipeline State Object) 수집","icon":"","description":"언리얼 엔진에서 PSO(Pipeline State Object)는 그래픽 렌더링 파이프라인의 상태를 정의하는 객체. PSO는 주로 Direct3D 12 및 Vulkan 같은 저수준 그래픽 API에서 사용되며, 그래픽 파이프라인의 다양한 설정(셰이더, 블렌딩)을 캡슐화합니다. 이를 통해 렌더링을 효율적으로 관리할 수 있습니다.\nPSO는 그래픽 파이프라인 상태를 한 번에 정의하고 이를 캐시할 수 있습니다. 이는 매 프레임마다 상태를 변경하는 것보다 훨씬 효율적입니다. PSO는 다양한 파이프라인 상태를 하나의 객체로 관리할 수 있어 상태 변경 관리가 단순해집니다. Unreal Engine은 이러한 저수준 API들을 추상화하여 PSO를 통해 다양한 플랫폼에서 최적화된 렌더링을 제공합니다. PSO 데이터 수집 목적은 성능 최적화, 셰이더 컴파일 시간 단축, 일관된 성능 제공, 런타임 프레임 드롭 방지, 디버깅 및 최적화에 있다. PSO를 미리 컴파일하여 필요할 때 빠르게 사용할 수 있어 런타임 성능을 향상시킵니다. 사전 정의된 PSO를 사용하면 상태 설정 과정에서 발생할 수 있는 불필요한 연산을 피할 수 있습니다. PSO는 패키징 설정을 Development로 바꾸고 Share Material Shader Code 체크 PSO 데이터 수집을 위해서는 디버깅 정보를 포함해서 패키징 해야하므로 Dev 빌드\n여러 머터리얼이 공통으로 사용하는 셰이더 코드를 공유하도록 함 → 중복된 셰이더 제거 → 메모리 효율 증가 맵 포함 패키징 맵에서 사용하는 모든 셰이더와 랜더링 상태를 로드하고 기록하기 위해 맵 전체 포함 .shk 파일을 백업 셰이더 키 캐시(Shader Key Cache) 파일\n파일은 셰이더 컴파일 과정에서 생성되며, 특정 셰이더의 키 정보를 저장합니다. 이 키 정보는 셰이더가 변경되었는지 여부를 확인하고, 캐싱된 버전을 사용할 수 있는지를 판단\n셰이더 키 캐시를 통해 게임 실행 시 셰이더 로딩 시간을 줄일 수 있음 위에서 뽑은 맵을 이용해서 PSO 데이터 수집 Android, iOS 각 플랫폼마다 게임을 플레이하면서 PSO 데이터를 수집 데이터 수집한 디바이스에서 .upipelinecache 확장자명을 가진 파일 추출 PSO 데이터가 저장된 .upipelinecache 백업한 파일과 upipelinecache 확장자명을 가진 파일을 이용해서 csv 파일로 추출 (with 최승인 프로) .shk 키와 .upipelinecache 데이터를 이용해서 PSO 데이터를 텍스트 형식으로 저장해 분석/수정 가능하게 수정 이를 {Project}/Build/{Platform}/PipelineCaches에 넣고, Shipping, Share Material Shader Code를 체크 해제하고 해당 맵을 포함한채로 패키징 해당 경로에 CSV 배치해두면 패키징 과정에서 해당 파일 참조하여 PSO 데이터 포함하게 된다. 모바일 디바이스를 PC에 연결하고 앱 Saved/CollectedPSOs 위치에 아래와 같은 파일들이 있다.\n<img alt=\"collectpso.png\" src=\"images/collectpso.png\" target=\"_self\">\n셰이더 키 캐시 파일(.shk)과 upipelinecache 파일을 한 폴더에 넣고 UE4Editor-Cmd를 이용해서 csv 파일을 추출한다.\n<br><img alt=\"pso_data.png\" src=\"images/pso_data.png\" target=\"_self\">cd {your_engine folder}/Engine/Binaries/Win64 .\\UE4Editor-Cmd.exe D:\\Develop\\WaveM\\U2Client_Wave\\U2Client.uproject -run=ShaderPipelineCacheTools expand C:\\Users\\psyche95\\Desktop\\WM_Backup\\pso_2.1.1_backup\\psodata\\*.rec.upipelinecache C:\\Users\\psyche95\\Desktop\\WM_Backup\\pso_2.1.1_backup\\psodata\\*.shk U2Client_SF_METAL.stablepc.csv 안드로이드는 GPU에 따라 OpenGL, 또는 Vulkan을 사용할 수 있다. (둘 다 지원할 수도 있음) 그렇기 때문에 안드로이드는 PSO 수집을 두 번 해야 한다.안드로이드 신버전은 앱에서 파일을 뽑는 것을 보안상 막아놓았기 때문에 구버전 (현재 가지고 있는 기기 s9, note9) 으로 진행한다.노트9, s9의 GPU는 Mali_72이고, OpenGL, Vulkan을 지원한다.따라서 Mali_72를 이용해서 OpenGL, Vulkan PSO 데이터를 수집하면 된다.\n[Android_Mali_G72 DeviceProfile] DeviceType=Android BaseProfileName=Android_High; enable Vulkan on Android 9 and up, older versions crash on creating PSO with a compute shader that uses texel_buffer (eye adaptation) +CVars=r.Android.DisableVulkanSupport=0\n+CVars=r.Vulkan.RobustBufferAccess=1 +CVars=r.Vulkan.DescriptorSetLayoutMode=2 +CVars=r.DefaultBackBufferPixelFormat=0 +CVars=r.Vulkan.RayTracing.AllowCompaction=0 +CVars=r.Vulkan.RayTracing.TLASPreferFastTraceTLAS=0\n위의 코드가 들어가 있으면 Mali_72 GPU는 Vulkan API를 사용한다는 뜻이다. → 불칸용 PSO 데이터 수집위의 코드가 들어가 있지 않으면 Mali_72 GPU는 OpenGL API를 사용한다는 뜻이다 → OpenGL PSO 데이터 수집Saved/Cooked/Android_ASTC/{GameProject}/Metadata/PipelineCaches에 .shk 파일이 생김. 이를 백업해놓아야함.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Overview","level":3,"id":"Overview_0"},{"heading":"PSO 기능","level":3,"id":"PSO_기능_0"},{"heading":"PSO 데이터 수집 목적","level":3,"id":"PSO_데이터_수집_목적_0"},{"heading":"PSO 데이터 수집 방법 In Golfzon M","level":3,"id":"PSO_데이터_수집_방법_In_Golfzon_M_0"},{"heading":"Detail 5, 6, 7","level":3,"id":"Detail_5,_6,_7_0"},{"heading":"안드로이드 PSO 데이터 수집시 주의점","level":3,"id":"안드로이드_PSO_데이터_수집시_주의점_0"},{"heading":"Overview","level":4,"id":"Overview_1"}],"links":[],"author":"","coverImageURL":"images/collectpso.png","fullURL":"ue/pso-(pipeline-state-object)-수집.html","pathToRoot":"..","attachments":["images/collectpso.html","images/pso_data.html"],"createdTime":1724571717955,"modifiedTime":1735573258521,"sourceSize":5453,"sourcePath":"UE/PSO (Pipeline State Object) 수집.md","exportPath":"ue/pso-(pipeline-state-object)-수집.html","showInTree":true,"treeOrder":436,"backlinks":[],"type":"markdown"},"ue/slate-architecture.html":{"title":"Slate Architecture","icon":"","description":" Pros: Programmers like that UI description is \"close\" to the code; easy to get at the data.\nInvalidation is usually a non-issue; just poll data directly.\nEasy to procedurally build interfaces. Cons: Adding animation and styling is harder.\nUI description is imperative code, so no chance to make it data-driven. Desired Slate Characteristics: Easy access to model's code and data 모델의 코드와 데이터에 쉽게 접근할 수 있습니다.\nSupport procedural UI generation. 절차적 UI 생성을 지원합니다.\nUI description should be hard to screw up.\nMust support animation and styling. 애니메이션과 스타일을 지원해야 합니다. 불투명한 캐시와 중복된 상태를 피하세요. 역사적으로 UI는 상태를 캐시하고 명시적인 무효화를 요구 (from preferred to least preferred) Polling\nTransparent caches\nOpaque caches with low-grain invalidation 노티피케이션보다 알림을 더 선호 When UI structure is changing, prefer polling to notification. (When notification is necessary, prefer low-grain notifications to fine-grain notifications.) 피드백 루프를 피하기. Ex: 모든 레이아웃은 프로그래머 설정에서 계산됩니다. 이전 레이아웃 상태에 의존하지 않기. Only exceptions are when UI state becomes the model; e.g. ScrollBars visualize UI state.\nThis is done for correctness and programmer sanity rather than performance. 일단 난잡하게 개발 -&gt; 후에 일반화하기. &nbsp;Slate uses delegates as a flexible conduit for widgets that need to read and write the Model's data. Slate widgets read the Model's data when they need to display it.\nSTextBlock 은 Text 라는 델리게이트를 사용.<img alt=\"SLATE_ARCITECTURE_1.png\" src=\"images/slate_arcitecture_1.png\" target=\"_self\">이 예제에서 Framerate는 float, integer로 저장될 확률이 높습니다. Delegate를 사용하면 값을 읽을 때마다 변환을 수행할 수 있는 유연성이 제공됩니다.<br><img alt=\"SLATE_ARCITECTURE_2.png\" src=\"images/slate_arcitecture_2.png\" target=\"_self\">SEditableText는 입력과 출력을 모두 담당하는 Slate 위젯입니다. STextBlock과 마찬가지로 데이터 시각화를 위해 Text 대리자를 사용합니다. 사용자가 편집 가능한 텍스트 필드에 일부 텍스트를 입력하고 Enter 키를 누르면 SEditableText가 OnTextChanged 대리자를 호출합니다. 프로그래머가 입력의 유효성을 검사하고 모델의 데이터를 OnTextChanged에 변경하는 데 적합한 기능을 연결했다고 가정합니다.다음 프레임 동안 SEditableText는 모델의 데이터에서 읽습니다. 위의 예에서 항목 이름은 OnTextChanged 대리자에 의해 변경되었으며 Text 대리자를 통해 시각화를 위해 읽혀집니다.Using a delegate is not always desirable. Depending on the use case, the arguments to Slate widgets may need to be constant values or functions. We encapsulate this notion via the&nbsp;TAttribute &lt; T &gt;&nbsp;class. An attribute can be set to a constant or to a delegate.<br>After reading the&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine#pollingdataflowanddelegates\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine#pollingdataflowanddelegates\" target=\"_self\">Polling Data Flow and Delegates</a>&nbsp;section, one might have serious concerns about performance.Consider the following observations:\nUI complexity is bounded by the number of live widgets.\nScrolling content is virtualized whenever possible; this mostly avoids live widgets off-screen. Large numbers of off-screen widgets can easily tank Slate performance. Assumption: users with big screens have beefy machines to drive those screens; they can handle a large number of widgets.\nSometimes polling is either not performant or functionally incorrect. This is often the case with non-trivial values that cannot be expressed as a combination of simpler, trivial values. We usually invalidate in scenarios where the structure of the Model changes drastically. It is then reasonable to scrap an existing UI and recreate it. However, doing so assumes state loss, so we should not do it unless necessary.Invalidation is - as a rule - reserved for infrequent, low-granularity events.Consider the example of the Blueprint Editor, which displays nodes on a graph. When an update is requested, all the&nbsp;Graph&nbsp;Panel widgets are cleared and re-created. This is preferable to fine-grain invalidation because it is simpler and more maintainable.모델 구조가 크게 변경된다면 다 지우고 다시 그리는 게 낫다. (like 그래프)All Slate widgets store children in child slots. (As opposed to storing a plain array of child widgets.) Child slots always store a valid widget; by default they store the&nbsp;SNullWidget, which is a widget with no visualization or interaction. Each type of widget can declare its own type of child slot, which caters to its specific needs. Consider that&nbsp;SVerticalSlot&nbsp;arranges its children completely differently than an&nbsp;SCanvas, which is quite different from SUniformGridPanel. The Slots allow each type of panel to ask for a set of per-child settings that affect the arrangement of the children.모든 Slate 위젯은 하위 슬롯에 하위 항목을 저장합니다. (하위 위젯의 일반 배열을 저장하는 것과 반대입니다.) 하위 슬롯은 항상 유효한 위젯을 저장합니다. 기본적으로 시각화나 상호작용이 없는 위젯인 SNullWidget을 저장합니다. 각 위젯 유형은 특정 요구 사항을 충족하는 자체 하위 슬롯 유형을 선언할 수 있습니다. SVerticalSlot은 SUniformGridPanel과 상당히 다른 SCanvas와 완전히 다르게 자식을 배열한다는 점을 고려하세요. 슬롯을 사용하면 각 유형의 패널에서 하위 배열에 영향을 미치는 하위별 설정 세트를 요청할 수 있습니다.위젯은 세 가지 형태로 제공됩니다 Leaf Widgets&nbsp;- widgets with no child slots. e.g. STextBlock displays a piece of text. It has native knowledge of how to draw text. 하위 슬롯이 없는 위젯. 예를 들어 STextBlock은 텍스트 조각을 표시합니다. 텍스트를 그리는 방법에 대한 기본 지식이 있습니다. Panels&nbsp;- widgets with a dynamic number of child slots. e.g.&nbsp;SVerticalBox&nbsp;arranges any number of children vertically given some layout rules. 동적 개수의 하위 슬롯이 있는 위젯. 예를 들어 SVerticalBox는 일부 레이아웃 규칙에 따라 여러 자식을 수직으로 정렬합니다. Compound Widgets&nbsp;- widgets with a fixed number of explicitly named child slots. e.g.&nbsp;SButton&nbsp;has one slot called Content which contains any widgets inside the button. 동적 개수의 하위 슬롯이 있는 위젯. 예를 들어 SVerticalBox는 일부 레이아웃 규칙에 따라 여러 자식을 수직으로 정렬합니다. Slate layout is accomplished in two passes.\nPass 1:&nbsp;Cache Desired Size&nbsp;- the relevant functions are&nbsp;SWidget::CacheDesiredSize&nbsp;and&nbsp;SWidget::ComputeDesiredSize\nPass 2:&nbsp;ArrangeChildren&nbsp;- the relevant function is&nbsp;SWidget::ArrangeChildren\nThe goal of this pass is to figure out how much space each widget wants to occupy.&nbsp; Widgets with no children (i.e. leaf widgets) are asked to compute and cache their desired size based on their intrinsic properties.Leaf Widget은 자기 고유의 intrinsic 특성을 기준으로 사이즈가 계산되고 캐싱되도록 요청됨.Widgets that combine other widgets (i.e. compound widgets and panels) use special logic to determine their desired size as a function of the size of their children.\n다른 위젯과 결합하는 위젯 (패널과 Compound 위젯)은 special logic을 통해 사이즈가 계산됩니다.Note that each type of widget is only required to implement&nbsp;ComputeDesiredSize();&nbsp;the caching and traversal logic are implemented by Slate.\n각 위젯 유형은 ComputeDesiredSize()를 구현하는 데만 필요합니다. 캐싱 및 순회 논리는 Slate에 의해 구현됩니다.Slate guarantees that when ComputeDesiredSize() is called on a widget, its children have already computed and cached their desired size. Thus, this is a bottom-up pass.\nSlate는 위젯에서 ComputeDesiredSize()가 호출될 때 해당 하위 항목이 이미 원하는 크기를 계산하고 캐시했음을 보장합니다. 따라서 이것은 상향식 패스입니다.다음의 예를 고려해보자.<br><img alt=\"SLATE_ARCITECTURE_3.png\" src=\"images/slate_arcitecture_3.png\" target=\"_self\">An STextBlock widget would compute its desired size by measuring the string that it is displaying. The SImage widget would determine its size based on the image data it is showing. Assume that the text inside the textblock requires 14 slate units of space, and the image requires 8. The horizontal panel arranges widgets horizontally, and therefore requires 14 + 8 = 22 units of space.STextBlock의 Text를 고려하면 14사이즈 되어야하고, SImage의 Image가 들어가려면 8사이즈가 필요하다. 그래서 Horizontal Box는 14+8 = 22로 결정된다.ArrangeChildren is a top-down pass. Slate begin at the top-level windows and asks each window to arrange its children based on the constraints provided by the programmers. When the space allotted for each child is known, Slate can recur and arrange the children's children. The recursion continues until all the children are arranged.AlignChildren은 하향식 패스입니다. 슬레이트는 최상위 창에서 시작하여 프로그래머가 제공한 제약 조건에 따라 하위 창을 정렬하도록 각 창에 요청합니다. 각 자식에게 할당된 공간이 알려지면 Slate는 자식의 자식을 반복해서 배열할 수 있습니다. 모든 하위 항목이 정렬될 때까지 재귀가 계속됩니다.<br><img alt=\"SLATE_ARCITECTURE_4.png\" src=\"images/slate_arcitecture_4.png\" target=\"_self\">먼저 Horizontal Box에 사이즈를 할당하고 그것에 맞춰 자식 컴포넌트의 사이즈가 결정된다.STextBlock은 Autosize이고 내부 Text는 14 사이즈를 필요로하기 때문에 14로 결정된다 SImage의 내부 이미지는 8의 사이즈를 필요로 하지만 Fill WIdth이기 때문에 11로 결정된다.Note that in the actual SHorizontalBox widget, the alignment of the SImage within its slot would be driven by the&nbsp;HAlign&nbsp;property, which can be Left, Center, Right, or Fill.In practice, Slate never performs a full ArrangeChildren pass. Instead, this functionality is used to implement other functionality. Key examples are hit detection and painting.\n실제로 Slate는 전체 AlignChildren 패스를 수행하지 않습니다. 대신 이 기능은 다른 기능을 구현하는 데 사용됩니다. 주요 예로는 히트 감지 및 페인팅이 있습니다.During the paint pass, Slate iterates over all the visible widgets and produces a list of draw elements which will be consumed by the rendering system. This list is produced anew for every frame. 페인트 패스 중에 Slate는 표시되는 모든 위젯을 반복하고 렌더링 시스템에서 사용할 그리기 요소 목록을 생성합니다. 이 목록은 매 프레임마다 새로 생성됩니다.We begin at the top level windows and recur down the hierarchy, appending the draw elements of every widget to the draw list. 최상위 창에서 시작하여 계층 구조를 따라 반복하여 모든 위젯의 그리기 요소를 그리기 목록에 추가합니다.Widgets tend to do two things during paint: they output actual draw elements or figure out where a child widget should exist and ask the child widget to paint itself. 위젯은 페인트하는 동안 두 가지 작업을 수행하는 경향이 있습니다. 즉, 실제 그리기 요소를 출력하거나 하위 위젯이 어디에 있어야 하는지 파악하고 하위 위젯에게 자체적으로 페인트하도록 요청합니다.Thus, we can think of a simplified general-case&nbsp;OnPaint&nbsp;function as being 따라서 단순화된 일반적인 경우의 OnPaint 함수를 다음과 같이 생각할 수 있습니다. // An arranged child is a widget and its allotted geometry\nstruct ArrangedChild\n{ Widget; Geometry;\n}; OutputElements OnPaint( AllottedGeometry )\n{ // Arrange all the children given our allotted geometry Array&lt;ArrangedChild&gt; ArrangedChildren = ArrangeChildrenGiven( AllottedGeometry ); // Paint the children for each ( Child in ArrangedChildren ) { OutputElements.Append( Child.Widget.OnPaint( Child.Geometry ) ); } // Paint a border OutputElements.Append( DrawBorder() );\n}\nThe key functions that define an SWidget's behavior in Slate are: ComputeDesiredSize() - responsible for desired size. 원하는 사이즈를 책임집니다.| ArrangeChildren() - responsible for arrangement of children within the parent's allotted area. 부모에게 할당된 공간 내에서 자녀를 배치할 책임이 있습니다. OnPaint() - responsible for appearance. Event handlers - these are of the form OnSomething. These are functions that may be invoked on your widget by Slate at various times. 이는 OnSomething 형식입니다. 이는 Slate가 위젯에서 다양한 시간에 호출할 수 있는 함수입니다. Composition is the notion that any slot should be able to contain arbitrary widget content. This affords users of Slate a great deal of flexibility. Composition is used whenever possible in core Slate widgets. 구성은 모든 슬롯이 임의의 위젯 콘텐츠를 포함할 수 있어야 한다는 개념입니다. 이는 Slate 사용자에게 상당한 유연성을 제공합니다. 컴포지션은 핵심 슬레이트 위젯에서 가능할 때마다 사용됩니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Core Tenets","level":2,"id":"Core_Tenets_0"},{"heading":"Polling Data Flow and Delegates","level":2,"id":"Polling_Data_Flow_and_Delegates_0"},{"heading":"Attributes and Arguments","level":3,"id":"Attributes_and_Arguments_0"},{"heading":"Performance Considerations","level":2,"id":"Performance_Considerations_0"},{"heading":"Invalidation vs Polling","level":2,"id":"Invalidation_vs_Polling_0"},{"heading":"Child Slots","level":2,"id":"Child_Slots_0"},{"heading":"Widget Roles","level":2,"id":"Widget_Roles_0"},{"heading":"Layout","level":2,"id":"Layout_0"},{"heading":"Pass 1: Cache Desired Size","level":4,"id":"Pass_1_Cache_Desired_Size_0"},{"heading":"Pass 2: ArrangeChildren","level":4,"id":"Pass_2_ArrangeChildren_0"},{"heading":"Drawing Slate : OnPaint","level":2,"id":"Drawing_Slate_OnPaint_0"},{"heading":"Anatomy of a SWidget","level":2,"id":"Anatomy_of_a_SWidget_0"},{"heading":"Composition","level":2,"id":"Composition_0"}],"links":[],"author":"","coverImageURL":"images/slate_arcitecture_1.png","fullURL":"ue/slate-architecture.html","pathToRoot":"..","attachments":["images/slate_arcitecture_1.html","images/slate_arcitecture_2.html","images/slate_arcitecture_3.html","images/slate_arcitecture_4.html"],"createdTime":1710855209758,"modifiedTime":1737703993282,"sourceSize":14084,"sourcePath":"UE/Slate Architecture.md","exportPath":"ue/slate-architecture.html","showInTree":true,"treeOrder":437,"backlinks":[],"type":"markdown"},"ue/slate-overview.html":{"title":"Slate Overview","icon":"","description":"Slate&nbsp;is a completely custom and platform agnostic user interface framework that is designed to make building the user interfaces for tools and applications such as Unreal Editor, or in-game user interfaces, fun and efficient. It combines a declarative syntax with the ability to easily design, lay out, and style components that allows for easily creating and iterating on UIs.The Slate UI solution makes it extremely easy to put together graphical user interfaces for tools and applications and iterate on them quickly.Slate의 선언적 구문을 사용하면 프로그래머가 간접 계층을 추가하지 않고도 UI 구축에 액세스할 수 있습니다. 새 위젯을 선언하고 생성하는 프로세스를 단순화하기 위해 완전한 매크로 세트가 제공됩니다.SLATE_BEGIN_ARGS( SSubMenuButton ) : _ShouldAppearHovered( false ) {} /** The label to display on the button */ SLATE_ATTRIBUTE( FString, Label ) /** Called when the button is clicked */ SLATE_EVENT( FOnClicked, OnClicked ) /** Content to put in the button */ SLATE_NAMED_SLOT( FArguments, FSimpleSlot, Content ) /** Whether or not the button should appear in the hovered state */ SLATE_ATTRIBUTE( bool, ShouldAppearHovered )\nSLATE_END_ARGS()\n// Add a new section for static meshes\nContextualEditingWidget-&gt;AddSlot()\n.Padding( 2.0f )\n[ SNew( SDetailSection ) .SectionName(\"StaticMeshSection\") .SectionTitle( LOCTEXT(\"StaticMeshSection\", \"Static Mesh\").ToString() ) .Content() [ SNew( SVerticalBox ) + SVerticalBox::Slot() .Padding( 3.0f, 1.0f ) [ SNew( SHorizontalBox ) + SHorizontalBox::Slot() .Padding( 2.0f ) [ SNew( SComboButton ) .ButtonContent() [ SNew( STextBlock ) .Text( LOCTEXT(\"BlockingVolumeMenu\", \"Create Blocking Volume\") ) .Font( FontInfo ) ] .MenuContent() [ BlockingVolumeBuilder.MakeWidget() ] ] ] ]\n];\n위의 코드는 아래 UI를 만든다.<img alt=\"SLATE_OVERVIEW_1.png\" src=\"images/slate_overview_1.png\" target=\"_self\">Styles can be created and applied to the various parts of a widget. This makes it easy to iterate on the look of the components in the UI, as well as share and reuse styles. 스타일을 생성하여 위젯의 다양한 부분에 적용할 수 있습니다. 이를 통해 UI의 구성 요소 모양을 쉽게 반복할 수 있을 뿐만 아니라 스타일을 공유하고 재사용할 수도 있습니다.// Tool bar\n{ Set( \"ToolBar.Background\", FSlateBoxBrush( TEXT(\"Common/GroupBorder\"), FMargin(4.0f/16.0f) ) ); Set( \"ToolBarButton.Normal\", FSlateNoResource() ); // Note: Intentionally transparent background Set( \"ToolBarButton.Pressed\", FSlateBoxBrush( TEXT(\"Old/MenuItemButton_Pressed\"), 4.0f/32.0f ) ); Set( \"ToolBarButton.Hovered\", FSlateBoxBrush( TEXT(\"Old/MenuItemButton_Hovered\"), 4.0f/32.0f ) ); // Tool bar buttons are sometimes toggle buttons, so they need styles for \"checked\" state Set( \"ToolBarButton.Checked\", FSlateBoxBrush( TEXT(\"Old/MenuItemButton_Pressed\"), 4.0f/32.0f, FLinearColor( 0.3f, 0.3f, 0.3f ) ) ); Set( \"ToolBarButton.Checked_Hovered\", FSlateBoxBrush( TEXT(\"Old/MenuItemButton_Hovered\"), 4.0f/32.0f ) ); Set( \"ToolBarButton.Checked_Pressed\", FSlateBoxBrush( TEXT(\"Old/MenuItemButton_Pressed\"), 4.0f/32.0f, FLinearColor( 0.5f, 0.5f, 0.5f ) ) ); // Tool bar button label font Set( \"ToolBarButton.LabelFont\", FSlateFontInfo( TEXT(\"Roboto-Regular\"), 8 ) );\n}\nSNew( SBorder )\n.BorderImage( FEditorStyle::GetBrush( \"ToolBar.Background\" ) )\n.Content()\n[ SNew(SHorizontalBox) // Compile button (faked to look like a multibox button) +SHorizontalBox::Slot() [ SNew(SButton) .Style(TEXT(\"ToolBarButton\")) .OnClicked( InKismet2.ToSharedRef(), &amp;FKismet::Compile_OnClicked ) .IsEnabled( InKismet2.ToSharedRef(), &amp;FKismet::InEditingMode ) .Content() [ SNew(SVerticalBox) +SVerticalBox::Slot() .Padding( 1.0f ) .HAlign(HAlign_Center) [ SNew(SImage) .Image(this, &amp;SBlueprintEditorToolbar::GetStatusImage) .ToolTipText(this, &amp;SBlueprintEditorToolbar::GetStatusTooltip) ] +SVerticalBox::Slot() .Padding( 1.0f ) .HAlign(HAlign_Center) [ SNew(STextBlock) .Text(LOCTEXT(\"CompileButton\", \"Compile\")) .Font( FEditorStyle::GetFontStyle( FName( \"ToolBarButton.LabelFont\" ) ) ) .ToolTipText(LOCTEXT(\"CompileButton_Tooltip\", \"Recompile the blueprint\")) ] ] ]\n]\nThe Slate Widget Reflector provides a means of debugging and analyzing the UI and associated code. This helps track down bugs and undesirable behavior as well as profile and optimize your user interface. 슬레이트 위젯 리플렉터는 UI 및 관련 코드를 디버깅하고 분석하는 수단을 제공합니다. 이는 버그와 바람직하지 않은 동작을 추적하고 사용자 인터페이스를 프로파일링하고 최적화하는 데 도움이 됩니다.슬레이트를 사용하기 위해서 아래 모듈을 설정해줘야 한다.<br><img alt=\"SLATE_OVERVIEW_2.png\" src=\"images/slate_overview_2.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Declarative Syntax","level":2,"id":"Declarative_Syntax_0"},{"heading":"Composition","level":2,"id":"Composition_0"},{"heading":"Styles","level":2,"id":"Styles_0"},{"heading":"Developer tools","level":2,"id":"Developer_tools_0"},{"heading":"Using Slate in a Project","level":2,"id":"Using_Slate_in_a_Project_0"}],"links":[],"author":"","coverImageURL":"images/slate_overview_1.png","fullURL":"ue/slate-overview.html","pathToRoot":"..","attachments":["images/slate_overview_1.html","images/slate_overview_2.html"],"createdTime":1710855209759,"modifiedTime":1710855209759,"sourceSize":5632,"sourcePath":"UE/Slate Overview.md","exportPath":"ue/slate-overview.html","showInTree":true,"treeOrder":438,"backlinks":[],"type":"markdown"},"ue/slate-widget-examples.html":{"title":"Slate Widget Examples","icon":"","description":" IsEnabled - This will specify whether or not the widget is able to be interacted with. If it is disabled, it will be greyed out. 위젯이 상호작용할 수 있는지 여부를 지정합니다. 비활성화된 경우 회색으로 표시됩니다. ToolTip - This will specify what kind of custom SToolTip widget will be used for this widget's tool tip. If not specified, it will not appear. 이 위젯의 ​​도구 설명에 사용할 사용자 정의 SToolTip 위젯의 종류를 지정합니다. 지정하지 않으면 나타나지 않습니다. ToolTipText - This will specify what kind of text will show up as a simple tooltip for this widget's tool tip. If not specified, or if the ToolTip attribute was used, it will not appear. 이 위젯의 ​​도구 설명에 대한 간단한 도구 설명으로 표시할 텍스트 종류를 지정합니다. 지정하지 않거나 ToolTip 속성을 사용한 경우에는 표시되지 않습니다. Cursor - This will specify what cursor will appear while the mouse is hovering over this widget. 이는 마우스가 이 위젯 위에 있는 동안 어떤 커서가 나타날지 지정합니다. Visibility 다음 인수는 모든 단일 위젯에 있는 것은 아니지만 대부분의 위젯에 있습니다.\nText - This will specify the text that this widget will have, if applicable.\nContent - This will specify what widget should be placed in the content section of the widget, if applicable.\nReadOnly - This will prevent this widget from being editable if&nbsp;true.\nStyle - This will specify the style of images or text font used by the widget. How this is applicable varies by widget.\nPadding - The padding of a widget amount of spacing in slate units around the left, top, right, and bottom parts of the widget within its parent. These can be specified as a single value for all four parts, or as a horizontal and vertical value, or as four separate values.\nHAlign - The horizontal alignment of content within the widget.\nVAlign - The vertical alignment of content within the widget.\nThe visibility of a widget determines how the widget will appear, as well as its interactivity.\n위젯의 가시성에 따라 위젯이 표시되는 방식과 상호작용성이 결정됩니다. Visible (Default) - The widget will appear normally. 위젯이 정상적으로 나타납니다. Collapsed - The widget will not be visible and will take up no space in the layout. It will not be interactive. 위젯은 표시되지 않으며 레이아웃에서 공간을 차지하지 않습니다. 인터렉션형이 아닙니다. Hidden - The widget will not be visible, but will take up space in the layout. It will not be interactive. 위젯은 표시되지 않지만 레이아웃에서 공간을 차지합니다. 인터렉션형이 아닙니다. HitTestInvisible - Visible to the user, but only as art. It will not be interactive. 사용자에게 표시되지만 아트로만 표시됩니다. 대화형이 아닙니다. SelfHitTestInvisible - Same as HitTestInvisible, but does not apply to child widgets. HitTestInvisible과 동일하지만 하위 위젯에는 적용되지 않습니다. HAlign_Fill/VAlign_Fill HAlign_Left VAlign_Top HAlign_Center/VAlign_Center HAlign_Right VAlign_Bottom ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Common Slate Arguments (공통)","level":2,"id":"Common_Slate_Arguments_(공통)_0"},{"heading":"Visibility","level":3,"id":"Visibility_0"},{"heading":"Alignment","level":3,"id":"Alignment_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/slate-widget-examples.html","pathToRoot":"..","attachments":[],"createdTime":1710855209759,"modifiedTime":1710855209759,"sourceSize":3391,"sourcePath":"UE/Slate Widget Examples.md","exportPath":"ue/slate-widget-examples.html","showInTree":true,"treeOrder":439,"backlinks":[],"type":"markdown"},"ue/sounds-개념.html":{"title":"Sounds 개념","icon":"","description":"사운드 큐는 하나 이상의 사운드 웨이브를 포함할 수 있는 오브젝트입니다. 이를 통해 복잡한 사운드 효과를 구성할 수 있습니다. 사운드 큐는 다양한 노드를 통해 사운드를 조작할 수 있습니다.\n모듈레이션 노드: 피치나 볼륨을 변경할 수 있습니다.\n믹서 노드: 여러 사운드를 믹싱할 수 있습니다.\n랜덤 노드: 여러 사운드 중 랜덤으로 하나를 재생합니다.\n시퀀스 노드: 여러 사운드를 순차적으로 재생합니다.\n사운드 웨이브는 실제 오디오 데이터를 포함하는 가장 기본적인 사운드 자산입니다. WAV, MP3 등의 파일 형식을 사용할 수 있으며, 주파수, 볼륨, 피치 등의 기본 속성을 설정할 수 있습니다.사운드 클래스는 사운드를 그룹화하고 그 그룹에 공통된 설정을 적용할 수 있게 해줍니다. 예를 들어, 음악, 효과음, 대사를 각각의 사운드 클래스로 나누고, 볼륨이나 믹싱 설정을 개별적으로 조정할 수 있습니다.사운드 믹스는 여러 사운드 클래스의 볼륨이나 피치를 조정하는 데 사용됩니다. 특정 이벤트가 발생했을 때, 사운드 믹스를 적용하여 게임 내 모든 사운드의 특성을 변경할 수 있습니다.오디오 컴포넌트는 액터에 붙여서 사운드를 재생하는 데 사용됩니다. 이를 통해 액터의 위치에 따라 3D 공간에서 사운드를 재생할 수 있습니다.\n리버브: 공간의 울림을 시뮬레이션하여 더 현실적인 사운드를 제공합니다.\n필터: 특정 주파수를 강조하거나 감소시켜 다양한 효과를 만들 수 있습니다.\n채널 (Channel)• 채널은 오디오 시스템에서 독립된 오디오 신호 경로를 의미합니다. 오디오의 방향성과 관련이 깊습니다.• 모노 (Mono), 스테레오 (Stereo), 서라운드 사운드 (Surround Sound) 같은 다양한 채널 구성은 사운드를 어떻게 분배하고 재생할지를 결정합니다.Mono (모노)• 모노는 단일 오디오 채널을 사용하여 소리를 재생합니다.\n• 모든 스피커에서 동일한 오디오 신호를 재생하기 때문에, 공간적인 방향성 없이 하나의 소리 원천처럼 들립니다.Stereo (스테레오)• 스테레오는 두 개의 채널(좌, 우)을 사용합니다.\n• 각 채널에 다른 오디오 신호를 보내어 공간감을 만들어냅니다. 예를 들어, 음악에서는 악기나 보컬이 왼쪽이나 오른쪽에서 더 크게 들릴 수 있습니다.Surround Sound (서라운드 사운드)\n• 서라운드 사운드는 다수의 채널(5.1, 7.1 등)을 사용하여 모든 방향에서 소리가 나오는 듯한 환경을 만듭니다.\n• 영화관, 홈시어터 시스템, 고급 게임 환경에서 주로 사용됩니다.Mono vs. Stereo의 차이• 모노는 단일 포인트에서 소리가 나오는 느낌을 줍니다.\n• 스테레오는 소리가 좌우로 퍼져 나가며, 청취자에게 더 풍부하고 입체적인 경험을 제공합니다.근데 모노를 사용하는 이유?\n용량\n공간감 표현 (3d)\n실제세계는 모노로 나가는게.. 좀 더 현실적임\nSoundManager를 어떻게 고도화할 수 있을까? 사운드 풀링 시스템 구현: 사운드가 재생될 때마다 새로운 오디오 구성 요소를 만드는 대신 재사용 가능한 오디오 구성 요소 풀을 구현합니다. 이는 특히 자주 재생되는 사운드의 경우 성능을 향상시키고 메모리 할당 오버헤드를 줄일 수 있습니다. 사운드 우선순위 구현: 바쁜 오디오 환경에서도 중요한 오디오 신호가 항상 들리도록 사운드 우선순위 시스템을 만듭니다.(6) 로깅시스템 및 에러처리 (5) 사운드 로딩 최적화: 초기화 시 모든 사운드를 로드하는 대신 요청 시 또는 일괄적으로 사운드를 로드하는 시스템을 구현하여 초기 로딩 시간을 줄입니다. 8 동적 음악 시스템에 대한 지원 추가: 게임 상태 또는 이벤트에 따라 다양한 음악 트랙 간에 원활하게 전환하는 시스템을 구현합니다.7 현지화 지원 추가: 오디오 파일의 다양한 언어 버전 간을 쉽게 전환할 수 있는 시스템을 구현합니다 사운드 자산에 비동기 로딩 사용: 동기 로딩을 비동기 로딩으로 대체하여 특히 대용량 사운드 파일의 성능을 향상시킵니다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. 사운드 큐(Sound Cue)","level":3,"id":"1._사운드_큐(Sound_Cue)_0"},{"heading":"2. 사운드 웨이브(Sound Wave)","level":3,"id":"2._사운드_웨이브(Sound_Wave)_0"},{"heading":"3. 사운드 클래스(Sound Class)","level":3,"id":"3._사운드_클래스(Sound_Class)_0"},{"heading":"4. 사운드 믹스(Sound Mix)","level":3,"id":"4._사운드_믹스(Sound_Mix)_0"},{"heading":"5. 오디오 컴포넌트(Audio Component)","level":3,"id":"5._오디오_컴포넌트(Audio_Component)_0"},{"heading":"6. 리버브(Reverb)와 필터(Filter)","level":3,"id":"6._리버브(Reverb)와_필터(Filter)_0"},{"heading":"채널과 스테레오,   모노","level":3,"id":"채널과_스테레오,__모노_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/sounds-개념.html","pathToRoot":"..","attachments":[],"createdTime":1719838659338,"modifiedTime":1735573278386,"sourceSize":4954,"sourcePath":"UE/Sounds 개념.md","exportPath":"ue/sounds-개념.html","showInTree":true,"treeOrder":440,"backlinks":[],"type":"markdown"},"ue/sounds-개선.html":{"title":"Sounds 개선","icon":"","description":"\n개요\n컨텐츠 폴더 구조 (기획 ,디자인, 개발)\nU2SoundDataTable - SoundType 카테고리 (기획, 디자인)\nU2SoundManager - Init, Load (개발)\nAudio Stream Caching 적용 (개발)\nSound 출력 Rule (기획, 디자인, 개발)\n결과\nP.S 사운드 작업 시 살펴봐야할 에셋들 기존에 사운드 관리자의 부재로 인해 유지보수가 지속적으로 이뤄지지 않았음. 기존의 사운드 시스템은 게임 시작 버튼 클릭시에 로딩바에서 SoundsDataTable에 있는 모든 사운드 에셋을 로딩하고, 이것들을 TMap에 저장한 후에 필요할 때 출력하는 방식으로 구성되어 있었음. 유지보수 하기 쉽고 안정적이지만 사용하지 않는 사운드 모두 메모리에 올리기 때문에 로비에서 메모리가 낭비되는 결과를 가져올 수 있음. <img src=\"images/foldering_to_be.png\" target=\"_self\"> ann_crash: 볼 맞추고 판정소리 () 아나운서가 벙커, OB 이런거 내주는 소리\nSoundType:인게임\n모두 ShotResult로 시작함.\nReplayState, U2GolfGameSoundComponent, UIIngameStrokePage에서 사용 ann_score: 찬스랑 결과 말해주는 소리 총 세가지 유형: 찬스, 홀인 결과, 컨시드 결과\nSoundType: 인게임\n찬스는 ScoreChane. 로 시작, UU2CaddieComponent에 종속\n홀인 결과와 컨시드 결과는 UU2GolfGameSoundComponent에 종속\n홀인원은 UMG(홀인원 결산)에서도 쓰임 ann_shot 스윙했을 때 나는 소리들 (굿샷, 나이스어프로치, 나이스온, 나이스플레이, 나이스샷)\nSoundType: 인게임\n모두 ShotResult. 로 시작함\nReplayState, U2GolfGameSoundComponent, UIIngameStrokePage에 종속\nann_crash와 거의 같음. ambient UU2GolfGameSoundComponent에 귀속\nSoundType: 인게임 ball_crash BallCollidedDataTable에서 참조\nSoundType: 인게임 bgm BGM\nSoundType: BGM button 버튼 클릭 소리 SoundType: Common event 이벤트 소리\n애니메이션에 넣지 못하는 소리 (분기처리 때문에 코드로 출력해야하는 사운드)\n코드로 호출\nSoundType: Common 또는 인게임 gallery 갤러리 사운드 (박수, 환호, 야유)\n인게임 swing_shot 클럽별 임팩트 소리\n인게임 swing_control - 전부 인게임 스윙게이지 소리\n인게임 animation UMG 애니메이션에 넣는 소리\nSoundType: Animation\n<br><img src=\"images/u2_soundtype.png\" target=\"_self\"> None\n사용 안함 표시 -&gt; 게임에서 사용하지 않겠다. In Game 게임 시작시에 로딩 됨\n게임중에만 사용\n스윙 임팩트, 스코어 사운드 등등\n코드로 호출 BGM BGM\n코드로 호출 Animation UMG에서 Animation - Audio Track에 추가할 사운드\n코드로 호출 불가 Common 버튼 클릭 사운드\n코드로 호출할 필요가 있는 사운드 (클럽, 의상 갓챠는 시네마틱 분기가 안되어서 어쩔 수 없이 여기 넣음)\n코드 호출 가능 U2SoundManager 클래스는 게임 내 사운드 관리를 담당합니다. Init() 메서드를 통해 초기화되며, 다음과 같은 작업을 수행함 메시지 매니저 초기화 사운드 테이블 로드 콘솔 명령어 설정 (에디터 모드에서만) void UU2SoundManager::Init()\n{ InitMessageManager(); LoadSoundTable(); #if WITH_EDITOR // 에디터에서만 콘솔 명령어 설정 if (CMD_LogSound == nullptr) { CMD_LogSound = UU2ConsoleManager::Instance()-&gt;RegisterConsoleCommand( DEF_CSC_LOG_SOUND, TEXT(\"테스트용: 사운드 로그\"), FConsoleCommandWithArgsDelegate::CreateUObject(this, &amp;UU2SoundManager::CONSOLE_LogSound), ECVF_Default ); } #endif\n} 등록된 콘솔 명령어는 런타임에서 사용할 수 있음.U2.Log.Sound 0 - Sound 로그 가리기U2.Log.Sound 1 - Sound 로그 보이기LoadSoundTable() SoundsDataTable의 모든 행을 읽음.각 행의 SoundType으로 각 사운드 에셋을 저장할 Map을 지정함.코드에서 None, Animation은 break; 처리함.None은 사용하지 않기 때문에 Map에 저장하지 않아도 되기 때문이고, Animation은 UMG에서 로드하고, 언로드하기 때문에 Map에 저장하지 않는다. (코드로 호출할 필요가 없기 때문)InGame, BGM, Common은 코드로 호출할 필요가 있기 때문에, 지정된 Map에 저장을 한다. 그 중 InGame 사운드는 사운드 큐를 넣을 곳 (Value) nullptr을 넣는다. 이유는 로비에서 InGame 사운드를 사용하지 않기 때문에 미리 로드하지 않기 때문이다. BGm, Common은 LoadSound를 하고 지정된 Map의 Value에 사운드 큐를 저장한다.void UU2SoundManager::LoadSoundTable()\n{ if (IsAlreadyCalling) { return; } IsAlreadyCalling = true; TArray&lt;FU2SoundDataTable*&gt; RowArray; UU2DBManager::Instance()-&gt;GetDataTableRows&lt;FU2SoundDataTable&gt;(TEXT(\"SoundsDataTable\"), RowArray); for (FU2SoundDataTable* it : RowArray) { switch (it-&gt;SoundType) { case EU2SoundType::None: break; case EU2SoundType::InGame: InGameSounds.Emplace(it-&gt;KeyValue, nullptr); break; case EU2SoundType::BGM: LoadSound(it-&gt;KeyValue, it-&gt;Sound, it-&gt;SoundType); break; case EU2SoundType::Animation: break; case EU2SoundType::Common: LoadSound(it-&gt;KeyValue, it-&gt;Sound, it-&gt;SoundType); break; default: break; } }\n} 인게임 사운드 로드와 언로드는 UU2RoundLoadingState와, UU2GameToLobbyState에서 아래 함수를 통해서 이뤄진다.void UU2SoundManager::LoadInGameSounds()\n{ for (auto&amp; Elem : InGameSounds) { if (!Elem.Value) { FU2SoundDataTable* Row = UU2DBManager::Instance()-&gt;GetDataTableRow&lt;FU2SoundDataTable&gt;(TEXT(\"SoundsDataTable\"), FName(Elem.Key)); TSoftObjectPtr&lt;USoundBase&gt; SoundPtr(Row-&gt;Sound); LoadSoundInternalAsync(Elem.Key, SoundPtr, EU2SoundType::InGame); } }\n} void UU2SoundManager::UnloadGameOnlySounds()\n{ for (auto&amp; Elem : InGameSounds) { if (Elem.Value) { Elem.Value = nullptr; OutGameSounds.Remove(Elem.Key); } }\n} Audio Stream Caching은 Unreal Engine에서 오디오 성능을 최적화하기 위한 기능 효과 쿡 타임에서 이 기능을 활성화하면 거의 모든 압축 오디오 데이터가 USoundWave 자산에서 분리되어 .pak 파일의 끝에 배치됨. 이를 통해 오디오가 어느 시점에서든 메모리에 로드되고 최근에 사용되지 않았을 때 다시 해제되는 것이 가능 Audio Stream Caching 사용법 각 Platform → iOS / Android → Audio → CookOverrides → Use Stream Caching\nMax Cache Size 설정 Prime On Load 적용 Sound 재생 초기 부분을 미리 메모리에 올린다 → 재생 지연 방지 Sound Class - Loading 에서 적용 가능 BGM: 코드로 출력 (보통 State에서 출력함)Animation: UMG에서 오디오 트랙을 이용해서만 호출 (코드로 호출 X) In Game: 코드로 호출\nswing impact, crash 등등: 코드로만 호출\nIngame UI: UMG 오디오 트랙으로 호출 가능Common\n현재는 코드로 호출\n추후 BP를 이용해서 호출할 예정\n적용 전\n로비, 게임: 132.275 MiB<br>\n<img src=\"images/insight_before.png\" target=\"_self\">\n적용 후 (Audio Stream Caching 사용)\nLobby ~ InGame 결과\n초기화 ~ Lobby ~ 인게임: 132.275 MiB → 20~ 30 MiB (감소율 81.01%)<br>\n<img src=\"images/insight_after.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"목차","level":2,"id":"목차_0"},{"heading":"개요","level":2,"id":"개요_0"},{"heading":"Content 폴더 구조","level":2,"id":"Content_폴더_구조_0"},{"heading":"Ann","level":4,"id":"Ann_0"},{"heading":"U2SoundDataTable - SoundType 카테고리","level":2,"id":"U2SoundDataTable_-_SoundType_카테고리_0"},{"heading":"U2SoundManager - Init, Load","level":2,"id":"U2SoundManager_-_Init,_Load_0"},{"heading":"Init","level":4,"id":"Init_0"},{"heading":"Load &amp; UnLoad","level":4,"id":"Load_&_UnLoad_0"},{"heading":"Audio stream caching 적용","level":2,"id":"Audio_stream_caching_적용_0"},{"heading":"Sound 출력 Rule","level":2,"id":"Sound_출력_Rule_0"},{"heading":"결과","level":2,"id":"결과_0"}],"links":[],"author":"","coverImageURL":"images/foldering_to_be.png","fullURL":"ue/sounds-개선.html","pathToRoot":"..","attachments":["images/foldering_to_be.html","images/u2_soundtype.html","images/insight_before.html","images/insight_after.html"],"createdTime":1730808631709,"modifiedTime":1735576991430,"sourceSize":7892,"sourcePath":"UE/Sounds 개선.md","exportPath":"ue/sounds-개선.html","showInTree":true,"treeOrder":441,"backlinks":[],"type":"markdown"},"ue/ue4-source-ios-debugging-on-macos.html":{"title":"UE4 Source iOS Debugging on MacOS","icon":"","description":"$ sudo chmod -R 755 ./\nSetup.command는 엔진을 빌드하기 위한 의존성 컨텐트(PhysX, Make, Cmake etc.. ) 를 다운로드 합니다.(binary content for engiene)overwrite 할 것이냐고 묻는데 N 눌러야 합니다.(만약 덮어쓸 경우 PhysX iOS 라이브러리 뽑아서 덮어쓴 다음에 엔진 빌드 해야함)Engine Source를 빌드하는 IDE를 설정합니다. 기본적으로 값이 없거나 보통 VisualStudio로 되어 있습니다.$ vim {Engine Source}/Engine/Config/BaseEditorSetting\n# BaseEditorSettings.ini ... [/Script/SourceCodeAccess.SourceCodeAccessSettings] PreferredAccessor=XCodeSourceCodeAccessor\n엔진 워크 스페이스를 생성합니다.엔진 워크스페이스를 열고 타겟을 ShaderCompileWorker 변경하고 로제타를 이용해서 빌드합니다. 그런 다음에 타겟을 UE4로 변경 후 역시 로제타를 이용해서 빌드 합니다. 빌드가 성공하면 엔진 빌드 성공입니다.로제타 빌드가 없는 경우는'Xcode -&gt; Product -&gt; destination -&gt; Destination Archtectures -&gt; show rosseta destination'를 확인해서 체크하기맥에서 빌드를 하고 iOS 기기로 디버깅을 하기 위해서는 몇가지 번거로운 작업을 해야합니다. 먼저 Windows에서 필요한 작업이 있습니다. 윈도우 데스크탑에서 아래 경로 폴더들을 맥으로 가져옵니다.{프로젝트 경로}/Intermediate/IOS(info.plist 제외)\n{프로젝트 경로}/Intermediate/Plugins (NativizedAssets)\n그런 다음에 리모트 빌드를 하고 .ipa 파일을 뽑고 맥으로 가져옵니다.$ cd {엔진 소스 경로}/Build/BatchFiles/Mac\n$ ./GenerateProjectFiles.sh -project={프로젝트 경로}/{프로젝트}.uproject -game\n프로젝트를 생성하면 Intermediate 폴더가 생기는데 Intermediate안에 위에서 가져온 폴더들을 넣습니다.그러고나서 타겟을 프로젝트로 바꾸고 Edit Scheme을 눌러서 Run을 클릭하고 Configuration을 Debug Game으로 바꿉니다. iOS 기기를 연결하고 빌드 합니다.위에서 리모트 빌드로 뽑은 .ipa 파일을 .zip 확장자로 바꿉니다. unzip을 한 후 Payload-{프로젝트}.app을 클릭하고 Show package contents를 클릭합니다.$ cd {프로젝트소스}/Binaries/iOS/Payload\n마찬가지로 .app에 Show package contents를 클릭하고 누락된 부분(cookeddata등)을 복사, 붙여넣기를 합니다.그런 다음에 빌드를 하고 XCode에서 Debug - Attach to Process를 클릭해서 중단점 찍어서 디버깅할 수 있게 됩니다.$ sudo chmod -R 755 ./\nPermission Denied 시에 권한을 줘야함 Setup.command는 여러 스크립트를 실행 시키므로각 스크립트에\n권한을 줘야함.\nOS 자체적으로 막는 경우는 System preference에서 GateKeeper 검색하고 Open anyway 클릭함\nChecking dependencies...\nUpdating dependencies: 0% (0/63485)...\nFailed to download '<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94\" target=\"_self\">http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94</a>': The remote server returned an error: (403) Forbidden. (WebException)\n이 경우에 Engine/Build/Commit.gitdeps.xml을 적절한 버전의 Engine/Build/Commit.gitdeps.xml으로 교체예를 들어 Unreal 4.27 같은 경우는 Unreal Engine Github의 4.27-plus 브랜치를 받으면 됨\nRunning bundled mono, version: Mono JIT compiler version 5.16.0.220 (2018-06/bb3ae37d71a Fri Nov 16 17:12:11 EST 2018)\nThe domain/default pair of (com.epicgames.ue4, MonoAOT) does not exist\nWARNING: Visual Studio C++ 2019 installation not found - ignoring preferred project file format.\nWhile compiling /Users/choeseung-in/Desktop/GolfzonMEngineSource/Engine/Intermediate/Build/BuildRules/UE4Rules.dll:\n../Plugins/GSDevices/CardReader/Source/CardReader/CardReader.Build.cs(58,10) : warning CS0219: The variable `RfdllIncludePath' is assigned but its value is never used\nGenerating data for project indexing...\nCouldn't find PLCrashReporter in folder 'lib-Xcode-14.1', using default 'lib-Xcode-12.4'\nGenerating data for project indexing... 100%\nWriting project files... 0%\nERROR: Visual Studio 2017 must be installed in order to build this target.Saving session...completed.\nSource Code를 빌드하는 IDE에 대한 오류 Engine/Config/BaseEditorSettings.ini에 있는 [/Script/SourceCodeAccess.SourceCodeAccessSettings] 설정이 VisualStudio라서 발생한 이슈Mac에서는 Xcode로 설정 해야함[/Script/SourceCodeAccess.SourceCodeAccessSettings] PreferredAccessor=XCodeSourceCodeAccessor\n// Engine/Source/Runtime/Engine/Private/Components/DeferredRoadComponent.cpp // TAtomic&lt;int&gt; OverlapCounter = 0;\nint32 OverlapCounter = 0; // Engine/Source/Editor/UnrealEd/Private/EditorEngine.cpp int32 XIndex = FString(PackageName).Find(TEXT(\"_X\"), ESearchCase::IgnoreCase, ESearchDir::FromEnd); int32 YIndex = FString(PackageName).Find(TEXT(\"_Y\"), ESearchCase::IgnoreCase, ESearchDir::FromEnd);\n// Engine/Source/Editor/TranslationEditor/Private/TranslationEditor.cpp if (!((AssetData.PackageFlags &amp; (PKG_ContainsMap | PKG_PlayInEditor | PKG_ContainsMapData)) == 0)) { OutFailureReason = FString::Printf(TEXT(\"The AssetData '%s' is not accessible because it is of type Map/Level.\"), *ObjectPath); return FAssetData(); }\nShowing All Messages\nUndefined symbols for architecture arm64:\n\"PxSetGSConfPxGSConf const&amp;\", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; \"PxSetCoefftablesPxCoefftableSource*\", referenced from:&nbsp;\nUPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; \"PxSetHolecupRadius(float)\", referenced from: &nbsp; &nbsp; &nbsp; UHoleContext::UpdateHole(unsigned char, EGreenType, EHoleType, FVector) in Module.U1Engine.cpp.o&nbsp; \"PxSetGreenSpeedTypeGZGreenSpeedType\", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::UpdateGreenSpeedTypeGZGreenSpeedType in Module.U1Engine.cpp.o&nbsp; \"PxSetHolecupPositionPxVec3 const&amp;\", referenced from:&nbsp; &nbsp; &nbsp; UHoleContext::UpdateHole(unsigned char, EGreenType, EHoleType, FVector) in Module.U1Engine.cpp.o &nbsp; \"PxSetSurfacetypeTablePxGSSurfacetypeTable*\", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; \"PxSetWindPxVec3 const&amp;\", referenced from: &nbsp; &nbsp; &nbsp; UHoleContext::SetWind(FVector2D const&amp;) in Module.U1Engine.cpp.old: symbol(s) not found for architecture arm64\nModule.U1Engine.cpp.o의 심볼을 확인할 때, PxSetGS... 같이 커스텀한 함수를 호출함. 근데, Engine은 PxSetGS 함수를 알지 못함.\n$ cd&nbsp;{엔진소스}/Engine/Source/ThirdParty/PhysX3/Lib/IOS\n$ nm libPxFoundationDEBUG.a\n그리고 PxSetGS를 검색 -&gt; 심볼이 있으면 엔진 XCode DerivedData 삭제, 클린 빌드 후 엔진 리빌드, 프로젝트 재생성심볼이 없는 경우 PhysX를 빌드하고 Binary를 교체한 후에 위의 과정을 따라감NativizedAssets 관련 - 프로젝트 Run 이후<br><img alt=\"NativizedAssets.png\" src=\"images/nativizedassets.png\" target=\"_self\">Blueprint로 작성한 내용들이 Native 코드로 변환되는 작업이 있음. 이를 윈도우에서 Intermediat/Plugin/IOS에서 가져 와야함.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"스크립트 실행 권한주기","level":3,"id":"스크립트_실행_권한주기_0"},{"heading":"Setup.sh 실행","level":3,"id":"Setup.sh_실행_0"},{"heading":"Engine Config 변경","level":3,"id":"Engine_Config_변경_0"},{"heading":"GenerateProjectFiles.sh 실행","level":3,"id":"GenerateProjectFiles.sh_실행_0"},{"heading":"Engine Build","level":3,"id":"Engine_Build_0"},{"heading":"프로젝트 빌드","level":3,"id":"프로젝트_빌드_0"},{"heading":"Errors","level":2,"id":"Errors_0"},{"heading":"Error 1 - Setup.command","level":4,"id":"Error_1_-_Setup.command_0"},{"heading":"Error 2 - Setup.commnad","level":4,"id":"Error_2_-_Setup.commnad_0"},{"heading":"Error 3 - GenerateProjectFiles.command 실행 시","level":4,"id":"Error_3_-_GenerateProjectFiles.command_실행_시_0"},{"heading":"Error 4 - 타겟 UE4 빌드시 컴파일 에러","level":4,"id":"Error_4_-_타겟_UE4_빌드시_컴파일_에러_0"},{"heading":"Error 6","level":3,"id":"Error_6_0"},{"heading":"Error 7","level":3,"id":"Error_7_0"}],"links":[],"author":"","coverImageURL":"images/nativizedassets.png","fullURL":"ue/ue4-source-ios-debugging-on-macos.html","pathToRoot":"..","attachments":["images/nativizedassets.html"],"createdTime":1710855209758,"modifiedTime":1735573377567,"sourceSize":8053,"sourcePath":"UE/UE4 Source iOS Debugging on MacOS.md","exportPath":"ue/ue4-source-ios-debugging-on-macos.html","showInTree":true,"treeOrder":442,"backlinks":[],"type":"markdown"},"ue/ue4.27-ios-background-앱-크래쉬.html":{"title":"UE4.27 iOS Background 앱 크래쉬","icon":"","description":"<a href=\".?query=tag:unreal\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#unreal\">#unreal</a> <a href=\".?query=tag:error\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#error\">#error</a> 게임을 실행하고 플레이한다.\n앱을 백그라운드로 전환한다.\n일정 시간 지난 후에 (시간은 각각 다양합니다.) 앱을 켭니다.\n앱 크래쉬 발생 렌더 스레드를 Flush 하고 suspend 하는 생성자\n생성자 - 렌더링 스레드를 없애고 재생성할 지, 단순 일시정지인 지 결정\n// 렌더링 스레드가 일시 중단되는 동안 렌더링 명령 대기열을 시작하지 않도록 비동기 로드 스레드를 일시 중단합니다.\nif (IsAsyncLoadingMultithreaded())\n{ SuspendAsyncLoading();\n} Async Loading Thread는 렌더링에 필요한 리소스를 비동기적으로 로딩하고 사용하지 않는 리소스들을 언로드한다.앱이 백그라운드 전환시에 렌더링 스레드 일시 중지 -&gt; 비동기 로딩 중단 -&gt; 비동기 로딩 기다림 -&gt; 크래쉬앱이 Background 갈 때 FAppEntry::Suspend(true) -&gt; 스레드 중지\n앱이 Foreground로 다시 돌아와서 팝업을 열어야 하는데 Async Loading Thread가 중지되어 있는 상태팝업을 여는 코드에서 Load Package를 하는 부분이 있는데 이때 ALT를 이용. 따라서 ALT가 돌지 않고 메인스레드는 ALT를 기다리고 있기 때문에 Stall 발생\n프로젝트 세팅에서 비동기화 로딩 스레드 끔 -&gt; 앱 크래쉬는 나지 않으나, 게임스레드가 모든 Asset을 로딩해서 속도 이슈가 있을 수 있음 ApplicationHasEnteredForegroundDelegate를 사용하지 말기(?) IOSAppDelegate.cpp\napplicationDidEnterBackground\napplicationWillEnterForeground\napplicationDidBecomeActive\n가 존재합니다. 각각 백그라운드로 갔을 때, Foreground로 돌아올 때 그리고 화면이 완전히 Active 되었을 때 호출되고 이는 각자 순서대로 호출함\nFIOSCoreDelegates::ApplicationWillEnterBackgroundDelegate\nFIOSCoreDelegates::ApplicationHasEnteredForegroundDelegate\nFIOSCoreDelegates.OnDidBecomeActive\nApplicationHasEnteredForegroundDelegate를 사용하지 말고 OnDidBecomeActive 하면됨.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"순서","level":3,"id":"순서_0"},{"heading":"배경 지식","level":5,"id":"배경_지식_0"},{"heading":"앱 죽는 이유 분석","level":3,"id":"앱_죽는_이유_분석_0"},{"heading":"해결 방법","level":3,"id":"해결_방법_0"}],"links":["?query=tag:unreal","?query=tag:error"],"author":"","coverImageURL":"","fullURL":"ue/ue4.27-ios-background-앱-크래쉬.html","pathToRoot":"..","attachments":[],"createdTime":1710855209758,"modifiedTime":1737703695333,"sourceSize":2189,"sourcePath":"UE/UE4.27 iOS Background 앱 크래쉬.md","exportPath":"ue/ue4.27-ios-background-앱-크래쉬.html","showInTree":true,"treeOrder":443,"backlinks":[],"type":"markdown"},"ue/ugameplaystatics.html":{"title":"UGameplayStatics","icon":"","description":"UGameplayStatics는 Unreal Engine에서 제공하는 유틸리티 클래스로, 게임플레이와 관련된 다양한 정적(static) 함수들을 포함하고 있습니다. 이 클래스는 게임 개발 시 자주 사용되는 여러 기능들을 쉽게 접근할 수 있게 해줍니다. 주요 기능들은 다음과 같습니다:\n게임 관리: GetGameMode, GetGameState, GetGameInstance 등을 통해 현재 게임의 주요 객체들에 접근\nOpenLevel을 통해 새로운 레벨 로드 플레이어 관리: GetPlayerController, GetPlayerCharacter, GetPlayerPawn 등을 통해 플레이어 관련 객체에 접근\nCreatePlayer를 통해 새로운 플레이어 생성 액터 관리: SpawnActor를 통해 새로운 액터 스폰\nGetAllActorsOfClass를 통해 특정 클래스의 모든 액터 찾기 사운드 및 오디오: PlaySound2D, PlayDialogueAtLocation 등을 통해 사운드 재생 시간 관리: GetTimeSeconds, GetRealTimeSeconds 등을 통해 게임 시간 정보 얻기 저장 및 로드: SaveGameToSlot, LoadGameFromSlot 등을 통해 게임 저장 및 로드 물리 및 추적: LineTraceSingleByChannel 등을 통해 물리적 충돌 검사 UI 및 HUD: GetPlayerCameraManager를 통해 카메라 관리자에 접근\nProjectWorldToScreen을 통해 3D 위치를 2D 스크린 좌표로 변환 디버깅: PrintString을 통해 화면에 디버그 메시지 출력 이러한 기능들을 통해 UGameplayStatics는 게임 개발 과정에서 자주 필요한 작업들을 편리하게 수행할 수 있게 해줍니다. 특히 이 클래스의 함수들은 대부분 정적이므로, 객체를 생성하지 않고도 직접 호출할 수 있어 사용이 간편합니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ue/ugameplaystatics.html","pathToRoot":"..","attachments":[],"createdTime":1724571717955,"modifiedTime":1724571717956,"sourceSize":1796,"sourcePath":"UE/UGameplayStatics.md","exportPath":"ue/ugameplaystatics.html","showInTree":true,"treeOrder":444,"backlinks":[],"type":"markdown"},"ue/ui-애니메이션.html":{"title":"UI 애니메이션","icon":"","description":"언리얼엔진은 UMG에서 각 UI Component에 대해서 애니메이션을 설정할 수 있음UI Component의 종류에 따라 제공하는 애니메이션이 다름.Border의 경우 Content Color and Opacity와 Transform 등 같은 요소 애니메이션을 제공함.Image 같은 경우는 Brush.Brush.Material와 같은 머터리얼을 이용한 애니메이션을 제공함.머터리얼을 이용하면 단순한 색상이나 이미지 이상의 복잡한 시각 효과를 UI 요소에 적용할 수 있음.머터리얼을 이용한 애니메이션 예시\n동적인 색상 변화\n텍스처 블렌딩\n애니메이션 효과\n특수 셰이더 효과\nUI 전환을 만들수도 있음.\n페이드 인/아웃 효과\n디졸브 전환\n색상 변화를 통한 상태 표시 Blend Type은 머티리얼이 다른 머티리얼이나 배경과 어떻게 상호작용 하는지를 정의함\nBlend Type은 전환효과의 시각적 특성에 큰 영향을 줌.\n세가지 타입이 존재 Additive: 머티리얼의 색상 값을 기존 배경에 더합니다.\n주로 밝은 효과나 빛나는 요소를 추가할 때 사용\n글로우 효과나 하이라이트 애니메이션에 적합\nEx. 버튼에 마우스를 올렸을 때 발생하는 글로우 효과 Additive from Base: 기본 색상(Base Color)을 시작점으로 사용\n머티리얼의 색상이 기본 색상에서 시작하여 추가되는 방식으로 블렌딩\n기존 UI 요소에 점진적으로 밝아지는 효과를 줄 때 유용\nEx. UI 패널이 점점 밝아지는 강조 효과 Absolute: 머티리얼의 색상을 있는 그대로 표시\n배경이나 다른 요소와의 블렌딩 없이 머티리얼의 색상이 그대로 적용\n완전히 불투명한 UI 요소나 배경을 덮는 전체 화면 효과에 사용\nEx. 전체 화면 페이드 인/아웃 전환 효과 두 키프레임 사이의 값을 어떻게 계산할지 결정. 총 세가지 타입. Linear: 선형 보간\nConstant: 다음 키 프레임까지 값 유지\nCubic: 부드러운 곡선 사용 즉 Linear, Constant인 경우에는 Tangent가 필요 없음. Cubic인 경우 부드러운 곡선 보간을 한다는 것인데 부드러운 곡선을 어떻게 제어하냐 그 방식이 바로 Tangent임\n키프레임 사이의 Interpolation 방식을 결정\nInterpolation(보간)이란? 데이터 지점들 사이의 새로운 데이터 지점을 구하는 방법 다음과 같은 옵션이 존재 (Smart) Auto: 시스템이 자동으로 가장 적절한 탄젠트를 계산\n부드러운 애니메이션에 적합하지만, 세밀한 제어는 어려움 Linear: 키프레임 사이를 직선으로 연결\n움직임이 일정하고 기계적인 느낌을 줌\n예시 UI 요소가 1초 동안 100%에서 200%로 커지는 애니메이션\nLinear Tangent: 0.5초 지점에서 정확히 150% 크기가 됨 Constant: 키프레임 사이에 변화가 없음. 다음 키프레임에서 갑자기 변함\n순간적인 변화나 디지털 효과에 유용 User: 사용자가 직접 탄젠트를 조절할 수 있음\n가장 세밀한 제어가 가능하지만, 설정에 시간이 걸림 Break: 입력(In)과 출력(Out) 탄젠트를 독립적으로 조절 가능\n복잡한 움직임을 만들 때 유용함 양수 값: 커브가 키프레임에서 위로 올라감\n음수 값: 커브가 키프레임에서 아래로 내려감\n0: 커브가 키프레임에서 평평해짐\n값의 크기에 따른 영향: 높은 값 급격한 변화\n애니메이션이 빠르게 시작하거나 끝남 낮은 값 부드러운 변화\n애니메이션이 천천히 시작하거나 끝남\n느린 가속 또는 감속 효과 Arrive Tangent 키프레임에 도착할 때의 탄젠트 값 Leave Tangent 키프레임에서 탈출할 때의 탄젠트 값 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Blend Type이란?","level":4,"id":"Blend_Type이란?_0"},{"heading":"Interp Mode","level":4,"id":"Interp_Mode_0"},{"heading":"Tangent","level":4,"id":"Tangent_0"},{"heading":"Tangent 값의 의미","level":4,"id":"Tangent_값의_의미_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/ui-애니메이션.html","pathToRoot":"..","attachments":[],"createdTime":1724571717940,"modifiedTime":1724571717940,"sourceSize":4184,"sourcePath":"UE/UI 애니메이션.md","exportPath":"ue/ui-애니메이션.html","showInTree":true,"treeOrder":445,"backlinks":[],"type":"markdown"},"ue/umg-클래스에-delegate-추가하기.html":{"title":"UMG 클래스에 Delegate 추가하기","icon":"","description":"\n목표: UMultiLineEditableTextBox에 FOnFocusReceviced와 FOnFocusLost를 구현하기\nUMultiLineEditableTextBox은 SMultiLineEditableTextBox를 래핑하고 있다. SMultiLineEditableTextBox는 SMultiLineEditableText를 내부적으로 사용하고 있다. 이벤트 전파 체인 이해 따라서 SMultiLineEditableText - &gt; SMultiLineEditableTextBox -&gt; UMultiLineEditableTextBox 체인을 따라 포커스 이벤트가 전파된다. 각 단계에서 처리하고 상위 레벨로 전달함. SMultiLineEditableText 수정 실제 텍스트 편집 기능 담당\n포커스 이벤트가 발생하는 가장 하위 레벨\nSlate Event 추가\nOnFocusReceived와, OnFocusLost 델리게이트를 추가 (.h에)\ncpp에서 construct()에서 값 할당 OnFocusReceivedDelegate = InArgs._OnFocusReceivedDelegate;\nOnFocusLostDelegate = InArgs._OnFocusLostDelegate; SWidget Interface의 OnFocusReceived, OnFocusLost 오버라이딩 후에 그곳에서 이벤트 Execute 하기 virtual FReply OnFocusReceived(const FGeometry&amp; MyGeometry, const FFocusEvent&amp; InFocusEvent) override;\nvirtual void OnFocusLost(const FFocusEvent&amp; InFocusEvent) override; SMultiLineEditableTextBox 수정 SMultiLineEditableText를 포함하는 컨테이너 역할\nSMultiLineEditableText의 포커스 이벤트를 받아 상위로 전달\nUMultiLineEditableTextBox와 직접 연결되는 Slate 레벨의 위젯 UMultiLineEditableTextBox 수정 UMG 레벨의 위젯으로 BP에서 사용 가능\nSMultiLineEditableTextBox의 포커스 이벤트를 받아 BP 이벤트로 변환 캡슐화와 책임 분리: 각 레벨의 위젯이 자신의 역할에 맞는 기능만 담당합니다. SMultiLineEditableText는 실제 편집 기능을, SMultiLineEditableTextBox는 컨테이너 역할을, UMultiLineEditableTextBox는 UMG 연동을 담당 유연성: 각 레벨에서 포커스 이벤트를 처리할 수 있어, 필요에 따라 다양한 방식으로 대응할 수 있음 일관성: 언리얼 엔진의 기존 위젯 구조와 일관성을 유지 가능. 다른 위젯들도 비슷한 구조로 이벤트를 처리. 확장성: 나중에 추가적인 기능이나 이벤트가 필요할 때 각 레벨에서 쉽게 확장할 수 있음. 블루프린트 지원: UMultiLineEditableTextBox에서 UPROPERTY와 UFUNCTION을 사용하여 블루프린트에서도 이 이벤트를 쉽게 사용할 수 있음. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UMG 클래스에 Delegate 추가하기","level":2,"id":"UMG_클래스에_Delegate_추가하기_1"},{"heading":"이러한 방식의 구현이 나쁘지 않은 이유?","level":3,"id":"이러한_방식의_구현이_나쁘지_않은_이유?_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/umg-클래스에-delegate-추가하기.html","pathToRoot":"..","attachments":[],"createdTime":1724571717956,"modifiedTime":1724571717956,"sourceSize":2618,"sourcePath":"UE/UMG 클래스에 Delegate 추가하기.md","exportPath":"ue/umg-클래스에-delegate-추가하기.html","showInTree":true,"treeOrder":446,"backlinks":[],"type":"markdown"},"ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html":{"title":"Unreal Engine만의 기본 타입이 있는 이유와 문자열","icon":"","description":" 언리얼 엔진에서 int32와 같은 언리얼 엔진 데이터형이 따로 있는 이유는 다양한 플랫폼에 대응하기 때문이다.\n언리얼은 문자 인코딩 방식 UTF-16을 사용하고 있음. 이것도 역시 다양한 플랫폼을 위해서..\n윈도우는 CP949를 사용해서 언리얼엔진에서 한글 사용시 깨진다. 소스코드를 UTF-8로 저장하면 한글 제대로 나온다.유니코드를 위한 언리얼 표준 Character 타입은 TCHAR이다.\n언리얼 엔진에서 문자열을 사용할 때 TEXT 매크로를 사용해 생성하고 다뤄야한다.\nTEXT 매크로로 감싸면 TCHAR 배열로 만들어짐!FString은 단순하게 TCHAR를 가르키고 있는 포인터임. 그래서 FString을 출력하고 싶으면 디레퍼런스 연산자 *를 사용해야함.FString을 자르거나, 찾거나 등 문자열을 다루는 함수들은 내부적으로 FCString으로 타입이 변환한 후 처리된다. 이는 저수준의 C 함수를 사용해야하기 때문이다. 실제로 Atoi나 Atof 같은 함수를 사용하기 위해서는 FCString을 이용한다. #include \"MyGameInstance.h\"\nvoid UMyGameInstance::Init()\n{ Super::Init(); TCHAR LogCharArray[] = TEXT(\"Hello World\"); UE_LOG(LogTemp, Log, TEXT(\"%s\"), LogCharArray); FString LogCharString = LogCharArray; UE_LOG(LogTemp, Log, TEXT(\"%s\"), *LogCharString); const TCHAR* LongCharPtr = *LogCharString; UE_LOG(LogTemp, Log, TEXT(\"%s\"), LongCharPtr); TCHAR* LogCharDataPtr = LogCharString.GetCharArray().GetData(); UE_LOG(LogTemp, Log, TEXT(\"%s\"), LogCharDataPtr); TCHAR LogCharArrayWithSize[100]; FCString::Strcpy(LogCharArrayWithSize, LogCharString.Len(), *LogCharString); UE_LOG(LogTemp, Log, TEXT(\"%s\"), LogCharArrayWithSize); // Find, Slice if (LogCharString.Contains(TEXT(\"World\"), ESearchCase::IgnoreCase)) { int32 Index = LogCharString.Find(TEXT(\"World\"),ESearchCase::IgnoreCase); FString EndString = LogCharString.Mid(Index); UE_LOG(LogTemp, Log, TEXT(\"Find Test: %s\"), *EndString); } FString Left, Right; if (LogCharString.Split(TEXT(\" \"), &amp;Left, &amp;Right)) { UE_LOG(LogTemp, Log, TEXT(\"%s and %s\"), *Left, *Right); } // Int, Float -&gt; String int IntValue = 32; float FloatValue = 3.141592; // 스트링으로 전환 FString FloatIntString = FString::Printf(TEXT(\"Int: %d, Float: %f\"), IntValue, FloatValue); FString FloatString = FString::SanitizeFloat(FloatValue); FString IntString = FString::FromInt(IntValue); UE_LOG(LogTemp, Log, TEXT(\"%s\"), *FloatIntString); UE_LOG(LogTemp, Log, TEXT(\"Int:%s, Float:%s\"), *IntString, *FloatString); int32 IntValueFromString = FCString::Atoi(*IntString); float FloatValueFromString = FCString::Atof(*FloatString); FString FloatIntFromString = FString::Printf(TEXT(\"Int: %d, Float: %f\"), IntValueFromString, FloatValueFromString); UE_LOG(LogTemp, Log, TEXT(\"%s\"), *FloatIntFromString); // FNAME // 에셋관리를 위한 것 // 대소문자 구분 x // 한번 선언되면 바꿀 수 없음 key로 만들어짐 Key - Vlaue // 팁 // 위의 코드는 overhead 발생 -&gt; 아래코드 staticonyonce를 이용하기 for (int i = 0; i &lt; 10000; ++i) { FName SerachInNamePool = FName(TEXT(\"pelvis\")); const static FName StaticOnlyOnce(TEXT(\"pelvis\")); } ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html","pathToRoot":"..","attachments":[],"createdTime":1710855209758,"modifiedTime":1710855209758,"sourceSize":3335,"sourcePath":"UE/Unreal Engine만의 기본 타입이 있는 이유와 문자열.md","exportPath":"ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html","showInTree":true,"treeOrder":447,"backlinks":[],"type":"markdown"},"ue/upl.html":{"title":"UPL","icon":"","description":"UPL은 언리얼 엔진에서 플랫폼별 네이티브 코드와 설정을 통합하기 위한 XML 기반의 스크립팅 언어입니다. 주로 Android와 iOS 플랫폼에서 사용되며, 빌드 과정에서 플랫폼별 설정을 자동으로 적용할 수 있게 해줍니다.\n네이티브 라이브러리 통합시 (jar, aar, framework)\n플랫폼별 권한 및 설정 Android Manifest\niOS info.plist Android proguardAdditions - Proguard 난독화 규칙 추가\nandroidManifestUpdates - 권한, 액티비티, 서비스, 리시버 등 추가 / 수정\nbuildscriptGradleAdditions - 플러그인 클래스패스, 저장소\nbuildGradleAdditions - 앱 레벨 build.gradle 파일을 수정\ngameActivityImportAdditions - GameActivity.java 파일에 import 구문을 추가\ngradleProperties - gradle.properties 파일을 수정, 주로 빌드 설정, 메모리 옵션, 프로젝트 전역 변수 설정 iOS iosPListUpdates - info.plist 값 업데이트 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"UPL이란?","level":3,"id":"UPL이란?_0"},{"heading":"when to use","level":3,"id":"when_to_use_0"},{"heading":"주요 태그","level":3,"id":"주요_태그_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/upl.html","pathToRoot":"..","attachments":[],"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":1078,"sourcePath":"UE/UPL.md","exportPath":"ue/upl.html","showInTree":true,"treeOrder":448,"backlinks":[],"type":"markdown"},"ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html":{"title":"내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유","icon":"","description":"기본적으로 내비게이션 영역은 내비게이션 메쉬가 커버하고 있는 영역 중에서 월드의 충돌 지오메트리를 통해 길찾기 영역이 설정됩니다. 그리고 내비게이션 메시를 타일로 분할하기 때문에 벽은 영역에 표시되지 않습니다. 그리고 내비게이션 메시는 폴리곤으로 구성되고 각 폴리곤에 비용이 할당되는데, 이를 이용해 비용이 가장 낮은 최적의 경로를 찾으려고 시도합니다. 폴리곤에 할당하는 비용을 조절함으로써 고도화된 내비게이션 시스템을 만들 수 있습니다.<img alt=\"Navigation.png\" src=\"images/navigation.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/navigation.png","fullURL":"ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html","pathToRoot":"..","attachments":["images/navigation.html"],"createdTime":1735577795303,"modifiedTime":1735577949194,"sourceSize":644,"sourcePath":"UE/내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유.md","exportPath":"ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html","showInTree":true,"treeOrder":449,"backlinks":[],"type":"markdown"},"ue/아틀라스.html":{"title":"아틀라스","icon":"","description":"-&gt; 여러개의 작은 이미지나 텍스쳐를 큰 이미지 파일로 만드는 것장점\n드로우콜 감소 - 여러개의 텍스쳐를 개별적으로 불러오는 것 대신 한번에 불러오니까 드로우 콜 감소시킬 수 있음\n메모리 사용 최적화 - 텍스처를 개별적으로 불러올 때 발생할 수 있는 메모리 낭비를 없애줌\n텍스처 스위칭 감소 - 동일한 드로우콜 내에서 다른 텍스처로 스위칭하는데 비용이 드는데 이 과정을 없앰\n배치처리 효율화 - 비슷한 유형의 많은 객체가 동일한 텍스처 아틀라스를 사용하는 경우, 이들을 함께 그룹화하여 배치 처리할 수 있습니다. 이는 렌더링 효율성을 높이고, CPU와 GPU 사이의 복잡한 상호작용을 줄일 수 있습니다.\n실제로 UMG에 생 이미지를 사용해서 3개의 이미지를 만든다면 Draw Call 3이고 Atlas를 사용하면 Draw Call이 1임.단점\n여러개의 텍스처를 하나의 아틀라스로 묶어야 하기 때문에 공격적인 압축이 필요함. 이는 세부 디테일이 흐려질수도 있음(화질 깨질 수도 있음)\n모든 텍스처가 동일한 해상도를 공유하기 때문에, 고해상도는 해상도를 낮춰야할 가능성이 있음\n사용되지 않는 부분의 아틀라스는 리소스 낭비\n큰 텍스처 아틀라스를 메모리에 로드할 때 각각 개별 로드하는 것보다 로드시간이 길 수 있음\n텍스처 스트리밍(MipMap) 동적으로 텍스처를 로드하고 언로드할 때 오바헤드가 있을 수 있음 UVMapping의 유연성- 텍스처 아틀라스를 사용하면, 개별 텍스처에 대한 UV 매핑을 조정하여 다양한 텍스처 조각을 사용할 수 있습니다. 이는 다양한 비주얼 효과를 생성하거나, 다양한 객체에 동일한 텍스처 아틀라스를 다르게 적용하여 리소스를 절약할 수 있는 방법을 제공합니다.\n아트 워크플로우 개선 - 아티스트들은 텍스처 아틀라스를 사용하여 텍스처 작업을 보다 효율적으로 관리할 수 있습니다. 특히, 게임 내에서 다양한 요소들이 비슷한 텍스처 스타일을 공유할 때, 아틀라스 하나를 업데이트함으로써 여러 개체의 비주얼을 일관되게 유지할 수 있습니다.\n텍스처를 Create Sprite -&gt; Sprite 클릭 -&gt; Atlas Group에 넣기밉맵은 동일한 텍스처의 여러 사전 계산된 버전을 작은 해상도로 점차 줄여 가며 저장하는 기법을 말합니다. 이렇게 하면, 3D 환경 내에서 물체가 더 멀리 있을 때, 더 작은 해상도의 텍스처를 사용하여 렌더링할 수 있습니다.\n성능 향상: 더 작은 해상도의 텍스처를 사용하면, 그래픽 처리 장치(GPU)의 부담이 줄어들어 렌더링 성능이 향상됩니다. 멀리 있는 객체에 고해상도 텍스처를 사용하는 것은 메모리와 처리 능력을 낭비하기 때문에, 밉맵을 사용하면 이러한 자원을 효율적으로 사용할 수 있습니다.\n시각적 품질 향상: 밉맵을 사용하면 텍스처의 해상도가 뷰포트와의 거리에 따라 동적으로 조정되므로, 텍스처 앨리어싱(계단 현상)이나 모아레 패턴 같은 시각적 아티팩트를 줄일 수 있습니다. 멀리 있는 객체에 대해 더 낮은 해상도의 텍스처를 사용함으로써, 더 부드럽고 자연스러운 이미지를 생성할 수 있습니다.\n미리 준비된 다양한 해상도 이미지를 준비하는 것객체가 화면에서 멀어질수록 이미지의 해상도를 동적으로 조절하여 사용\n가까이 -&gt; 고해상도\n멀리 -&gt; 저해상도밉맵은 언리얼엔진4에서는 텍스쳐가 Power of two인 경우에 자동으로 생성된다. 아닌 경우는 자동생성 안해준다. 그런데 5에서는 자동 생성해준다.여담으로 텍스쳐 압축기술인 DXT5는 Power of four인 경우에 적용된다.\n따라서 텍스쳐 크기는 안전하게 Power of two를 유지하는 것이 좋다.같은 이미지를 사용하는 UMG가 있을 때 아틀라스를 사용하는 것이 합리적이다. Draw Call을 줄여준다.\nDraw Call이 뭐야?\nDraw Call을 수동으로 부를 수 있을까?\nDraw Call이 적으면 무조건 좋은거야?\nUMG를 사용할 때 Draw Call을 줄이기 위해서 어떤 작업들을 해야할까?\n아틀라스를 사용하면 그러면 Draw Call이 1 보장되겠네? <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://drehzr.tistory.com/666\" target=\"_self\">https://drehzr.tistory.com/666</a> - 밉맵\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://coding-hell.tistory.com/78\" target=\"_self\">https://coding-hell.tistory.com/78</a> - 언리얼 UI 최적화하기\n<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://blog.nullbus.net/94\" target=\"_self\">https://blog.nullbus.net/94</a> - UMG Draw Call 분석하기\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"아틀라스란","level":3,"id":"아틀라스란_0"},{"heading":"UVMapping","level":3,"id":"UVMapping_0"},{"heading":"사용 방법","level":3,"id":"사용_방법_0"},{"heading":"밉맵","level":3,"id":"밉맵_0"},{"heading":"UMG와 Draw Call","level":3,"id":"UMG와_Draw_Call_0"},{"heading":"받은 피드백 및 다음 발표 주제","level":3,"id":"받은_피드백_및_다음_발표_주제_0"},{"heading":"Ref","level":3,"id":"Ref_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/아틀라스.html","pathToRoot":"..","attachments":[],"createdTime":1710855209758,"modifiedTime":1710855209758,"sourceSize":4880,"sourcePath":"UE/아틀라스.md","exportPath":"ue/아틀라스.html","showInTree":true,"treeOrder":450,"backlinks":[],"type":"markdown"},"ue/언리얼-패키징-관련-error.html":{"title":"언리얼 패키징 관련 Error","icon":"","description":"<a href=\".?query=tag:unreal\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#unreal\">#unreal</a> <a href=\".?query=tag:error\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#error\">#error</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted\" target=\"_self\">https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted</a> 보고 적용-&gt; provisioning과 certificate matching을 다시 한번 확인하기\n-&gt; 인증서와 모바일 프로비저닝 다시 임포트하기","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"패키징 안드 초기설정","level":3,"id":"패키징_안드_초기설정_0"},{"heading":"Cryptography Missing Keyset Error","level":3,"id":"Cryptography_Missing_Keyset_Error_0"}],"links":["?query=tag:unreal","?query=tag:error"],"author":"","coverImageURL":"","fullURL":"ue/언리얼-패키징-관련-error.html","pathToRoot":"..","attachments":[],"createdTime":1710855209771,"modifiedTime":1737703706174,"sourceSize":366,"sourcePath":"UE/언리얼 패키징 관련 Error.md","exportPath":"ue/언리얼-패키징-관련-error.html","showInTree":true,"treeOrder":451,"backlinks":[],"type":"markdown"},"ue/언리얼엔진에서의-lamda.html":{"title":"언리얼엔진에서의 Lamda","icon":"","description":"참조로 변수를 캡쳐하는데 람다가 실행되기 전에 해당 '객체'가 파괴되면 널 포인터 참조가 발생함. 이 현상이 언리얼엔진의 Deferred Execution(지연 실행), 비동기 작업, 생명주기 같은 것들과 맞물려서 위험할 수 있음. Prefer Capturing by Value\n가능하다면 참조 캡쳐보다 값 캡쳐를 사용할 것. 람다는 값을 복사해서 사용할 것이므로 독립적인 생명주기를 가지게 됨 Use TWeakObjectPtr\nUnreal 객체에 대한 포인터를 캡처할 때 raw 포인터 대신 TWeakObjectPtr를 사용하는 것. TWeakObjectPtr는 객체가 파괴되는 경우를 안전하게 처리하여 객체에 액세스하기 전에 객체가 여전히 유효한지 확인 Check for Validity\n캡쳐된 포인터나 레퍼런스에 접근하기 전에 nullptr 또는 TWeakObjectPtr를 체크한다. Using a Weak Lambda\nWeak Lamda를 사용하면 람다 내부의 객체를 안전하게 참조할 수 있음. 소유 객체가 유효하지 않다면 대리자를 통해 람다를 호출하지 않음.\nif (const UWorld* World = OwnerComp.GetWorld())\n{ const float DeltaTime = NumTicksExecuting * FAITestHelpers::TickInterval; World-&gt;GetTimerManager().SetTimerCreateWeakLambda(this, [&amp;OwnerComp, TaskMemory, this]() // &lt;---- This is the declaration of a weak lambda\n{\nTaskMemory-&gt;TimerHandle.Invalidate(); &lt;span class=\"token function\"&gt;ensure&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token operator\"&gt;!&lt;/span&gt;TaskMemory&lt;span class=\"token operator\"&gt;-&amp;gt;&lt;/span&gt;bIsAborting&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;;&lt;/span&gt; &lt;span class=\"token function\"&gt;LogExecution&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;OwnerComp&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; LogIndexExecuteFinish&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;;&lt;/span&gt; &lt;span class=\"token function\"&gt;FinishLatentTask&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;OwnerComp&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; LogResult&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;;&lt;/span&gt; &lt;span class=\"token punctuation\"&gt;}&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; DeltaTime&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; &lt;span class=\"token boolean\"&gt;false&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\n;\n} ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"람다의 문제점","level":3,"id":"람다의_문제점_0"},{"heading":"람다의 문제점을 완화하는 방법","level":3,"id":"람다의_문제점을_완화하는_방법_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"ue/언리얼엔진에서의-lamda.html","pathToRoot":"..","attachments":[],"createdTime":1730808631672,"modifiedTime":1730808631672,"sourceSize":1761,"sourcePath":"UE/언리얼엔진에서의 Lamda.md","exportPath":"ue/언리얼엔진에서의-lamda.html","showInTree":true,"treeOrder":452,"backlinks":[],"type":"markdown"},"ue/월드의-생명주기.html":{"title":"월드의 생명주기","icon":"","description":"월드는 액터와 컴포넌트가 존재하고 렌더링 되는 top level 오브젝트다. 쉽게 맵이라고 생각할 수 있다. 그렇다면 월드의 생명주기는 무엇일까?게임플로우의 일반적인 순서는 Engine 초기화 -&gt; GameInstance 생성 및 초기화 -&gt; Level 로드다. 월드는 레벨이 로드될 때 생성되고 초기화 되고 로드된다.월드는 레벨에 종속되어 있는 오브젝트라고 할 수 있다. 따라서 Level이 생성될 때 World도 같이 생성 및 초기화가 진행되고, Level이 사라질 때 월드도 같이 사라지는 것이라고 할 수 있다.<img alt=\"GameFlowChart.png\" src=\"images/gameflowchart.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"images/gameflowchart.png","fullURL":"ue/월드의-생명주기.html","pathToRoot":"..","attachments":["images/gameflowchart.html"],"createdTime":1735577697889,"modifiedTime":1735577892795,"sourceSize":653,"sourcePath":"UE/월드의 생명주기.md","exportPath":"ue/월드의-생명주기.html","showInTree":true,"treeOrder":453,"backlinks":[],"type":"markdown"},"unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html":{"title":"13. Clear Counter - RayCast로 객체와 인터렉트하기","icon":"","description":"Empty Object(ClearCounter)를 생성하고 Prefab Asset(ClearCounter_Visual)을 만든 오브젝트에 끌어당겨 넣습니다.비주얼과 로직을 분리해야 하기 때문에 ClearCounter에 로직을 넣고 _Visual에는 UI 관련된 것을 넣습니다.따라서 ClearCounter에 ClearCounter.cs를 추가하고 Box Colider를 설정하고 크기는 Visual과 맞춥니다.그런 다음에 Player.cs를 작성할 것입니다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class Player : MonoBehaviour { private bool isWalking; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float interactDistance = 2f; if (Physics.Raycast(transform.position, moveDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log(\"-\"); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); }\n}\nParameter에 out이 들어가는 경우는 일종의 콜백으로 생각하면 될 것 같습니다.위의 코드를 실행하면, 멈춰있을 때 이벤트가 발생하지 않아 인터렉션을 할 수가 없는 이슈가 있습니다. 그 이유는 HandleInteractions()에서 멈춰있을 때 moveDir이 0이기 때문입니다. 이것을 클래스 프로퍼티로 가지고 있으면 이슈를 해결할 수 있습니다.\n// Player.cs // 클래스 프로퍼티로 가지고 있기\nprivate Vector3 lastInteractDir; // ... /// private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log(\"-\"); } }\n그리고 만든 Object Instance를 다음에 다른 인스턴스를 빠르게 생성하기 위해서 파일창으로 드래그 앤 드롭을 해서 Object Prefab으로 만듭니다.<img src=\"https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Interact를 하기 위해서는 플레이어가 객체를 Identifying 할 수 있어야 합니다. 이때 유니티에서 제공하는 tag를 사용할 수 있으나, 코드에서 컴포넌트를 얻어서 처리하는 것이 더욱 효과적인 방법인 것 같습니다. Try-를 이용하면 null 체크까지 진행할 수 있습니다. 이제 HandleInteractions()을 수정하겠습니다.// Player.cs // ... // private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }\nRayCast를 사용할 때 매개변수에 layerMask를 쓸 수 있습니다. 이것을 설정하면 Player의 rayCast가 반응하는 Layer들을 설정할 수 있게 됩니다.&nbsp; Counter layer를 Counters라고 만들고 Counter의 Layer를 Counters로 설정하겠습니다.<br><img src=\"https://blog.kakaocdn.net/dn/XC2Hp/btso8z4Fejb/nHJTV998t8IKb312TzGJQ0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/ct99it/btso09muO2Z/GdpNRfT1HIXmhhynng9EUk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그런 다음에 Player.cs에서 SerializeField를 설정합시다.// Player.cs [SerializeField] private LayerMask counterLayerMask;\n그러고나서 유니티로 돌아와 Player 인스턴스를 클릭하고 Inspector에서 SerializeField를 설정하면 끝입니다.<br><img src=\"https://blog.kakaocdn.net/dn/RaakV/btso12gk3LK/UQmJClmkttamek63c4N8F0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그러면 Player는 아래처럼 Layer가 Counters로 설정된 오브젝트에만 인터렉트를 하게 됩니다!<br><img src=\"https://blog.kakaocdn.net/dn/D96LV/btso7R5xiII/WZahA3bPsoVxmdF6R2L0K1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"LayerMask","level":4,"id":"LayerMask_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png","fullURL":"unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html","pathToRoot":"..","attachments":[],"createdTime":1735624171800,"modifiedTime":1735624345928,"sourceSize":6670,"sourcePath":"Unity/13. Clear Counter - RayCast로 객체와 인터렉트하기.md","exportPath":"unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html","showInTree":true,"treeOrder":455,"backlinks":[],"type":"markdown"},"unity/14.-interact-action-events.html":{"title":"14. Interact Action Events","icon":"","description":"Player가 Object에 갔을 때 Interact를 하는 것을 개발하겠습니다.&nbsp;Input System 열어서 Actions에 Interact를 생성하고 'E'를 바인딩합시다.<img src=\"https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이벤트의 흐름은 아래와 같아요.\nGameInput -&gt; Player -&gt; ClearCounter\n먼저 GameInput.cs를 열어 코드를 작성해 볼까요? 어떻게 구현하면 될까요?Input System에서 Interact가 발생했을 때 알아채기 위해서 우리는 이 이벤트를 리스닝하고 있어야 합니다. 그러고 나서 이 이벤트가 발생했다는 사실을&nbsp; Player에게 보내야 해요. 따라서 EventHandler를 프로퍼티로 가지고 있어야 하고, Input System에서 오는 Interact를 리스닝하고 액션이 들어왔을 때 EventHandler를 통해 이벤트를 보내주는 함수를 구현하면 됩니다.&nbsp;public class GameInput : MonoBehaviour { // Event를 넘겨주는 객체 public EventHandler OnInteractAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Listening playerInputActions.Player.Interact.performed += Interact_performed; } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { //OnInteractAction이 Null일 수 있기 때문에 Invoke를 사용한다. OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }\n}\nPlayer.cs에서 OnInteractAction을 리스닝하면 됩니다.// Player.cs // GameInput.cs에서 발생하는 OnInteractAction을 리스닝 하기 private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }\n유니티에서 이런 비동기 처리는 Event라는 것을 처리하는 것 같습니다. Swift는 클로저를 통해 제어권을 넘겨주는 방식이랑 상당히 유사한 것 같네요. 끝!","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png","fullURL":"unity/14.-interact-action-events.html","pathToRoot":"..","attachments":[],"createdTime":1735624192302,"modifiedTime":1735624336039,"sourceSize":2889,"sourcePath":"Unity/14. Interact Action Events.md","exportPath":"unity/14.-interact-action-events.html","showInTree":true,"treeOrder":456,"backlinks":[],"type":"markdown"},"unity/15.-selected-counter-visual-&-singleton-pattern.html":{"title":"15. Selected Counter Visual & Singleton Pattern","icon":"","description":"이번에는 오브젝트에 다가갈 때 UI를 업데이트하는 것을 구현했어요. UI 로직과 게임 로직은 분리하는 게 좋아요.SelectedCounterVisual 스크립트를 생성하고 공통적으로 적용해야 하기 때문에 ClearCounter Prefab을 열어줍니다. 그리고 ClearCounter_Visual을 복사해서 Selected로 이름을 바꿉시다. 그런 다음 Inspector에서 세 가지 과정을 완료하면 되어요.\nCounterSelected로 Meterial 변경 (Selected 하위에 있는 컴포넌트들)\n사이즈 변경 (사이즈가 같으면 발생하는 렌더링 버그가 있음)\nSelectedCounterVisual 넣기\n<img src=\"https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/dNulJo/btspE3SQKsU/H3PrGoAKCMIhBuYF9d6Tgk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/XdXso/btspNP0efBe/UfjgVYsPfcUiLcY4MY1QCK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 코드를 작성하고, SerializeField를 만들어서 레퍼런스를 넣어줍시다!흐름은 Player가 Object에 다가간다. -&gt; Selected Counter Visual을 업데이트해준다. 그러면 Player.cs에 다음과 같은 코드를 작성하면 되어요. 그리고 아직은 1인용 게임이기 때문에 Player는 인스턴스는 무조건 하나일 수밖에 없어서 싱글톤으로 만들면 됩니다.// Player.cs\npublic event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } // Single 톤으로 만들어야하니까 public static Player Instance { get; private set; } private void Awake() { if (Instance != null) { Debug.LogError(\"Player가 한명보다 많습니다.\"); } Instance = this; } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // 수정\nprivate void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } }\n이제 Visual을 업데이트를 하는 코드를 작성합시다!// SelectedCounterVisual.cs public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private ClearCounter clearCounter; [SerializeField] private GameObject visualGameObject; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == clearCounter) { Show(); } else { Hide(); } } private void Show() { gameObject.SetActive(true); } private void Hide() { gameObject.SetActive(false); }\n}\n이때 좀 주의할 점이 있는데 이벤트 등록을 Start()에서 하는 것입니다. Awake()에서 등록을 하게 되면 에러가 발생할 수 있습니다.왜냐하면 Player.cs에서 Instance를 Awake()에서 만들기 때문에 순서가 보장되지 않을 수 있기 때문입니다.따라서! 반드시 Start()에서 이벤트 등록을 해줍시다.이제 다시 유니티로 돌아가 [SerializeField]에 알맞는 레퍼런스를 넣어줄까요?<br><img src=\"https://blog.kakaocdn.net/dn/cveG34/btspOyYfvgw/91xl8AZvUZ4XgWtzWGXch0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/bfZ78Q/btspCnqqB3Z/sYY06RxUirfT2CRaSdoMQK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/d2OVRZ/btspGLxv4Oz/1AVqaYIqCEan1owh9eTlt1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/bUh0Ao/btspRinhPFO/4mvrstPKOfYh7zouWBcz10/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/lF40S/btspFM4lwGY/uYgrQlWSSg8EzynxPNt201/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"15. Selected Counter Visual &amp; Singleton Pattern","level":1,"id":"15._Selected_Counter_Visual_&_Singleton_Pattern_0"},{"heading":"결과 영상","level":4,"id":"결과_영상_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png","fullURL":"unity/15.-selected-counter-visual-&-singleton-pattern.html","pathToRoot":"..","attachments":[],"createdTime":1735624219304,"modifiedTime":1735624324140,"sourceSize":4509,"sourcePath":"Unity/15. Selected Counter Visual & Singleton Pattern.md","exportPath":"unity/15.-selected-counter-visual-&-singleton-pattern.html","showInTree":true,"treeOrder":457,"backlinks":[],"type":"markdown"},"unity/16.-kitchen-object,-scriptable-object.html":{"title":"16. Kitchen Object, Scriptable Object","icon":"","description":"Clear Counter에는 음식을 올려놓을 수 있어요. Clear Counter에 객체를 올려놓는 것을 개발하겠습니다.먼저 올려놓을 객체들을 Prefab으로 만듭니다. KitchenObjects 폴더에 만들어줄게요. 그런 다음에, ClearCounter 스크립트를 열고다음 코드를 작성합니다.public class ClearCounter : MonoBehaviour { [SerializeField] private Transform tomatoPrefab; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log(\"Interact\"); Transform tomatoTransform = Instantiate(tomatoPrefab, counterTopPoint); tomatoTransform.localPosition = Vector3.zero; }\n}\nInteract()가 호출되면 Log를 띄우고 토마토를 Clear Counter 위에 올려놓을 거예요. 이제 유니티로 돌아가서 설정한 SerializeField에 레퍼런스를 넣겠습니다.<img src=\"https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그러면 인터렉트를 하게 되면 토마토가 슉하고 올라갈 거예요. 근데 Clear Counter 위에는 토마토도 올라갈 수 있지만 다양한 것들도 올라갈 수 있어요. 그래서 이것을 Scriptable Object로 감싸고, 안에 멤버 변수로 Prefab을 가지고 있다면 코드를 공통화할 수 있어요.Scriptable Object를 만듭시다.[CreateAssetMenu()]\npublic class KitchenObjectSO : ScriptableObject { public Transform prefab; public Sprite sprite; public string objectName;\n}\n유니티로 돌아가서 확인해 보면 Create Kitchen Object SO라는 것이 생겼을 거예요. Tomato와, CheeseBlock을 만듭니다.<br><img src=\"https://blog.kakaocdn.net/dn/Bgna7/btspCllNj6o/lrnpl70tqht3IeX3Ev4Ptk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">ClearCounter.cs를 수정해 볼까요?public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log(\"Interact\"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; }\n}\n이렇게 하면 끝입니다.근데 kitchenObjectTransform에서 해당하는 KitchenObjectSO를 얻을 수 있을까요? 바로 얻을 수 없습니다. 이것 역시 스크립트를 이용해야 하는데 Scriptable Object에는 Script를 드래그 앤 드롭할 수 없습니다. 그래서 KitchenObject 스크립트를 만들어서 Prefab에 넣어야 합니다. 뭔가 쓰고 보니 말이 좀 헷갈리네요.<br><img src=\"https://blog.kakaocdn.net/dn/pp8fj/btspRh2ZVw7/OflwT6hlZfzIauDyiRsKDK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; }\n}\n즉 여러 KitchenObject&nbsp;(Tomato, Cheese etc..)를&nbsp;사용하는 곳 일종의 Type Erasing을 하는 곳에서는 Scriptable Object를 사용해서 관리하고 유니티에서 프리팹으로 KitchenObject에 Scriptable Object 레퍼런스를 넣어주면 되겠습니다.public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log(\"Interact\"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; // KitchenObject로 Scriptable Object를 얻을 수 있음! Debug.Log(kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().GetKitchenObjectSO().objectName); }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png","fullURL":"unity/16.-kitchen-object,-scriptable-object.html","pathToRoot":"..","attachments":[],"createdTime":1735624243948,"modifiedTime":1735624313608,"sourceSize":3759,"sourcePath":"Unity/16. Kitchen Object, Scriptable Object.md","exportPath":"unity/16.-kitchen-object,-scriptable-object.html","showInTree":true,"treeOrder":458,"backlinks":[],"type":"markdown"},"unity/17.-kitchen-object-parent.html":{"title":"17. Kitchen Object Parent","icon":"","description":"플레이어나 Counter들은 Kitchen Object를 가지고 있을 수 있어요.(플레이어는 Kitchen Object를 들 수 있고, Counter는 위에 Kitchen Object를 올릴 수 있습니다.) 이것을 Parent라고 할게요. 나중에 Interface를 이용해서 바꾸겠지만 지금은 Kitchen Object의 부모는 Clear Counter라고 가정하고 코드를 작성할게요.플레이어가 키친 오브젝트를 들고 있고 ClearCounter에 가서 ClearCounter의 Interact() 코드를 호출할 거예요. 이때 Clear Counter가 자식을 가지고 있으면 (즉 키친 오브젝트가 올려져 있으면) 아무것도 처리하지 않고, 자식을 가지고 있지 않으면 Kitchen Object를 자식으로 만들면 되겠네요.그리고 KitchenObject에서 부모를&nbsp; SetClearCounter로 설정하면 되어요. 그리고 키친오브젝트의 부모를 Set할 때 부모의 UI를 업데이트를 하면 됩니다. 비주얼 업데이틀 어떻게 하면 될까요? 부모의 Top인 CounterTopPoint에 올려놓으면 됩니다. 그리고 여기에서 부모의 메서드인 SetKitchenObject를 해주면 될 거예요. (부모의 자식은 나다.)public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; private void Update() { } public void Interact() { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetClearCounter(this); } else { Debug.Log(kitchenObject.GetClearCounter()); } } public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }\n이제 KitchenObject로 가서 SetClearCounter()를 구현합시다.public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private ClearCounter clearCounter; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public ClearCounter GetClearCounter() { return clearCounter; } public void SetClearCounter(ClearCounter clearCounter) { if (this.clearCounter != null) { this.clearCounter.ClearKitchenObject(); } this.clearCounter = clearCounter; if (clearCounter.hasKitchenObject()) { Debug.LogError(\"clear counter already has kitchen object\"); } clearCounter.SetKitchenObject(this); transform.parent = clearCounter.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"unity/17.-kitchen-object-parent.html","pathToRoot":"..","attachments":[],"createdTime":1735624260478,"modifiedTime":1735624296954,"sourceSize":3143,"sourcePath":"Unity/17. Kitchen Object Parent.md","exportPath":"unity/17.-kitchen-object-parent.html","showInTree":true,"treeOrder":459,"backlinks":[],"type":"markdown"},"unity/18.-player-pick-up,-csharp-interfaces.html":{"title":"18. Player Pick up, CSharp Interfaces","icon":"","description":"카운터들이 키친 오브젝트를 가지고 있는 경우도 있지만, 플레이어가 키친 오브젝트를 가지고 있는 경우도 있겠죠? 이를 Interface를 이용해서 리팩토링 하면 됩니다!인터페이스 스크립트를 만들게요.public interface IKitchenObjectParent { public Transform GetKitchenObjectFollowTransform(); public KitchenObject GetKitchenObject(); public void SetKitchenObject(KitchenObject kitchenObject); public void ClearKitchenObject(); public bool HasKitchenObject(); }\n이렇게 만들면, KitchenObject가 ClearCounter를 가지고 있는 것 아니라 IKitchenObjectParent를 프로퍼티로 가지게 합니다. 수정을 해볼까요?public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError(\"IKitchenObjectParent already has kitchen object\"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }\n}\n부모가 될 수 있는 ClearCounter로 가서 IKitchenObjectParent를 컨펌할게요. 그리고 인터렉트를 할 때, Clear Counter가 들고 있는 Kitchen Object의 부모를 Player로 바꿔줘야 하기 때문에 Interact의 파라미터에 Player가 필요해요.&nbsp;public class ClearCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }\n}\nPlayer도 IKitchenObjectParent를 컨펌합시다! 아직 플레이어는 ClearCounter가 가지고 있는 counterTopPoint (물건을 놓는 위치) 같은 것이 없어요. 이것을 SerializedField로 Transform kitchenObjectHoldPoint로 이름 짓고 Player 하위에 빈 객체를 하나 만들고 아래처럼 위치를 잡아줄게요. 그리고 Player Scirpt의 kitchenObjectHoldPoint에 레퍼런스로 넣어주면 되겠죠?<img src=\"https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">public class Player : MonoBehaviour, IKitchenObjectParent { public static Player Instance { get; set; } public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } private bool isWalking; private Vector3 lastInteractDir; private ClearCounter selectedCounter; private KitchenObject kitchenObject; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; [SerializeField] private LayerMask counterLayerMask; [SerializeField] private Transform kitchenObjectHoldPoint; private void Awake() { if (Instance != null) { Debug.LogError(\"Player가 한명보다 많습니다.\"); } Instance = this; } private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { if (selectedCounter != null) { selectedCounter.Interact(this); } } private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; // 회전을 부드럽게 하는 lerp, slerp transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return kitchenObjectHoldPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; } }\nInterface를 이용한 리팩토링을 완료했어요. 이제 플레이어가 카운터에 있는 키친 오브젝트를 들 수 있게 되었습니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png","fullURL":"unity/18.-player-pick-up,-csharp-interfaces.html","pathToRoot":"..","attachments":[],"createdTime":1735624355849,"modifiedTime":1735624382465,"sourceSize":8681,"sourcePath":"Unity/18. Player Pick up, CSharp Interfaces.md","exportPath":"unity/18.-player-pick-up,-csharp-interfaces.html","showInTree":true,"treeOrder":460,"backlinks":[],"type":"markdown"},"unity/19.-container-counter와-상속.html":{"title":"19. Container Counter와 상속","icon":"","description":"이번에는 물건을 꺼내오는 Container Counter를 구현할 거예요.이 게임에는 다양한 종류의 Counter가 존재합니다. 그래서 BaseCounter를 만들고 구체적인 카운터가 Base를 상속받게 하는 것이 좋습니다.프리팹도 베이스를 만들어 놓으면 프리팹을 정말 빠르게 만들 수 있습니다. 그래서 프리팹부터 만들어보도록 하겠습니다._BaseCounter로 이름 짓고 프리팹을 열어 CounterTopPoint를 넣어줍니다.<img src=\"https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">_BaseCounter을 이용해서 ClearCounter 프리팹을 만들어볼게요.우클릭하고 Prefab Variant를 클릭합시다.<br><img src=\"https://blog.kakaocdn.net/dn/bjcUyF/btsqZvNH1vT/kKOpjwB2mkbPMhWrqC1pUK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그러고나서 기존의 ClearCounter에 들어있는 Selected, ClearCounter_Visual을 복붙하고 스크립트를 잘 넣으면 됩니다.기존의 ClearCounter는 지워주면 되겠죠?<br><img src=\"https://blog.kakaocdn.net/dn/bMMeIK/btsqYP0df5o/et5dTWLLgxjIwzdMF1F2Bk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 _BaseCounter를 이용해서 ContainerCounter 프리팹을 만들게요.프리팹을 만들 때 설정해줘야 하는 건 다음과 같아요.\nVisual Prefab(Asset) 끌당하기\n복사해서 Selected 만들기\n선택되었을 때, 하위 MeshRender 설정하기\nRendering 버그가 안 나게 선택되었을 때, Scale 전체 1.01로 수정하기\nSelectedCounter에 스크립트 넣어주기\n다 적용하면 아래처럼 사진처럼 됩니다.<br><img src=\"https://blog.kakaocdn.net/dn/dfUG6B/btsqXSQNHDr/d8M2SSux89DATZXuCm9KZK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 ContainerCounter 스크립트를 만든 다음 어태치 하고 코드를 작성할게요.public class ContainerCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool hasKitchenObject() { return kitchenObject != null; }\n}\n시리얼라이즈드필드 변수를 썼으니 어떻게 해야 된다? 유니티에서 레퍼런스를 추가해야 한다!&nbsp;추가 ㄱㄱ<br><img src=\"https://blog.kakaocdn.net/dn/biz7BP/btsqYZolSGD/qL5RsQqPyqQej5xaKm1AKK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 BaseCounter 스크립트를 만들어서 구체적인 Counter들의 부모로 사용할 거예요.public class BaseCounter : MonoBehaviour { public virtual void Interact(Player player) { Debug.LogError(\"BaseCounter.Interact();\"); }\n} 그런 다음에 Player.cs에서 ClearCounter를 BaseCounter로 변경\nContainer의 SelectedCounter를 설정해 볼까요. 현재는 SelectedCounterVisual이 시리얼라이즈 필드로 ClearCounter를 가지고 있는데 BaseCounter로 변경하고 그리고 GameObject는 Array로 바꿉시다.public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private BaseCounter baseCounter; [SerializeField] private GameObject[] visualGameObjectArray; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == baseCounter) { Show(); } else { Hide(); } } private void Show() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(true); } } private void Hide() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(false); } }\n}\n시리얼라이즈드 필드를 바꿨으니 각각 프리팹의 Selected로 가서 레퍼런스를 다시 넣어줍시다.<br><img src=\"https://blog.kakaocdn.net/dn/bDYQ2I/btsqZgwz8EM/N0rgbcuxLhfrPAlFeWOu61/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/dWVoRR/btsqYpOi57P/vrQg3yTGe27xekzOSR59bK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">코드 겹치는 부분인 IKitchenObjectParent도 Base로 뺄게요.public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void Interact(Player player) { Debug.LogError(\"BaseCounter.Interact();\"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }\n}\npublic class ContainerCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); }\n}\npublic class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { }\n}\n상속을 하니까 코드 라인이 눈에 띄게 줄어들었네요.이제 ContainerCounter에 Animation을 넣어볼게요. Animator를 이용하면 되겠죠?먼저 ContainerCounter에서 인터렉트가 발생했을 때 ContainerCounterVisual에 이벤트를 넘겨주게 코드를 작성합시다.public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); }\n}\nCountainerCounterVisual 스크립트를 생성하고 이벤트를 리스닝하는 코드를 작성하면 됩니다.public class CountainerCounterVisual : MonoBehaviour { [SerializeField] private ContainerCounter containerCounter; private Animator animator; private const string OPEN_CLOSE = \"OpenClose\"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { containerCounter.OnPlayerGrabbedObject += ContainerCounter_OnPlayerGrabbedObject; } private void ContainerCounter_OnPlayerGrabbedObject(object sedner, System.EventArgs e) { animator.SetTrigger(OPEN_CLOSE); } }\n시리얼라이즈드 필드를 사용했으니 아래처럼 CotainerCounter_Visual에 레퍼런스를 넣고 구현을 마무리하면 되겠습니다! 끝<br><img src=\"https://blog.kakaocdn.net/dn/xiUU3/btsqYUHgX9Z/AKB4OKNI7LX6LecrI2CqgK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png","fullURL":"unity/19.-container-counter와-상속.html","pathToRoot":"..","attachments":[],"createdTime":1735624385587,"modifiedTime":1735624437645,"sourceSize":7975,"sourcePath":"Unity/19. Container Counter와 상속.md","exportPath":"unity/19.-container-counter와-상속.html","showInTree":true,"treeOrder":461,"backlinks":[],"type":"markdown"},"unity/20.-player-pick-up-&-drop-object.html":{"title":"20. Player Pick Up & Drop Object","icon":"","description":"이번에는 Player가 ContainerCounter에서 Object를 꺼내서 ClearCounter에 놓았다 들었다 하는 것을 구현할게요.public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { if (player.HasKitchenObject()) { // Player가 가지고 있으면 아무것도 해선 안됨 } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } }\n}\n컨터이너에서 오브젝트를 꺼내고, 바로 컨테이너에서 인터렉트를 할 시에 에러가 발생해야 해요. 왜냐하면 플레이어가 오브젝트를 들고 있지 않을 때만 인터렉트를 해야 하기 하기 때문이에요.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }\n}\n현재는 KitchenObject가 Tomato, CheeseBlock만 존재합니다. Bread와, Cabbage를 추가하고 이것들을 담는 Prefab들을 유니티에만 들게요.각각 KitchenObjectSO와, KitchenObject, ContainerPrefab을 만들고 씬에 배치하면 끝!<img src=\"https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"20. Player Pick Up &amp; Drop Object","level":1,"id":"20._Player_Pick_Up_&_Drop_Object_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png","fullURL":"unity/20.-player-pick-up-&-drop-object.html","pathToRoot":"..","attachments":[],"createdTime":1735624439475,"modifiedTime":1735624454574,"sourceSize":2284,"sourcePath":"Unity/20. Player Pick Up & Drop Object.md","exportPath":"unity/20.-player-pick-up-&-drop-object.html","showInTree":true,"treeOrder":462,"backlinks":[],"type":"markdown"},"unity/21.-cutting-counter,-interact-alternate.html":{"title":"21. Cutting Counter, Interact Alternate","icon":"","description":"이번에는 CuttingCounter를 만들게요!플레이어는 Cutting Counter에서 치즈, 토마토, 양배추를 놓고 자를 수 있어요. 그래서 놓고 드는 인터렉트 말고 다른 인터렉트가 필요할 거예요!프리팹을 먼저 만들게요. _BaseCounter를 선택하고 Prefab Variant를 클릭해서 만들어줍시다. 그리고 비주얼 넣고, 선택되었을 때 처리를 하면 되겠죠? 스크립트도 만들어서 어태치 하고 BaseCounter를 상속하게 합니다.그리고 유니티로 돌아와서 레퍼런스를 넣어줍시다. 처음에 할 때 이 과정이 복잡했는데, 이제는 조금 익숙해져서 다행이네요. 역시 반복이 답이제 자르는 인터렉트 키를 만들어봅시다.Input System에서 열고 InteractAlternate 추가하고 F로 설정! Save Asset 누르는 거 잊지 말기<img src=\"https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Input System에서 액션을 만들어줬기 때문에 이것을 등록하고 구현해야겠죠? 이미 구현한 Interact처럼 하면 됩니다.\nGameInput.cs에 등록\nPlayer가 Interact를 하기 때문에 Player.cs에서 등록 및 구현\nBaseCounter에서 구현\n코드를 작성해 봅시다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System;\nusing UnityEngine.InputSystem; public class GameInput : MonoBehaviour { public EventHandler OnInteractAction; // 새로 구현한 곳 public EventHandler OnInteractAlternateAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Subscribe 코드 playerInputActions.Player.Interact.performed += Interact_performed; playerInputActions.Player.InteractAlternate.performed += InteractAlternateOnperformed; }\n// 새로 구현한 곳 private void InteractAlternateOnperformed(InputAction.CallbackContext obj) { OnInteractAlternateAction?.Invoke(this, EventArgs.Empty); } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }\n}\nPlayer.cs에 추가합시다.private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction;\n// 새로 추가됨 gameInput.OnInteractAlternateAction += OnInteractAlternateAction; }\n// 새로 추가됨 private void OnInteractAlternateAction(object sender, EventArgs e) { if (selectedCounter != null) { selectedCounter.InteractAlternate(this); } }\nBaseCounter에 구현을 하러 갑시다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void InteractAlternate(Player player) { Debug.LogError(\"InteractAlternate.Interact();\"); } public virtual void Interact(Player player) { Debug.LogError(\"BaseCounter.Interact();\"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }\n}\n이제 CuttingCounter에서 overriding을 구현해야 해요. 그전에 Cutting을 했을 때 원래 있던 KitchenObject가 새로운 KitchenObject(Ex: 토마토 -&gt; 잘린 토마토)로 변해야므로 새로운 KitchenObjectSO와 KitchenObject를 만들겠습니다.일단 바로 추가할 수 있는 Destory()를 먼저 구현할게요(토마토 -&gt; 잘린 토마토인 경우 토마토 객체를 먼저 없애줘야 하므로)using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError(\"IKitchenObjectParent already has kitchen object\"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; } // 새로 추가된 부분 public void DestroySelf() { kitchenObjectParent.ClearKitchenObject(); Destroy(gameObject); }\n}\n잘린 토마토 슬라이스 Scriptable Object와 프리팹을 유니티에서 만듭시다.<br><img src=\"https://blog.kakaocdn.net/dn/0QIKK/btsqYZ9QisQ/e0ETQgs7TAA2kRdfLderD0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">다 만든 다음에, CuttingCounter 코드를 작성 ㄱㄱusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class CuttingCounter : BaseCounter\n{ [SerializeField] private KitchenObjectSO cuttingKitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Player is carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject()) { // There is Kitchen Object here kitchenObject.DestroySelf(); // Cutting Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); } }\n}\n코드에서, 다음 두 라인이 CuttingCounter.cs와 ContainerCounter.cs에서 공통적으로 사용됩니다. 따라서 리펙토링 대상이겠죠? 고고Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab);\nkitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player);\nKitchenObject.cs에서 static 메서드로 만들어줍시다.public static KitchenObject SpawnKitchenObject(KitchenObjectSO kitchenObjectSO, IKitchenObjectParent kitchenObjectParent) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); KitchenObject kitchenObject = kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;(); kitchenObject.SetKitchenObjectParent(kitchenObjectParent); return kitchenObject; }\n// ContainerCounter.cs\npublic override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 KitchenObject.SpawnKitchenObject(kitchenObjectSO, player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }\n마지막으로 Cutting Counter에 시리얼라이즈드 필드를 사용했으니 유니티에서 레퍼런스(만들어 놓은 Tomato Slice SO)를 넣어주면 끝!여기까지 하면, 토마토를 자르면 잘린 토마토가 되는 걸 확인할 수 있어요. 근데 치즈를 잘라도 잘린 토마토가 나오기 때문에 다음에 이 문제를 해결하도록 하겠습니다!","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png","fullURL":"unity/21.-cutting-counter,-interact-alternate.html","pathToRoot":"..","attachments":[],"createdTime":1735624455452,"modifiedTime":1735624505445,"sourceSize":8776,"sourcePath":"Unity/21. Cutting Counter, Interact Alternate.md","exportPath":"unity/21.-cutting-counter,-interact-alternate.html","showInTree":true,"treeOrder":463,"backlinks":[],"type":"markdown"},"unity/22.-cutting-recipe-so.html":{"title":"22. Cutting Recipe SO","icon":"","description":"지난번에 언급했던 문제점!하드코딩 되어있기 때문에 어떤 재료든 컷팅하며 슬라이스 토마토가 되어있는 이슈를 해결하도록 하겠습니다.각각 종류에 맞는 슬라이스로 만드는 것이 목표입니다.Scriptable Object를 이용해서 해결해봅시다. 고고대력 흐름은 CuttingRecipeSO를 만들어서 Input과 outpt으로 원재료 -&gt; 슬라이스로 다루는 것입니다.Input - 토마토, 치즈, 양배추Output - 토마토 슬라이스, 치즈 슬라이스, 양배추 슬라이스제약조건도 추가해줘야 합니다. 이미 잘린 것은 또 자를 수 없기 때문에요먼저 CuttingRecipeSO 스크립트를 만듭시다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; [CreateAssetMenu()]\npublic class CuttingRecipeSO : ScriptableObject\n{ public KitchenObjectSO input; public KitchenObjectSO output;\n}\n유니티에서 노가다를 통해서 프리팹과 SO를 만듭시다. 처음엔 드래그 앤 드랍 싫고 그랬는데 익숙해지면 소소한 재미가 있더라고요.KitchenObjectSO - 치즈슬라이스랑, 캐비지 슬라이스 만들기KitchenObject - 치즈 슬라이스, 캐비지 슬라이스 만들기CuttingRecipeSO - 토마토,치즈,캐비지 만들기<img src=\"https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 CuttingCounter에서 로직 구현을 할 차례예요.시리얼라이즈드 필드로 CuttingRecipeSO를 배열로 들고 있어야하고, KitchenObjectSO를 리턴하는 메서드가 필요하겠네요.그리고 이미 잘린 것은 또 못자르게 로직을 구현합시다.&nbsp;간단하게 CuttingCounter가 가지고 있는 KitchenObject가 루프를 돌아서 이게 Recipe의 Input과 같으면, 잘라주면 됩니다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class CuttingCounter : BaseCounter\n{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(kitchenObject.GetKitchenObjectSO()); kitchenObject.DestroySelf(); // Cutting KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return true; } } return false; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO.output; } } return null; }\n}\n마지막으로 유니티로 돌아가서 시리얼라이즈드 필드에 아래처럼 SOArray 레퍼런스를 잘 넣어주면 끝!<br><img src=\"https://blog.kakaocdn.net/dn/MeJop/btsqYqfsKQm/cI5DI71dFiLKeLt6TObc11/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png","fullURL":"unity/22.-cutting-recipe-so.html","pathToRoot":"..","attachments":[],"createdTime":1735624508093,"modifiedTime":1735624548480,"sourceSize":4347,"sourcePath":"Unity/22. Cutting Recipe SO.md","exportPath":"unity/22.-cutting-recipe-so.html","showInTree":true,"treeOrder":464,"backlinks":[],"type":"markdown"},"unity/23.-cutting-progress,-world-canvas.html":{"title":"23. Cutting Progress, World Canvas","icon":"","description":"이번에는 재료들을 컷할 때 몇 번 액션을 줘야 하는지 정하고 Cutting Counter 위에 프로그레스바를 넣을 거예요.토마토는 3번, 치즈는 3번, 양배추는 5번 F키를 눌러서 잘라줘야 합니다.원재료가 있고 이를 컷팅했을 때 Sliced 재료가 되어야 하니까 Scriptable Object를 만들어서 관리하는 게 좋아요.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; [CreateAssetMenu()]\npublic class CuttingRecipeSO : ScriptableObject\n{ public KitchenObjectSO input; public KitchenObjectSO output; public int cuttingProgressMax;\n}\n<img src=\"https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Cutting Counter에 가서 로직을 작성해 볼까요? cuttingProgress라는 이름으로 int인 프로퍼티를 만들고 Player가 CuttingCounter에 원재료를 올려놓으면 0으로 초기화해줍니다. 그리고 F키를 눌러 InteractAlternate를 하게 되면 cuttingProgress를 높이면 되겠습니다.그 외 코드들은, CuttingRecipeSO의 input인 토마토, 치즈, 양배추만 컷팅 카운터에 올릴 수 있게 하는 코드입니다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class CuttingCounter : BaseCounter\n{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; private int cuttingProgess; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgess = 0; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgess++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgess) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }\n}\n그리고 [SerializedField]로 설정했기 때문에 유니티에서 꼭 레퍼런스를 지정해 주세요.<br><img src=\"https://blog.kakaocdn.net/dn/EHheN/btsrNBG5Htz/5kSMlkvN7e2r0aa6DSXp41/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">CuttingCounter 하위에 Empty Object를 만들고, Render Mode를 World Space로 바꿔줍시다. Rect Transform에서 Position과 width, height를 다 0으로 설정합시다. 그리고 프로그레스 바를 어디에다가 띄울지 위치를 대충 결정해 주면 됩니다. 그런 다음에 하위에 Image를 만들게요.Image를 눌러서 Color를 정해주고 Source 이미지에 White 1x1을 넣어주세요.<br><img src=\"https://blog.kakaocdn.net/dn/u82GH/btsrSKXRW5u/LN0bud5Z4lOEzRdYJkIYFK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Image type을 정해줍시다.Image Type에는 아래 4종류가 있습니다.\nSimple\nTiled\nSliced\nFilled\n저는 Filled를 선택할게요. Fill Amount를 조정하면 아까 위에서 설정한 Source Image(하얀색)에서 우리가 설정한 색깔(노란색)로 변합니다. 1이면 전체가 노란색으로 채워집니다. 노란색으로 채우는 방법도 여러 가지입니다. Fill Method에서 Horizontal로 설정하면 왼쪽에서부터 가로로 채워집니다.<br><img src=\"https://blog.kakaocdn.net/dn/sqVRe/btsrSM2rv0c/rM2KN55cTnmJ1whSzup6Lk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/GCYaK/btsrYVRyRXh/qsaIsO3P6wNKrV18kv5Atk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">위처럼 백그라운드 설정하기 위해서 먼저 Bar를 복사하고 이름을 Background로 짓습니다. 그런 다음에 Simple로 바꾸고 색깔을 검은색으로 하면 됩니다. 여기에서 중요한 것이 Bar보다 위에 위치시켜야 한다는 점입니다. 순서대로 그리기 때문입니다.Background에 아웃라인을 좀 더 주고 명확하게 하고 싶어서 컴포넌트를 추가하겠습니다.<br><img src=\"https://blog.kakaocdn.net/dn/AIGG7/btsrIb9Pm3Z/4S8qXoMIqZOHhTziVLSPQK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">CuttingCounter에서 ProgressUI를 분리하는 것이 더 깔끔하기 때문에 스크립트를 생성하고 ProgressBarUI로 이름 짓겠습니다. 스크립트를 ProgressBarUI에 어태치 해주세요.SerializedField로 CuttingCounter, Image를 선언하고 유니티에서 레퍼런스를 지정해 줍시다.public class ProgressBarUI : MonoBehaviour\n{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image image;\n}\nCuttingCounter에서 이벤트로 ProgressBarUI에 이벤트를 넘겨줘야 하기 때문에 CuttingCounter에서 EventHandler를 만들고, 명확하게 몇 번 컷팅했는 지를 보내야 하기 때문에, EventArgus도 만들어줘야 합니다. 그런 다음에 InteractAlternate에서 Invoke 해주면 되겠죠?CuttingCounter.cs\n// ...\npublic event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged;\npublic class OnProgressChangedEventArgs: EventArgs\n{ public float progressNormalized;\n} //... // CuttingCounter.cs (InteractAlternate 메서드 안) CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new OnProgressChangedEventArgs\n{ progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax\n});\n이벤트를 Invoke 하는 코드를 만들었으니, ProgressBarUI에서 이벤트를 리스닝하는 코드를 작성하면 되겠습니다.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI; public class ProgressBarUI : MonoBehaviour\n{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image barImage; private void Start() { cuttingCounter.OnProgressChanged += CuttingCounter_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void CuttingCounter_OnProgressChanged(object sender, CuttingCounter.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }\n}\n이제 마지막으로 Cutting 애니메이션을 넣도록 하겠습니다.CuttingCounter에서 OnCut이라는 이벤트 핸들러를 만들고 역시 InteracteAlternate()에서 Invoke 해줍시다.public event EventHandler OnCut; OnCut?.Invoke(this, EventArgs.Empty);\nCuttingCounterVisual 스크립트를 만들어줄게요.public class CuttingCounterVisual : MonoBehaviour { [SerializeField] private CuttingCounter cuttingCounter; private Animator animator; private const string CUT = \"Cut\"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { cuttingCounter.OnCut += CuttingCounter_OnCut; } private void CuttingCounter_OnCut(object sedner, System.EventArgs e) { animator.SetTrigger(CUT); } }\nSerializedField를 선언했으면? 당연히 레퍼런스를 넣어줘야겠죠? 끝!<br><img src=\"https://blog.kakaocdn.net/dn/lpEMX/btsrSNNNpx1/JXtASI1Rj7lKfM41TlNWJK/img.gif\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png","fullURL":"unity/23.-cutting-progress,-world-canvas.html","pathToRoot":"..","attachments":[],"createdTime":1735624550856,"modifiedTime":1735624598026,"sourceSize":9381,"sourcePath":"Unity/23. Cutting Progress, World Canvas.md","exportPath":"unity/23.-cutting-progress,-world-canvas.html","showInTree":true,"treeOrder":465,"backlinks":[],"type":"markdown"},"unity/24.-look-at-camera.html":{"title":"24. Look At Camera","icon":"","description":"오브젝트마다 사용자에게 어떻게 보여줘야 할지 다른 경우가 있습니다. 이것을 일일이 설정하면 코드가 복잡해질 거예요. 이를 스크립트로 만들어서 필요한 경우 스크립트를 넣어서 핸들링하는 방법을 알아볼게요.LookAtCamera 스크립트를 생성할게요.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Unity.VisualScripting;\nusing UnityEngine; public class LookAtCamera : MonoBehaviour\n{ [SerializeField] private Mode mode; private enum Mode { LookAt, LookAtInverted, CameraForward, CameraForwardInverted } private void LateUpdate() { switch (mode) { case Mode.LookAt: // 예전에는 Camera.main이 캐시되지 않아서 배드 퍼포먼스여서 사용하지 않았으나 지금은 디폴트로 캐시되어서 사용 transform.LookAt(Camera.main.transform); break; case Mode.LookAtInverted: Vector3 dirFromCamera = transform.position - Camera.main.transform.position; transform.LookAt(transform.position + dirFromCamera); break; case Mode.CameraForward: transform.forward = Camera.main.transform.forward; break; case Mode.CameraForwardInverted: transform.forward = -Camera.main.transform.forward; break; } }\n}\n위처럼 enum으로 상태를 관리해줄게요. LookAt은 오브젝트가 카메라를 바라봅니다. (메인 카메라가 중앙에 있다면, 중앙을 향해서)LookAtInverted는 카메라를 바라보는 것은 같은데 좌우가 뒤집힙니다. CamerarForward는 메인 카메라 방향을 바라보지만, 기울어지지 않습니다. 역시 CameraForwardInverted는 좌우가 반전됩니다.유니티에서 오브젝트에 스크립트를 추가한 후에 설정해서 사용하면 됩니다.<img src=\"https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png","fullURL":"unity/24.-look-at-camera.html","pathToRoot":"..","attachments":[],"createdTime":1735624602402,"modifiedTime":1735624619309,"sourceSize":2149,"sourcePath":"Unity/24. Look At Camera.md","exportPath":"unity/24.-look-at-camera.html","showInTree":true,"treeOrder":466,"backlinks":[],"type":"markdown"},"unity/25.-trash-counter.html":{"title":"25. Trash Counter","icon":"","description":"어떤 오브젝트도 버릴 수 있는 TrashCounter를 만듭시다.TrashCounter Prefab을 먼저 만들기_BaseCounter -&gt; Create Prefab Variant -&gt; TrashCounter로 네이밍프리팹에 들어가서 TrashCounter_Visual 넣고 복사해서 Selected로 네이밍 합니다.&nbsp; 그런 다음에 Selected에 SelectedCounter 스크립트를 넣어주기 그리고 Mesh 설정, Scale 1.01배 설정 등 귀찮은 작업들을 해줍시다.<img src=\"https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Script를 생성합니다. 로직은 매우 단순해요. 인터렉트가 발생하면 플레이어가 가지고 있는 오브젝트를 없애면 되겠습니다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class TrashCounter : BaseCounter { public override void Interact(Player player) { if (player.HasKitchenObject()) { player.GetKitchenObject().DestroySelf(); } }\n}\n<br><img src=\"https://blog.kakaocdn.net/dn/cwFk56/btsshrj0wKp/CjAEbaE6rG0AbuggrFQKGk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png","fullURL":"unity/25.-trash-counter.html","pathToRoot":"..","attachments":[],"createdTime":1735624621210,"modifiedTime":1735624638757,"sourceSize":1082,"sourcePath":"Unity/25. Trash Counter.md","exportPath":"unity/25.-trash-counter.html","showInTree":true,"treeOrder":467,"backlinks":[],"type":"markdown"},"unity/26.-stove-counter.html":{"title":"26. Stove Counter","icon":"","description":"고기를 굽는 StoveCounter를 만들어봅시다. 역시 Prefab을 먼저 만들어야 합니다. StoveCounter는 익히기 전 익힌 후의 오브젝트 input, output이 있기 때문에 Scriptable Object Script를 만들겠습니다.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; [CreateAssetMenu()]\npublic class FryingRecipeSO : ScriptableObject\n{ public KitchenObjectSO input; public KitchenObjectSO output; public float fryingTimerMax;\n}\n이제 고기 상태에 따라 Meet Uncooked, Cooked, Burned의 Scriptable Object와 Prefab을 만듭시다.<img src=\"https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/bagZDK/btssAHL3PhM/rXjdwUtJkw8eAJT6pyGOr0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/cx1MPZ/btssk1SBRSJ/VBwrujauNrjjP9KSciFCPk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/cSdtLN/btssBZyGhGf/JruIsm7eW6zkIP6BxFqlzK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">StoveCounter 스크립트를 만들고 SerializedField를 만들어줍시다. 그런 다음에 유니티로 돌아가서 레퍼런스를 넣어줍시다.public class StoveCounter : BaseCounter\n{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray;\n}\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounter : BaseCounter\n{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; private float fryingTimer; private FryingRecipeSO fryingRecipeSO; private void Update() { if (HasKitchenObject()) { fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { Debug.Log(\"Fried\"); fryingTimer = 0f; GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); } Debug.Log(fryingTimer); } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; }\n}\n위 코드는 문제가 발생 합니다. 시간은 계속 흐르기 때문에 오브젝트(고기)가 사라지고 output 오브젝트가 계속 새로 생깁니다. 이 문제를 해결하기 위해서 State Machine 개념을 도입해야 합니다. 처리하기 쉽게 Enum을 사용하도록 합시다. 그리고 State에 Burned도 있기 때문에 유사하게 Burning SO도 만듭시다.[CreateAssetMenu()]\npublic class BurningRecipeSO : ScriptableObject\n{ public KitchenObjectSO input; public KitchenObjectSO output; public float burningTimerMax;\n}\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounter : BaseCounter\n{ private enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }\n}\nStoveCounter에 Animation을 넣읍시다. StoveCounterVisual 스크립트를 생성할게요using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounterVisual : MonoBehaviour\n{ [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; [SerializeField] private StoveCounter stoveCounter;\n}\nStoveCounter에서 EventHandler를 만들고 Invoke 할게요.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounter : BaseCounter\n{ public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }\n}\nStoveCounterVisual에서 이벤트를 리슨 하는 코드를 작성!using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounterVisual : MonoBehaviour\n{ [SerializeField] private StoveCounter stoveCounter; [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; private void Start() { stoveCounter.OnStateChanged += StoveCounter_OnOnStateChanged; } private void StoveCounter_OnOnStateChanged(object sender, StoveCounter.OnStateChangedEventArgs e) { bool showVisual = e.state == StoveCounter.State.Frying || e.state == StoveCounter.State.Fried; stoveOnGameObject.SetActive(showVisual); particlesGameObject.SetActive(showVisual); }\n}\nProgressBar를 만듭시다. 전에 CuttingCounter에서 만든 거와 동일해요 그래서 재사용 가능using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public interface IHasProgress\n{ public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged; public class OnProgressChangedEventArgs: EventArgs { public float progressNormalized; }\n}\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI; public class ProgressBarUI : MonoBehaviour\n{ [SerializeField] private GameObject hasProgressGameObject; [SerializeField] private Image barImage; private IHasProgress hasProgress; private void Start() { hasProgress = hasProgressGameObject.GetComponent&lt;IHasProgress&gt;(); if (hasProgress == null) { Debug.LogError(\"GameObject \" + hasProgressGameObject + \" does not have a component that implements IHasProgress\"); } hasProgress.OnProgressChanged += HasProgress_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void HasProgress_OnProgressChanged(object sender, IHasProgress.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }\n}\nStoveCounter에서 Confirm 합시다.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounter : BaseCounter, IHasProgress\n{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }\n}\n끝!","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png","fullURL":"unity/26.-stove-counter.html","pathToRoot":"..","attachments":[],"createdTime":1735624640157,"modifiedTime":1735624693345,"sourceSize":23592,"sourcePath":"Unity/26. Stove Counter.md","exportPath":"unity/26.-stove-counter.html","showInTree":true,"treeOrder":468,"backlinks":[],"type":"markdown"},"unity/27.-plates-counter.html":{"title":"27. Plates Counter","icon":"","description":"접시가 생성되는 PlatesCounter를 만들어봅시다. Prefab을 만들어줍시다.스크립트를 생성합니다. PlatesCounter는 일정 시간이 흐르면 접시가 하나씩 생성되고 이미 존재한다면 그 위에 쌓아야 합니다.Plates Scriptable Object (기존에 만든 KitchenObjectSO로), Plate Object를 생성합니다.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounter : BaseCounter\n{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; } } }\n}\nVisual을 담당하는 스크립트도 만듭시다. 왜냐하면 그릇을 쌓아야 하기 때문입니다. 따라서, Visual에는 TopPoint와 그릇 Visual Prefab을 알고 있어야겠죠?using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounterVisual : MonoBehaviour\n{ [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab;\n}\n<img src=\"https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 PlatesCounter에서 이벤트 핸들러를 만들고 Invoke를 해줍시다. 그런 다음에 Visual에서 리슨 해주면 되겠네요.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounter : BaseCounter\n{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } }\n}\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounterVisual : MonoBehaviour\n{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); }\n}\n근데 뭔가 잘못된 거 같아요. 그릇들을 쌓으려면 그릇 List를 가지고 있어야하고 Vector를 높이는 코드가 없어요. 처리 ㄱㄱusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounterVisual : MonoBehaviour\n{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }\n}\n여기까지 하면 그릇을 추가하면 슉슉하고 올라갑니다. 이제 플레이어가 그릇을 가져가는 코드를 작성합시다. PlatesCounter에서 Remove 이벤트 핸들러를 만들어주고&nbsp;Interact가 발생하면&nbsp;&nbsp;이를 Invoke하면 되겠죠?using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounter : BaseCounter\n{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; public event EventHandler OnPlateRemoved; private float spawnPlateTimer; private float spawnPlateTimerMax = 4f; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } } public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player is empty Handed if (platesSpawnedAmount &gt; 0) { // There is at least one plate here platesSpawnedAmount--; KitchenObject.SpawnKitchenObject(plateKitchenObjectSO, player); // Update Visual OnPlateRemoved?.Invoke(this, EventArgs.Empty); } } }\n}\n비쥬얼에서 그릇 가져가는 이벤트를 리스닝 합시다.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlatesCounterVisual : MonoBehaviour\n{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; platesCounter.OnPlateRemoved += PlatesCounter_OnPlateRemoved; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png","fullURL":"unity/27.-plates-counter.html","pathToRoot":"..","attachments":[],"createdTime":1735624706370,"modifiedTime":1735624741552,"sourceSize":7704,"sourcePath":"Unity/27. Plates Counter.md","exportPath":"unity/27.-plates-counter.html","showInTree":true,"treeOrder":469,"backlinks":[],"type":"markdown"},"unity/28.-plate-pick-up-objects.html":{"title":"28. Plate Pick up Objects","icon":"","description":"Player가 그릇에 KitchenObject를 두는 로직을 구현하도록 하겠습니다.제약사항은 다음과 같습니다.\n같은 KitchenObject가 들어가면 안됨\nValid한 KitchenObject만 들어가야함\n가능한 경우는 두 가지입니다. 첫 번째는 ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직입니다. 두 번째는 ClearCounter에 KitchenObject(그릇 제외)가 놓여져 있고, Player가 들고 있는 그릇에 놓는 로직입니다.ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직부터 구현 하겠습니다.PlateKitchenObject 스크립트를 생성합니다. 이는 KitchenObject를 상속합니다. Plate Prefab에 스크립트를 넣고 레퍼런스로 Scriptable Object를 넣습니다.<img src=\"https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">// ClearCouter.cs public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject() is PlateKitchenObject) { // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter plateKitchenObject.AddIngredient(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }\n}\n여기에서 제약조건을 추가해야 합니다. - 이미 가지고 있는 타입인 경우에 어떠한 액션도 일어나지 않게 하겠습니다.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlateKitchenObject : KitchenObject\n{ private List&lt;KitchenObjectSO&gt; kitchenObjectSOArray; private void Awake() { kitchenObjectSOArray = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (kitchenObjectSOArray.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOArray.Add(kitchenObjectSO); return true; } } }\nClearCounter에 있는 함수 AddIngredienet를 TryAddIngredent로 리팩토링 하겠습니당// ClearCouter.cs if (player.GetKitchenObject() is PlateKitchenObject)\n{ // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter if(plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); }\n}\n제약조건 추가하기 - 유효한 KitchenObject만 넣을 수 있게 할게요\n토마토슬라이스\n치즈슬라이스\n빵\n양배추 슬라이스\n익힌 고기패티\n탄 고기패티\npublic class PlateKitchenObject : KitchenObject { [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOList; }\n<br><img src=\"https://blog.kakaocdn.net/dn/cj2Xuj/btssACqprSj/ONuQLp1IF5IhnmfiTsAgDk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class PlateKitchenObject : KitchenObject\n{ [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOListy; private List&lt;KitchenObjectSO&gt; kitchenObjectSOList; private void Awake() { kitchenObjectSOList = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (!validKitchenObjectSOListy.Contains(kitchenObjectSO)) { return false; } if (kitchenObjectSOList.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOList.Add(kitchenObjectSO); return true; } } }\n코드 리팩토링을 진행할게요. KitchenObject에&nbsp; TryGetPlate 메서드를 만들어서 이것을 사용하도록 할게요. plateKitchenObject를 얻기 위해서 GetKitchenObject를 호출하고 as를 이용해서 타입캐스팅을 하는데 이것을 더 안전하게 하기 위해서 out parameter를 이용하도록 하겠습니다.// KitchenObject.cs\npublic bool TryGetPlate(out PlateKitchenObject plateKitchenObject) { if (this is PlateKitchenObject) { plateKitchenObject = this as PlateKitchenObject; return true; } else { plateKitchenObject = null; return false; } }\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }\n}\nClearCounter에서 열심히 만든 부분을 StoveCounter, CuttingCounter에도 똑같이 적용하도록 하겠습니다.using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class StoveCounter : BaseCounter, IHasProgress\n{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } // State Machine 초기화 state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }\n}\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class CuttingCounter : BaseCounter, IHasProgress\n{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler OnCut; private int cuttingProgress; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgress = 0; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgress++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnCut?.Invoke(this, EventArgs.Empty); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgress) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }\n}\n이제는 ClearCounter에 그릇이 놓여져 있고 그릇에 KitchenObject를 위치시키는 로직을 짜도록 하겠습니다.ClearCounter가 HasKitchenObject가 true인 경우에서 Player가 KitchenObject를 가지고 있지만 그릇이 아닌 경우에서 ClearCounter가 그릇을 가지고 있는 경우를 생각하면 됩니다. 말로 전달하니 조금 복잡한 것 같네요.using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } else { // Player is not holding plate but something else if (GetKitchenObject().TryGetPlate(out plateKitchenObject)) { // There is Plate in Clear Counter if (plateKitchenObject.TryAddIngredient(player.GetKitchenObject().GetKitchenObjectSO())) { player.GetKitchenObject().DestroySelf(); } } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }\n}\n&nbsp;끝!","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png","fullURL":"unity/28.-plate-pick-up-objects.html","pathToRoot":"..","attachments":[],"createdTime":1735624742804,"modifiedTime":1735624803864,"sourceSize":21003,"sourcePath":"Unity/28. Plate Pick up Objects.md","exportPath":"unity/28.-plate-pick-up-objects.html","showInTree":true,"treeOrder":470,"backlinks":[],"type":"markdown"},"unity/glow-effect-만들기.html":{"title":"Glow Effect 만들기","icon":"","description":"게임을 만들어보고 싶어서, 요즘 유니티를 공부하고 있어요.게임을 하다 보면 반짝거리는 물체들이 많이 있는데, 이 반짝거리는 효과를 어떻게 만드는지 공부해 보고 정리해 봤습니다.&nbsp;Glow Effect를 만들기 위해서 4가지가 성립해야 합니다.\nShader - Emission에서 Color가 검은색이 아니고, Intensity &gt; 0 이어야 합니다.\nPost Processing Bloom (Intensity와 Threshold 세팅)\nRender Pipeline Asset에서 HDR 체크\nCamera에서 Rendering - Post Processing 체크\n먼저 3D Object 구를 만든 다음에 이 구에 적용한 Material을 만듭시다.<img src=\"https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/digjIe/btsnTEeToHv/SEV8Xa8MbugddHdz7EcIT0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">만든 Material을 구에 드래그 앤 드랍 해줍시다. 구 오브젝트를 선택하고 오른쪽 Inspector에서 Surface Inputs - Emission을 체크하고 색깔(검은색 X)을 지정하고 intensity를 0보다 높게 설정하면 1번 과정은 끝입니다. 그러면 구에 색깔이 있을 거예요.intensity를 엄청 높여도 Render Pipeline Asset이 HDR 옵션이 해제되어 있다면 Glow Effect는 나타나지 않을 거예요. 만약 나타난다면 HDR 옵션이 체크되어 있는 겁니다.<br><img src=\"https://blog.kakaocdn.net/dn/rYlDe/btsnTDfYB5N/KTQwg2cdfH6vEaKk9GTnR0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이제 Post Processing 옵션을 가지고 있는 Object를 만들 거예요. Create Empty 하고 이름을 변경합시다. 그런 다음에 아래처럼 Add Componet를 눌러서 Volume을 추가합시다.<br><img src=\"https://blog.kakaocdn.net/dn/cAcJUG/btsnSXFAZ5U/Uirq8dXFSglHSBkO8vArnK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/ME19w/btsnFK8UrKr/uTAOWh6GYcHtVmySaBjv61/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img src=\"https://blog.kakaocdn.net/dn/EykhQ/btsnEXAV6i8/qMLIiOvafOxKXXFoe67ye1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Volume에서 Profile 칸이 아마 비워져 있을 텐데, New를 클릭해서 새로 생성한 뒤에, Add Override를 눌러서 Post Processing - Bloom을 클릭합니다. 그리고 Threshold를 설정하고 Intensity를 설정하면 됩니다. 이때 Threshold는 최솟값이에요. Intensity보다 작아야 작동합니다. Intensity는 Glow Effect의 강함입니다. 저는 Intensity를 1로 설정하겠습니다. 아직도 역시 효과가 없을 거예요!이제 URP에서 HDR 옵션을 체크해 주면 Glow Effect가 적용됩니다.<br><img src=\"https://blog.kakaocdn.net/dn/yWAiA/btsnF6Ya6uR/KmEDRHvcznviMUYwbWb2fK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">근데 한 가지 문제점이 있는데 씬 뷰에서는 적용되는데 게임 뷰에서 적용이 안될 수도 있습니다. (아래사진 왼쪽). Camera를 클릭해서 Rendering - Post Processing을 체크하면 게임 뷰에서도 적용(아래사진 오른쪽)됩니다.<br><img src=\"https://blog.kakaocdn.net/dn/bFAcJS/btsnLvJE7ic/KLNSIRJlE4hBxymlgALJVK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/bg7pfi/btsnHRsEeVi/k0CzMQSMCyd2nV873aYKqK/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">단순 Glow Effect 뿐만 아니라 더 다양한 Effect를 적용하고 싶을 때 (예를 들면 캐릭터를 클릭했을 때 외곽선 하이라이팅 하고 싶은 경우)는 Unity에서 제공하는 Shader Graph를 사용하면 된다고 하네요. 다음에 기회가 되면 다뤄보도록 하겠습니다~<br>&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.youtube.com/watch?v=bkPe1hxOmbI\" target=\"_self\">https://www.youtube.com/watch?v=bkPe1hxOmbI</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1. Shader - Emission에서 Color가 검은색이 아니고, Intensity &gt; 0","level":4,"id":"1._Shader_-_Emission에서_Color가_검은색이_아니고,_Intensity_>_0_0"},{"heading":"2. Post Processing Bloom (Intensity와 Threshold 세팅)","level":4,"id":"2._Post_Processing_Bloom_(Intensity와_Threshold_세팅)_0"},{"heading":"Render Pipeline Asset에서 HDR 체크","level":4,"id":"Render_Pipeline_Asset에서_HDR_체크_0"},{"heading":"Camera에서 Rendering - Post Processing 체크","level":4,"id":"Camera에서_Rendering_-_Post_Processing_체크_0"},{"heading":"마무리","level":4,"id":"마무리_0"},{"heading":"Ref.","level":4,"id":"Ref._0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png","fullURL":"unity/glow-effect-만들기.html","pathToRoot":"..","attachments":[],"createdTime":1735624104412,"modifiedTime":1735624119471,"sourceSize":3650,"sourcePath":"Unity/Glow Effect 만들기.md","exportPath":"unity/glow-effect-만들기.html","showInTree":true,"treeOrder":471,"backlinks":[],"type":"markdown"},"unity/캐릭터-움직임과-time.deltatime.html":{"title":"캐릭터 움직임과 Time.deltaTime","icon":"","description":"이번에는 유니티를 이용해 WASD로 움직이는 캐릭터를 만들어봅시다.Unity Project 3D URP로 생성해요.<img src=\"https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">공허한 화면을 뒤로한 채 Hierarchy에서 오른쪽 클릭 후 3D Object -&gt; Plane을 눌러서 생성합시다. 이름을 Floor로 해줄게요그런 다음에, Inspector 창에서, Scale을 5, 5, 5로 Position과 Rotation을 0, 0, 0으로 설정합니다.<br><img src=\"https://blog.kakaocdn.net/dn/bgttrZ/btsn6GSp3Nd/jRc4YxJMqApLlhmuq8I6O0/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하이어러키 창에서 메인 카메라를 클릭한 다음 인스펙터창에서 Position, Rotation, Scale을 아래처럼 설정합니다.<br><img src=\"https://blog.kakaocdn.net/dn/AjHWa/btsn9Tizkle/7XvsKtRoy95S7IjBmF8cd1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">하이어러키 창에서 Create Empty를 만들고 이름을 Player로 합시다. 그리고 만든 Player 하위에 3D Object - Capsule을 생성합니다. 이렇게 하는 이유는 뷰 로직과 동작 로직을 분리하기 위해서예요.Player 오브젝트의 Position과 Rotation은 0,0,0 Scale은 1,1,1으로 설정하고 PlayerVisual(하위에 만든 캡슐)은 Postion (0,1,0) Rotation은 0,0,0, Scale은 1,1,1로 설정해 주세요.<br><img src=\"https://blog.kakaocdn.net/dn/RqMrq/btsn8pI3tFB/SnaoJYXV9i7IINUlK9jrO1/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><img src=\"https://blog.kakaocdn.net/dn/cBgb5p/btsn7trHo5k/ibnoMMkaaZStsV2b9Jpaek/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Project 창에서 Asset 폴더 아래에 Script 폴더를 만들고 그곳에 C# Script를 만들고 파일을 Player 오브젝트에 드래그 앤 드롭합니다.그런 다음에 Asset - Open C# Project를 클릭합니다.<br><img src=\"https://blog.kakaocdn.net/dn/TaZwr/btsn8pI31yr/M7jSrnckR44FD7Tkg4yU70/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine; public class Player : MonoBehaviour { [SerializeField] private float moveSpeed = 7f; private void Update() { Vector2 inputVector = new Vector2(0, 0); if (Input.GetKey(KeyCode.W)) { inputVector.y += 1; } if (Input.GetKey(KeyCode.A)) { inputVector.x -= 1; } if (Input.GetKey(KeyCode.S)) { inputVector.y -= 1; } if (Input.GetKey(KeyCode.D)) { inputVector.x += 1; } inputVector = inputVector.normalized; Vector3 moveDir = new Vector3(inputVector.x, 0, inputVector.y); transform.position += moveDir * moveSpeed * Time.deltaTime; }\n}\n좌표 시스템이 평소 학교에서 배웠던 거랑 일치하지 않을 수 있어요. 그리고 게임 엔진마다 축이 조금씩 상이하더라고요.&nbsp; 제가 공부할 때는 Right Handed를 많이 사용했는데, 유니티는 Left Handed라고 합니다. 아래 그림 참고 하시면 될 것 같아요.<br><img src=\"https://blog.kakaocdn.net/dn/TIRvR/btsn8lfDOKD/RL0AI3d1kyNgGDFcfsrZSk/img.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">코드 자체는 별 게 없는 것 같아요. 조금 특징적인 것에 대해서만 알면 될 것 같습니다.inputVector = inputVector.normalized;\n왜 inputVector를 정규화를 할까요? 왜냐하면, Vector는 속력이 아닌 속도를 나타내기 때문입니다. 만약 정규화를 하지 않았을 때, 대각선으로 이동한다면 inputVector의 값은 (1,1)이 될 거예요. 그러면 벡터의 길이 (스칼라) 값은 1.414...이 되기 때문에 대각선으로 이동할 때 더 빠른 속도로 이동하게 됩니다. 즉 동일한 속도가 보장이 되지 않게 됩니다. 이러한 이유로 정규화를 통해서 방향만을 얻고, 이동 속도는 변수로 곱해서 처리하는 것이 일반적인 것 같습니다.transform.position += moveDir * moveSpeed * Time.deltaTime;\n위 코드에서 속력과 방향에 Time.deltaTime를 곱하고 있습니다. 왜 그럴까요? 이것을 알기 위해서는 Frame(프레임)과 FPS에 대해 먼저 알아야 합니다.동영상은 정지된 여러 장의 사진으로 구성되어 있고, 우리는 이 사진이 빠르게 변하는 것을 움직이는 것으로 보게 됩니다. 여기에서 이 정지된 사진을 프레임이라고 합니다. FPS는 Frame Per seconds의 준말로 1초당 몇 장의 사진이 변하는가입니다. 60 FPS면 1초당 연속하는 60장의 사진을 보는 것이라고 이해하면 될 것 같아요. 그래서 FPS는 성능에 비례합니다. (고사양 컴퓨터면 더 높고, 더 낮은 사양이면 더 낮습니다.)유니티에서 Update() 메서드는 1 프레임을 주기로 호출됩니다. 만약 위의 코드에서 Time.deltaTime이 없다면, 어떻게 될까요? 고사양의 컴퓨터를 가진 사람은 더 빨리 이동할 것입니다. 저사양의 컴퓨터를 가진 사람은 더 느리게 이동할 테고요. 이러한 차이를 보정하기 위해서 바로 Time.deltaTime을 곱하는 것입니다.&nbsp;유니티에서 Time.deltaTime의 정의는&nbsp;The interval in seconds from the last frame to the current one입니다.&nbsp;즉 현재 프레임과 이전 프레임의 시간 간격을 의미하게 되는 거예요. 따라서 고사양의 컴퓨터는 deltaTime의 값은 작을 테고, 저사양의 컴퓨터의 값은 더 높게 됩니다.&nbsp;고사양 컴퓨터는 60 fps가 나오고, 저사양의 게임은 30fps가 나온다고 가정하면, 아래와 같이 1 프레임당 시간 간격, 즉 deltaTime을 구할 수 있습니다.30fps = 1 / 30 = 0.03333333360fps = 1 / 60 = 0.01666666이때 Update 코드를 생각해봅시다. Update 코드는 1 프레임에 한번 호출된다고 했으니까,&nbsp;저사양 컴퓨터: (moveDir moveSpeed 0.3333333) * 30 만큼 이동 (30프레임)고사양 컴퓨터: (moveDir moveSpeed 0.016666666) * 60 만큼 이동 (60프레임)의 값은 같게 됩니다.그래서, Time.deltaTime로 컴퓨터 사양에 따른 이동을 보정할 수 있게 됩니다.캐릭터 이동을 구현할 때, GetKey를 이용해 구현하는 것보다, Input System이라는 package를 이용해서 구현하는 것이 확장하기 더 좋아요. 절대 Input System Package를 이용하세요!<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose/Ex_Collision_Detection\" target=\"_self\">https://github.com/psychehose/Ex_Collision_Detection</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://m.blog.naver.com/destiny9720/221411002215?view=img_1\" target=\"_self\">https://m.blog.naver.com/destiny9720/221411002215?view=img_1</a>&nbsp;<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization\" target=\"_self\">https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization</a><br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://windeva.tistory.com/840\" target=\"_self\">https://windeva.tistory.com/840</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"마무리","level":4,"id":"마무리_0"},{"heading":"Github","level":4,"id":"Github_0"},{"heading":"Ref","level":4,"id":"Ref_0"}],"links":[],"author":"","coverImageURL":"https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png","fullURL":"unity/캐릭터-움직임과-time.deltatime.html","pathToRoot":"..","attachments":[],"createdTime":1735624132830,"modifiedTime":1735624168427,"sourceSize":6707,"sourcePath":"Unity/캐릭터 움직임과 Time.deltaTime.md","exportPath":"unity/캐릭터-움직임과-time.deltatime.html","showInTree":true,"treeOrder":472,"backlinks":[],"type":"markdown"},"index.html":{"title":" Home","icon":"","description":" 금융공학과 소프트웨어공학을 전공하며 쌓은 수학적, 논리적 사고를 바탕으로 iOS 개발을 시작했습니다. 저는 시스템 설계와 구현에 강점이 있으며, 새로운 기술 도입에 적극적입니다. iOS 개발과 Android / iOS SDK - 언리얼엔진 플러그인 개발을 해왔습니다. 현재는 크로스플랫폼 (Windows, Android, iOS)을 타겟으로 하는 골프공 물리 시뮬레이터 개발과 스윙 모션 영상 처리를 개발 하고 있습니다.\nC++ CMake - ⭐⭐⭐\nOpenCV - ⭐⭐⭐ Swift Objective C RxSwift - ⭐⭐⭐⭐\nMetal - ⭐⭐\nJava Android - ⭐⭐\nUnreal Engine - ⭐⭐\nGit Perforce Helix Core -⭐⭐⭐\nQt - ⭐⭐⭐\n⭐⭐⭐⭐: 전문적 활용 - 심화 문제 해결 및 최적화 가능\n⭐⭐⭐ : 실무 활용 - 일상적 개발 업무 수행 가능\n⭐⭐: 기본 활용 - 이해 및 참고 자료를 통한 구현 가능\nGraphics\nRobotics\nComputer Vision C++ 물리 라이브러리 리팩토링 (윈도우 Legacy C / C++ -&gt; 크로스플랫폼 Modern C++ ) 골프공 물리 Simulator 개발, Qt, OpenGL, Metal) iOS: SwiftUI, Combine, Metal, MVMM (Front: Full Swift Native)\nAndroid, Linux, Windows: Qt 크로스플랫폼 비디오 캡쳐 라이브러리 개발 (OpenCV) 안드로이드 / iOS 네이티브 라이브러리 개발 및 언리얼엔진 통합\n+ 언리얼엔진 클라이언트 개발 및 언리얼 인사이트를 활용한 게임 최적화 경험\n+ 브랜치 머지 전략 수립과 코드 리뷰 문화 도입 등을 통해 개발 문화를 정착 핀테크 기업에서 iOS 개발자로 근무하며 블록딜 및 비상장주식 플랫폼 개발을 주도 펀드고 앱 : 기획/디자인 단계부터 참여하며 모든 피쳐 개발을 담당 제이스톡 앱 : Modular Architecture를 바탕으로 비상장주식 거래 플랫폼을 개발 + 회사 내 프로젝트를 위한 인앱결제, 네트워크, 유저 정보, OAuth 모듈을 개발 및 CI/CD 배포 환경을 구축 Role - iOS Developer lead\n20th SOPT 앱잼(3주 장기 해커톤) Project Init ~ AppStore 배포 종료 (22.11 ~ 24.07)\nMVVM, RxSwift, ReactorKit, xcframework, fastlane\nSPM을 이용한 일부 부분 모듈화\niOS 4명 - 기획 1명 - 디자인 1명 - 서버 2명 - 안드로이드 4명 Role - iOS Developer\n무중력지대 씨앗프로젝트\nProject Init ~ AppStore 배포 종료(20.09 ~ 22.08)\nMVVM, RxSwift, Moya, `Socket' iOS 3명 - 기획 2명 - 디자인 1명 - 서버 2명 16th SOPT 앱잼 (3주 장기 해커톤) Project Init ~ AppStore 배포 종료 (20.08 ~ 23.04)\nMVC , YPImagePicker …\niOS 5명 - 기획 2명 - 디자인 1명 - 서버 1명 - 안드로이드 3명\nMAU: 225명\n전체 유저: 1,295명 / 고양이: 1,523마리 / 리뷰: 11,169개\n아주대학교 금융공학과 전공, 소프트웨어학과 복수전공\n딥러닝 컴퓨터 비전 완벽 가이드 - 인프런\nQt 프로그래밍 1편 - 인프런\nSOPT 창업동아리 26th iOS 파트 수료2023 let us: Go! Summer 찍먹톤 최우수상 (2023.06)\nSOPT 창업동아리 20th 앱잼 대상 (2022.08)\nSOPT 창업동아리 16th 앱잼 최우수상 (2020.08)Glitch Hackathon - Near Rust SDK 사용 Project (2023.05)\nEmail: <a data-tooltip-position=\"top\" aria-label=\"mailto:psychehose@gmail.com\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"mailto:psychehose@gmail.com\" target=\"_self\">psychehose@gmail.com</a>\n<br>GitHub: <a data-tooltip-position=\"top\" aria-label=\"https://github.com/psychehose\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/psychehose\" target=\"_self\">psychehose</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"psychehose's Blog","level":1,"id":"psychehose's_Blog_0"},{"heading":"Introduce","level":2,"id":"Introduce_0"},{"heading":"Skill.","level":2,"id":"Skill._0"},{"heading":"Interest.","level":2,"id":"Interest._0"},{"heading":"Work.","level":2,"id":"Work._0"},{"heading":"골프존","level":3,"id":"골프존_0"},{"heading":"SDK Developer (23.10 ~ 재직중)","level":4,"id":"SDK_Developer_(23.10_~_재직중)_0"},{"heading":"제이스톡","level":3,"id":"제이스톡_0"},{"heading":"iOS Developer (21.11 ~ 22.11)","level":4,"id":"iOS_Developer_(21.11_~_22.11)_0"},{"heading":"Side Team Project","level":2,"id":"Side_Team_Project_0"},{"heading":"Hous","level":3,"id":"Hous_0"},{"heading":"공동생활 규칙 체크 어플리케이션","level":4,"id":"공동생활_규칙_체크_어플리케이션_0"},{"heading":"마루","level":3,"id":"마루_0"},{"heading":"온라인 독서 토론 어플리케이션","level":4,"id":"온라인_독서_토론_어플리케이션_0"},{"heading":"Ounce","level":3,"id":"Ounce_0"},{"heading":"고양이 사료 기록 어플리케이션","level":4,"id":"고양이_사료_기록_어플리케이션_0"},{"heading":"Education","level":2,"id":"Education_0"},{"heading":"Award","level":2,"id":"Award_0"},{"heading":"Hackathon","level":2,"id":"Hackathon_0"},{"heading":"Contact.","level":2,"id":"Contact._0"}],"links":["mailto:psychehose@gmail.com"],"author":"","coverImageURL":"","fullURL":"index.html","pathToRoot":".","attachments":[],"createdTime":1742132448496,"modifiedTime":1750251890936,"sourceSize":3922,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":473,"backlinks":[],"type":"markdown"}},"fileInfo":{"algorithm/lecture/bfs.html":{"createdTime":1719764451038,"modifiedTime":1737702291698,"sourceSize":1827,"sourcePath":"Algorithm/Lecture/BFS.md","exportPath":"algorithm/lecture/bfs.html","showInTree":true,"treeOrder":2,"backlinks":[],"type":"markdown","data":null},"algorithm/lecture/dfs.html":{"createdTime":1719763455545,"modifiedTime":1737702293259,"sourceSize":1256,"sourcePath":"Algorithm/Lecture/DFS.md","exportPath":"algorithm/lecture/dfs.html","showInTree":true,"treeOrder":3,"backlinks":[],"type":"markdown","data":null},"algorithm/lecture/그리디-알고리즘.html":{"createdTime":1719241549696,"modifiedTime":1737702294443,"sourceSize":2002,"sourcePath":"Algorithm/Lecture/그리디 알고리즘.md","exportPath":"algorithm/lecture/그리디-알고리즘.html","showInTree":true,"treeOrder":4,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/3.-longest-substring-without-repeating-characters.html":{"createdTime":1736861505493,"modifiedTime":1737702301768,"sourceSize":1758,"sourcePath":"Algorithm/LeetCode/3. Longest Substring Without Repeating Characters.md","exportPath":"algorithm/leetcode/3.-longest-substring-without-repeating-characters.html","showInTree":true,"treeOrder":6,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/21.-merge-two-sorted-lists.html":{"createdTime":1741189701487,"modifiedTime":1741189701487,"sourceSize":935,"sourcePath":"Algorithm/LeetCode/21. Merge Two Sorted Lists.md","exportPath":"algorithm/leetcode/21.-merge-two-sorted-lists.html","showInTree":true,"treeOrder":7,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/55.-jump-game.html":{"createdTime":1736697355570,"modifiedTime":1737702320255,"sourceSize":2478,"sourcePath":"Algorithm/LeetCode/55. Jump Game.md","exportPath":"algorithm/leetcode/55.-jump-game.html","showInTree":true,"treeOrder":8,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/62.-unique-paths.html":{"createdTime":1736064680155,"modifiedTime":1737702331785,"sourceSize":1322,"sourcePath":"Algorithm/LeetCode/62. Unique Paths.md","exportPath":"algorithm/leetcode/62.-unique-paths.html","showInTree":true,"treeOrder":9,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/70.-climbing-stair.html":{"createdTime":1735919172876,"modifiedTime":1737702359498,"sourceSize":875,"sourcePath":"Algorithm/LeetCode/70. Climbing Stair.md","exportPath":"algorithm/leetcode/70.-climbing-stair.html","showInTree":true,"treeOrder":10,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/78.-subsets.html":{"createdTime":1719241549696,"modifiedTime":1737702373256,"sourceSize":980,"sourcePath":"Algorithm/LeetCode/78. Subsets.md","exportPath":"algorithm/leetcode/78.-subsets.html","showInTree":true,"treeOrder":11,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/141.-linked-list-cycle.html":{"createdTime":1741189701486,"modifiedTime":1741189701486,"sourceSize":386,"sourcePath":"Algorithm/LeetCode/141. Linked List Cycle.md","exportPath":"algorithm/leetcode/141.-linked-list-cycle.html","showInTree":true,"treeOrder":12,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/143.-reorder-list.html":{"createdTime":1741189701486,"modifiedTime":1741189701486,"sourceSize":1064,"sourcePath":"Algorithm/LeetCode/143. Reorder List.md","exportPath":"algorithm/leetcode/143.-reorder-list.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/152.-maximum-product-subarray.html":{"createdTime":1737458669761,"modifiedTime":1738476474319,"sourceSize":1622,"sourcePath":"Algorithm/LeetCode/152. Maximum Product Subarray.md","exportPath":"algorithm/leetcode/152.-maximum-product-subarray.html","showInTree":true,"treeOrder":14,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/198.-house-robber.html":{"createdTime":1736174638171,"modifiedTime":1737702392885,"sourceSize":1496,"sourcePath":"Algorithm/LeetCode/198. House Robber.md","exportPath":"algorithm/leetcode/198.-house-robber.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/200.-number-of-islands.html":{"createdTime":1736697355570,"modifiedTime":1737702401027,"sourceSize":3707,"sourcePath":"Algorithm/LeetCode/200. Number of Islands.md","exportPath":"algorithm/leetcode/200.-number-of-islands.html","showInTree":true,"treeOrder":16,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/206.-reverse-linked-list.html":{"createdTime":1741189701486,"modifiedTime":1741189701487,"sourceSize":632,"sourcePath":"Algorithm/LeetCode/206. Reverse Linked List.md","exportPath":"algorithm/leetcode/206.-reverse-linked-list.html","showInTree":true,"treeOrder":17,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/217.-contains-duplicate.html":{"createdTime":1719241549696,"modifiedTime":1737702408185,"sourceSize":658,"sourcePath":"Algorithm/LeetCode/217. Contains Duplicate.md","exportPath":"algorithm/leetcode/217.-contains-duplicate.html","showInTree":true,"treeOrder":18,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/271.-encode-and-decode-strings.html":{"createdTime":1737280427455,"modifiedTime":1737702411256,"sourceSize":1553,"sourcePath":"Algorithm/LeetCode/271. Encode and Decode Strings.md","exportPath":"algorithm/leetcode/271.-encode-and-decode-strings.html","showInTree":true,"treeOrder":19,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/424.-longest-repeating-character-replacement.html":{"createdTime":1736945531620,"modifiedTime":1737702414822,"sourceSize":3596,"sourcePath":"Algorithm/LeetCode/424. Longest Repeating Character Replacement.md","exportPath":"algorithm/leetcode/424.-longest-repeating-character-replacement.html","showInTree":true,"treeOrder":20,"backlinks":[],"type":"markdown","data":null},"algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html":{"createdTime":1750168435995,"modifiedTime":1750171108266,"sourceSize":7393,"sourcePath":"Algorithm/LeetCode/3405. Count the Number of Arrays with K Matching Adjacent Elements.md","exportPath":"algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html","showInTree":true,"treeOrder":21,"backlinks":[],"type":"markdown","data":null},"algorithm/study/dp.html":{"createdTime":1724571717940,"modifiedTime":1735553971555,"sourceSize":202,"sourcePath":"Algorithm/Study/DP.md","exportPath":"algorithm/study/dp.html","showInTree":true,"treeOrder":23,"backlinks":[],"type":"markdown","data":null},"algorithm/study/heap-&-우선순위-큐.html":{"createdTime":1720440755344,"modifiedTime":1735553976765,"sourceSize":6124,"sourcePath":"Algorithm/Study/Heap & 우선순위 큐.md","exportPath":"algorithm/study/heap-&-우선순위-큐.html","showInTree":true,"treeOrder":24,"backlinks":[],"type":"markdown","data":null},"algorithm/study/two-pointer.html":{"createdTime":1724571717940,"modifiedTime":1735554000945,"sourceSize":4954,"sourcePath":"Algorithm/Study/Two Pointer.md","exportPath":"algorithm/study/two-pointer.html","showInTree":true,"treeOrder":25,"backlinks":[],"type":"markdown","data":null},"algorithm/study/누적합-알고리즘.html":{"createdTime":1722252321633,"modifiedTime":1722252599292,"sourceSize":444,"sourcePath":"Algorithm/Study/누적합 알고리즘.md","exportPath":"algorithm/study/누적합-알고리즘.html","showInTree":true,"treeOrder":26,"backlinks":[],"type":"markdown","data":null},"algorithm/study/문제유형.html":{"createdTime":1742565162943,"modifiedTime":1742617487893,"sourceSize":4387,"sourcePath":"Algorithm/Study/문제유형.md","exportPath":"algorithm/study/문제유형.html","showInTree":true,"treeOrder":27,"backlinks":[],"type":"markdown","data":null},"algorithm/study/이분탐색-&-파라메트릭-서치.html":{"createdTime":1722252335588,"modifiedTime":1722253810939,"sourceSize":2877,"sourcePath":"Algorithm/Study/이분탐색 & 파라메트릭 서치.md","exportPath":"algorithm/study/이분탐색-&-파라메트릭-서치.html","showInTree":true,"treeOrder":28,"backlinks":[],"type":"markdown","data":null},"algorithm/study/코딩테스트를-위한-암기.html":{"createdTime":1742305069535,"modifiedTime":1742306811370,"sourceSize":1172,"sourcePath":"Algorithm/Study/코딩테스트를 위한 암기.md","exportPath":"algorithm/study/코딩테스트를-위한-암기.html","showInTree":true,"treeOrder":29,"backlinks":[],"type":"markdown","data":null},"android/wifi-util-class.html":{"createdTime":1739278204978,"modifiedTime":1739281293005,"sourceSize":850,"sourcePath":"Android/Wifi Util Class.md","exportPath":"android/wifi-util-class.html","showInTree":true,"treeOrder":31,"backlinks":[],"type":"markdown","data":null},"android/인앱-결제.html":{"createdTime":1751291017364,"modifiedTime":1751291017364,"sourceSize":3344,"sourcePath":"Android/인앱 결제.md","exportPath":"android/인앱-결제.html","showInTree":true,"treeOrder":32,"backlinks":[],"type":"markdown","data":null},"ble/1.-ble-개요.html":{"createdTime":1710855209731,"modifiedTime":1737702241699,"sourceSize":520,"sourcePath":"BLE/1. BLE 개요.md","exportPath":"ble/1.-ble-개요.html","showInTree":true,"treeOrder":34,"backlinks":[],"type":"markdown","data":null},"ble/2.-ble-프로토콜-스택.html":{"createdTime":1710855209731,"modifiedTime":1737702244630,"sourceSize":3286,"sourcePath":"BLE/2. BLE 프로토콜 스택.md","exportPath":"ble/2.-ble-프로토콜-스택.html","showInTree":true,"treeOrder":35,"backlinks":[],"type":"markdown","data":null},"ble/3.-ble-att,-gatt.html":{"createdTime":1710855209732,"modifiedTime":1737702245694,"sourceSize":1077,"sourcePath":"BLE/3. BLE ATT, GATT.md","exportPath":"ble/3.-ble-att,-gatt.html","showInTree":true,"treeOrder":36,"backlinks":[],"type":"markdown","data":null},"ble/4.-ble-디바이스-연결.html":{"createdTime":1710855209732,"modifiedTime":1737702259925,"sourceSize":3855,"sourcePath":"BLE/4. BLE 디바이스 연결.md","exportPath":"ble/4.-ble-디바이스-연결.html","showInTree":true,"treeOrder":37,"backlinks":[],"type":"markdown","data":null},"cpp/basic/0.-c,-c++-컴파일-과정.html":{"createdTime":1737701652291,"modifiedTime":1737702579388,"sourceSize":4915,"sourcePath":"CPP/Basic/0. c, c++ 컴파일 과정.md","exportPath":"cpp/basic/0.-c,-c++-컴파일-과정.html","showInTree":true,"treeOrder":40,"backlinks":[],"type":"markdown","data":null},"cpp/basic/1.-참조와-포인터.html":{"createdTime":1710855209736,"modifiedTime":1737702735019,"sourceSize":2798,"sourcePath":"CPP/Basic/1. 참조와 포인터.md","exportPath":"cpp/basic/1.-참조와-포인터.html","showInTree":true,"treeOrder":41,"backlinks":[],"type":"markdown","data":null},"cpp/basic/2.-생성자.html":{"createdTime":1718520040497,"modifiedTime":1738470398378,"sourceSize":2644,"sourcePath":"CPP/Basic/2. 생성자.md","exportPath":"cpp/basic/2.-생성자.html","showInTree":true,"treeOrder":42,"backlinks":[],"type":"markdown","data":null},"cpp/basic/3.-overloading.html":{"createdTime":1718520040497,"modifiedTime":1738470395424,"sourceSize":5972,"sourcePath":"CPP/Basic/3. Overloading.md","exportPath":"cpp/basic/3.-overloading.html","showInTree":true,"treeOrder":43,"backlinks":[],"type":"markdown","data":null},"cpp/basic/4.-상속.html":{"createdTime":1719322122419,"modifiedTime":1738470391965,"sourceSize":16194,"sourcePath":"CPP/Basic/4. 상속.md","exportPath":"cpp/basic/4.-상속.html","showInTree":true,"treeOrder":44,"backlinks":[],"type":"markdown","data":null},"cpp/basic/5.-다중-상속.html":{"createdTime":1718520040498,"modifiedTime":1738470386639,"sourceSize":6417,"sourcePath":"CPP/Basic/5. 다중 상속.md","exportPath":"cpp/basic/5.-다중-상속.html","showInTree":true,"treeOrder":45,"backlinks":[],"type":"markdown","data":null},"cpp/basic/6.-파일-입출력.html":{"createdTime":1718520118477,"modifiedTime":1738470383466,"sourceSize":15389,"sourcePath":"CPP/Basic/6. 파일 입출력.md","exportPath":"cpp/basic/6.-파일-입출력.html","showInTree":true,"treeOrder":46,"backlinks":[],"type":"markdown","data":null},"cpp/build-system/cmake.html":{"createdTime":1742132450645,"modifiedTime":1742132450645,"sourceSize":1697,"sourcePath":"CPP/Build System/CMake.md","exportPath":"cpp/build-system/cmake.html","showInTree":true,"treeOrder":48,"backlinks":[],"type":"markdown","data":null},"cpp/build-system/pic.html":{"createdTime":1740931213902,"modifiedTime":1740931213902,"sourceSize":2715,"sourcePath":"CPP/Build System/PIC.md","exportPath":"cpp/build-system/pic.html","showInTree":true,"treeOrder":49,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/1.-thread.html":{"createdTime":1735206576299,"modifiedTime":1738470378986,"sourceSize":4745,"sourcePath":"CPP/Concurrency/1. thread.md","exportPath":"cpp/concurrency/1.-thread.html","showInTree":true,"treeOrder":51,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/2.-mutex,-deadlock.html":{"createdTime":1735209156958,"modifiedTime":1738470375860,"sourceSize":15232,"sourcePath":"CPP/Concurrency/2. Mutex, deadlock.md","exportPath":"cpp/concurrency/2.-mutex,-deadlock.html","showInTree":true,"treeOrder":52,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/3.-memory-order,-atomic.html":{"createdTime":1735212962377,"modifiedTime":1738470370845,"sourceSize":12235,"sourcePath":"CPP/Concurrency/3. memory order, atomic.md","exportPath":"cpp/concurrency/3.-memory-order,-atomic.html","showInTree":true,"treeOrder":53,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/4.-future,-async,-promise.html":{"createdTime":1735219967281,"modifiedTime":1738470366963,"sourceSize":9339,"sourcePath":"CPP/Concurrency/4. future, async, promise.md","exportPath":"cpp/concurrency/4.-future,-async,-promise.html","showInTree":true,"treeOrder":54,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html":{"createdTime":1735453051496,"modifiedTime":1738470362844,"sourceSize":2929,"sourcePath":"CPP/Concurrency/5. 비동기, promise & future, callback, async, ThreadPool.md","exportPath":"cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html","showInTree":true,"treeOrder":55,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/6.-threadpool.html":{"createdTime":1735310618551,"modifiedTime":1738470354443,"sourceSize":13497,"sourcePath":"CPP/Concurrency/6. ThreadPool.md","exportPath":"cpp/concurrency/6.-threadpool.html","showInTree":true,"treeOrder":56,"backlinks":[],"type":"markdown","data":null},"cpp/concurrency/7.-event-system.html":{"createdTime":1739066946213,"modifiedTime":1739067160063,"sourceSize":207,"sourcePath":"CPP/Concurrency/7.  Event System.md","exportPath":"cpp/concurrency/7.-event-system.html","showInTree":true,"treeOrder":57,"backlinks":[],"type":"markdown","data":null},"cpp/etc/c++-static-const-초기화.html":{"createdTime":1743691206979,"modifiedTime":1743691206979,"sourceSize":2871,"sourcePath":"CPP/etc/C++ static const 초기화.md","exportPath":"cpp/etc/c++-static-const-초기화.html","showInTree":true,"treeOrder":59,"backlinks":[],"type":"markdown","data":null},"cpp/etc/const-위치-헷갈리는-점-정리.html":{"createdTime":1742746589113,"modifiedTime":1742748551725,"sourceSize":3217,"sourcePath":"CPP/etc/const 위치 헷갈리는 점 정리.md","exportPath":"cpp/etc/const-위치-헷갈리는-점-정리.html","showInTree":true,"treeOrder":60,"backlinks":[],"type":"markdown","data":null},"cpp/etc/rvo.html":{"createdTime":1751879420587,"modifiedTime":1751879420587,"sourceSize":1562,"sourcePath":"CPP/etc/RVO.md","exportPath":"cpp/etc/rvo.html","showInTree":true,"treeOrder":61,"backlinks":[],"type":"markdown","data":null},"cpp/etc/리소스-임베딩-by-compile.html":{"createdTime":1748530578247,"modifiedTime":1748530578247,"sourceSize":1054,"sourcePath":"CPP/etc/리소스 임베딩 by compile.md","exportPath":"cpp/etc/리소스-임베딩-by-compile.html","showInTree":true,"treeOrder":62,"backlinks":[],"type":"markdown","data":null},"cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html":{"createdTime":1742745781068,"modifiedTime":1742746401621,"sourceSize":2672,"sourcePath":"CPP/etc/상속 생성자, 소멸자 헷갈리는 점.md","exportPath":"cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html","showInTree":true,"treeOrder":63,"backlinks":[],"type":"markdown","data":null},"cpp/etc/유리수-클래스-구현.html":{"createdTime":1742742104554,"modifiedTime":1742744544787,"sourceSize":3253,"sourcePath":"CPP/etc/유리수 클래스 구현.md","exportPath":"cpp/etc/유리수-클래스-구현.html","showInTree":true,"treeOrder":64,"backlinks":[],"type":"markdown","data":null},"cpp/etc/전역변수와-정적변수의-공통점과-차이점.html":{"createdTime":1742748775631,"modifiedTime":1742749373299,"sourceSize":1085,"sourcePath":"CPP/etc/전역변수와 정적변수의 공통점과 차이점.md","exportPath":"cpp/etc/전역변수와-정적변수의-공통점과-차이점.html","showInTree":true,"treeOrder":65,"backlinks":[],"type":"markdown","data":null},"cpp/lib/fmt.html":{"createdTime":1738210790687,"modifiedTime":1738229071138,"sourceSize":3710,"sourcePath":"CPP/Lib/fmt.md","exportPath":"cpp/lib/fmt.html","showInTree":true,"treeOrder":67,"backlinks":[],"type":"markdown","data":null},"cpp/lib/google-test.html":{"createdTime":1738155816275,"modifiedTime":1738210616535,"sourceSize":1130,"sourcePath":"CPP/Lib/Google Test.md","exportPath":"cpp/lib/google-test.html","showInTree":true,"treeOrder":68,"backlinks":[],"type":"markdown","data":null},"cpp/modern/1.-rvalue-rvalue-참조.html":{"createdTime":1737701652292,"modifiedTime":1738470341586,"sourceSize":2063,"sourcePath":"CPP/Modern/1. rvalue rvalue 참조.md","exportPath":"cpp/modern/1.-rvalue-rvalue-참조.html","showInTree":true,"treeOrder":70,"backlinks":[],"type":"markdown","data":null},"cpp/modern/2.-move,-레퍼런스-겹침-규칙.html":{"createdTime":1734522365540,"modifiedTime":1738470334592,"sourceSize":3039,"sourcePath":"CPP/Modern/2. move, 레퍼런스 겹침 규칙.md","exportPath":"cpp/modern/2.-move,-레퍼런스-겹침-규칙.html","showInTree":true,"treeOrder":71,"backlinks":[],"type":"markdown","data":null},"cpp/modern/3.-raii,-unique-ptr.html":{"createdTime":1737701652291,"modifiedTime":1738470330827,"sourceSize":7122,"sourcePath":"CPP/Modern/3. RAII, unique ptr.md","exportPath":"cpp/modern/3.-raii,-unique-ptr.html","showInTree":true,"treeOrder":72,"backlinks":[],"type":"markdown","data":null},"cpp/modern/4.-shared,-weak-ptr.html":{"createdTime":1735107852604,"modifiedTime":1739074423015,"sourceSize":9792,"sourcePath":"CPP/Modern/4. shared, weak ptr.md","exportPath":"cpp/modern/4.-shared,-weak-ptr.html","showInTree":true,"treeOrder":73,"backlinks":[],"type":"markdown","data":null},"cpp/modern/5.-callable-etc..html":{"createdTime":1737701652292,"modifiedTime":1738470322442,"sourceSize":9317,"sourcePath":"CPP/Modern/5. callable etc..md","exportPath":"cpp/modern/5.-callable-etc..html","showInTree":true,"treeOrder":74,"backlinks":[],"type":"markdown","data":null},"cpp/modern/6.-uniform-initializer.html":{"createdTime":1738400809952,"modifiedTime":1738470293413,"sourceSize":6098,"sourcePath":"CPP/Modern/6. Uniform Initializer.md","exportPath":"cpp/modern/6.-uniform-initializer.html","showInTree":true,"treeOrder":75,"backlinks":[],"type":"markdown","data":null},"cpp/modern/7.-random,-chrono-library.html":{"createdTime":1737554201126,"modifiedTime":1738470350209,"sourceSize":3357,"sourcePath":"CPP/Modern/7. random, chrono library.md","exportPath":"cpp/modern/7.-random,-chrono-library.html","showInTree":true,"treeOrder":76,"backlinks":[],"type":"markdown","data":null},"cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html":{"createdTime":1739278009360,"modifiedTime":1739278009360,"sourceSize":11800,"sourcePath":"CPP/Platform/C++ 프로젝트에서 JNI를 이용해서 Android 호출.md","exportPath":"cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html","showInTree":true,"treeOrder":78,"backlinks":[],"type":"markdown","data":null},"cpp/platform/sfml과-visitor-pattern.html":{"createdTime":1735918424772,"modifiedTime":1735918424773,"sourceSize":7230,"sourcePath":"CPP/Platform/SFML과 Visitor Pattern.md","exportPath":"cpp/platform/sfml과-visitor-pattern.html","showInTree":true,"treeOrder":79,"backlinks":[],"type":"markdown","data":null},"cpp/template/1.-명시적-템플릿-인스터스화.html":{"createdTime":1752046023827,"modifiedTime":1752046023827,"sourceSize":4419,"sourcePath":"CPP/Template/1. 명시적 템플릿 인스터스화.md","exportPath":"cpp/template/1.-명시적-템플릿-인스터스화.html","showInTree":true,"treeOrder":81,"backlinks":[],"type":"markdown","data":null},"cpp/quiz.html":{"createdTime":1754545491055,"modifiedTime":1754545491055,"sourceSize":0,"sourcePath":"CPP/Quiz.md","exportPath":"cpp/quiz.html","showInTree":true,"treeOrder":82,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/avl-트리.html":{"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":0,"sourcePath":"CS/자료구조/AVL 트리.md","exportPath":"cs/자료구조/avl-트리.html","showInTree":true,"treeOrder":85,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/b+-tree.html":{"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":524,"sourcePath":"CS/자료구조/B+ Tree.md","exportPath":"cs/자료구조/b+-tree.html","showInTree":true,"treeOrder":86,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/binary-search-tree.html":{"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":687,"sourcePath":"CS/자료구조/Binary Search Tree.md","exportPath":"cs/자료구조/binary-search-tree.html","showInTree":true,"treeOrder":87,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/deque.html":{"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":16,"sourcePath":"CS/자료구조/Deque.md","exportPath":"cs/자료구조/deque.html","showInTree":true,"treeOrder":88,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/hash-table.html":{"createdTime":1754545491064,"modifiedTime":1754545491065,"sourceSize":11941,"sourcePath":"CS/자료구조/Hash Table.md","exportPath":"cs/자료구조/hash-table.html","showInTree":true,"treeOrder":89,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/red-black-tree.html":{"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":17,"sourcePath":"CS/자료구조/Red Black Tree.md","exportPath":"cs/자료구조/red-black-tree.html","showInTree":true,"treeOrder":90,"backlinks":[],"type":"markdown","data":null},"cs/자료구조/tree.html":{"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":1099,"sourcePath":"CS/자료구조/Tree.md","exportPath":"cs/자료구조/tree.html","showInTree":true,"treeOrder":91,"backlinks":[],"type":"markdown","data":null},"cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html":{"createdTime":1754545491056,"modifiedTime":1754545491056,"sourceSize":2694,"sourcePath":"CS/01. 배열과 연결리스트의 차이점과 각각의 시간복잡도.md","exportPath":"cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html","showInTree":true,"treeOrder":92,"backlinks":[],"type":"markdown","data":null},"cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html":{"createdTime":1754545491057,"modifiedTime":1754545491057,"sourceSize":1309,"sourcePath":"CS/05. 정렬 알고리즘들의 시간복잡도와 특징 (정리중.md","exportPath":"cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html","showInTree":true,"treeOrder":93,"backlinks":[],"type":"markdown","data":null},"cs/07.-캐시-지역성.html":{"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":1441,"sourcePath":"CS/07. 캐시 지역성.md","exportPath":"cs/07.-캐시-지역성.html","showInTree":true,"treeOrder":94,"backlinks":[],"type":"markdown","data":null},"cs/08.-메모리-단편화.html":{"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":1538,"sourcePath":"CS/08. 메모리 단편화.md","exportPath":"cs/08.-메모리-단편화.html","showInTree":true,"treeOrder":95,"backlinks":[],"type":"markdown","data":null},"cs/09.-c++-메모리-구조.html":{"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":1684,"sourcePath":"CS/09. C++ 메모리 구조.md","exportPath":"cs/09.-c++-메모리-구조.html","showInTree":true,"treeOrder":96,"backlinks":[],"type":"markdown","data":null},"cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html":{"createdTime":1754545491058,"modifiedTime":1754545491058,"sourceSize":5626,"sourcePath":"CS/10. 스택과 힙 메모리 특징과 차이점, 사용시기.md","exportPath":"cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html","showInTree":true,"treeOrder":97,"backlinks":[],"type":"markdown","data":null},"cs/12.-new,-delete와-malloc,-free의-차이점.html":{"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":1432,"sourcePath":"CS/12.  new, delete와 malloc, free의 차이점.md","exportPath":"cs/12.-new,-delete와-malloc,-free의-차이점.html","showInTree":true,"treeOrder":98,"backlinks":[],"type":"markdown","data":null},"cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html":{"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":1791,"sourcePath":"CS/13. 가상함수와 순수가상함수의 차이점과 vtable 동작원리.md","exportPath":"cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html","showInTree":true,"treeOrder":99,"backlinks":[],"type":"markdown","data":null},"cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html":{"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":2017,"sourcePath":"CS/14. 상속 관계에서 생성자와 소멸자의 호출순서.md","exportPath":"cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html","showInTree":true,"treeOrder":100,"backlinks":[],"type":"markdown","data":null},"cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html":{"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":3561,"sourcePath":"CS/15. 깊은 복사와 얕은 복사의 차이점과 구현 방법.md","exportPath":"cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html","showInTree":true,"treeOrder":101,"backlinks":[],"type":"markdown","data":null},"cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html":{"createdTime":1754545491059,"modifiedTime":1754545491059,"sourceSize":2686,"sourcePath":"CS/16. vector, list, deque의 차이점과 시간복잡도.md","exportPath":"cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html","showInTree":true,"treeOrder":102,"backlinks":[],"type":"markdown","data":null},"cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html":{"createdTime":1754545491059,"modifiedTime":1754545491060,"sourceSize":1742,"sourcePath":"CS/17. map, unordered_map, set, unordered_set의 차이점.md","exportPath":"cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html","showInTree":true,"treeOrder":103,"backlinks":[],"type":"markdown","data":null},"cs/18.-priority_queue의-내부-구현과-사용법.html":{"createdTime":1754545491060,"modifiedTime":1754545491060,"sourceSize":172,"sourcePath":"CS/18. priority_queue의 내부 구현과 사용법.md","exportPath":"cs/18.-priority_queue의-내부-구현과-사용법.html","showInTree":true,"treeOrder":104,"backlinks":[],"type":"markdown","data":null},"cs/20.-map과-unordered_map-중-선택-기준.html":{"createdTime":1754545491060,"modifiedTime":1754545491060,"sourceSize":1579,"sourcePath":"CS/20. map과 unordered_map 중 선택 기준.md","exportPath":"cs/20.-map과-unordered_map-중-선택-기준.html","showInTree":true,"treeOrder":105,"backlinks":[],"type":"markdown","data":null},"cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html":{"createdTime":1754545491060,"modifiedTime":1754545491060,"sourceSize":1782,"sourcePath":"CS/21. 스마트 포인터 (unique_ptr, shared_ptr, weak_ptr).md","exportPath":"cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html","showInTree":true,"treeOrder":106,"backlinks":[],"type":"markdown","data":null},"cs/23.-lvalue와-rvalue의-차이점.html":{"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":3275,"sourcePath":"CS/23. lvalue와 rvalue의 차이점.md","exportPath":"cs/23.-lvalue와-rvalue의-차이점.html","showInTree":true,"treeOrder":107,"backlinks":[],"type":"markdown","data":null},"cs/24.-move-constructor와-move-assignment의-필요성.html":{"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":2228,"sourcePath":"CS/24. move constructor와 move assignment의 필요성.md","exportPath":"cs/24.-move-constructor와-move-assignment의-필요성.html","showInTree":true,"treeOrder":108,"backlinks":[],"type":"markdown","data":null},"cs/25.-auto-키워드의-장단점.html":{"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":1044,"sourcePath":"CS/25. auto 키워드의 장단점.md","exportPath":"cs/25.-auto-키워드의-장단점.html","showInTree":true,"treeOrder":109,"backlinks":[],"type":"markdown","data":null},"cs/26.-람다함수의-캡처-방식들과-사용법.html":{"createdTime":1754545491061,"modifiedTime":1754545491061,"sourceSize":3038,"sourcePath":"CS/26. 람다함수의 캡처 방식들과 사용법.md","exportPath":"cs/26.-람다함수의-캡처-방식들과-사용법.html","showInTree":true,"treeOrder":110,"backlinks":[],"type":"markdown","data":null},"cs/28.-메모리-누수를-탐지하는-방법.html":{"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":838,"sourcePath":"CS/28.  메모리 누수를 탐지하는 방법.md","exportPath":"cs/28.-메모리-누수를-탐지하는-방법.html","showInTree":true,"treeOrder":111,"backlinks":[],"type":"markdown","data":null},"cs/29.-스레드와-프로세스의-차이점.html":{"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":1510,"sourcePath":"CS/29. 스레드와 프로세스의 차이점.md","exportPath":"cs/29.-스레드와-프로세스의-차이점.html","showInTree":true,"treeOrder":112,"backlinks":[],"type":"markdown","data":null},"cs/30.-c++에서-스레드-동기화-방법들.html":{"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":1794,"sourcePath":"CS/30.  C++에서 스레드 동기화 방법들.md","exportPath":"cs/30.-c++에서-스레드-동기화-방법들.html","showInTree":true,"treeOrder":113,"backlinks":[],"type":"markdown","data":null},"cs/31.-뮤텍스와-세마포어의-차이점.html":{"createdTime":1754545491062,"modifiedTime":1754545491062,"sourceSize":1680,"sourcePath":"CS/31. 뮤텍스와 세마포어의 차이점.md","exportPath":"cs/31.-뮤텍스와-세마포어의-차이점.html","showInTree":true,"treeOrder":114,"backlinks":[],"type":"markdown","data":null},"cs/33.-레이스-컨디션에-대해-설명해주세요.html":{"createdTime":1754545491063,"modifiedTime":1754545491063,"sourceSize":1826,"sourcePath":"CS/33. 레이스 컨디션에 대해 설명해주세요.md","exportPath":"cs/33.-레이스-컨디션에-대해-설명해주세요.html","showInTree":true,"treeOrder":115,"backlinks":[],"type":"markdown","data":null},"cs/34.-포인터와-참조의-차이점.html":{"createdTime":1754545491063,"modifiedTime":1754545491063,"sourceSize":1277,"sourcePath":"CS/34. 포인터와 참조의 차이점.md","exportPath":"cs/34.-포인터와-참조의-차이점.html","showInTree":true,"treeOrder":116,"backlinks":[],"type":"markdown","data":null},"cs/35.-가상-메모리는-무엇인가.html":{"createdTime":1754545491063,"modifiedTime":1754545491063,"sourceSize":4787,"sourcePath":"CS/35. 가상 메모리는 무엇인가.md","exportPath":"cs/35.-가상-메모리는-무엇인가.html","showInTree":true,"treeOrder":117,"backlinks":[],"type":"markdown","data":null},"cs/36.-static-키워드.html":{"createdTime":1754545491063,"modifiedTime":1754545491064,"sourceSize":29,"sourcePath":"CS/36. static 키워드.md","exportPath":"cs/36.-static-키워드.html","showInTree":true,"treeOrder":118,"backlinks":[],"type":"markdown","data":null},"cs/context-switching.html":{"createdTime":1742749871667,"modifiedTime":1742751866920,"sourceSize":2626,"sourcePath":"CS/Context Switching.md","exportPath":"cs/context-switching.html","showInTree":true,"treeOrder":119,"backlinks":[],"type":"markdown","data":null},"cs/deadlock.html":{"createdTime":1742749398018,"modifiedTime":1742749767776,"sourceSize":883,"sourcePath":"CS/Deadlock.md","exportPath":"cs/deadlock.html","showInTree":true,"treeOrder":120,"backlinks":[],"type":"markdown","data":null},"cs/floating-point.html":{"createdTime":1742708090950,"modifiedTime":1742751879138,"sourceSize":2600,"sourcePath":"CS/Floating Point.md","exportPath":"cs/floating-point.html","showInTree":true,"treeOrder":121,"backlinks":[],"type":"markdown","data":null},"cs/pseudo-random-(의사-난수).html":{"createdTime":1742744578859,"modifiedTime":1742745104423,"sourceSize":1604,"sourcePath":"CS/Pseudo random (의사 난수).md","exportPath":"cs/pseudo-random-(의사-난수).html","showInTree":true,"treeOrder":122,"backlinks":[],"type":"markdown","data":null},"cs/리틀-앤디언과-빅-앤디언.html":{"createdTime":1754545491064,"modifiedTime":1754545491064,"sourceSize":0,"sourcePath":"CS/리틀 앤디언과 빅 앤디언.md","exportPath":"cs/리틀-앤디언과-빅-앤디언.html","showInTree":true,"treeOrder":123,"backlinks":[],"type":"markdown","data":null},"cs/캐시-전략.html":{"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":215,"sourcePath":"CS/캐시 전략.md","exportPath":"cs/캐시-전략.html","showInTree":true,"treeOrder":124,"backlinks":[],"type":"markdown","data":null},"csharp/linq.html":{"createdTime":1735624836303,"modifiedTime":1735624866986,"sourceSize":15206,"sourcePath":"csharp/LINQ.md","exportPath":"csharp/linq.html","showInTree":true,"treeOrder":126,"backlinks":[],"type":"markdown","data":null},"docker/1.-basic.html":{"createdTime":1740931213902,"modifiedTime":1740931213902,"sourceSize":1839,"sourcePath":"docker/1. basic.md","exportPath":"docker/1.-basic.html","showInTree":true,"treeOrder":128,"backlinks":[],"type":"markdown","data":null},"docker/2.-도커-컨테이너-환경-구축.html":{"createdTime":1740931213902,"modifiedTime":1740931213902,"sourceSize":1942,"sourcePath":"docker/2. 도커 컨테이너 환경 구축.md","exportPath":"docker/2.-도커-컨테이너-환경-구축.html","showInTree":true,"treeOrder":129,"backlinks":[],"type":"markdown","data":null},"flutter/0.-setup.html":{"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":1160,"sourcePath":"flutter/0. setup.md","exportPath":"flutter/0.-setup.html","showInTree":true,"treeOrder":131,"backlinks":[],"type":"markdown","data":null},"flutter/animation.html":{"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":1448,"sourcePath":"flutter/Animation.md","exportPath":"flutter/animation.html","showInTree":true,"treeOrder":132,"backlinks":[],"type":"markdown","data":null},"flutter/appbar.html":{"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":2737,"sourcePath":"flutter/AppBar.md","exportPath":"flutter/appbar.html","showInTree":true,"treeOrder":133,"backlinks":[],"type":"markdown","data":null},"flutter/build-context.html":{"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":2187,"sourcePath":"flutter/Build Context.md","exportPath":"flutter/build-context.html","showInTree":true,"treeOrder":134,"backlinks":[],"type":"markdown","data":null},"flutter/gridview.html":{"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":3820,"sourcePath":"flutter/GridView.md","exportPath":"flutter/gridview.html","showInTree":true,"treeOrder":135,"backlinks":[],"type":"markdown","data":null},"flutter/scaffold-vs-builder.html":{"createdTime":1754545491067,"modifiedTime":1754545491067,"sourceSize":4896,"sourcePath":"flutter/Scaffold vs Builder.md","exportPath":"flutter/scaffold-vs-builder.html","showInTree":true,"treeOrder":136,"backlinks":[],"type":"markdown","data":null},"flutter/statefulwidget-생명주기.html":{"createdTime":1754545491067,"modifiedTime":1754545491067,"sourceSize":1051,"sourcePath":"flutter/StatefulWidget 생명주기.md","exportPath":"flutter/statefulwidget-생명주기.html","showInTree":true,"treeOrder":137,"backlinks":[],"type":"markdown","data":null},"flutter/tickerproviderstatemixin.html":{"createdTime":1754545491067,"modifiedTime":1754545491067,"sourceSize":978,"sourcePath":"flutter/TickerProviderStateMixin.md","exportPath":"flutter/tickerproviderstatemixin.html","showInTree":true,"treeOrder":138,"backlinks":[],"type":"markdown","data":null},"graphics/etc/golf-simulator-using-sfml.html":{"createdTime":1735664604542,"modifiedTime":1752496355211,"sourceSize":5740,"sourcePath":"graphics/etc/Golf Simulator using SFML.md","exportPath":"graphics/etc/golf-simulator-using-sfml.html","showInTree":true,"treeOrder":141,"backlinks":[],"type":"markdown","data":null},"graphics/etc/sfml.html":{"createdTime":1735664846664,"modifiedTime":1735666283958,"sourceSize":1402,"sourcePath":"graphics/etc/SFML.md","exportPath":"graphics/etc/sfml.html","showInTree":true,"treeOrder":142,"backlinks":["graphics/etc/golf-simulator-using-sfml.html"],"type":"markdown","data":null},"graphics/metal/0.-metal-basic.html":{"createdTime":1752512486110,"modifiedTime":1752512492915,"sourceSize":1276,"sourcePath":"graphics/metal/0. Metal Basic.md","exportPath":"graphics/metal/0.-metal-basic.html","showInTree":true,"treeOrder":144,"backlinks":[],"type":"markdown","data":null},"graphics/metal/depth-buffer.html":{"createdTime":1751455892432,"modifiedTime":1751455892432,"sourceSize":1598,"sourcePath":"graphics/metal/Depth buffer.md","exportPath":"graphics/metal/depth-buffer.html","showInTree":true,"treeOrder":145,"backlinks":[],"type":"markdown","data":null},"graphics/metal/metal-rendering-pipeline.html":{"createdTime":1751291017365,"modifiedTime":1752512484491,"sourceSize":992,"sourcePath":"graphics/metal/Metal Rendering pipeline.md","exportPath":"graphics/metal/metal-rendering-pipeline.html","showInTree":true,"treeOrder":146,"backlinks":[],"type":"markdown","data":null},"graphics/metal/shadow-map.html":{"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":3285,"sourcePath":"graphics/metal/Shadow Map.md","exportPath":"graphics/metal/shadow-map.html","showInTree":true,"treeOrder":147,"backlinks":[],"type":"markdown","data":null},"graphics/metal/uniform-buffer.html":{"createdTime":1752512573860,"modifiedTime":1752512627279,"sourceSize":1406,"sourcePath":"graphics/metal/Uniform Buffer.md","exportPath":"graphics/metal/uniform-buffer.html","showInTree":true,"treeOrder":148,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/01.기본/01.-기본.html":{"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":3765,"sourcePath":"graphics/opengl/01.기본/01. 기본.md","exportPath":"graphics/opengl/01.기본/01.-기본.html","showInTree":true,"treeOrder":151,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html":{"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":1639,"sourcePath":"graphics/opengl/01.기본/02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용.md","exportPath":"graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html","showInTree":true,"treeOrder":152,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html":{"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":5995,"sourcePath":"graphics/opengl/01.기본/03. 콜백함수와 컬러 기초 이론 - Callback 함수.md","exportPath":"graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html","showInTree":true,"treeOrder":153,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/01.기본/04.-컬러-기초이론.html":{"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":858,"sourcePath":"graphics/opengl/01.기본/04. 컬러 기초이론.md","exportPath":"graphics/opengl/01.기본/04.-컬러-기초이론.html","showInTree":true,"treeOrder":154,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html":{"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":1312,"sourcePath":"graphics/opengl/01.기본/05. 컬러 이미지 저장 방식.md","exportPath":"graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html","showInTree":true,"treeOrder":155,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/01.기본/06.-rgba-컬러-모델.html":{"createdTime":1724679437332,"modifiedTime":1724679437332,"sourceSize":2977,"sourcePath":"graphics/opengl/01.기본/06. RGBA 컬러 모델.md","exportPath":"graphics/opengl/01.기본/06.-rgba-컬러-모델.html","showInTree":true,"treeOrder":156,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html":{"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":978,"sourcePath":"graphics/opengl/02.응용/01. 그래픽스 파이프라인.md","exportPath":"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html","showInTree":true,"treeOrder":158,"backlinks":["graphics/이론/렌더링-파이프라인-이론.html"],"type":"markdown","data":null},"graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html":{"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":900,"sourcePath":"graphics/opengl/02.응용/02. 프로그래머블 그래픽스 파이프라인.md","exportPath":"graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html","showInTree":true,"treeOrder":159,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/03.-gpu-내부-구조.html":{"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":2443,"sourcePath":"graphics/opengl/02.응용/03. GPU 내부 구조.md","exportPath":"graphics/opengl/02.응용/03.-gpu-내부-구조.html","showInTree":true,"treeOrder":160,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/04.-glsl.html":{"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":1802,"sourcePath":"graphics/opengl/02.응용/04. GLSL.md","exportPath":"graphics/opengl/02.응용/04.-glsl.html","showInTree":true,"treeOrder":161,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/05.-shader-programming-코드-분석.html":{"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":3578,"sourcePath":"graphics/opengl/02.응용/05. Shader Programming 코드 분석.md","exportPath":"graphics/opengl/02.응용/05.-shader-programming-코드-분석.html","showInTree":true,"treeOrder":162,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/06.-재사용가능한-코드.html":{"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":2133,"sourcePath":"graphics/opengl/02.응용/06. 재사용가능한 코드.md","exportPath":"graphics/opengl/02.응용/06.-재사용가능한-코드.html","showInTree":true,"treeOrder":163,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/07.-glsl-자료형.html":{"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":1384,"sourcePath":"graphics/opengl/02.응용/07. GLSL 자료형.md","exportPath":"graphics/opengl/02.응용/07.-glsl-자료형.html","showInTree":true,"treeOrder":164,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/08.-uniform-variable.html":{"createdTime":1743691206982,"modifiedTime":1743691206982,"sourceSize":3215,"sourcePath":"graphics/opengl/02.응용/08. Uniform Variable.md","exportPath":"graphics/opengl/02.응용/08.-uniform-variable.html","showInTree":true,"treeOrder":165,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/09.-glsl-디버그-함수들.html":{"createdTime":1743691206983,"modifiedTime":1743691206983,"sourceSize":4052,"sourcePath":"graphics/opengl/02.응용/09. GLSL 디버그 함수들.md","exportPath":"graphics/opengl/02.응용/09.-glsl-디버그-함수들.html","showInTree":true,"treeOrder":166,"backlinks":[],"type":"markdown","data":null},"graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html":{"createdTime":1743691206983,"modifiedTime":1743691206983,"sourceSize":2388,"sourcePath":"graphics/opengl/02.응용/10. OpenGL 깊이 버퍼와 렌더링 순서.md","exportPath":"graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html","showInTree":true,"treeOrder":167,"backlinks":[],"type":"markdown","data":null},"graphics/rasterizer/0.-목표에-대해서.html":{"createdTime":1752496366911,"modifiedTime":1752496661853,"sourceSize":343,"sourcePath":"graphics/Rasterizer/0. 목표에 대해서.md","exportPath":"graphics/rasterizer/0.-목표에-대해서.html","showInTree":true,"treeOrder":169,"backlinks":[],"type":"markdown","data":null},"graphics/rasterizer/1.-브레젠험-직선-알고리즘.html":{"createdTime":1752496673734,"modifiedTime":1752506723611,"sourceSize":6698,"sourcePath":"graphics/Rasterizer/1. 브레젠험 직선 알고리즘.md","exportPath":"graphics/rasterizer/1.-브레젠험-직선-알고리즘.html","showInTree":true,"treeOrder":170,"backlinks":[],"type":"markdown","data":null},"graphics/unreal-engine/basic.html":{"createdTime":1754545491026,"modifiedTime":1754545491026,"sourceSize":701,"sourcePath":"graphics/Unreal Engine/Basic.md","exportPath":"graphics/unreal-engine/basic.html","showInTree":true,"treeOrder":172,"backlinks":[],"type":"markdown","data":null},"graphics/unreal-engine/material.html":{"createdTime":1752590582977,"modifiedTime":1752590582977,"sourceSize":2278,"sourcePath":"graphics/Unreal Engine/Material.md","exportPath":"graphics/unreal-engine/material.html","showInTree":true,"treeOrder":173,"backlinks":[],"type":"markdown","data":null},"graphics/unreal-engine/rim-light와-fresnel-노드.html":{"createdTime":1752590582977,"modifiedTime":1752590582977,"sourceSize":4423,"sourcePath":"graphics/Unreal Engine/Rim Light와 Fresnel 노드.md","exportPath":"graphics/unreal-engine/rim-light와-fresnel-노드.html","showInTree":true,"treeOrder":174,"backlinks":[],"type":"markdown","data":null},"graphics/이론/modeling.html":{"createdTime":1735624912401,"modifiedTime":1735624953441,"sourceSize":2154,"sourcePath":"graphics/이론/Modeling.md","exportPath":"graphics/이론/modeling.html","showInTree":true,"treeOrder":176,"backlinks":[],"type":"markdown","data":null},"graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html":{"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":2150,"sourcePath":"graphics/이론/Phong vs Blinn-Phong 셰이딩 모델.md","exportPath":"graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html","showInTree":true,"treeOrder":177,"backlinks":[],"type":"markdown","data":null},"graphics/이론/vsync-(수직-동기화).html":{"createdTime":1754545491067,"modifiedTime":1754545491068,"sourceSize":2955,"sourcePath":"graphics/이론/VSync (수직 동기화).md","exportPath":"graphics/이론/vsync-(수직-동기화).html","showInTree":true,"treeOrder":178,"backlinks":[],"type":"markdown","data":null},"graphics/이론/동차-좌표계와-원근-분할.html":{"createdTime":1754545491026,"modifiedTime":1754545491026,"sourceSize":4994,"sourcePath":"graphics/이론/동차 좌표계와 원근 분할.md","exportPath":"graphics/이론/동차-좌표계와-원근-분할.html","showInTree":true,"treeOrder":179,"backlinks":[],"type":"markdown","data":null},"graphics/이론/렌더링-파이프라인-이론.html":{"createdTime":1752391096503,"modifiedTime":1752392500292,"sourceSize":1715,"sourcePath":"graphics/이론/렌더링 파이프라인 이론.md","exportPath":"graphics/이론/렌더링-파이프라인-이론.html","showInTree":true,"treeOrder":180,"backlinks":[],"type":"markdown","data":null},"graphics/이론/변환행렬.html":{"createdTime":1751879420587,"modifiedTime":1752496314668,"sourceSize":2118,"sourcePath":"graphics/이론/변환행렬.md","exportPath":"graphics/이론/변환행렬.html","showInTree":true,"treeOrder":181,"backlinks":[],"type":"markdown","data":null},"graphics/이론/컴퓨터-그래픽스-기초와-수학.html":{"createdTime":1735624889065,"modifiedTime":1735624911169,"sourceSize":2307,"sourcePath":"graphics/이론/컴퓨터 그래픽스 기초와 수학.md","exportPath":"graphics/이론/컴퓨터-그래픽스-기초와-수학.html","showInTree":true,"treeOrder":182,"backlinks":[],"type":"markdown","data":null},"hose/develop.html":{"createdTime":1737037094008,"modifiedTime":1748688668793,"sourceSize":0,"sourcePath":"Hose/Develop.md","exportPath":"hose/develop.html","showInTree":true,"treeOrder":184,"backlinks":[],"type":"markdown","data":null},"hose/내가-블로그를-시작한-이유.html":{"createdTime":1735621785179,"modifiedTime":1735621805711,"sourceSize":4654,"sourcePath":"Hose/내가 블로그를 시작한 이유.md","exportPath":"hose/내가-블로그를-시작한-이유.html","showInTree":true,"treeOrder":185,"backlinks":[],"type":"markdown","data":null},"images/3colorchannel.png":{"createdTime":1724571717957,"modifiedTime":1724571717958,"sourceSize":398882,"sourcePath":"images/3colorchannel.png","exportPath":"images/3colorchannel.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/3colorchannel.html":{"createdTime":1724571717957,"modifiedTime":1724571717958,"sourceSize":398882,"sourcePath":"images/3colorchannel.png","exportPath":"images/3colorchannel.html","showInTree":true,"treeOrder":187,"backlinks":["graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html"],"type":"attachment","data":null},"images/aggregate.png":{"createdTime":1710855209764,"modifiedTime":1710855209764,"sourceSize":98091,"sourcePath":"images/aggregate.png","exportPath":"images/aggregate.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/aggregate.html":{"createdTime":1710855209764,"modifiedTime":1710855209764,"sourceSize":98091,"sourcePath":"images/aggregate.png","exportPath":"images/aggregate.html","showInTree":true,"treeOrder":188,"backlinks":["ios/fat-framework.html"],"type":"attachment","data":null},"images/allpublic.png":{"createdTime":1710855209767,"modifiedTime":1710855209768,"sourceSize":48860,"sourcePath":"images/allpublic.png","exportPath":"images/allpublic.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/allpublic.html":{"createdTime":1710855209767,"modifiedTime":1710855209768,"sourceSize":48860,"sourcePath":"images/allpublic.png","exportPath":"images/allpublic.html","showInTree":true,"treeOrder":189,"backlinks":["ios/swift,-objective-c-interoperability.html"],"type":"attachment","data":null},"images/bfs_1.png":{"createdTime":1719764579395,"modifiedTime":1719764579396,"sourceSize":769588,"sourcePath":"images/BFS_1.png","exportPath":"images/bfs_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/bfs_1.html":{"createdTime":1719764579395,"modifiedTime":1719764579396,"sourceSize":769588,"sourcePath":"images/BFS_1.png","exportPath":"images/bfs_1.html","showInTree":true,"treeOrder":190,"backlinks":["algorithm/lecture/bfs.html"],"type":"attachment","data":null},"images/bfs_2.png":{"createdTime":1719764657808,"modifiedTime":1719764657808,"sourceSize":887930,"sourcePath":"images/BFS_2.png","exportPath":"images/bfs_2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/bfs_2.html":{"createdTime":1719764657808,"modifiedTime":1719764657808,"sourceSize":887930,"sourcePath":"images/BFS_2.png","exportPath":"images/bfs_2.html","showInTree":true,"treeOrder":191,"backlinks":["algorithm/lecture/bfs.html"],"type":"attachment","data":null},"images/bi_linear_interpolation.png":{"createdTime":1730808631673,"modifiedTime":1730808631674,"sourceSize":404027,"sourcePath":"images/bi_linear_interpolation.png","exportPath":"images/bi_linear_interpolation.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/bi_linear_interpolation.html":{"createdTime":1730808631673,"modifiedTime":1730808631674,"sourceSize":404027,"sourcePath":"images/bi_linear_interpolation.png","exportPath":"images/bi_linear_interpolation.html","showInTree":true,"treeOrder":192,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment","data":null},"images/ble_configuration.png":{"createdTime":1714816620140,"modifiedTime":1714816620140,"sourceSize":83464,"sourcePath":"images/ble_configuration.png","exportPath":"images/ble_configuration.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble_configuration.html":{"createdTime":1714816620140,"modifiedTime":1714816620140,"sourceSize":83464,"sourcePath":"images/ble_configuration.png","exportPath":"images/ble_configuration.html","showInTree":true,"treeOrder":193,"backlinks":[],"type":"attachment","data":null},"images/ble_host_controller.png":{"createdTime":1710855209732,"modifiedTime":1710855209732,"sourceSize":93521,"sourcePath":"images/ble_host_controller.png","exportPath":"images/ble_host_controller.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble_host_controller.html":{"createdTime":1710855209732,"modifiedTime":1710855209732,"sourceSize":93521,"sourcePath":"images/ble_host_controller.png","exportPath":"images/ble_host_controller.html","showInTree":true,"treeOrder":194,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment","data":null},"images/ble-attribute-table.png":{"createdTime":1710855209732,"modifiedTime":1710855209733,"sourceSize":97663,"sourcePath":"images/ble-attribute-table.png","exportPath":"images/ble-attribute-table.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-attribute-table.html":{"createdTime":1710855209732,"modifiedTime":1710855209733,"sourceSize":97663,"sourcePath":"images/ble-attribute-table.png","exportPath":"images/ble-attribute-table.html","showInTree":true,"treeOrder":195,"backlinks":["ble/3.-ble-att,-gatt.html"],"type":"attachment","data":null},"images/ble-conn-fig-1.png":{"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":97797,"sourcePath":"images/ble-conn-fig-1.png","exportPath":"images/ble-conn-fig-1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-conn-fig-1.html":{"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":97797,"sourcePath":"images/ble-conn-fig-1.png","exportPath":"images/ble-conn-fig-1.html","showInTree":true,"treeOrder":196,"backlinks":["ble/4.-ble-디바이스-연결.html"],"type":"attachment","data":null},"images/ble-conn-fig-2.png":{"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":39578,"sourcePath":"images/ble-conn-fig-2.png","exportPath":"images/ble-conn-fig-2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-conn-fig-2.html":{"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":39578,"sourcePath":"images/ble-conn-fig-2.png","exportPath":"images/ble-conn-fig-2.html","showInTree":true,"treeOrder":197,"backlinks":["ble/4.-ble-디바이스-연결.html"],"type":"attachment","data":null},"images/ble-conn-fig-3.png":{"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":38156,"sourcePath":"images/ble-conn-fig-3.png","exportPath":"images/ble-conn-fig-3.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-conn-fig-3.html":{"createdTime":1710855209733,"modifiedTime":1710855209733,"sourceSize":38156,"sourcePath":"images/ble-conn-fig-3.png","exportPath":"images/ble-conn-fig-3.html","showInTree":true,"treeOrder":198,"backlinks":["ble/4.-ble-디바이스-연결.html"],"type":"attachment","data":null},"images/ble-connection.png":{"createdTime":1710855209734,"modifiedTime":1710855209734,"sourceSize":103318,"sourcePath":"images/ble-connection.png","exportPath":"images/ble-connection.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-connection.html":{"createdTime":1710855209734,"modifiedTime":1710855209734,"sourceSize":103318,"sourcePath":"images/ble-connection.png","exportPath":"images/ble-connection.html","showInTree":true,"treeOrder":199,"backlinks":[],"type":"attachment","data":null},"images/ble-connection-1.png":{"createdTime":1710855209733,"modifiedTime":1710855209734,"sourceSize":103318,"sourcePath":"images/ble-connection 1.png","exportPath":"images/ble-connection-1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-connection-1.html":{"createdTime":1710855209733,"modifiedTime":1710855209734,"sourceSize":103318,"sourcePath":"images/ble-connection 1.png","exportPath":"images/ble-connection-1.html","showInTree":true,"treeOrder":200,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment","data":null},"images/ble-data-exchange.png":{"createdTime":1710855209734,"modifiedTime":1710855209734,"sourceSize":109854,"sourcePath":"images/ble-data-exchange.png","exportPath":"images/ble-data-exchange.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-data-exchange.html":{"createdTime":1710855209734,"modifiedTime":1710855209734,"sourceSize":109854,"sourcePath":"images/ble-data-exchange.png","exportPath":"images/ble-data-exchange.html","showInTree":true,"treeOrder":201,"backlinks":["ble/3.-ble-att,-gatt.html"],"type":"attachment","data":null},"images/ble-gatt-structure.png":{"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":111762,"sourcePath":"images/ble-gatt-structure.png","exportPath":"images/ble-gatt-structure.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-gatt-structure.html":{"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":111762,"sourcePath":"images/ble-gatt-structure.png","exportPath":"images/ble-gatt-structure.html","showInTree":true,"treeOrder":202,"backlinks":["ble/3.-ble-att,-gatt.html"],"type":"attachment","data":null},"images/ble-l2cap.png":{"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":90933,"sourcePath":"images/ble-l2cap.png","exportPath":"images/ble-l2cap.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-l2cap.html":{"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":90933,"sourcePath":"images/ble-l2cap.png","exportPath":"images/ble-l2cap.html","showInTree":true,"treeOrder":203,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment","data":null},"images/ble-link-layer.png":{"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":31520,"sourcePath":"images/ble-link-layer.png","exportPath":"images/ble-link-layer.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ble-link-layer.html":{"createdTime":1710855209735,"modifiedTime":1710855209735,"sourceSize":31520,"sourcePath":"images/ble-link-layer.png","exportPath":"images/ble-link-layer.html","showInTree":true,"treeOrder":204,"backlinks":["ble/2.-ble-프로토콜-스택.html"],"type":"attachment","data":null},"images/blendspace.png":{"createdTime":1710855209736,"modifiedTime":1710855209737,"sourceSize":641674,"sourcePath":"images/Blendspace.png","exportPath":"images/blendspace.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/blendspace.html":{"createdTime":1710855209736,"modifiedTime":1710855209737,"sourceSize":641674,"sourcePath":"images/Blendspace.png","exportPath":"images/blendspace.html","showInTree":true,"treeOrder":205,"backlinks":["ue/blendspace와-blendspace1d-차이점.html"],"type":"attachment","data":null},"images/bpgi_onbeginplay.png":{"createdTime":1724571717940,"modifiedTime":1724571717941,"sourceSize":37007,"sourcePath":"images/bpgi_onbeginplay.png","exportPath":"images/bpgi_onbeginplay.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/bpgi_onbeginplay.html":{"createdTime":1724571717940,"modifiedTime":1724571717941,"sourceSize":37007,"sourcePath":"images/bpgi_onbeginplay.png","exportPath":"images/bpgi_onbeginplay.html","showInTree":true,"treeOrder":206,"backlinks":[],"type":"attachment","data":null},"images/broadcastip_address.png":{"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":98496,"sourcePath":"images/broadcastip_address.png","exportPath":"images/broadcastip_address.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/broadcastip_address.html":{"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":98496,"sourcePath":"images/broadcastip_address.png","exportPath":"images/broadcastip_address.html","showInTree":true,"treeOrder":207,"backlinks":["network/09.-broadcast-ip-주소-&-loopback-주소.html"],"type":"attachment","data":null},"images/build_process.png":{"createdTime":1710855209750,"modifiedTime":1710855209750,"sourceSize":64168,"sourcePath":"images/build_process.png","exportPath":"images/build_process.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/build_process.html":{"createdTime":1710855209750,"modifiedTime":1710855209750,"sourceSize":64168,"sourcePath":"images/build_process.png","exportPath":"images/build_process.html","showInTree":true,"treeOrder":208,"backlinks":["cpp/basic/0.-c,-c++-컴파일-과정.html"],"type":"attachment","data":null},"images/bw_grayscale.png":{"createdTime":1724571717958,"modifiedTime":1724571717959,"sourceSize":177310,"sourcePath":"images/bw_grayscale.png","exportPath":"images/bw_grayscale.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/bw_grayscale.html":{"createdTime":1724571717958,"modifiedTime":1724571717959,"sourceSize":177310,"sourcePath":"images/bw_grayscale.png","exportPath":"images/bw_grayscale.html","showInTree":true,"treeOrder":209,"backlinks":["graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html"],"type":"attachment","data":null},"images/change_scheme.png":{"createdTime":1710855209754,"modifiedTime":1710855209755,"sourceSize":73919,"sourcePath":"images/change_scheme.png","exportPath":"images/change_scheme.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/change_scheme.html":{"createdTime":1710855209754,"modifiedTime":1710855209755,"sourceSize":73919,"sourcePath":"images/change_scheme.png","exportPath":"images/change_scheme.html","showInTree":true,"treeOrder":210,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment","data":null},"images/cmake_setting.png":{"createdTime":1710855209756,"modifiedTime":1710855209756,"sourceSize":301772,"sourcePath":"images/cmake_setting.png","exportPath":"images/cmake_setting.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cmake_setting.html":{"createdTime":1710855209756,"modifiedTime":1710855209756,"sourceSize":301772,"sourcePath":"images/cmake_setting.png","exportPath":"images/cmake_setting.html","showInTree":true,"treeOrder":211,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment","data":null},"images/cmy_model.png":{"createdTime":1724571717959,"modifiedTime":1724571717959,"sourceSize":267248,"sourcePath":"images/cmy_model.png","exportPath":"images/cmy_model.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cmy_model.html":{"createdTime":1724571717959,"modifiedTime":1724571717959,"sourceSize":267248,"sourcePath":"images/cmy_model.png","exportPath":"images/cmy_model.html","showInTree":true,"treeOrder":212,"backlinks":["graphics/opengl/01.기본/04.-컬러-기초이론.html"],"type":"attachment","data":null},"images/collectpso.png":{"createdTime":1719838659337,"modifiedTime":1719838659337,"sourceSize":21519,"sourcePath":"images/collectpso.png","exportPath":"images/collectpso.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/collectpso.html":{"createdTime":1719838659337,"modifiedTime":1719838659337,"sourceSize":21519,"sourcePath":"images/collectpso.png","exportPath":"images/collectpso.html","showInTree":true,"treeOrder":213,"backlinks":["ue/pso-(pipeline-state-object)-수집.html"],"type":"attachment","data":null},"images/color_image.png":{"createdTime":1724571717960,"modifiedTime":1724571717960,"sourceSize":285111,"sourcePath":"images/color_image.png","exportPath":"images/color_image.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/color_image.html":{"createdTime":1724571717960,"modifiedTime":1724571717960,"sourceSize":285111,"sourcePath":"images/color_image.png","exportPath":"images/color_image.html","showInTree":true,"treeOrder":214,"backlinks":["graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html"],"type":"attachment","data":null},"images/color_vs_grayscale.png":{"createdTime":1724571717960,"modifiedTime":1724571717961,"sourceSize":354188,"sourcePath":"images/color_vs_grayscale.png","exportPath":"images/color_vs_grayscale.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/color_vs_grayscale.html":{"createdTime":1724571717960,"modifiedTime":1724571717961,"sourceSize":354188,"sourcePath":"images/color_vs_grayscale.png","exportPath":"images/color_vs_grayscale.html","showInTree":true,"treeOrder":215,"backlinks":["graphics/opengl/01.기본/06.-rgba-컬러-모델.html"],"type":"attachment","data":null},"images/common_ui_plugin.png":{"createdTime":1724571717940,"modifiedTime":1724571717940,"sourceSize":9707,"sourcePath":"images/Common_ui_plugin.png","exportPath":"images/common_ui_plugin.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/common_ui_plugin.html":{"createdTime":1724571717940,"modifiedTime":1724571717940,"sourceSize":9707,"sourcePath":"images/Common_ui_plugin.png","exportPath":"images/common_ui_plugin.html","showInTree":true,"treeOrder":216,"backlinks":[],"type":"attachment","data":null},"images/compared_ext_trigger.png":{"createdTime":1736697355563,"modifiedTime":1736697355563,"sourceSize":144452,"sourcePath":"images/compared_ext_trigger.png","exportPath":"images/compared_ext_trigger.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/compared_ext_trigger.html":{"createdTime":1736697355563,"modifiedTime":1736697355563,"sourceSize":144452,"sourcePath":"images/compared_ext_trigger.png","exportPath":"images/compared_ext_trigger.html","showInTree":true,"treeOrder":217,"backlinks":["infra/p4-extension,-p4-triggers.html"],"type":"attachment","data":null},"images/concurrent.png":{"createdTime":1710855209769,"modifiedTime":1710855209769,"sourceSize":224190,"sourcePath":"images/concurrent.png","exportPath":"images/concurrent.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/concurrent.html":{"createdTime":1710855209769,"modifiedTime":1710855209769,"sourceSize":224190,"sourcePath":"images/concurrent.png","exportPath":"images/concurrent.html","showInTree":true,"treeOrder":218,"backlinks":["ios/동기,-비동기.html"],"type":"attachment","data":null},"images/cpp_1.png":{"createdTime":1717918207669,"modifiedTime":1717918207669,"sourceSize":237712,"sourcePath":"images/cpp_1.png","exportPath":"images/cpp_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_1.html":{"createdTime":1717918207669,"modifiedTime":1717918207669,"sourceSize":237712,"sourcePath":"images/cpp_1.png","exportPath":"images/cpp_1.html","showInTree":true,"treeOrder":219,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment","data":null},"images/cpp_2.png":{"createdTime":1717918387053,"modifiedTime":1717918387053,"sourceSize":273603,"sourcePath":"images/cpp_2.png","exportPath":"images/cpp_2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_2.html":{"createdTime":1717918387053,"modifiedTime":1717918387053,"sourceSize":273603,"sourcePath":"images/cpp_2.png","exportPath":"images/cpp_2.html","showInTree":true,"treeOrder":220,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment","data":null},"images/cpp_3.png":{"createdTime":1718520040498,"modifiedTime":1718520040498,"sourceSize":88165,"sourcePath":"images/cpp_3.png","exportPath":"images/cpp_3.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_3.html":{"createdTime":1718520040498,"modifiedTime":1718520040498,"sourceSize":88165,"sourcePath":"images/cpp_3.png","exportPath":"images/cpp_3.html","showInTree":true,"treeOrder":221,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment","data":null},"images/cpp_4.png":{"createdTime":1718520040498,"modifiedTime":1718520040499,"sourceSize":24551,"sourcePath":"images/cpp_4.png","exportPath":"images/cpp_4.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_4.html":{"createdTime":1718520040498,"modifiedTime":1718520040499,"sourceSize":24551,"sourcePath":"images/cpp_4.png","exportPath":"images/cpp_4.html","showInTree":true,"treeOrder":222,"backlinks":["cpp/basic/4.-상속.html"],"type":"attachment","data":null},"images/cpp_5.png":{"createdTime":1718520241779,"modifiedTime":1718520241780,"sourceSize":41839,"sourcePath":"images/cpp_5.png","exportPath":"images/cpp_5.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_5.html":{"createdTime":1718520241779,"modifiedTime":1718520241780,"sourceSize":41839,"sourcePath":"images/cpp_5.png","exportPath":"images/cpp_5.html","showInTree":true,"treeOrder":223,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment","data":null},"images/cpp_6.png":{"createdTime":1718521210207,"modifiedTime":1718521210207,"sourceSize":174995,"sourcePath":"images/cpp_6.png","exportPath":"images/cpp_6.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_6.html":{"createdTime":1718521210207,"modifiedTime":1718521210207,"sourceSize":174995,"sourcePath":"images/cpp_6.png","exportPath":"images/cpp_6.html","showInTree":true,"treeOrder":224,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment","data":null},"images/cpp_7.png":{"createdTime":1718526857149,"modifiedTime":1718526857150,"sourceSize":105916,"sourcePath":"images/cpp_7.png","exportPath":"images/cpp_7.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_7.html":{"createdTime":1718526857149,"modifiedTime":1718526857150,"sourceSize":105916,"sourcePath":"images/cpp_7.png","exportPath":"images/cpp_7.html","showInTree":true,"treeOrder":225,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment","data":null},"images/cpp_8.png":{"createdTime":1718528192210,"modifiedTime":1718528192210,"sourceSize":25704,"sourcePath":"images/cpp_8.png","exportPath":"images/cpp_8.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_8.html":{"createdTime":1718528192210,"modifiedTime":1718528192210,"sourceSize":25704,"sourcePath":"images/cpp_8.png","exportPath":"images/cpp_8.html","showInTree":true,"treeOrder":226,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment","data":null},"images/cpp_9.png":{"createdTime":1718528199266,"modifiedTime":1718528199267,"sourceSize":50752,"sourcePath":"images/cpp_9.png","exportPath":"images/cpp_9.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_9.html":{"createdTime":1718528199266,"modifiedTime":1718528199267,"sourceSize":50752,"sourcePath":"images/cpp_9.png","exportPath":"images/cpp_9.html","showInTree":true,"treeOrder":227,"backlinks":["cpp/basic/6.-파일-입출력.html"],"type":"attachment","data":null},"images/cpp_10.png":{"createdTime":1735109236636,"modifiedTime":1735109236636,"sourceSize":88781,"sourcePath":"images/cpp_10.png","exportPath":"images/cpp_10.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_10.html":{"createdTime":1735109236636,"modifiedTime":1735109236636,"sourceSize":88781,"sourcePath":"images/cpp_10.png","exportPath":"images/cpp_10.html","showInTree":true,"treeOrder":228,"backlinks":["cpp/modern/4.-shared,-weak-ptr.html"],"type":"attachment","data":null},"images/cpp_11.png":{"createdTime":1735109444001,"modifiedTime":1735109444002,"sourceSize":92686,"sourcePath":"images/cpp_11.png","exportPath":"images/cpp_11.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_11.html":{"createdTime":1735109444001,"modifiedTime":1735109444002,"sourceSize":92686,"sourcePath":"images/cpp_11.png","exportPath":"images/cpp_11.html","showInTree":true,"treeOrder":229,"backlinks":["cpp/modern/4.-shared,-weak-ptr.html"],"type":"attachment","data":null},"images/cpp_12.png":{"createdTime":1735110647426,"modifiedTime":1735110647426,"sourceSize":63339,"sourcePath":"images/cpp_12.png","exportPath":"images/cpp_12.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_12.html":{"createdTime":1735110647426,"modifiedTime":1735110647426,"sourceSize":63339,"sourcePath":"images/cpp_12.png","exportPath":"images/cpp_12.html","showInTree":true,"treeOrder":230,"backlinks":["cpp/modern/4.-shared,-weak-ptr.html"],"type":"attachment","data":null},"images/cpp_13.png":{"createdTime":1735210581953,"modifiedTime":1735210581954,"sourceSize":91927,"sourcePath":"images/cpp_13.png","exportPath":"images/cpp_13.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_13.html":{"createdTime":1735210581953,"modifiedTime":1735210581954,"sourceSize":91927,"sourcePath":"images/cpp_13.png","exportPath":"images/cpp_13.html","showInTree":true,"treeOrder":231,"backlinks":["cpp/concurrency/2.-mutex,-deadlock.html"],"type":"attachment","data":null},"images/cpp_14.png":{"createdTime":1735309162898,"modifiedTime":1735309162898,"sourceSize":101382,"sourcePath":"images/cpp_14.png","exportPath":"images/cpp_14.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_14.html":{"createdTime":1735309162898,"modifiedTime":1735309162898,"sourceSize":101382,"sourcePath":"images/cpp_14.png","exportPath":"images/cpp_14.html","showInTree":true,"treeOrder":232,"backlinks":["cpp/concurrency/4.-future,-async,-promise.html"],"type":"attachment","data":null},"images/cpp_memory_struct.png":{"createdTime":1754545491068,"modifiedTime":1754545491069,"sourceSize":171474,"sourcePath":"images/cpp_memory_struct.png","exportPath":"images/cpp_memory_struct.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/cpp_memory_struct.html":{"createdTime":1754545491068,"modifiedTime":1754545491069,"sourceSize":171474,"sourcePath":"images/cpp_memory_struct.png","exportPath":"images/cpp_memory_struct.html","showInTree":true,"treeOrder":233,"backlinks":["cs/09.-c++-메모리-구조.html"],"type":"attachment","data":null},"images/data_transfer_struct.png":{"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":631577,"sourcePath":"images/data_transfer_struct.png","exportPath":"images/data_transfer_struct.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/data_transfer_struct.html":{"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":631577,"sourcePath":"images/data_transfer_struct.png","exportPath":"images/data_transfer_struct.html","showInTree":true,"treeOrder":234,"backlinks":["network/06.-tcp-ip-송수신-구조.html"],"type":"attachment","data":null},"images/datahandle_row_result.png":{"createdTime":1724571717953,"modifiedTime":1724571717954,"sourceSize":19027,"sourcePath":"images/datahandle_row_result.png","exportPath":"images/datahandle_row_result.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/datahandle_row_result.html":{"createdTime":1724571717953,"modifiedTime":1724571717954,"sourceSize":19027,"sourcePath":"images/datahandle_row_result.png","exportPath":"images/datahandle_row_result.html","showInTree":true,"treeOrder":235,"backlinks":["ue/datatable_asset_ref.html"],"type":"attachment","data":null},"images/debugging_failure.png":{"createdTime":1730808631674,"modifiedTime":1730808631675,"sourceSize":176534,"sourcePath":"images/debugging_failure.png","exportPath":"images/debugging_failure.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/debugging_failure.html":{"createdTime":1730808631674,"modifiedTime":1730808631675,"sourceSize":176534,"sourcePath":"images/debugging_failure.png","exportPath":"images/debugging_failure.html","showInTree":true,"treeOrder":236,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment","data":null},"images/debugging_success.png":{"createdTime":1730808631675,"modifiedTime":1730808631675,"sourceSize":144960,"sourcePath":"images/debugging_success.png","exportPath":"images/debugging_success.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/debugging_success.html":{"createdTime":1730808631675,"modifiedTime":1730808631675,"sourceSize":144960,"sourcePath":"images/debugging_success.png","exportPath":"images/debugging_success.html","showInTree":true,"treeOrder":237,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment","data":null},"images/dfs_1.png":{"createdTime":1719763592496,"modifiedTime":1719763592496,"sourceSize":796867,"sourcePath":"images/DFS_1.png","exportPath":"images/dfs_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/dfs_1.html":{"createdTime":1719763592496,"modifiedTime":1719763592496,"sourceSize":796867,"sourcePath":"images/DFS_1.png","exportPath":"images/dfs_1.html","showInTree":true,"treeOrder":238,"backlinks":["algorithm/lecture/dfs.html"],"type":"attachment","data":null},"images/dfs_2.png":{"createdTime":1719763717770,"modifiedTime":1719763717770,"sourceSize":827352,"sourcePath":"images/DFS_2.png","exportPath":"images/dfs_2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/dfs_2.html":{"createdTime":1719763717770,"modifiedTime":1719763717770,"sourceSize":827352,"sourcePath":"images/DFS_2.png","exportPath":"images/dfs_2.html","showInTree":true,"treeOrder":239,"backlinks":["algorithm/lecture/dfs.html"],"type":"attachment","data":null},"images/ebtnode_result_aborted.png":{"createdTime":1710855209739,"modifiedTime":1710855209743,"sourceSize":2050056,"sourcePath":"images/ebtnode_result_aborted.png","exportPath":"images/ebtnode_result_aborted.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ebtnode_result_aborted.html":{"createdTime":1710855209739,"modifiedTime":1710855209743,"sourceSize":2050056,"sourcePath":"images/ebtnode_result_aborted.png","exportPath":"images/ebtnode_result_aborted.html","showInTree":true,"treeOrder":240,"backlinks":[],"type":"attachment","data":null},"images/ebtnode_result_failed.png":{"createdTime":1710855209743,"modifiedTime":1710855209747,"sourceSize":1897692,"sourcePath":"images/ebtnode_result_failed.png","exportPath":"images/ebtnode_result_failed.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ebtnode_result_failed.html":{"createdTime":1710855209743,"modifiedTime":1710855209747,"sourceSize":1897692,"sourcePath":"images/ebtnode_result_failed.png","exportPath":"images/ebtnode_result_failed.html","showInTree":true,"treeOrder":241,"backlinks":[],"type":"attachment","data":null},"images/ebtnode_result_inprogress.png":{"createdTime":1710855209747,"modifiedTime":1710855209750,"sourceSize":1709730,"sourcePath":"images/ebtnode_result_inprogress.png","exportPath":"images/ebtnode_result_inprogress.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ebtnode_result_inprogress.html":{"createdTime":1710855209747,"modifiedTime":1710855209750,"sourceSize":1709730,"sourcePath":"images/ebtnode_result_inprogress.png","exportPath":"images/ebtnode_result_inprogress.html","showInTree":true,"treeOrder":242,"backlinks":[],"type":"attachment","data":null},"images/ebtnode_result_type.png":{"createdTime":1710855209750,"modifiedTime":1710855209750,"sourceSize":28011,"sourcePath":"images/ebtnode_result_type.png","exportPath":"images/ebtnode_result_type.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ebtnode_result_type.html":{"createdTime":1710855209750,"modifiedTime":1710855209750,"sourceSize":28011,"sourcePath":"images/ebtnode_result_type.png","exportPath":"images/ebtnode_result_type.html","showInTree":true,"treeOrder":243,"backlinks":[],"type":"attachment","data":null},"images/executable_file_structure.png":{"createdTime":1710855209752,"modifiedTime":1710855209752,"sourceSize":135281,"sourcePath":"images/executable_file_structure.png","exportPath":"images/executable_file_structure.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/executable_file_structure.html":{"createdTime":1710855209752,"modifiedTime":1710855209752,"sourceSize":135281,"sourcePath":"images/executable_file_structure.png","exportPath":"images/executable_file_structure.html","showInTree":true,"treeOrder":244,"backlinks":[],"type":"attachment","data":null},"images/export_shader_code.png":{"createdTime":1730808631675,"modifiedTime":1730808631676,"sourceSize":232733,"sourcePath":"images/export_shader_code.png","exportPath":"images/export_shader_code.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/export_shader_code.html":{"createdTime":1730808631675,"modifiedTime":1730808631676,"sourceSize":232733,"sourcePath":"images/export_shader_code.png","exportPath":"images/export_shader_code.html","showInTree":true,"treeOrder":245,"backlinks":["graphics/opengl/02.응용/06.-재사용가능한-코드.html"],"type":"attachment","data":null},"images/fatframework_path.png":{"createdTime":1710855209764,"modifiedTime":1710855209765,"sourceSize":236754,"sourcePath":"images/fatframework_path.png","exportPath":"images/fatframework_path.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/fatframework_path.html":{"createdTime":1710855209764,"modifiedTime":1710855209765,"sourceSize":236754,"sourcePath":"images/fatframework_path.png","exportPath":"images/fatframework_path.html","showInTree":true,"treeOrder":246,"backlinks":["ios/fat-framework.html"],"type":"attachment","data":null},"images/foldering_as_is.png":{"createdTime":1724571717968,"modifiedTime":1724571717968,"sourceSize":14318,"sourcePath":"images/foldering_as_is.png","exportPath":"images/foldering_as_is.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/foldering_as_is.html":{"createdTime":1724571717968,"modifiedTime":1724571717968,"sourceSize":14318,"sourcePath":"images/foldering_as_is.png","exportPath":"images/foldering_as_is.html","showInTree":true,"treeOrder":247,"backlinks":[],"type":"attachment","data":null},"images/foldering_to_be.png":{"createdTime":1724679437333,"modifiedTime":1724679437333,"sourceSize":12843,"sourcePath":"images/foldering_to_be.png","exportPath":"images/foldering_to_be.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/foldering_to_be.html":{"createdTime":1724679437333,"modifiedTime":1724679437333,"sourceSize":12843,"sourcePath":"images/foldering_to_be.png","exportPath":"images/foldering_to_be.html","showInTree":true,"treeOrder":248,"backlinks":["ue/sounds-개선.html"],"type":"attachment","data":null},"images/fragment_shader.png":{"createdTime":1730808631676,"modifiedTime":1730808631677,"sourceSize":450079,"sourcePath":"images/fragment_shader.png","exportPath":"images/fragment_shader.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/fragment_shader.html":{"createdTime":1730808631676,"modifiedTime":1730808631677,"sourceSize":450079,"sourcePath":"images/fragment_shader.png","exportPath":"images/fragment_shader.html","showInTree":true,"treeOrder":249,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment","data":null},"images/fragment_shader_execute.png":{"createdTime":1730808631678,"modifiedTime":1730808631680,"sourceSize":645434,"sourcePath":"images/fragment_shader_execute.png","exportPath":"images/fragment_shader_execute.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/fragment_shader_execute.html":{"createdTime":1730808631678,"modifiedTime":1730808631680,"sourceSize":645434,"sourcePath":"images/fragment_shader_execute.png","exportPath":"images/fragment_shader_execute.html","showInTree":true,"treeOrder":250,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment","data":null},"images/framework_path.png":{"createdTime":1710855209766,"modifiedTime":1710855209767,"sourceSize":199600,"sourcePath":"images/framework_path.png","exportPath":"images/framework_path.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/framework_path.html":{"createdTime":1710855209766,"modifiedTime":1710855209767,"sourceSize":199600,"sourcePath":"images/framework_path.png","exportPath":"images/framework_path.html","showInTree":true,"treeOrder":251,"backlinks":["ios/fat-framework.html"],"type":"attachment","data":null},"images/fresnel.png":{"createdTime":1752590582977,"modifiedTime":1752590582979,"sourceSize":679528,"sourcePath":"images/fresnel.png","exportPath":"images/fresnel.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/fresnel.html":{"createdTime":1752590582977,"modifiedTime":1752590582979,"sourceSize":679528,"sourcePath":"images/fresnel.png","exportPath":"images/fresnel.html","showInTree":true,"treeOrder":252,"backlinks":["graphics/unreal-engine/rim-light와-fresnel-노드.html"],"type":"attachment","data":null},"images/func_1.png":{"createdTime":1730808631680,"modifiedTime":1730808631680,"sourceSize":120737,"sourcePath":"images/func_1.png","exportPath":"images/func_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/func_1.html":{"createdTime":1730808631680,"modifiedTime":1730808631680,"sourceSize":120737,"sourcePath":"images/func_1.png","exportPath":"images/func_1.html","showInTree":true,"treeOrder":253,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment","data":null},"images/gameflowchart.png":{"createdTime":1710855209737,"modifiedTime":1710855209738,"sourceSize":71598,"sourcePath":"images/GameFlowChart.png","exportPath":"images/gameflowchart.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/gameflowchart.html":{"createdTime":1710855209737,"modifiedTime":1710855209738,"sourceSize":71598,"sourcePath":"images/GameFlowChart.png","exportPath":"images/gameflowchart.html","showInTree":true,"treeOrder":254,"backlinks":["ue/월드의-생명주기.html"],"type":"attachment","data":null},"images/gl_error_flag.png":{"createdTime":1730808631681,"modifiedTime":1730808631682,"sourceSize":115525,"sourcePath":"images/gl_error_flag.png","exportPath":"images/gl_error_flag.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/gl_error_flag.html":{"createdTime":1730808631681,"modifiedTime":1730808631682,"sourceSize":115525,"sourcePath":"images/gl_error_flag.png","exportPath":"images/gl_error_flag.html","showInTree":true,"treeOrder":255,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment","data":null},"images/glew32_install_error.png":{"createdTime":1710855209770,"modifiedTime":1710855209770,"sourceSize":42922,"sourcePath":"images/glew32_install_error.png","exportPath":"images/glew32_install_error.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/glew32_install_error.html":{"createdTime":1710855209770,"modifiedTime":1710855209770,"sourceSize":42922,"sourcePath":"images/glew32_install_error.png","exportPath":"images/glew32_install_error.html","showInTree":true,"treeOrder":256,"backlinks":["graphics/opengl/01.기본/01.-기본.html"],"type":"attachment","data":null},"images/glsl_debugging_1.png":{"createdTime":1730808631683,"modifiedTime":1730808631684,"sourceSize":315674,"sourcePath":"images/glsl_debugging_1.png","exportPath":"images/glsl_debugging_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/glsl_debugging_1.html":{"createdTime":1730808631683,"modifiedTime":1730808631684,"sourceSize":315674,"sourcePath":"images/glsl_debugging_1.png","exportPath":"images/glsl_debugging_1.html","showInTree":true,"treeOrder":257,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment","data":null},"images/glsl_debugging2.png":{"createdTime":1730808631682,"modifiedTime":1730808631683,"sourceSize":310477,"sourcePath":"images/glsl_debugging2.png","exportPath":"images/glsl_debugging2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/glsl_debugging2.html":{"createdTime":1730808631682,"modifiedTime":1730808631683,"sourceSize":310477,"sourcePath":"images/glsl_debugging2.png","exportPath":"images/glsl_debugging2.html","showInTree":true,"treeOrder":258,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment","data":null},"images/glvertexattribpointer.png":{"createdTime":1730808631680,"modifiedTime":1730808631681,"sourceSize":803090,"sourcePath":"images/glVertexAttribPointer.png","exportPath":"images/glvertexattribpointer.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/glvertexattribpointer.html":{"createdTime":1730808631680,"modifiedTime":1730808631681,"sourceSize":803090,"sourcePath":"images/glVertexAttribPointer.png","exportPath":"images/glvertexattribpointer.html","showInTree":true,"treeOrder":259,"backlinks":["graphics/opengl/02.응용/05.-shader-programming-코드-분석.html"],"type":"attachment","data":null},"images/gpu_structure.png":{"createdTime":1730808631684,"modifiedTime":1730808631684,"sourceSize":233489,"sourcePath":"images/gpu_structure.png","exportPath":"images/gpu_structure.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/gpu_structure.html":{"createdTime":1730808631684,"modifiedTime":1730808631684,"sourceSize":233489,"sourcePath":"images/gpu_structure.png","exportPath":"images/gpu_structure.html","showInTree":true,"treeOrder":260,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment","data":null},"images/graphic_pipeline.png":{"createdTime":1724679437333,"modifiedTime":1724679437333,"sourceSize":146778,"sourcePath":"images/graphic_pipeline.png","exportPath":"images/graphic_pipeline.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/graphic_pipeline.html":{"createdTime":1724679437333,"modifiedTime":1724679437333,"sourceSize":146778,"sourcePath":"images/graphic_pipeline.png","exportPath":"images/graphic_pipeline.html","showInTree":true,"treeOrder":261,"backlinks":["graphics/opengl/02.응용/01.-그래픽스-파이프라인.html"],"type":"attachment","data":null},"images/greedy_1.png":{"createdTime":1719241549677,"modifiedTime":1719241549680,"sourceSize":1130554,"sourcePath":"images/greedy_1.png","exportPath":"images/greedy_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/greedy_1.html":{"createdTime":1719241549677,"modifiedTime":1719241549680,"sourceSize":1130554,"sourcePath":"images/greedy_1.png","exportPath":"images/greedy_1.html","showInTree":true,"treeOrder":262,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment","data":null},"images/greedy_2.png":{"createdTime":1719241549680,"modifiedTime":1719241549686,"sourceSize":2298930,"sourcePath":"images/greedy_2.png","exportPath":"images/greedy_2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/greedy_2.html":{"createdTime":1719241549680,"modifiedTime":1719241549686,"sourceSize":2298930,"sourcePath":"images/greedy_2.png","exportPath":"images/greedy_2.html","showInTree":true,"treeOrder":263,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment","data":null},"images/greedy_3.png":{"createdTime":1719241549686,"modifiedTime":1719241549690,"sourceSize":2122424,"sourcePath":"images/greedy_3.png","exportPath":"images/greedy_3.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/greedy_3.html":{"createdTime":1719241549686,"modifiedTime":1719241549690,"sourceSize":2122424,"sourcePath":"images/greedy_3.png","exportPath":"images/greedy_3.html","showInTree":true,"treeOrder":264,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment","data":null},"images/greedy_4.png":{"createdTime":1719241549691,"modifiedTime":1719241549695,"sourceSize":2150616,"sourcePath":"images/greedy_4.png","exportPath":"images/greedy_4.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/greedy_4.html":{"createdTime":1719241549691,"modifiedTime":1719241549695,"sourceSize":2150616,"sourcePath":"images/greedy_4.png","exportPath":"images/greedy_4.html","showInTree":true,"treeOrder":265,"backlinks":["algorithm/lecture/그리디-알고리즘.html"],"type":"attachment","data":null},"images/grey_to_color_using_ai.png":{"createdTime":1724571717961,"modifiedTime":1724571717962,"sourceSize":212484,"sourcePath":"images/grey_to_color_using_ai.png","exportPath":"images/grey_to_color_using_ai.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/grey_to_color_using_ai.html":{"createdTime":1724571717961,"modifiedTime":1724571717962,"sourceSize":212484,"sourcePath":"images/grey_to_color_using_ai.png","exportPath":"images/grey_to_color_using_ai.html","showInTree":true,"treeOrder":266,"backlinks":["graphics/opengl/01.기본/06.-rgba-컬러-모델.html"],"type":"attachment","data":null},"images/hostapp_file.png":{"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":34963,"sourcePath":"images/hostapp_file.png","exportPath":"images/hostapp_file.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/hostapp_file.html":{"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":34963,"sourcePath":"images/hostapp_file.png","exportPath":"images/hostapp_file.html","showInTree":true,"treeOrder":267,"backlinks":["ios/fat-framework.html"],"type":"attachment","data":null},"images/immutable_mutable.png":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":78402,"sourcePath":"images/immutable_mutable.png","exportPath":"images/immutable_mutable.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/immutable_mutable.html":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":78402,"sourcePath":"images/immutable_mutable.png","exportPath":"images/immutable_mutable.html","showInTree":true,"treeOrder":268,"backlinks":["ios/objective-c.html"],"type":"attachment","data":null},"images/inc_support.png":{"createdTime":1722511221529,"modifiedTime":1722511221529,"sourceSize":29604,"sourcePath":"images/inc_support.png","exportPath":"images/inc_support.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/inc_support.html":{"createdTime":1722511221529,"modifiedTime":1722511221529,"sourceSize":29604,"sourcePath":"images/inc_support.png","exportPath":"images/inc_support.html","showInTree":true,"treeOrder":269,"backlinks":["infra/jenkins-안드로이드-패키징.html"],"type":"attachment","data":null},"images/initializer_list_char.png":{"createdTime":1738469787018,"modifiedTime":1738469787019,"sourceSize":43161,"sourcePath":"images/initializer_list_char.png","exportPath":"images/initializer_list_char.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/initializer_list_char.html":{"createdTime":1738469787018,"modifiedTime":1738469787019,"sourceSize":43161,"sourcePath":"images/initializer_list_char.png","exportPath":"images/initializer_list_char.html","showInTree":true,"treeOrder":270,"backlinks":["cpp/modern/6.-uniform-initializer.html"],"type":"attachment","data":null},"images/insight_after.png":{"createdTime":1730808631708,"modifiedTime":1730808631708,"sourceSize":11597,"sourcePath":"images/insight_after.png","exportPath":"images/insight_after.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/insight_after.html":{"createdTime":1730808631708,"modifiedTime":1730808631708,"sourceSize":11597,"sourcePath":"images/insight_after.png","exportPath":"images/insight_after.html","showInTree":true,"treeOrder":271,"backlinks":["ue/sounds-개선.html"],"type":"attachment","data":null},"images/insight_before.png":{"createdTime":1730808631709,"modifiedTime":1730808631709,"sourceSize":9803,"sourcePath":"images/insight_before.png","exportPath":"images/insight_before.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/insight_before.html":{"createdTime":1730808631709,"modifiedTime":1730808631709,"sourceSize":9803,"sourcePath":"images/insight_before.png","exportPath":"images/insight_before.html","showInTree":true,"treeOrder":272,"backlinks":["ue/sounds-개선.html"],"type":"attachment","data":null},"images/ip4v_header.png":{"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":108041,"sourcePath":"images/ip4v_header.png","exportPath":"images/ip4v_header.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/ip4v_header.html":{"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":108041,"sourcePath":"images/ip4v_header.png","exportPath":"images/ip4v_header.html","showInTree":true,"treeOrder":273,"backlinks":["network/07.-ipv4-header-형식.html"],"type":"attachment","data":null},"images/layout_qualifier.png":{"createdTime":1730808631684,"modifiedTime":1730808631685,"sourceSize":297491,"sourcePath":"images/layout_qualifier.png","exportPath":"images/layout_qualifier.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/layout_qualifier.html":{"createdTime":1730808631684,"modifiedTime":1730808631685,"sourceSize":297491,"sourcePath":"images/layout_qualifier.png","exportPath":"images/layout_qualifier.html","showInTree":true,"treeOrder":274,"backlinks":["graphics/opengl/02.응용/06.-재사용가능한-코드.html"],"type":"attachment","data":null},"images/linear_interpolation.png":{"createdTime":1730808631685,"modifiedTime":1730808631686,"sourceSize":383876,"sourcePath":"images/linear_interpolation.png","exportPath":"images/linear_interpolation.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/linear_interpolation.html":{"createdTime":1730808631685,"modifiedTime":1730808631686,"sourceSize":383876,"sourcePath":"images/linear_interpolation.png","exportPath":"images/linear_interpolation.html","showInTree":true,"treeOrder":275,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment","data":null},"images/math_func.png":{"createdTime":1730808631686,"modifiedTime":1730808631686,"sourceSize":126361,"sourcePath":"images/math_func.png","exportPath":"images/math_func.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/math_func.html":{"createdTime":1730808631686,"modifiedTime":1730808631686,"sourceSize":126361,"sourcePath":"images/math_func.png","exportPath":"images/math_func.html","showInTree":true,"treeOrder":276,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment","data":null},"images/matrix_row_prior.png":{"createdTime":1730808631686,"modifiedTime":1730808631687,"sourceSize":139225,"sourcePath":"images/matrix_row_prior.png","exportPath":"images/matrix_row_prior.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/matrix_row_prior.html":{"createdTime":1730808631686,"modifiedTime":1730808631687,"sourceSize":139225,"sourcePath":"images/matrix_row_prior.png","exportPath":"images/matrix_row_prior.html","showInTree":true,"treeOrder":277,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment","data":null},"images/metal_rendering_pipeline.png":{"createdTime":1732431283258,"modifiedTime":1732431283258,"sourceSize":87904,"sourcePath":"images/metal_rendering_pipeline.png","exportPath":"images/metal_rendering_pipeline.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/metal_rendering_pipeline.html":{"createdTime":1732431283258,"modifiedTime":1732431283258,"sourceSize":87904,"sourcePath":"images/metal_rendering_pipeline.png","exportPath":"images/metal_rendering_pipeline.html","showInTree":true,"treeOrder":278,"backlinks":["graphics/metal/0.-metal-basic.html"],"type":"attachment","data":null},"images/nativizedassets.png":{"createdTime":1710855209753,"modifiedTime":1710855209754,"sourceSize":365059,"sourcePath":"images/NativizedAssets.png","exportPath":"images/nativizedassets.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nativizedassets.html":{"createdTime":1710855209753,"modifiedTime":1710855209754,"sourceSize":365059,"sourcePath":"images/NativizedAssets.png","exportPath":"images/nativizedassets.html","showInTree":true,"treeOrder":279,"backlinks":["ue/ue4-source-ios-debugging-on-macos.html"],"type":"attachment","data":null},"images/navigation.png":{"createdTime":1710855209738,"modifiedTime":1710855209739,"sourceSize":1082780,"sourcePath":"images/Navigation.png","exportPath":"images/navigation.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/navigation.html":{"createdTime":1710855209738,"modifiedTime":1710855209739,"sourceSize":1082780,"sourcePath":"images/Navigation.png","exportPath":"images/navigation.html","showInTree":true,"treeOrder":280,"backlinks":["ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html"],"type":"attachment","data":null},"images/object_file_header.png":{"createdTime":1710855209752,"modifiedTime":1710855209753,"sourceSize":66978,"sourcePath":"images/object_file_header.png","exportPath":"images/object_file_header.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/object_file_header.html":{"createdTime":1710855209752,"modifiedTime":1710855209753,"sourceSize":66978,"sourcePath":"images/object_file_header.png","exportPath":"images/object_file_header.html","showInTree":true,"treeOrder":281,"backlinks":["cpp/basic/0.-c,-c++-컴파일-과정.html"],"type":"attachment","data":null},"images/opengl_shader_program_process.png":{"createdTime":1730808631687,"modifiedTime":1730808631689,"sourceSize":1013791,"sourcePath":"images/opengl_shader_program_process.png","exportPath":"images/opengl_shader_program_process.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/opengl_shader_program_process.html":{"createdTime":1730808631687,"modifiedTime":1730808631689,"sourceSize":1013791,"sourcePath":"images/opengl_shader_program_process.png","exportPath":"images/opengl_shader_program_process.html","showInTree":true,"treeOrder":282,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment","data":null},"images/packet.png":{"createdTime":1724571717943,"modifiedTime":1724571717944,"sourceSize":484235,"sourcePath":"images/packet.png","exportPath":"images/packet.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/packet.html":{"createdTime":1724571717943,"modifiedTime":1724571717944,"sourceSize":484235,"sourcePath":"images/packet.png","exportPath":"images/packet.html","showInTree":true,"treeOrder":283,"backlinks":["network/04.-패킷의-생성과-전달.html"],"type":"attachment","data":null},"images/paralle_processing.png":{"createdTime":1730808631689,"modifiedTime":1730808631689,"sourceSize":128064,"sourcePath":"images/paralle_processing.png","exportPath":"images/paralle_processing.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/paralle_processing.html":{"createdTime":1730808631689,"modifiedTime":1730808631689,"sourceSize":128064,"sourcePath":"images/paralle_processing.png","exportPath":"images/paralle_processing.html","showInTree":true,"treeOrder":284,"backlinks":["graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html"],"type":"attachment","data":null},"images/primitive_assembly_rasterization.png":{"createdTime":1730808631689,"modifiedTime":1730808631691,"sourceSize":650335,"sourcePath":"images/primitive_assembly_rasterization.png","exportPath":"images/primitive_assembly_rasterization.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/primitive_assembly_rasterization.html":{"createdTime":1730808631689,"modifiedTime":1730808631691,"sourceSize":650335,"sourcePath":"images/primitive_assembly_rasterization.png","exportPath":"images/primitive_assembly_rasterization.html","showInTree":true,"treeOrder":285,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment","data":null},"images/printf.png":{"createdTime":1710855209753,"modifiedTime":1710855209753,"sourceSize":108395,"sourcePath":"images/printf.png","exportPath":"images/printf.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/printf.html":{"createdTime":1710855209753,"modifiedTime":1710855209753,"sourceSize":108395,"sourcePath":"images/printf.png","exportPath":"images/printf.html","showInTree":true,"treeOrder":286,"backlinks":["cpp/basic/0.-c,-c++-컴파일-과정.html"],"type":"attachment","data":null},"images/prog_debugging.png":{"createdTime":1730808631691,"modifiedTime":1730808631692,"sourceSize":178240,"sourcePath":"images/prog_debugging.png","exportPath":"images/prog_debugging.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/prog_debugging.html":{"createdTime":1730808631691,"modifiedTime":1730808631692,"sourceSize":178240,"sourcePath":"images/prog_debugging.png","exportPath":"images/prog_debugging.html","showInTree":true,"treeOrder":287,"backlinks":["graphics/opengl/02.응용/09.-glsl-디버그-함수들.html"],"type":"attachment","data":null},"images/programmable_pipeline.png":{"createdTime":1730808631692,"modifiedTime":1730808631693,"sourceSize":486510,"sourcePath":"images/programmable_pipeline.png","exportPath":"images/programmable_pipeline.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/programmable_pipeline.html":{"createdTime":1730808631692,"modifiedTime":1730808631693,"sourceSize":486510,"sourcePath":"images/programmable_pipeline.png","exportPath":"images/programmable_pipeline.html","showInTree":true,"treeOrder":288,"backlinks":["graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html"],"type":"attachment","data":null},"images/pso.png":{"createdTime":1724571717969,"modifiedTime":1724571717970,"sourceSize":85554,"sourcePath":"images/pso.png","exportPath":"images/pso.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/pso.html":{"createdTime":1724571717969,"modifiedTime":1724571717970,"sourceSize":85554,"sourcePath":"images/pso.png","exportPath":"images/pso.html","showInTree":true,"treeOrder":289,"backlinks":[],"type":"attachment","data":null},"images/pso_data.png":{"createdTime":1719838659338,"modifiedTime":1719838659338,"sourceSize":24251,"sourcePath":"images/pso_data.png","exportPath":"images/pso_data.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/pso_data.html":{"createdTime":1719838659338,"modifiedTime":1719838659338,"sourceSize":24251,"sourcePath":"images/pso_data.png","exportPath":"images/pso_data.html","showInTree":true,"treeOrder":290,"backlinks":["ue/pso-(pipeline-state-object)-수집.html"],"type":"attachment","data":null},"images/rasterization_mean.png":{"createdTime":1730808631693,"modifiedTime":1730808631694,"sourceSize":547080,"sourcePath":"images/rasterization_mean.png","exportPath":"images/rasterization_mean.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/rasterization_mean.html":{"createdTime":1730808631693,"modifiedTime":1730808631694,"sourceSize":547080,"sourcePath":"images/rasterization_mean.png","exportPath":"images/rasterization_mean.html","showInTree":true,"treeOrder":291,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment","data":null},"images/register_vec.png":{"createdTime":1730808631694,"modifiedTime":1730808631694,"sourceSize":36023,"sourcePath":"images/register_vec.png","exportPath":"images/register_vec.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/register_vec.html":{"createdTime":1730808631694,"modifiedTime":1730808631694,"sourceSize":36023,"sourcePath":"images/register_vec.png","exportPath":"images/register_vec.html","showInTree":true,"treeOrder":292,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment","data":null},"images/removedinternal.png":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":44765,"sourcePath":"images/removedinternal.png","exportPath":"images/removedinternal.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/removedinternal.html":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":44765,"sourcePath":"images/removedinternal.png","exportPath":"images/removedinternal.html","showInTree":true,"treeOrder":293,"backlinks":["ios/swift,-objective-c-interoperability.html"],"type":"attachment","data":null},"images/rgb_cmy_conversion.png":{"createdTime":1724571717962,"modifiedTime":1724571717962,"sourceSize":22210,"sourcePath":"images/rgb_cmy_conversion.png","exportPath":"images/rgb_cmy_conversion.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/rgb_cmy_conversion.html":{"createdTime":1724571717962,"modifiedTime":1724571717962,"sourceSize":22210,"sourcePath":"images/rgb_cmy_conversion.png","exportPath":"images/rgb_cmy_conversion.html","showInTree":true,"treeOrder":294,"backlinks":["graphics/opengl/01.기본/04.-컬러-기초이론.html"],"type":"attachment","data":null},"images/rgb_color_model.png":{"createdTime":1724571717962,"modifiedTime":1724571717962,"sourceSize":347295,"sourcePath":"images/rgb_color_model.png","exportPath":"images/rgb_color_model.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/rgb_color_model.html":{"createdTime":1724571717962,"modifiedTime":1724571717962,"sourceSize":347295,"sourcePath":"images/rgb_color_model.png","exportPath":"images/rgb_color_model.html","showInTree":true,"treeOrder":295,"backlinks":["graphics/opengl/01.기본/04.-컬러-기초이론.html"],"type":"attachment","data":null},"images/robot_maze.png":{"createdTime":1736064754186,"modifiedTime":1736064754187,"sourceSize":9685,"sourcePath":"images/robot_maze.png","exportPath":"images/robot_maze.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/robot_maze.html":{"createdTime":1736064754186,"modifiedTime":1736064754187,"sourceSize":9685,"sourcePath":"images/robot_maze.png","exportPath":"images/robot_maze.html","showInTree":true,"treeOrder":296,"backlinks":["algorithm/leetcode/62.-unique-paths.html"],"type":"attachment","data":null},"images/sandbox_error.png":{"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":90251,"sourcePath":"images/sandbox_error.png","exportPath":"images/sandbox_error.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/sandbox_error.html":{"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":90251,"sourcePath":"images/sandbox_error.png","exportPath":"images/sandbox_error.html","showInTree":true,"treeOrder":297,"backlinks":["ios/fat-framework.html"],"type":"attachment","data":null},"images/serial.png":{"createdTime":1710855209769,"modifiedTime":1710855209770,"sourceSize":190288,"sourcePath":"images/serial.png","exportPath":"images/serial.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/serial.html":{"createdTime":1710855209769,"modifiedTime":1710855209770,"sourceSize":190288,"sourcePath":"images/serial.png","exportPath":"images/serial.html","showInTree":true,"treeOrder":298,"backlinks":["ios/동기,-비동기.html"],"type":"attachment","data":null},"images/shader_program_structure.png":{"createdTime":1730808631694,"modifiedTime":1730808631696,"sourceSize":1027728,"sourcePath":"images/shader_program_structure.png","exportPath":"images/shader_program_structure.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/shader_program_structure.html":{"createdTime":1730808631694,"modifiedTime":1730808631696,"sourceSize":1027728,"sourcePath":"images/shader_program_structure.png","exportPath":"images/shader_program_structure.html","showInTree":true,"treeOrder":299,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment","data":null},"images/simulator_device_error.png":{"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":24329,"sourcePath":"images/simulator_device_error.png","exportPath":"images/simulator_device_error.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/simulator_device_error.html":{"createdTime":1710855209767,"modifiedTime":1710855209767,"sourceSize":24329,"sourcePath":"images/simulator_device_error.png","exportPath":"images/simulator_device_error.html","showInTree":true,"treeOrder":300,"backlinks":["ios/fat-framework.html"],"type":"attachment","data":null},"images/slate_arcitecture_1.png":{"createdTime":1710855209759,"modifiedTime":1710855209760,"sourceSize":224814,"sourcePath":"images/SLATE_ARCITECTURE_1.png","exportPath":"images/slate_arcitecture_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/slate_arcitecture_1.html":{"createdTime":1710855209759,"modifiedTime":1710855209760,"sourceSize":224814,"sourcePath":"images/SLATE_ARCITECTURE_1.png","exportPath":"images/slate_arcitecture_1.html","showInTree":true,"treeOrder":301,"backlinks":["ue/slate-architecture.html"],"type":"attachment","data":null},"images/slate_arcitecture_2.png":{"createdTime":1710855209760,"modifiedTime":1710855209760,"sourceSize":124195,"sourcePath":"images/SLATE_ARCITECTURE_2.png","exportPath":"images/slate_arcitecture_2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/slate_arcitecture_2.html":{"createdTime":1710855209760,"modifiedTime":1710855209760,"sourceSize":124195,"sourcePath":"images/SLATE_ARCITECTURE_2.png","exportPath":"images/slate_arcitecture_2.html","showInTree":true,"treeOrder":302,"backlinks":["ue/slate-architecture.html"],"type":"attachment","data":null},"images/slate_arcitecture_3.png":{"createdTime":1710855209760,"modifiedTime":1710855209762,"sourceSize":526967,"sourcePath":"images/SLATE_ARCITECTURE_3.png","exportPath":"images/slate_arcitecture_3.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/slate_arcitecture_3.html":{"createdTime":1710855209760,"modifiedTime":1710855209762,"sourceSize":526967,"sourcePath":"images/SLATE_ARCITECTURE_3.png","exportPath":"images/slate_arcitecture_3.html","showInTree":true,"treeOrder":303,"backlinks":["ue/slate-architecture.html"],"type":"attachment","data":null},"images/slate_arcitecture_4.png":{"createdTime":1710855209762,"modifiedTime":1710855209763,"sourceSize":248247,"sourcePath":"images/SLATE_ARCITECTURE_4.png","exportPath":"images/slate_arcitecture_4.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/slate_arcitecture_4.html":{"createdTime":1710855209762,"modifiedTime":1710855209763,"sourceSize":248247,"sourcePath":"images/SLATE_ARCITECTURE_4.png","exportPath":"images/slate_arcitecture_4.html","showInTree":true,"treeOrder":304,"backlinks":["ue/slate-architecture.html"],"type":"attachment","data":null},"images/slate_overview_1.png":{"createdTime":1710855209763,"modifiedTime":1710855209763,"sourceSize":90359,"sourcePath":"images/SLATE_OVERVIEW_1.png","exportPath":"images/slate_overview_1.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/slate_overview_1.html":{"createdTime":1710855209763,"modifiedTime":1710855209763,"sourceSize":90359,"sourcePath":"images/SLATE_OVERVIEW_1.png","exportPath":"images/slate_overview_1.html","showInTree":true,"treeOrder":305,"backlinks":["ue/slate-overview.html"],"type":"attachment","data":null},"images/slate_overview_2.png":{"createdTime":1710855209763,"modifiedTime":1710855209763,"sourceSize":16778,"sourcePath":"images/SLATE_OVERVIEW_2.png","exportPath":"images/slate_overview_2.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/slate_overview_2.html":{"createdTime":1710855209763,"modifiedTime":1710855209763,"sourceSize":16778,"sourcePath":"images/SLATE_OVERVIEW_2.png","exportPath":"images/slate_overview_2.html","showInTree":true,"treeOrder":306,"backlinks":["ue/slate-overview.html"],"type":"attachment","data":null},"images/sphere-indexing-screenshot.png":{"createdTime":1743604604148,"modifiedTime":1743604604148,"sourceSize":62639,"sourcePath":"images/sphere-indexing-screenshot.png","exportPath":"images/sphere-indexing-screenshot.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/sphere-indexing-screenshot.html":{"createdTime":1743604604148,"modifiedTime":1743604604148,"sourceSize":62639,"sourcePath":"images/sphere-indexing-screenshot.png","exportPath":"images/sphere-indexing-screenshot.html","showInTree":true,"treeOrder":307,"backlinks":["qt/opengl/opengl-sphere-그리기.html"],"type":"attachment","data":null},"images/subnetmask.png":{"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":22693,"sourcePath":"images/subnetmask.png","exportPath":"images/subnetmask.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/subnetmask.html":{"createdTime":1730808631671,"modifiedTime":1730808631671,"sourceSize":22693,"sourcePath":"images/subnetmask.png","exportPath":"images/subnetmask.html","showInTree":true,"treeOrder":308,"backlinks":["network/08.-서브넷-마스크와-cidr.html"],"type":"attachment","data":null},"images/subset_graph.png":{"createdTime":1719241549696,"modifiedTime":1719241549700,"sourceSize":1319039,"sourcePath":"images/subset_graph.png","exportPath":"images/subset_graph.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/subset_graph.html":{"createdTime":1719241549696,"modifiedTime":1719241549700,"sourceSize":1319039,"sourcePath":"images/subset_graph.png","exportPath":"images/subset_graph.html","showInTree":true,"treeOrder":309,"backlinks":["algorithm/leetcode/78.-subsets.html"],"type":"attachment","data":null},"images/symbol_find_result.png":{"createdTime":1710855209756,"modifiedTime":1710855209757,"sourceSize":94053,"sourcePath":"images/symbol_find_result.png","exportPath":"images/symbol_find_result.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/symbol_find_result.html":{"createdTime":1710855209756,"modifiedTime":1710855209757,"sourceSize":94053,"sourcePath":"images/symbol_find_result.png","exportPath":"images/symbol_find_result.html","showInTree":true,"treeOrder":310,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment","data":null},"images/symbol_result.png":{"createdTime":1710855209757,"modifiedTime":1710855209757,"sourceSize":224111,"sourcePath":"images/symbol_result.png","exportPath":"images/symbol_result.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/symbol_result.html":{"createdTime":1710855209757,"modifiedTime":1710855209757,"sourceSize":224111,"sourcePath":"images/symbol_result.png","exportPath":"images/symbol_result.html","showInTree":true,"treeOrder":311,"backlinks":["ue/physx-ios-빌드.html"],"type":"attachment","data":null},"images/type_structure.png":{"createdTime":1730808631697,"modifiedTime":1730808631697,"sourceSize":89283,"sourcePath":"images/type_structure.png","exportPath":"images/type_structure.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/type_structure.html":{"createdTime":1730808631697,"modifiedTime":1730808631697,"sourceSize":89283,"sourcePath":"images/type_structure.png","exportPath":"images/type_structure.html","showInTree":true,"treeOrder":312,"backlinks":["graphics/opengl/02.응용/07.-glsl-자료형.html"],"type":"attachment","data":null},"images/u2_soundtype.png":{"createdTime":1724679437333,"modifiedTime":1724679437334,"sourceSize":6442,"sourcePath":"images/u2_soundtype.png","exportPath":"images/u2_soundtype.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/u2_soundtype.html":{"createdTime":1724679437333,"modifiedTime":1724679437334,"sourceSize":6442,"sourcePath":"images/u2_soundtype.png","exportPath":"images/u2_soundtype.html","showInTree":true,"treeOrder":313,"backlinks":["ue/sounds-개선.html"],"type":"attachment","data":null},"images/use_vertex_attirbute_arrays.png":{"createdTime":1730808631697,"modifiedTime":1730808631699,"sourceSize":913884,"sourcePath":"images/use_vertex_attirbute_arrays.png","exportPath":"images/use_vertex_attirbute_arrays.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/use_vertex_attirbute_arrays.html":{"createdTime":1730808631697,"modifiedTime":1730808631699,"sourceSize":913884,"sourcePath":"images/use_vertex_attirbute_arrays.png","exportPath":"images/use_vertex_attirbute_arrays.html","showInTree":true,"treeOrder":314,"backlinks":["graphics/opengl/02.응용/05.-shader-programming-코드-분석.html"],"type":"attachment","data":null},"images/usermode_kernalmode.png":{"createdTime":1724571717944,"modifiedTime":1724571717953,"sourceSize":1937082,"sourcePath":"images/usermode_kernalmode.png","exportPath":"images/usermode_kernalmode.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/usermode_kernalmode.html":{"createdTime":1724571717944,"modifiedTime":1724571717953,"sourceSize":1937082,"sourcePath":"images/usermode_kernalmode.png","exportPath":"images/usermode_kernalmode.html","showInTree":true,"treeOrder":315,"backlinks":[],"type":"attachment","data":null},"images/using_uniform.png":{"createdTime":1730808631700,"modifiedTime":1730808631703,"sourceSize":1221648,"sourcePath":"images/using_uniform.png","exportPath":"images/using_uniform.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/using_uniform.html":{"createdTime":1730808631700,"modifiedTime":1730808631703,"sourceSize":1221648,"sourcePath":"images/using_uniform.png","exportPath":"images/using_uniform.html","showInTree":true,"treeOrder":316,"backlinks":["graphics/opengl/02.응용/08.-uniform-variable.html"],"type":"attachment","data":null},"images/var_error.jpg":{"createdTime":1724571717970,"modifiedTime":1724571717972,"sourceSize":232611,"sourcePath":"images/var_error.jpg","exportPath":"images/var_error.jpg","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/var_error.html":{"createdTime":1724571717970,"modifiedTime":1724571717972,"sourceSize":232611,"sourcePath":"images/var_error.jpg","exportPath":"images/var_error.html","showInTree":true,"treeOrder":317,"backlinks":["ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html"],"type":"attachment","data":null},"images/vertex_shader.png":{"createdTime":1730808631703,"modifiedTime":1730808631704,"sourceSize":517973,"sourcePath":"images/vertex_shader.png","exportPath":"images/vertex_shader.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/vertex_shader.html":{"createdTime":1730808631703,"modifiedTime":1730808631704,"sourceSize":517973,"sourcePath":"images/vertex_shader.png","exportPath":"images/vertex_shader.html","showInTree":true,"treeOrder":318,"backlinks":["graphics/opengl/02.응용/03.-gpu-내부-구조.html"],"type":"attachment","data":null},"images/vertext_shader_parallel.png":{"createdTime":1730808631704,"modifiedTime":1730808631706,"sourceSize":882522,"sourcePath":"images/vertext_shader_parallel.png","exportPath":"images/vertext_shader_parallel.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/vertext_shader_parallel.html":{"createdTime":1730808631704,"modifiedTime":1730808631706,"sourceSize":882522,"sourcePath":"images/vertext_shader_parallel.png","exportPath":"images/vertext_shader_parallel.html","showInTree":true,"treeOrder":319,"backlinks":["graphics/opengl/02.응용/04.-glsl.html"],"type":"attachment","data":null},"images/vtableoperation.png":{"createdTime":1754545491069,"modifiedTime":1754545491071,"sourceSize":343938,"sourcePath":"images/vtableoperation.png","exportPath":"images/vtableoperation.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/vtableoperation.html":{"createdTime":1754545491069,"modifiedTime":1754545491071,"sourceSize":343938,"sourcePath":"images/vtableoperation.png","exportPath":"images/vtableoperation.html","showInTree":true,"treeOrder":320,"backlinks":["cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html"],"type":"attachment","data":null},"images/wbp_ui_transition.png":{"createdTime":1724571717941,"modifiedTime":1724571717941,"sourceSize":57064,"sourcePath":"images/wbp_ui_transition.png","exportPath":"images/wbp_ui_transition.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/wbp_ui_transition.html":{"createdTime":1724571717941,"modifiedTime":1724571717941,"sourceSize":57064,"sourcePath":"images/wbp_ui_transition.png","exportPath":"images/wbp_ui_transition.html","showInTree":true,"treeOrder":321,"backlinks":[],"type":"attachment","data":null},"images/whoami.png":{"createdTime":1722511221529,"modifiedTime":1722511221529,"sourceSize":6297,"sourcePath":"images/whoami.png","exportPath":"images/whoami.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/whoami.html":{"createdTime":1722511221529,"modifiedTime":1722511221529,"sourceSize":6297,"sourcePath":"images/whoami.png","exportPath":"images/whoami.html","showInTree":true,"treeOrder":322,"backlinks":["infra/jenkins-안드로이드-패키징.html"],"type":"attachment","data":null},"infra/helix-core-workflow.html":{"createdTime":1734522365541,"modifiedTime":1735574042983,"sourceSize":2109,"sourcePath":"Infra/Helix Core Workflow.md","exportPath":"infra/helix-core-workflow.html","showInTree":true,"treeOrder":324,"backlinks":[],"type":"markdown","data":null},"infra/helix-core,-helix-swarm-구성.html":{"createdTime":1734787474580,"modifiedTime":1737704717627,"sourceSize":2038,"sourcePath":"Infra/Helix core,  Helix Swarm 구성.md","exportPath":"infra/helix-core,-helix-swarm-구성.html","showInTree":true,"treeOrder":325,"backlinks":[],"type":"markdown","data":null},"infra/jenkins-설치-및-구성.html":{"createdTime":1733121252270,"modifiedTime":1736945671713,"sourceSize":11293,"sourcePath":"Infra/Jenkins 설치 및 구성.md","exportPath":"infra/jenkins-설치-및-구성.html","showInTree":true,"treeOrder":326,"backlinks":[],"type":"markdown","data":null},"infra/jenkins-안드로이드-패키징.html":{"createdTime":1724571717956,"modifiedTime":1736945653302,"sourceSize":13318,"sourcePath":"Infra/Jenkins 안드로이드 패키징.md","exportPath":"infra/jenkins-안드로이드-패키징.html","showInTree":true,"treeOrder":327,"backlinks":[],"type":"markdown","data":null},"infra/p4-extension,-p4-triggers.html":{"createdTime":1737458659182,"modifiedTime":1737458659183,"sourceSize":4421,"sourcePath":"Infra/P4 extension, P4 Triggers.md","exportPath":"infra/p4-extension,-p4-triggers.html","showInTree":true,"treeOrder":328,"backlinks":[],"type":"markdown","data":null},"infra/perforce-label.html":{"createdTime":1739188974319,"modifiedTime":1739188974319,"sourceSize":1695,"sourcePath":"Infra/Perforce Label.md","exportPath":"infra/perforce-label.html","showInTree":true,"treeOrder":329,"backlinks":[],"type":"markdown","data":null},"infra/perforce-명령어.html":{"createdTime":1735918424722,"modifiedTime":1737704466311,"sourceSize":1696,"sourcePath":"Infra/Perforce 명령어.md","exportPath":"infra/perforce-명령어.html","showInTree":true,"treeOrder":330,"backlinks":[],"type":"markdown","data":null},"infra/swarm-teams.html":{"createdTime":1737458659183,"modifiedTime":1737458659183,"sourceSize":9378,"sourcePath":"Infra/Swarm Teams.md","exportPath":"infra/swarm-teams.html","showInTree":true,"treeOrder":331,"backlinks":[],"type":"markdown","data":null},"interview_practice/c++.html":{"createdTime":1754545491065,"modifiedTime":1754545491065,"sourceSize":6059,"sourcePath":"Interview_practice/C++.md","exportPath":"interview_practice/c++.html","showInTree":true,"treeOrder":333,"backlinks":[],"type":"markdown","data":null},"interview_practice/ios-(1).html":{"createdTime":1754545491066,"modifiedTime":1754545491066,"sourceSize":2521,"sourcePath":"Interview_practice/iOS (1).md","exportPath":"interview_practice/ios-(1).html","showInTree":true,"treeOrder":334,"backlinks":[],"type":"markdown","data":null},"interview_practice/platform-sdk-(1).html":{"createdTime":1751981687162,"modifiedTime":1751981771007,"sourceSize":2575,"sourcePath":"Interview_practice/Platform SDK (1).md","exportPath":"interview_practice/platform-sdk-(1).html","showInTree":true,"treeOrder":335,"backlinks":[],"type":"markdown","data":null},"interview_practice/platform-sdk-(2).html":{"createdTime":1751981861762,"modifiedTime":1751982381892,"sourceSize":3486,"sourcePath":"Interview_practice/Platform SDK (2).md","exportPath":"interview_practice/platform-sdk-(2).html","showInTree":true,"treeOrder":336,"backlinks":[],"type":"markdown","data":null},"interview_practice/qt.html":{"createdTime":1752046023828,"modifiedTime":1752046023828,"sourceSize":2322,"sourcePath":"Interview_practice/Qt.md","exportPath":"interview_practice/qt.html","showInTree":true,"treeOrder":337,"backlinks":[],"type":"markdown","data":null},"ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html":{"createdTime":1735622506626,"modifiedTime":1735622762245,"sourceSize":9062,"sourcePath":"iOS/@testable import와  빌드 환경 구성 (Build Environment Configuration) 그리고 에러.md","exportPath":"ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html","showInTree":true,"treeOrder":339,"backlinks":[],"type":"markdown","data":null},"ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html":{"createdTime":1735622382925,"modifiedTime":1735622391198,"sourceSize":2858,"sourcePath":"iOS/Could not find module 'Alamofire' for target armv7-apple-ios';.md","exportPath":"ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html","showInTree":true,"treeOrder":340,"backlinks":[],"type":"markdown","data":null},"ios/fat-framework.html":{"createdTime":1710855209764,"modifiedTime":1735554492925,"sourceSize":5359,"sourcePath":"iOS/Fat Framework.md","exportPath":"ios/fat-framework.html","showInTree":true,"treeOrder":341,"backlinks":[],"type":"markdown","data":null},"ios/lazy-sequence.html":{"createdTime":1735623166859,"modifiedTime":1735623215320,"sourceSize":6852,"sourcePath":"iOS/Lazy Sequence.md","exportPath":"ios/lazy-sequence.html","showInTree":true,"treeOrder":342,"backlinks":[],"type":"markdown","data":null},"ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html":{"createdTime":1736176210787,"modifiedTime":1736176233291,"sourceSize":12236,"sourcePath":"iOS/Missing required module 'RxCocoaRuntime'에 대한 고찰 - SPM과 UnitTest에서의 오류.md","exportPath":"ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html","showInTree":true,"treeOrder":343,"backlinks":[],"type":"markdown","data":null},"ios/network-timeout-unittest.html":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":2133,"sourcePath":"iOS/Network Timeout UnitTest.md","exportPath":"ios/network-timeout-unittest.html","showInTree":true,"treeOrder":344,"backlinks":[],"type":"markdown","data":null},"ios/objective-c.html":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":5349,"sourcePath":"iOS/Objective - C.md","exportPath":"ios/objective-c.html","showInTree":true,"treeOrder":345,"backlinks":[],"type":"markdown","data":null},"ios/orientation.html":{"createdTime":1710855209769,"modifiedTime":1710855209769,"sourceSize":4212,"sourcePath":"iOS/Orientation.md","exportPath":"ios/orientation.html","showInTree":true,"treeOrder":346,"backlinks":[],"type":"markdown","data":null},"ios/photokit을-다뤄보자-(이론편).html":{"createdTime":1735622405574,"modifiedTime":1735622438849,"sourceSize":3385,"sourcePath":"iOS/PhotoKit을 다뤄보자 (이론편).md","exportPath":"ios/photokit을-다뤄보자-(이론편).html","showInTree":true,"treeOrder":347,"backlinks":[],"type":"markdown","data":null},"ios/photokit을-다뤄보자-(커스텀-코드편).html":{"createdTime":1735622444833,"modifiedTime":1735622471118,"sourceSize":8702,"sourcePath":"iOS/PhotoKit을 다뤄보자 (커스텀 코드편).md","exportPath":"ios/photokit을-다뤄보자-(커스텀-코드편).html","showInTree":true,"treeOrder":348,"backlinks":[],"type":"markdown","data":null},"ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html":{"createdTime":1735623124626,"modifiedTime":1735623128411,"sourceSize":2855,"sourcePath":"iOS/Scalable Application 설계부터 구현까지 - (0) 대략의 설계.md","exportPath":"ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html","showInTree":true,"treeOrder":349,"backlinks":[],"type":"markdown","data":null},"ios/scalable-application-설계부터-구현까지-(1)-tuist.html":{"createdTime":1735623139117,"modifiedTime":1739278187152,"sourceSize":24074,"sourcePath":"iOS/Scalable Application 설계부터 구현까지 - (1) Tuist.md","exportPath":"ios/scalable-application-설계부터-구현까지-(1)-tuist.html","showInTree":true,"treeOrder":350,"backlinks":[],"type":"markdown","data":null},"ios/swift,-objective-c-interoperability.html":{"createdTime":1710855209768,"modifiedTime":1710855209768,"sourceSize":3835,"sourcePath":"iOS/Swift, Objective - C interoperability.md","exportPath":"ios/swift,-objective-c-interoperability.html","showInTree":true,"treeOrder":351,"backlinks":[],"type":"markdown","data":null},"ios/swift에서-다형성을-달성하는-방법.html":{"createdTime":1735623216854,"modifiedTime":1735623315641,"sourceSize":31720,"sourcePath":"iOS/Swift에서 다형성을 달성하는 방법.md","exportPath":"ios/swift에서-다형성을-달성하는-방법.html","showInTree":true,"treeOrder":352,"backlinks":[],"type":"markdown","data":null},"ios/tuist-기본적인-사용법.html":{"createdTime":1735622304353,"modifiedTime":1735622371219,"sourceSize":12470,"sourcePath":"iOS/Tuist 기본적인 사용법.md","exportPath":"ios/tuist-기본적인-사용법.html","showInTree":true,"treeOrder":353,"backlinks":[],"type":"markdown","data":null},"ios/tuist에서-ribs-fetch하기.-(carthage).html":{"createdTime":1735621880078,"modifiedTime":1735621898262,"sourceSize":8804,"sourcePath":"iOS/Tuist에서 RIBs Fetch하기. (Carthage).md","exportPath":"ios/tuist에서-ribs-fetch하기.-(carthage).html","showInTree":true,"treeOrder":354,"backlinks":[],"type":"markdown","data":null},"ios/ui-update-cycle.html":{"createdTime":1751291409476,"modifiedTime":1751292660903,"sourceSize":3770,"sourcePath":"iOS/UI Update Cycle.md","exportPath":"ios/ui-update-cycle.html","showInTree":true,"treeOrder":355,"backlinks":[],"type":"markdown","data":null},"ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html":{"createdTime":1735622595968,"modifiedTime":1735622725013,"sourceSize":22950,"sourcePath":"iOS/Unit Test와 TDD - 근데 이게 async await를 곁들인.md","exportPath":"ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html","showInTree":true,"treeOrder":356,"backlinks":[],"type":"markdown","data":null},"ios/wwdc-2023-parameter-pack.html":{"createdTime":1735623352028,"modifiedTime":1735623599141,"sourceSize":12900,"sourcePath":"iOS/WWDC 2023 Parameter pack.md","exportPath":"ios/wwdc-2023-parameter-pack.html","showInTree":true,"treeOrder":357,"backlinks":[],"type":"markdown","data":null},"ios/단위테스트와-product_module_name.html":{"createdTime":1735623639381,"modifiedTime":1735623667317,"sourceSize":4997,"sourcePath":"iOS/단위테스트와 PRODUCT_MODULE_NAME.md","exportPath":"ios/단위테스트와-product_module_name.html","showInTree":true,"treeOrder":358,"backlinks":[],"type":"markdown","data":null},"ios/동기,-비동기.html":{"createdTime":1710855209770,"modifiedTime":1710855209770,"sourceSize":5755,"sourcePath":"iOS/동기, 비동기.md","exportPath":"ios/동기,-비동기.html","showInTree":true,"treeOrder":359,"backlinks":[],"type":"markdown","data":null},"ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html":{"createdTime":1735622483665,"modifiedTime":1735622504946,"sourceSize":22120,"sourcePath":"iOS/드래그가 가능한 BottomSheet를 만들어보자(DraggableBottomSheet ).md","exportPath":"ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html","showInTree":true,"treeOrder":360,"backlinks":[],"type":"markdown","data":null},"network/01.-network.html":{"createdTime":1724571717941,"modifiedTime":1724571717941,"sourceSize":1200,"sourcePath":"Network/01. Network.md","exportPath":"network/01.-network.html","showInTree":true,"treeOrder":362,"backlinks":[],"type":"markdown","data":null},"network/02.-l2.html":{"createdTime":1724571717941,"modifiedTime":1724571717942,"sourceSize":2052,"sourcePath":"Network/02. L2.md","exportPath":"network/02.-l2.html","showInTree":true,"treeOrder":363,"backlinks":[],"type":"markdown","data":null},"network/03.-l3.html":{"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":620,"sourcePath":"Network/03. L3.md","exportPath":"network/03.-l3.html","showInTree":true,"treeOrder":364,"backlinks":[],"type":"markdown","data":null},"network/04.-패킷의-생성과-전달.html":{"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":278,"sourcePath":"Network/04. 패킷의 생성과 전달.md","exportPath":"network/04.-패킷의-생성과-전달.html","showInTree":true,"treeOrder":365,"backlinks":[],"type":"markdown","data":null},"network/05.-계층별-데이터-단위.html":{"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":525,"sourcePath":"Network/05. 계층별 데이터 단위.md","exportPath":"network/05.-계층별-데이터-단위.html","showInTree":true,"treeOrder":366,"backlinks":[],"type":"markdown","data":null},"network/06.-tcp-ip-송수신-구조.html":{"createdTime":1724571717942,"modifiedTime":1724571717942,"sourceSize":1732,"sourcePath":"Network/06. TCP IP 송수신 구조.md","exportPath":"network/06.-tcp-ip-송수신-구조.html","showInTree":true,"treeOrder":367,"backlinks":[],"type":"markdown","data":null},"network/07.-ipv4-header-형식.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":1220,"sourcePath":"Network/07. IPv4 Header 형식.md","exportPath":"network/07.-ipv4-header-형식.html","showInTree":true,"treeOrder":368,"backlinks":[],"type":"markdown","data":null},"network/08.-서브넷-마스크와-cidr.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":908,"sourcePath":"Network/08. 서브넷 마스크와 CIDR.md","exportPath":"network/08.-서브넷-마스크와-cidr.html","showInTree":true,"treeOrder":369,"backlinks":[],"type":"markdown","data":null},"network/09.-broadcast-ip-주소-&-loopback-주소.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":828,"sourcePath":"Network/09. Broadcast IP 주소 & Loopback 주소.md","exportPath":"network/09.-broadcast-ip-주소-&-loopback-주소.html","showInTree":true,"treeOrder":370,"backlinks":[],"type":"markdown","data":null},"network/10.-ttl과-단편화.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":1196,"sourcePath":"Network/10. TTL과 단편화.md","exportPath":"network/10.-ttl과-단편화.html","showInTree":true,"treeOrder":371,"backlinks":[],"type":"markdown","data":null},"network/11.-인터넷-자동-설정-dhcp.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":1710,"sourcePath":"Network/11. 인터넷 자동 설정 - DHCP.md","exportPath":"network/11.-인터넷-자동-설정-dhcp.html","showInTree":true,"treeOrder":372,"backlinks":[],"type":"markdown","data":null},"network/12.-arp.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":599,"sourcePath":"Network/12. ARP.md","exportPath":"network/12.-arp.html","showInTree":true,"treeOrder":373,"backlinks":[],"type":"markdown","data":null},"network/13.-ping과-rtt.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":185,"sourcePath":"Network/13. Ping과 RTT.md","exportPath":"network/13.-ping과-rtt.html","showInTree":true,"treeOrder":374,"backlinks":[],"type":"markdown","data":null},"network/14.-tcp와-udp-개요.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":579,"sourcePath":"Network/14. TCP와 UDP 개요.md","exportPath":"network/14.-tcp와-udp-개요.html","showInTree":true,"treeOrder":375,"backlinks":[],"type":"markdown","data":null},"network/15.-tcp-연결-과정.html":{"createdTime":1730808631670,"modifiedTime":1730808631670,"sourceSize":644,"sourcePath":"Network/15. TCP 연결 과정.md","exportPath":"network/15.-tcp-연결-과정.html","showInTree":true,"treeOrder":376,"backlinks":[],"type":"markdown","data":null},"network/16.-tcp-연결-종료-과정.html":{"createdTime":1730808631670,"modifiedTime":1730808631671,"sourceSize":317,"sourcePath":"Network/16.  TCP 연결 종료 과정.md","exportPath":"network/16.-tcp-연결-종료-과정.html","showInTree":true,"treeOrder":377,"backlinks":[],"type":"markdown","data":null},"network/17.-dns.html":{"createdTime":1733748909718,"modifiedTime":1733749688993,"sourceSize":802,"sourcePath":"Network/17. DNS.md","exportPath":"network/17.-dns.html","showInTree":true,"treeOrder":378,"backlinks":[],"type":"markdown","data":null},"network/18.-http.html":{"createdTime":1733749713419,"modifiedTime":1733749848142,"sourceSize":99,"sourcePath":"Network/18. HTTP.md","exportPath":"network/18.-http.html","showInTree":true,"treeOrder":379,"backlinks":[],"type":"markdown","data":null},"opencv/video-capture.html":{"createdTime":1742132450645,"modifiedTime":1742132450645,"sourceSize":7590,"sourcePath":"opencv/Video Capture.md","exportPath":"opencv/video-capture.html","showInTree":true,"treeOrder":381,"backlinks":[],"type":"markdown","data":null},"physics/physx.html":{"createdTime":1733748900822,"modifiedTime":1735554755753,"sourceSize":8288,"sourcePath":"physics/physX.md","exportPath":"physics/physx.html","showInTree":true,"treeOrder":383,"backlinks":[],"type":"markdown","data":null},"physics/untitled.html":{"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":333,"sourcePath":"physics/Untitled.md","exportPath":"physics/untitled.html","showInTree":true,"treeOrder":384,"backlinks":[],"type":"markdown","data":null},"qt/opengl/opengl-sphere-그리기.html":{"createdTime":1743691206980,"modifiedTime":1743691206980,"sourceSize":8113,"sourcePath":"Qt/opengl/OpenGL Sphere 그리기.md","exportPath":"qt/opengl/opengl-sphere-그리기.html","showInTree":true,"treeOrder":387,"backlinks":[],"type":"markdown","data":null},"qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html":{"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":3313,"sourcePath":"Qt/opengl/OpenGL 인덱스 순서와 면 컬링 관계.md","exportPath":"qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html","showInTree":true,"treeOrder":388,"backlinks":[],"type":"markdown","data":null},"qt/opengl/qt-opengl-in-macos.html":{"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":1452,"sourcePath":"Qt/opengl/Qt OpenGL in macOS.md","exportPath":"qt/opengl/qt-opengl-in-macos.html","showInTree":true,"treeOrder":389,"backlinks":[],"type":"markdown","data":null},"qt/opengl/qt-opengl-코드.html":{"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":7066,"sourcePath":"Qt/opengl/Qt OpenGL 코드.md","exportPath":"qt/opengl/qt-opengl-코드.html","showInTree":true,"treeOrder":390,"backlinks":[],"type":"markdown","data":null},"qt/qt-quick-3d-기본-개념-정리.html":{"createdTime":1743691206980,"modifiedTime":1743691206980,"sourceSize":5503,"sourcePath":"Qt/Qt Quick 3D - 기본 개념 정리.md","exportPath":"qt/qt-quick-3d-기본-개념-정리.html","showInTree":true,"treeOrder":391,"backlinks":[],"type":"markdown","data":null},"qt/자주-사용하는-단축키.html":{"createdTime":1748530578248,"modifiedTime":1748530578248,"sourceSize":1431,"sourcePath":"Qt/자주 사용하는 단축키.md","exportPath":"qt/자주-사용하는-단축키.html","showInTree":true,"treeOrder":392,"backlinks":[],"type":"markdown","data":null},"robotics/ros-2-핵심-통신-개념.html":{"createdTime":1748530578256,"modifiedTime":1748530578256,"sourceSize":3807,"sourcePath":"robotics/ROS 2 핵심 통신 개념.md","exportPath":"robotics/ros-2-핵심-통신-개념.html","showInTree":true,"treeOrder":394,"backlinks":[],"type":"markdown","data":null},"robotics/ros2-명령어.html":{"createdTime":1741189701478,"modifiedTime":1741189701478,"sourceSize":228,"sourcePath":"robotics/ros2 명령어.md","exportPath":"robotics/ros2-명령어.html","showInTree":true,"treeOrder":395,"backlinks":[],"type":"markdown","data":null},"rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html":{"createdTime":1735623775678,"modifiedTime":1735623798130,"sourceSize":3672,"sourcePath":"rust/asdf를 이용한 Rust 설치와 IntelliJ가 Path를 못 찾는 이슈 및 해결.md","exportPath":"rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html","showInTree":true,"treeOrder":397,"backlinks":[],"type":"markdown","data":null},"rust/cargo.html":{"createdTime":1735623817216,"modifiedTime":1735623822420,"sourceSize":1533,"sourcePath":"rust/Cargo.md","exportPath":"rust/cargo.html","showInTree":true,"treeOrder":398,"backlinks":[],"type":"markdown","data":null},"rust/rust-기초-control,-연습-문제.html":{"createdTime":1735623896644,"modifiedTime":1735623917039,"sourceSize":5206,"sourcePath":"rust/Rust 기초 - Control, 연습 문제.md","exportPath":"rust/rust-기초-control,-연습-문제.html","showInTree":true,"treeOrder":399,"backlinks":[],"type":"markdown","data":null},"rust/rust-기초-data-type.html":{"createdTime":1735623842533,"modifiedTime":1735623866268,"sourceSize":3126,"sourcePath":"rust/Rust 기초 - Data Type.md","exportPath":"rust/rust-기초-data-type.html","showInTree":true,"treeOrder":400,"backlinks":[],"type":"markdown","data":null},"rust/rust-기초-function.html":{"createdTime":1735623877030,"modifiedTime":1735623892347,"sourceSize":3155,"sourcePath":"rust/Rust 기초 - Function.md","exportPath":"rust/rust-기초-function.html","showInTree":true,"treeOrder":401,"backlinks":[],"type":"markdown","data":null},"rust/rust-기초-variable.html":{"createdTime":1735623825170,"modifiedTime":1735623841631,"sourceSize":2351,"sourcePath":"rust/Rust 기초 - Variable.md","exportPath":"rust/rust-기초-variable.html","showInTree":true,"treeOrder":402,"backlinks":[],"type":"markdown","data":null},"rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html":{"createdTime":1735624011804,"modifiedTime":1735624026451,"sourceSize":10040,"sourcePath":"rust/Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵).md","exportPath":"rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html","showInTree":true,"treeOrder":403,"backlinks":[],"type":"markdown","data":null},"tip/git.html":{"createdTime":1737289663889,"modifiedTime":1737289772479,"sourceSize":585,"sourcePath":"Tip/Git.md","exportPath":"tip/git.html","showInTree":true,"treeOrder":405,"backlinks":[],"type":"markdown","data":null},"tip/linux-명령어.html":{"createdTime":1739539459930,"modifiedTime":1739539459931,"sourceSize":2456,"sourcePath":"Tip/Linux 명령어.md","exportPath":"tip/linux-명령어.html","showInTree":true,"treeOrder":406,"backlinks":[],"type":"markdown","data":null},"tip/mcp-setting.html":{"createdTime":1743691206981,"modifiedTime":1743691206981,"sourceSize":1996,"sourcePath":"Tip/MCP Setting.md","exportPath":"tip/mcp-setting.html","showInTree":true,"treeOrder":407,"backlinks":[],"type":"markdown","data":null},"tip/tip.html":{"createdTime":1739539459931,"modifiedTime":1739539459931,"sourceSize":445,"sourcePath":"Tip/Tip.md","exportPath":"tip/tip.html","showInTree":true,"treeOrder":408,"backlinks":[],"type":"markdown","data":null},"tip/vscode-clang++-설정.html":{"createdTime":1739065650848,"modifiedTime":1739115423857,"sourceSize":2080,"sourcePath":"Tip/vscode clang++ 설정.md","exportPath":"tip/vscode-clang++-설정.html","showInTree":true,"treeOrder":409,"backlinks":[],"type":"markdown","data":null},"tip/비트-다루기.html":{"createdTime":1735623937724,"modifiedTime":1735623984477,"sourceSize":4746,"sourcePath":"Tip/비트 다루기.md","exportPath":"tip/비트-다루기.html","showInTree":true,"treeOrder":410,"backlinks":[],"type":"markdown","data":null},"tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html":{"createdTime":1735622526976,"modifiedTime":1737704262981,"sourceSize":2863,"sourcePath":"Tip/터미널 명령어로 원하는 .gitignore를 빠르게 생성하기.md","exportPath":"tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html","showInTree":true,"treeOrder":411,"backlinks":[],"type":"markdown","data":null},"ue/network-프레임워크/02.html":{"createdTime":1724571717963,"modifiedTime":1724571717963,"sourceSize":1541,"sourcePath":"UE/Network 프레임워크/02.md","exportPath":"ue/network-프레임워크/02.html","showInTree":true,"treeOrder":414,"backlinks":[],"type":"markdown","data":null},"ue/network-프레임워크/03.-커넥션과-오너십.html":{"createdTime":1724571717963,"modifiedTime":1724571717963,"sourceSize":6112,"sourcePath":"UE/Network 프레임워크/03. 커넥션과 오너십.md","exportPath":"ue/network-프레임워크/03.-커넥션과-오너십.html","showInTree":true,"treeOrder":415,"backlinks":[],"type":"markdown","data":null},"ue/agde와-ue연동.html":{"createdTime":1735579487357,"modifiedTime":1735579487358,"sourceSize":583,"sourcePath":"UE/AGDE와 UE연동.md","exportPath":"ue/agde와-ue연동.html","showInTree":true,"treeOrder":416,"backlinks":[],"type":"markdown","data":null},"ue/audio_stream_caching.html":{"createdTime":1730808631672,"modifiedTime":1730808631672,"sourceSize":5142,"sourcePath":"UE/Audio_Stream_caching.md","exportPath":"ue/audio_stream_caching.html","showInTree":true,"treeOrder":417,"backlinks":[],"type":"markdown","data":null},"ue/blendspace와-blendspace1d-차이점.html":{"createdTime":1735577788845,"modifiedTime":1735577922469,"sourceSize":1015,"sourcePath":"UE/BlendSpace와 BlendSpace1D 차이점.md","exportPath":"ue/blendspace와-blendspace1d-차이점.html","showInTree":true,"treeOrder":418,"backlinks":[],"type":"markdown","data":null},"ue/bool-vs-uint8.html":{"createdTime":1714816620141,"modifiedTime":1714816620141,"sourceSize":4061,"sourcePath":"UE/bool vs uint8.md","exportPath":"ue/bool-vs-uint8.html","showInTree":true,"treeOrder":419,"backlinks":[],"type":"markdown","data":null},"ue/build-system.html":{"createdTime":1710855209753,"modifiedTime":1710855209753,"sourceSize":983,"sourcePath":"UE/Build System.md","exportPath":"ue/build-system.html","showInTree":true,"treeOrder":420,"backlinks":[],"type":"markdown","data":null},"ue/console_command-등록-하는-법.html":{"createdTime":1724571717953,"modifiedTime":1735556217232,"sourceSize":14893,"sourcePath":"UE/Console_Command 등록 하는 법.md","exportPath":"ue/console_command-등록-하는-법.html","showInTree":true,"treeOrder":421,"backlinks":[],"type":"markdown","data":null},"ue/content-cooking-&-pak-&-chunk.html":{"createdTime":1722664940150,"modifiedTime":1735572667627,"sourceSize":3375,"sourcePath":"UE/Content Cooking & pak & chunk.md","exportPath":"ue/content-cooking-&-pak-&-chunk.html","showInTree":true,"treeOrder":422,"backlinks":[],"type":"markdown","data":null},"ue/datatable_asset_ref.html":{"createdTime":1724571717953,"modifiedTime":1735572709375,"sourceSize":1370,"sourcePath":"UE/DataTable_Asset_Ref.md","exportPath":"ue/datatable_asset_ref.html","showInTree":true,"treeOrder":423,"backlinks":[],"type":"markdown","data":null},"ue/enum-vs-enum-class.html":{"createdTime":1714816620141,"modifiedTime":1714816620141,"sourceSize":2014,"sourcePath":"UE/enum vs enum class.md","exportPath":"ue/enum-vs-enum-class.html","showInTree":true,"treeOrder":424,"backlinks":[],"type":"markdown","data":null},"ue/etriggerevent.html":{"createdTime":1735577794835,"modifiedTime":1735577939666,"sourceSize":2687,"sourcePath":"UE/ETriggerEvent.md","exportPath":"ue/etriggerevent.html","showInTree":true,"treeOrder":425,"backlinks":[],"type":"markdown","data":null},"ue/fgenricerror.html":{"createdTime":1732431190260,"modifiedTime":1737703718711,"sourceSize":11451,"sourcePath":"UE/FGenricError.md","exportPath":"ue/fgenricerror.html","showInTree":true,"treeOrder":426,"backlinks":[],"type":"markdown","data":null},"ue/fiosview-inserttext-objc_msgsend.html":{"createdTime":1719838659337,"modifiedTime":1737703376388,"sourceSize":3274,"sourcePath":"UE/FIOSView insertText - objc_msgSend.md","exportPath":"ue/fiosview-inserttext-objc_msgsend.html","showInTree":true,"treeOrder":427,"backlinks":[],"type":"markdown","data":null},"ue/ftp-manager.html":{"createdTime":1730808631709,"modifiedTime":1735577208142,"sourceSize":2834,"sourcePath":"UE/FTP Manager.md","exportPath":"ue/ftp-manager.html","showInTree":true,"treeOrder":428,"backlinks":[],"type":"markdown","data":null},"ue/get_audiotrackinfo_umg.html":{"createdTime":1724571717953,"modifiedTime":1735572789648,"sourceSize":2396,"sourcePath":"UE/Get_AudioTrackInfo_UMG.md","exportPath":"ue/get_audiotrackinfo_umg.html","showInTree":true,"treeOrder":429,"backlinks":[],"type":"markdown","data":null},"ue/insight.html":{"createdTime":1724571717956,"modifiedTime":1735572951591,"sourceSize":4583,"sourcePath":"UE/insight.md","exportPath":"ue/insight.html","showInTree":true,"treeOrder":430,"backlinks":[],"type":"markdown","data":null},"ue/invalidation-box.html":{"createdTime":1718198160527,"modifiedTime":1718198160527,"sourceSize":2383,"sourcePath":"UE/Invalidation Box.md","exportPath":"ue/invalidation-box.html","showInTree":true,"treeOrder":431,"backlinks":[],"type":"markdown","data":null},"ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html":{"createdTime":1710855209772,"modifiedTime":1710855209772,"sourceSize":5037,"sourcePath":"UE/Mac에서 UE4 엔진 소스 빌드 시 유의사항.md","exportPath":"ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html","showInTree":true,"treeOrder":432,"backlinks":[],"type":"markdown","data":null},"ue/media-framework.html":{"createdTime":1730808631672,"modifiedTime":1735573061236,"sourceSize":1153,"sourcePath":"UE/Media Framework.md","exportPath":"ue/media-framework.html","showInTree":true,"treeOrder":433,"backlinks":[],"type":"markdown","data":null},"ue/navigation-system.html":{"createdTime":1710855209758,"modifiedTime":1710855209758,"sourceSize":1096,"sourcePath":"UE/Navigation System.md","exportPath":"ue/navigation-system.html","showInTree":true,"treeOrder":434,"backlinks":[],"type":"markdown","data":null},"ue/physx-ios-빌드.html":{"createdTime":1710855209757,"modifiedTime":1710855209758,"sourceSize":1122,"sourcePath":"UE/PhysX iOS 빌드.md","exportPath":"ue/physx-ios-빌드.html","showInTree":true,"treeOrder":435,"backlinks":[],"type":"markdown","data":null},"ue/pso-(pipeline-state-object)-수집.html":{"createdTime":1724571717955,"modifiedTime":1735573258521,"sourceSize":5453,"sourcePath":"UE/PSO (Pipeline State Object) 수집.md","exportPath":"ue/pso-(pipeline-state-object)-수집.html","showInTree":true,"treeOrder":436,"backlinks":[],"type":"markdown","data":null},"ue/slate-architecture.html":{"createdTime":1710855209758,"modifiedTime":1737703993282,"sourceSize":14084,"sourcePath":"UE/Slate Architecture.md","exportPath":"ue/slate-architecture.html","showInTree":true,"treeOrder":437,"backlinks":[],"type":"markdown","data":null},"ue/slate-overview.html":{"createdTime":1710855209759,"modifiedTime":1710855209759,"sourceSize":5632,"sourcePath":"UE/Slate Overview.md","exportPath":"ue/slate-overview.html","showInTree":true,"treeOrder":438,"backlinks":[],"type":"markdown","data":null},"ue/slate-widget-examples.html":{"createdTime":1710855209759,"modifiedTime":1710855209759,"sourceSize":3391,"sourcePath":"UE/Slate Widget Examples.md","exportPath":"ue/slate-widget-examples.html","showInTree":true,"treeOrder":439,"backlinks":[],"type":"markdown","data":null},"ue/sounds-개념.html":{"createdTime":1719838659338,"modifiedTime":1735573278386,"sourceSize":4954,"sourcePath":"UE/Sounds 개념.md","exportPath":"ue/sounds-개념.html","showInTree":true,"treeOrder":440,"backlinks":[],"type":"markdown","data":null},"ue/sounds-개선.html":{"createdTime":1730808631709,"modifiedTime":1735576991430,"sourceSize":7892,"sourcePath":"UE/Sounds 개선.md","exportPath":"ue/sounds-개선.html","showInTree":true,"treeOrder":441,"backlinks":[],"type":"markdown","data":null},"ue/ue4-source-ios-debugging-on-macos.html":{"createdTime":1710855209758,"modifiedTime":1735573377567,"sourceSize":8053,"sourcePath":"UE/UE4 Source iOS Debugging on MacOS.md","exportPath":"ue/ue4-source-ios-debugging-on-macos.html","showInTree":true,"treeOrder":442,"backlinks":[],"type":"markdown","data":null},"ue/ue4.27-ios-background-앱-크래쉬.html":{"createdTime":1710855209758,"modifiedTime":1737703695333,"sourceSize":2189,"sourcePath":"UE/UE4.27 iOS Background 앱 크래쉬.md","exportPath":"ue/ue4.27-ios-background-앱-크래쉬.html","showInTree":true,"treeOrder":443,"backlinks":[],"type":"markdown","data":null},"ue/ugameplaystatics.html":{"createdTime":1724571717955,"modifiedTime":1724571717956,"sourceSize":1796,"sourcePath":"UE/UGameplayStatics.md","exportPath":"ue/ugameplaystatics.html","showInTree":true,"treeOrder":444,"backlinks":[],"type":"markdown","data":null},"ue/ui-애니메이션.html":{"createdTime":1724571717940,"modifiedTime":1724571717940,"sourceSize":4184,"sourcePath":"UE/UI 애니메이션.md","exportPath":"ue/ui-애니메이션.html","showInTree":true,"treeOrder":445,"backlinks":[],"type":"markdown","data":null},"ue/umg-클래스에-delegate-추가하기.html":{"createdTime":1724571717956,"modifiedTime":1724571717956,"sourceSize":2618,"sourcePath":"UE/UMG 클래스에 Delegate 추가하기.md","exportPath":"ue/umg-클래스에-delegate-추가하기.html","showInTree":true,"treeOrder":446,"backlinks":[],"type":"markdown","data":null},"ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html":{"createdTime":1710855209758,"modifiedTime":1710855209758,"sourceSize":3335,"sourcePath":"UE/Unreal Engine만의 기본 타입이 있는 이유와 문자열.md","exportPath":"ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html","showInTree":true,"treeOrder":447,"backlinks":[],"type":"markdown","data":null},"ue/upl.html":{"createdTime":1751291017365,"modifiedTime":1751291017365,"sourceSize":1078,"sourcePath":"UE/UPL.md","exportPath":"ue/upl.html","showInTree":true,"treeOrder":448,"backlinks":[],"type":"markdown","data":null},"ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html":{"createdTime":1735577795303,"modifiedTime":1735577949194,"sourceSize":644,"sourcePath":"UE/내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유.md","exportPath":"ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html","showInTree":true,"treeOrder":449,"backlinks":[],"type":"markdown","data":null},"ue/아틀라스.html":{"createdTime":1710855209758,"modifiedTime":1710855209758,"sourceSize":4880,"sourcePath":"UE/아틀라스.md","exportPath":"ue/아틀라스.html","showInTree":true,"treeOrder":450,"backlinks":[],"type":"markdown","data":null},"ue/언리얼-패키징-관련-error.html":{"createdTime":1710855209771,"modifiedTime":1737703706174,"sourceSize":366,"sourcePath":"UE/언리얼 패키징 관련 Error.md","exportPath":"ue/언리얼-패키징-관련-error.html","showInTree":true,"treeOrder":451,"backlinks":[],"type":"markdown","data":null},"ue/언리얼엔진에서의-lamda.html":{"createdTime":1730808631672,"modifiedTime":1730808631672,"sourceSize":1761,"sourcePath":"UE/언리얼엔진에서의 Lamda.md","exportPath":"ue/언리얼엔진에서의-lamda.html","showInTree":true,"treeOrder":452,"backlinks":[],"type":"markdown","data":null},"ue/월드의-생명주기.html":{"createdTime":1735577697889,"modifiedTime":1735577892795,"sourceSize":653,"sourcePath":"UE/월드의 생명주기.md","exportPath":"ue/월드의-생명주기.html","showInTree":true,"treeOrder":453,"backlinks":[],"type":"markdown","data":null},"unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html":{"createdTime":1735624171800,"modifiedTime":1735624345928,"sourceSize":6670,"sourcePath":"Unity/13. Clear Counter - RayCast로 객체와 인터렉트하기.md","exportPath":"unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html","showInTree":true,"treeOrder":455,"backlinks":[],"type":"markdown","data":null},"unity/14.-interact-action-events.html":{"createdTime":1735624192302,"modifiedTime":1735624336039,"sourceSize":2889,"sourcePath":"Unity/14. Interact Action Events.md","exportPath":"unity/14.-interact-action-events.html","showInTree":true,"treeOrder":456,"backlinks":[],"type":"markdown","data":null},"unity/15.-selected-counter-visual-&-singleton-pattern.html":{"createdTime":1735624219304,"modifiedTime":1735624324140,"sourceSize":4509,"sourcePath":"Unity/15. Selected Counter Visual & Singleton Pattern.md","exportPath":"unity/15.-selected-counter-visual-&-singleton-pattern.html","showInTree":true,"treeOrder":457,"backlinks":[],"type":"markdown","data":null},"unity/16.-kitchen-object,-scriptable-object.html":{"createdTime":1735624243948,"modifiedTime":1735624313608,"sourceSize":3759,"sourcePath":"Unity/16. Kitchen Object, Scriptable Object.md","exportPath":"unity/16.-kitchen-object,-scriptable-object.html","showInTree":true,"treeOrder":458,"backlinks":[],"type":"markdown","data":null},"unity/17.-kitchen-object-parent.html":{"createdTime":1735624260478,"modifiedTime":1735624296954,"sourceSize":3143,"sourcePath":"Unity/17. Kitchen Object Parent.md","exportPath":"unity/17.-kitchen-object-parent.html","showInTree":true,"treeOrder":459,"backlinks":[],"type":"markdown","data":null},"unity/18.-player-pick-up,-csharp-interfaces.html":{"createdTime":1735624355849,"modifiedTime":1735624382465,"sourceSize":8681,"sourcePath":"Unity/18. Player Pick up, CSharp Interfaces.md","exportPath":"unity/18.-player-pick-up,-csharp-interfaces.html","showInTree":true,"treeOrder":460,"backlinks":[],"type":"markdown","data":null},"unity/19.-container-counter와-상속.html":{"createdTime":1735624385587,"modifiedTime":1735624437645,"sourceSize":7975,"sourcePath":"Unity/19. Container Counter와 상속.md","exportPath":"unity/19.-container-counter와-상속.html","showInTree":true,"treeOrder":461,"backlinks":[],"type":"markdown","data":null},"unity/20.-player-pick-up-&-drop-object.html":{"createdTime":1735624439475,"modifiedTime":1735624454574,"sourceSize":2284,"sourcePath":"Unity/20. Player Pick Up & Drop Object.md","exportPath":"unity/20.-player-pick-up-&-drop-object.html","showInTree":true,"treeOrder":462,"backlinks":[],"type":"markdown","data":null},"unity/21.-cutting-counter,-interact-alternate.html":{"createdTime":1735624455452,"modifiedTime":1735624505445,"sourceSize":8776,"sourcePath":"Unity/21. Cutting Counter, Interact Alternate.md","exportPath":"unity/21.-cutting-counter,-interact-alternate.html","showInTree":true,"treeOrder":463,"backlinks":[],"type":"markdown","data":null},"unity/22.-cutting-recipe-so.html":{"createdTime":1735624508093,"modifiedTime":1735624548480,"sourceSize":4347,"sourcePath":"Unity/22. Cutting Recipe SO.md","exportPath":"unity/22.-cutting-recipe-so.html","showInTree":true,"treeOrder":464,"backlinks":[],"type":"markdown","data":null},"unity/23.-cutting-progress,-world-canvas.html":{"createdTime":1735624550856,"modifiedTime":1735624598026,"sourceSize":9381,"sourcePath":"Unity/23. Cutting Progress, World Canvas.md","exportPath":"unity/23.-cutting-progress,-world-canvas.html","showInTree":true,"treeOrder":465,"backlinks":[],"type":"markdown","data":null},"unity/24.-look-at-camera.html":{"createdTime":1735624602402,"modifiedTime":1735624619309,"sourceSize":2149,"sourcePath":"Unity/24. Look At Camera.md","exportPath":"unity/24.-look-at-camera.html","showInTree":true,"treeOrder":466,"backlinks":[],"type":"markdown","data":null},"unity/25.-trash-counter.html":{"createdTime":1735624621210,"modifiedTime":1735624638757,"sourceSize":1082,"sourcePath":"Unity/25. Trash Counter.md","exportPath":"unity/25.-trash-counter.html","showInTree":true,"treeOrder":467,"backlinks":[],"type":"markdown","data":null},"unity/26.-stove-counter.html":{"createdTime":1735624640157,"modifiedTime":1735624693345,"sourceSize":23592,"sourcePath":"Unity/26. Stove Counter.md","exportPath":"unity/26.-stove-counter.html","showInTree":true,"treeOrder":468,"backlinks":[],"type":"markdown","data":null},"unity/27.-plates-counter.html":{"createdTime":1735624706370,"modifiedTime":1735624741552,"sourceSize":7704,"sourcePath":"Unity/27. Plates Counter.md","exportPath":"unity/27.-plates-counter.html","showInTree":true,"treeOrder":469,"backlinks":[],"type":"markdown","data":null},"unity/28.-plate-pick-up-objects.html":{"createdTime":1735624742804,"modifiedTime":1735624803864,"sourceSize":21003,"sourcePath":"Unity/28. Plate Pick up Objects.md","exportPath":"unity/28.-plate-pick-up-objects.html","showInTree":true,"treeOrder":470,"backlinks":[],"type":"markdown","data":null},"unity/glow-effect-만들기.html":{"createdTime":1735624104412,"modifiedTime":1735624119471,"sourceSize":3650,"sourcePath":"Unity/Glow Effect 만들기.md","exportPath":"unity/glow-effect-만들기.html","showInTree":true,"treeOrder":471,"backlinks":[],"type":"markdown","data":null},"unity/캐릭터-움직임과-time.deltatime.html":{"createdTime":1735624132830,"modifiedTime":1735624168427,"sourceSize":6707,"sourcePath":"Unity/캐릭터 움직임과 Time.deltaTime.md","exportPath":"unity/캐릭터-움직임과-time.deltatime.html","showInTree":true,"treeOrder":472,"backlinks":[],"type":"markdown","data":null},"index.html":{"createdTime":1742132448496,"modifiedTime":1750251890936,"sourceSize":3922,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":473,"backlinks":[],"type":"markdown","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1754545597793,"modifiedTime":1754545597793,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1754545597793,"modifiedTime":1754545597793,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1754545597794,"modifiedTime":1754545597794,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1754545597793,"modifiedTime":1754545597793,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1754545597794,"modifiedTime":1754545597794,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1754545597794,"modifiedTime":1754545597794,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1754545597794,"modifiedTime":1754545597794,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1754545597794,"modifiedTime":1754545597794,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1754545597796,"modifiedTime":1754545597796,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1754545597796,"modifiedTime":1754545597796,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1754545597794,"modifiedTime":1754545597794,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1754545597796,"modifiedTime":1754545597796,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1754545597780,"modifiedTime":1754545597780,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1754545597780,"modifiedTime":1754545597780,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1754545597781,"modifiedTime":1754545597781,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1754545599989,"modifiedTime":1754545599989,"sourceSize":179169,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1754444152503,"modifiedTime":1754444152503,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1754545597695,"modifiedTime":1754545597695,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/obsidian.css":{"createdTime":1754545597827,"modifiedTime":1754545597827,"sourceSize":163819,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/other-plugins.css":{"createdTime":1754444152744,"modifiedTime":1754444152744,"sourceSize":2914,"sourcePath":"","exportPath":"site-lib/styles/other-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/theme.css":{"createdTime":1754444152632,"modifiedTime":1754444152632,"sourceSize":177039,"sourcePath":"","exportPath":"site-lib/styles/theme.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1754545597753,"modifiedTime":1754545597753,"sourceSize":380,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1754545597783,"modifiedTime":1754545597783,"sourceSize":1928,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1754444152522,"modifiedTime":1754444152522,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/rss.xml":{"createdTime":1754545685506,"modifiedTime":1754545685506,"sourceSize":20326,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null}},"sourceToTarget":{"Algorithm/Lecture/BFS.md":"algorithm/lecture/bfs.html","Algorithm/Lecture/DFS.md":"algorithm/lecture/dfs.html","Algorithm/Lecture/그리디 알고리즘.md":"algorithm/lecture/그리디-알고리즘.html","Algorithm/LeetCode/3. Longest Substring Without Repeating Characters.md":"algorithm/leetcode/3.-longest-substring-without-repeating-characters.html","Algorithm/LeetCode/21. Merge Two Sorted Lists.md":"algorithm/leetcode/21.-merge-two-sorted-lists.html","Algorithm/LeetCode/55. Jump Game.md":"algorithm/leetcode/55.-jump-game.html","Algorithm/LeetCode/62. Unique Paths.md":"algorithm/leetcode/62.-unique-paths.html","Algorithm/LeetCode/70. Climbing Stair.md":"algorithm/leetcode/70.-climbing-stair.html","Algorithm/LeetCode/78. Subsets.md":"algorithm/leetcode/78.-subsets.html","Algorithm/LeetCode/141. Linked List Cycle.md":"algorithm/leetcode/141.-linked-list-cycle.html","Algorithm/LeetCode/143. Reorder List.md":"algorithm/leetcode/143.-reorder-list.html","Algorithm/LeetCode/152. Maximum Product Subarray.md":"algorithm/leetcode/152.-maximum-product-subarray.html","Algorithm/LeetCode/198. House Robber.md":"algorithm/leetcode/198.-house-robber.html","Algorithm/LeetCode/200. Number of Islands.md":"algorithm/leetcode/200.-number-of-islands.html","Algorithm/LeetCode/206. Reverse Linked List.md":"algorithm/leetcode/206.-reverse-linked-list.html","Algorithm/LeetCode/217. Contains Duplicate.md":"algorithm/leetcode/217.-contains-duplicate.html","Algorithm/LeetCode/271. Encode and Decode Strings.md":"algorithm/leetcode/271.-encode-and-decode-strings.html","Algorithm/LeetCode/424. Longest Repeating Character Replacement.md":"algorithm/leetcode/424.-longest-repeating-character-replacement.html","Algorithm/LeetCode/3405. Count the Number of Arrays with K Matching Adjacent Elements.md":"algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html","Algorithm/Study/DP.md":"algorithm/study/dp.html","Algorithm/Study/Heap & 우선순위 큐.md":"algorithm/study/heap-&-우선순위-큐.html","Algorithm/Study/Two Pointer.md":"algorithm/study/two-pointer.html","Algorithm/Study/누적합 알고리즘.md":"algorithm/study/누적합-알고리즘.html","Algorithm/Study/문제유형.md":"algorithm/study/문제유형.html","Algorithm/Study/이분탐색 & 파라메트릭 서치.md":"algorithm/study/이분탐색-&-파라메트릭-서치.html","Algorithm/Study/코딩테스트를 위한 암기.md":"algorithm/study/코딩테스트를-위한-암기.html","Android/Wifi Util Class.md":"android/wifi-util-class.html","Android/인앱 결제.md":"android/인앱-결제.html","BLE/1. BLE 개요.md":"ble/1.-ble-개요.html","BLE/2. BLE 프로토콜 스택.md":"ble/2.-ble-프로토콜-스택.html","BLE/3. BLE ATT, GATT.md":"ble/3.-ble-att,-gatt.html","BLE/4. BLE 디바이스 연결.md":"ble/4.-ble-디바이스-연결.html","CPP/Basic/0. c, c++ 컴파일 과정.md":"cpp/basic/0.-c,-c++-컴파일-과정.html","CPP/Basic/1. 참조와 포인터.md":"cpp/basic/1.-참조와-포인터.html","CPP/Basic/2. 생성자.md":"cpp/basic/2.-생성자.html","CPP/Basic/3. Overloading.md":"cpp/basic/3.-overloading.html","CPP/Basic/4. 상속.md":"cpp/basic/4.-상속.html","CPP/Basic/5. 다중 상속.md":"cpp/basic/5.-다중-상속.html","CPP/Basic/6. 파일 입출력.md":"cpp/basic/6.-파일-입출력.html","CPP/Build System/CMake.md":"cpp/build-system/cmake.html","CPP/Build System/PIC.md":"cpp/build-system/pic.html","CPP/Concurrency/1. thread.md":"cpp/concurrency/1.-thread.html","CPP/Concurrency/2. Mutex, deadlock.md":"cpp/concurrency/2.-mutex,-deadlock.html","CPP/Concurrency/3. memory order, atomic.md":"cpp/concurrency/3.-memory-order,-atomic.html","CPP/Concurrency/4. future, async, promise.md":"cpp/concurrency/4.-future,-async,-promise.html","CPP/Concurrency/5. 비동기, promise & future, callback, async, ThreadPool.md":"cpp/concurrency/5.-비동기,-promise-&-future,-callback,-async,-threadpool.html","CPP/Concurrency/6. ThreadPool.md":"cpp/concurrency/6.-threadpool.html","CPP/Concurrency/7.  Event System.md":"cpp/concurrency/7.-event-system.html","CPP/etc/C++ static const 초기화.md":"cpp/etc/c++-static-const-초기화.html","CPP/etc/const 위치 헷갈리는 점 정리.md":"cpp/etc/const-위치-헷갈리는-점-정리.html","CPP/etc/RVO.md":"cpp/etc/rvo.html","CPP/etc/리소스 임베딩 by compile.md":"cpp/etc/리소스-임베딩-by-compile.html","CPP/etc/상속 생성자, 소멸자 헷갈리는 점.md":"cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html","CPP/etc/유리수 클래스 구현.md":"cpp/etc/유리수-클래스-구현.html","CPP/etc/전역변수와 정적변수의 공통점과 차이점.md":"cpp/etc/전역변수와-정적변수의-공통점과-차이점.html","CPP/Lib/fmt.md":"cpp/lib/fmt.html","CPP/Lib/Google Test.md":"cpp/lib/google-test.html","CPP/Modern/1. rvalue rvalue 참조.md":"cpp/modern/1.-rvalue-rvalue-참조.html","CPP/Modern/2. move, 레퍼런스 겹침 규칙.md":"cpp/modern/2.-move,-레퍼런스-겹침-규칙.html","CPP/Modern/3. RAII, unique ptr.md":"cpp/modern/3.-raii,-unique-ptr.html","CPP/Modern/4. shared, weak ptr.md":"cpp/modern/4.-shared,-weak-ptr.html","CPP/Modern/5. callable etc..md":"cpp/modern/5.-callable-etc..html","CPP/Modern/6. Uniform Initializer.md":"cpp/modern/6.-uniform-initializer.html","CPP/Modern/7. random, chrono library.md":"cpp/modern/7.-random,-chrono-library.html","CPP/Platform/C++ 프로젝트에서 JNI를 이용해서 Android 호출.md":"cpp/platform/c++-프로젝트에서-jni를-이용해서-android-호출.html","CPP/Platform/SFML과 Visitor Pattern.md":"cpp/platform/sfml과-visitor-pattern.html","CPP/Template/1. 명시적 템플릿 인스터스화.md":"cpp/template/1.-명시적-템플릿-인스터스화.html","CPP/Quiz.md":"cpp/quiz.html","CS/자료구조/AVL 트리.md":"cs/자료구조/avl-트리.html","CS/자료구조/B+ Tree.md":"cs/자료구조/b+-tree.html","CS/자료구조/Binary Search Tree.md":"cs/자료구조/binary-search-tree.html","CS/자료구조/Deque.md":"cs/자료구조/deque.html","CS/자료구조/Hash Table.md":"cs/자료구조/hash-table.html","CS/자료구조/Red Black Tree.md":"cs/자료구조/red-black-tree.html","CS/자료구조/Tree.md":"cs/자료구조/tree.html","CS/01. 배열과 연결리스트의 차이점과 각각의 시간복잡도.md":"cs/01.-배열과-연결리스트의-차이점과-각각의-시간복잡도.html","CS/05. 정렬 알고리즘들의 시간복잡도와 특징 (정리중.md":"cs/05.-정렬-알고리즘들의-시간복잡도와-특징-(정리중.html","CS/07. 캐시 지역성.md":"cs/07.-캐시-지역성.html","CS/08. 메모리 단편화.md":"cs/08.-메모리-단편화.html","CS/09. C++ 메모리 구조.md":"cs/09.-c++-메모리-구조.html","CS/10. 스택과 힙 메모리 특징과 차이점, 사용시기.md":"cs/10.-스택과-힙-메모리-특징과-차이점,-사용시기.html","CS/12.  new, delete와 malloc, free의 차이점.md":"cs/12.-new,-delete와-malloc,-free의-차이점.html","CS/13. 가상함수와 순수가상함수의 차이점과 vtable 동작원리.md":"cs/13.-가상함수와-순수가상함수의-차이점과-vtable-동작원리.html","CS/14. 상속 관계에서 생성자와 소멸자의 호출순서.md":"cs/14.-상속-관계에서-생성자와-소멸자의-호출순서.html","CS/15. 깊은 복사와 얕은 복사의 차이점과 구현 방법.md":"cs/15.-깊은-복사와-얕은-복사의-차이점과-구현-방법.html","CS/16. vector, list, deque의 차이점과 시간복잡도.md":"cs/16.-vector,-list,-deque의-차이점과-시간복잡도.html","CS/17. map, unordered_map, set, unordered_set의 차이점.md":"cs/17.-map,-unordered_map,-set,-unordered_set의-차이점.html","CS/18. priority_queue의 내부 구현과 사용법.md":"cs/18.-priority_queue의-내부-구현과-사용법.html","CS/20. map과 unordered_map 중 선택 기준.md":"cs/20.-map과-unordered_map-중-선택-기준.html","CS/21. 스마트 포인터 (unique_ptr, shared_ptr, weak_ptr).md":"cs/21.-스마트-포인터-(unique_ptr,-shared_ptr,-weak_ptr).html","CS/23. lvalue와 rvalue의 차이점.md":"cs/23.-lvalue와-rvalue의-차이점.html","CS/24. move constructor와 move assignment의 필요성.md":"cs/24.-move-constructor와-move-assignment의-필요성.html","CS/25. auto 키워드의 장단점.md":"cs/25.-auto-키워드의-장단점.html","CS/26. 람다함수의 캡처 방식들과 사용법.md":"cs/26.-람다함수의-캡처-방식들과-사용법.html","CS/28.  메모리 누수를 탐지하는 방법.md":"cs/28.-메모리-누수를-탐지하는-방법.html","CS/29. 스레드와 프로세스의 차이점.md":"cs/29.-스레드와-프로세스의-차이점.html","CS/30.  C++에서 스레드 동기화 방법들.md":"cs/30.-c++에서-스레드-동기화-방법들.html","CS/31. 뮤텍스와 세마포어의 차이점.md":"cs/31.-뮤텍스와-세마포어의-차이점.html","CS/33. 레이스 컨디션에 대해 설명해주세요.md":"cs/33.-레이스-컨디션에-대해-설명해주세요.html","CS/34. 포인터와 참조의 차이점.md":"cs/34.-포인터와-참조의-차이점.html","CS/35. 가상 메모리는 무엇인가.md":"cs/35.-가상-메모리는-무엇인가.html","CS/36. static 키워드.md":"cs/36.-static-키워드.html","CS/Context Switching.md":"cs/context-switching.html","CS/Deadlock.md":"cs/deadlock.html","CS/Floating Point.md":"cs/floating-point.html","CS/Pseudo random (의사 난수).md":"cs/pseudo-random-(의사-난수).html","CS/리틀 앤디언과 빅 앤디언.md":"cs/리틀-앤디언과-빅-앤디언.html","CS/캐시 전략.md":"cs/캐시-전략.html","csharp/LINQ.md":"csharp/linq.html","docker/1. basic.md":"docker/1.-basic.html","docker/2. 도커 컨테이너 환경 구축.md":"docker/2.-도커-컨테이너-환경-구축.html","flutter/0. setup.md":"flutter/0.-setup.html","flutter/Animation.md":"flutter/animation.html","flutter/AppBar.md":"flutter/appbar.html","flutter/Build Context.md":"flutter/build-context.html","flutter/GridView.md":"flutter/gridview.html","flutter/Scaffold vs Builder.md":"flutter/scaffold-vs-builder.html","flutter/StatefulWidget 생명주기.md":"flutter/statefulwidget-생명주기.html","flutter/TickerProviderStateMixin.md":"flutter/tickerproviderstatemixin.html","graphics/etc/Golf Simulator using SFML.md":"graphics/etc/golf-simulator-using-sfml.html","graphics/etc/SFML.md":"graphics/etc/sfml.html","graphics/metal/0. Metal Basic.md":"graphics/metal/0.-metal-basic.html","graphics/metal/Depth buffer.md":"graphics/metal/depth-buffer.html","graphics/metal/Metal Rendering pipeline.md":"graphics/metal/metal-rendering-pipeline.html","graphics/metal/Shadow Map.md":"graphics/metal/shadow-map.html","graphics/metal/Uniform Buffer.md":"graphics/metal/uniform-buffer.html","graphics/opengl/01.기본/01. 기본.md":"graphics/opengl/01.기본/01.-기본.html","graphics/opengl/01.기본/02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용.md":"graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html","graphics/opengl/01.기본/03. 콜백함수와 컬러 기초 이론 - Callback 함수.md":"graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html","graphics/opengl/01.기본/04. 컬러 기초이론.md":"graphics/opengl/01.기본/04.-컬러-기초이론.html","graphics/opengl/01.기본/05. 컬러 이미지 저장 방식.md":"graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html","graphics/opengl/01.기본/06. RGBA 컬러 모델.md":"graphics/opengl/01.기본/06.-rgba-컬러-모델.html","graphics/opengl/02.응용/01. 그래픽스 파이프라인.md":"graphics/opengl/02.응용/01.-그래픽스-파이프라인.html","graphics/opengl/02.응용/02. 프로그래머블 그래픽스 파이프라인.md":"graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html","graphics/opengl/02.응용/03. GPU 내부 구조.md":"graphics/opengl/02.응용/03.-gpu-내부-구조.html","graphics/opengl/02.응용/04. GLSL.md":"graphics/opengl/02.응용/04.-glsl.html","graphics/opengl/02.응용/05. Shader Programming 코드 분석.md":"graphics/opengl/02.응용/05.-shader-programming-코드-분석.html","graphics/opengl/02.응용/06. 재사용가능한 코드.md":"graphics/opengl/02.응용/06.-재사용가능한-코드.html","graphics/opengl/02.응용/07. GLSL 자료형.md":"graphics/opengl/02.응용/07.-glsl-자료형.html","graphics/opengl/02.응용/08. Uniform Variable.md":"graphics/opengl/02.응용/08.-uniform-variable.html","graphics/opengl/02.응용/09. GLSL 디버그 함수들.md":"graphics/opengl/02.응용/09.-glsl-디버그-함수들.html","graphics/opengl/02.응용/10. OpenGL 깊이 버퍼와 렌더링 순서.md":"graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html","graphics/Rasterizer/0. 목표에 대해서.md":"graphics/rasterizer/0.-목표에-대해서.html","graphics/Rasterizer/1. 브레젠험 직선 알고리즘.md":"graphics/rasterizer/1.-브레젠험-직선-알고리즘.html","graphics/Unreal Engine/Basic.md":"graphics/unreal-engine/basic.html","graphics/Unreal Engine/Material.md":"graphics/unreal-engine/material.html","graphics/Unreal Engine/Rim Light와 Fresnel 노드.md":"graphics/unreal-engine/rim-light와-fresnel-노드.html","graphics/이론/Modeling.md":"graphics/이론/modeling.html","graphics/이론/Phong vs Blinn-Phong 셰이딩 모델.md":"graphics/이론/phong-vs-blinn-phong-셰이딩-모델.html","graphics/이론/VSync (수직 동기화).md":"graphics/이론/vsync-(수직-동기화).html","graphics/이론/동차 좌표계와 원근 분할.md":"graphics/이론/동차-좌표계와-원근-분할.html","graphics/이론/렌더링 파이프라인 이론.md":"graphics/이론/렌더링-파이프라인-이론.html","graphics/이론/변환행렬.md":"graphics/이론/변환행렬.html","graphics/이론/컴퓨터 그래픽스 기초와 수학.md":"graphics/이론/컴퓨터-그래픽스-기초와-수학.html","Hose/Develop.md":"hose/develop.html","Hose/내가 블로그를 시작한 이유.md":"hose/내가-블로그를-시작한-이유.html","images/3colorchannel.png":"images/3colorchannel.html","images/aggregate.png":"images/aggregate.html","images/allpublic.png":"images/allpublic.html","images/BFS_1.png":"images/bfs_1.html","images/BFS_2.png":"images/bfs_2.html","images/bi_linear_interpolation.png":"images/bi_linear_interpolation.html","images/ble_configuration.png":"images/ble_configuration.html","images/ble_host_controller.png":"images/ble_host_controller.html","images/ble-attribute-table.png":"images/ble-attribute-table.html","images/ble-conn-fig-1.png":"images/ble-conn-fig-1.html","images/ble-conn-fig-2.png":"images/ble-conn-fig-2.html","images/ble-conn-fig-3.png":"images/ble-conn-fig-3.html","images/ble-connection.png":"images/ble-connection.html","images/ble-connection 1.png":"images/ble-connection-1.html","images/ble-data-exchange.png":"images/ble-data-exchange.html","images/ble-gatt-structure.png":"images/ble-gatt-structure.html","images/ble-l2cap.png":"images/ble-l2cap.html","images/ble-link-layer.png":"images/ble-link-layer.html","images/Blendspace.png":"images/blendspace.html","images/bpgi_onbeginplay.png":"images/bpgi_onbeginplay.html","images/broadcastip_address.png":"images/broadcastip_address.html","images/build_process.png":"images/build_process.html","images/bw_grayscale.png":"images/bw_grayscale.html","images/change_scheme.png":"images/change_scheme.html","images/cmake_setting.png":"images/cmake_setting.html","images/cmy_model.png":"images/cmy_model.html","images/collectpso.png":"images/collectpso.html","images/color_image.png":"images/color_image.html","images/color_vs_grayscale.png":"images/color_vs_grayscale.html","images/Common_ui_plugin.png":"images/common_ui_plugin.html","images/compared_ext_trigger.png":"images/compared_ext_trigger.html","images/concurrent.png":"images/concurrent.html","images/cpp_1.png":"images/cpp_1.html","images/cpp_2.png":"images/cpp_2.html","images/cpp_3.png":"images/cpp_3.html","images/cpp_4.png":"images/cpp_4.html","images/cpp_5.png":"images/cpp_5.html","images/cpp_6.png":"images/cpp_6.html","images/cpp_7.png":"images/cpp_7.html","images/cpp_8.png":"images/cpp_8.html","images/cpp_9.png":"images/cpp_9.html","images/cpp_10.png":"images/cpp_10.html","images/cpp_11.png":"images/cpp_11.html","images/cpp_12.png":"images/cpp_12.html","images/cpp_13.png":"images/cpp_13.html","images/cpp_14.png":"images/cpp_14.html","images/cpp_memory_struct.png":"images/cpp_memory_struct.html","images/data_transfer_struct.png":"images/data_transfer_struct.html","images/datahandle_row_result.png":"images/datahandle_row_result.html","images/debugging_failure.png":"images/debugging_failure.html","images/debugging_success.png":"images/debugging_success.html","images/DFS_1.png":"images/dfs_1.html","images/DFS_2.png":"images/dfs_2.html","images/ebtnode_result_aborted.png":"images/ebtnode_result_aborted.html","images/ebtnode_result_failed.png":"images/ebtnode_result_failed.html","images/ebtnode_result_inprogress.png":"images/ebtnode_result_inprogress.html","images/ebtnode_result_type.png":"images/ebtnode_result_type.html","images/executable_file_structure.png":"images/executable_file_structure.html","images/export_shader_code.png":"images/export_shader_code.html","images/fatframework_path.png":"images/fatframework_path.html","images/foldering_as_is.png":"images/foldering_as_is.html","images/foldering_to_be.png":"images/foldering_to_be.html","images/fragment_shader.png":"images/fragment_shader.html","images/fragment_shader_execute.png":"images/fragment_shader_execute.html","images/framework_path.png":"images/framework_path.html","images/fresnel.png":"images/fresnel.html","images/func_1.png":"images/func_1.html","images/GameFlowChart.png":"images/gameflowchart.html","images/gl_error_flag.png":"images/gl_error_flag.html","images/glew32_install_error.png":"images/glew32_install_error.html","images/glsl_debugging_1.png":"images/glsl_debugging_1.html","images/glsl_debugging2.png":"images/glsl_debugging2.html","images/glVertexAttribPointer.png":"images/glvertexattribpointer.html","images/gpu_structure.png":"images/gpu_structure.html","images/graphic_pipeline.png":"images/graphic_pipeline.html","images/greedy_1.png":"images/greedy_1.html","images/greedy_2.png":"images/greedy_2.html","images/greedy_3.png":"images/greedy_3.html","images/greedy_4.png":"images/greedy_4.html","images/grey_to_color_using_ai.png":"images/grey_to_color_using_ai.html","images/hostapp_file.png":"images/hostapp_file.html","images/immutable_mutable.png":"images/immutable_mutable.html","images/inc_support.png":"images/inc_support.html","images/initializer_list_char.png":"images/initializer_list_char.html","images/insight_after.png":"images/insight_after.html","images/insight_before.png":"images/insight_before.html","images/ip4v_header.png":"images/ip4v_header.html","images/layout_qualifier.png":"images/layout_qualifier.html","images/linear_interpolation.png":"images/linear_interpolation.html","images/math_func.png":"images/math_func.html","images/matrix_row_prior.png":"images/matrix_row_prior.html","images/metal_rendering_pipeline.png":"images/metal_rendering_pipeline.html","images/NativizedAssets.png":"images/nativizedassets.html","images/Navigation.png":"images/navigation.html","images/object_file_header.png":"images/object_file_header.html","images/opengl_shader_program_process.png":"images/opengl_shader_program_process.html","images/packet.png":"images/packet.html","images/paralle_processing.png":"images/paralle_processing.html","images/primitive_assembly_rasterization.png":"images/primitive_assembly_rasterization.html","images/printf.png":"images/printf.html","images/prog_debugging.png":"images/prog_debugging.html","images/programmable_pipeline.png":"images/programmable_pipeline.html","images/pso.png":"images/pso.html","images/pso_data.png":"images/pso_data.html","images/rasterization_mean.png":"images/rasterization_mean.html","images/register_vec.png":"images/register_vec.html","images/removedinternal.png":"images/removedinternal.html","images/rgb_cmy_conversion.png":"images/rgb_cmy_conversion.html","images/rgb_color_model.png":"images/rgb_color_model.html","images/robot_maze.png":"images/robot_maze.html","images/sandbox_error.png":"images/sandbox_error.html","images/serial.png":"images/serial.html","images/shader_program_structure.png":"images/shader_program_structure.html","images/simulator_device_error.png":"images/simulator_device_error.html","images/SLATE_ARCITECTURE_1.png":"images/slate_arcitecture_1.html","images/SLATE_ARCITECTURE_2.png":"images/slate_arcitecture_2.html","images/SLATE_ARCITECTURE_3.png":"images/slate_arcitecture_3.html","images/SLATE_ARCITECTURE_4.png":"images/slate_arcitecture_4.html","images/SLATE_OVERVIEW_1.png":"images/slate_overview_1.html","images/SLATE_OVERVIEW_2.png":"images/slate_overview_2.html","images/sphere-indexing-screenshot.png":"images/sphere-indexing-screenshot.html","images/subnetmask.png":"images/subnetmask.html","images/subset_graph.png":"images/subset_graph.html","images/symbol_find_result.png":"images/symbol_find_result.html","images/symbol_result.png":"images/symbol_result.html","images/type_structure.png":"images/type_structure.html","images/u2_soundtype.png":"images/u2_soundtype.html","images/use_vertex_attirbute_arrays.png":"images/use_vertex_attirbute_arrays.html","images/usermode_kernalmode.png":"images/usermode_kernalmode.html","images/using_uniform.png":"images/using_uniform.html","images/var_error.jpg":"images/var_error.html","images/vertex_shader.png":"images/vertex_shader.html","images/vertext_shader_parallel.png":"images/vertext_shader_parallel.html","images/vtableoperation.png":"images/vtableoperation.html","images/wbp_ui_transition.png":"images/wbp_ui_transition.html","images/whoami.png":"images/whoami.html","Infra/Helix Core Workflow.md":"infra/helix-core-workflow.html","Infra/Helix core,  Helix Swarm 구성.md":"infra/helix-core,-helix-swarm-구성.html","Infra/Jenkins 설치 및 구성.md":"infra/jenkins-설치-및-구성.html","Infra/Jenkins 안드로이드 패키징.md":"infra/jenkins-안드로이드-패키징.html","Infra/P4 extension, P4 Triggers.md":"infra/p4-extension,-p4-triggers.html","Infra/Perforce Label.md":"infra/perforce-label.html","Infra/Perforce 명령어.md":"infra/perforce-명령어.html","Infra/Swarm Teams.md":"infra/swarm-teams.html","Interview_practice/C++.md":"interview_practice/c++.html","Interview_practice/iOS (1).md":"interview_practice/ios-(1).html","Interview_practice/Platform SDK (1).md":"interview_practice/platform-sdk-(1).html","Interview_practice/Platform SDK (2).md":"interview_practice/platform-sdk-(2).html","Interview_practice/Qt.md":"interview_practice/qt.html","iOS/@testable import와  빌드 환경 구성 (Build Environment Configuration) 그리고 에러.md":"ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html","iOS/Could not find module 'Alamofire' for target armv7-apple-ios';.md":"ios/could-not-find-module-'alamofire'-for-target-armv7-apple-ios';.html","iOS/Fat Framework.md":"ios/fat-framework.html","iOS/Lazy Sequence.md":"ios/lazy-sequence.html","iOS/Missing required module 'RxCocoaRuntime'에 대한 고찰 - SPM과 UnitTest에서의 오류.md":"ios/missing-required-module-'rxcocoaruntime'에-대한-고찰-spm과-unittest에서의-오류.html","iOS/Network Timeout UnitTest.md":"ios/network-timeout-unittest.html","iOS/Objective - C.md":"ios/objective-c.html","iOS/Orientation.md":"ios/orientation.html","iOS/PhotoKit을 다뤄보자 (이론편).md":"ios/photokit을-다뤄보자-(이론편).html","iOS/PhotoKit을 다뤄보자 (커스텀 코드편).md":"ios/photokit을-다뤄보자-(커스텀-코드편).html","iOS/Scalable Application 설계부터 구현까지 - (0) 대략의 설계.md":"ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html","iOS/Scalable Application 설계부터 구현까지 - (1) Tuist.md":"ios/scalable-application-설계부터-구현까지-(1)-tuist.html","iOS/Swift, Objective - C interoperability.md":"ios/swift,-objective-c-interoperability.html","iOS/Swift에서 다형성을 달성하는 방법.md":"ios/swift에서-다형성을-달성하는-방법.html","iOS/Tuist 기본적인 사용법.md":"ios/tuist-기본적인-사용법.html","iOS/Tuist에서 RIBs Fetch하기. (Carthage).md":"ios/tuist에서-ribs-fetch하기.-(carthage).html","iOS/UI Update Cycle.md":"ios/ui-update-cycle.html","iOS/Unit Test와 TDD - 근데 이게 async await를 곁들인.md":"ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html","iOS/WWDC 2023 Parameter pack.md":"ios/wwdc-2023-parameter-pack.html","iOS/단위테스트와 PRODUCT_MODULE_NAME.md":"ios/단위테스트와-product_module_name.html","iOS/동기, 비동기.md":"ios/동기,-비동기.html","iOS/드래그가 가능한 BottomSheet를 만들어보자(DraggableBottomSheet ).md":"ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html","Network/01. Network.md":"network/01.-network.html","Network/02. L2.md":"network/02.-l2.html","Network/03. L3.md":"network/03.-l3.html","Network/04. 패킷의 생성과 전달.md":"network/04.-패킷의-생성과-전달.html","Network/05. 계층별 데이터 단위.md":"network/05.-계층별-데이터-단위.html","Network/06. TCP IP 송수신 구조.md":"network/06.-tcp-ip-송수신-구조.html","Network/07. IPv4 Header 형식.md":"network/07.-ipv4-header-형식.html","Network/08. 서브넷 마스크와 CIDR.md":"network/08.-서브넷-마스크와-cidr.html","Network/09. Broadcast IP 주소 & Loopback 주소.md":"network/09.-broadcast-ip-주소-&-loopback-주소.html","Network/10. TTL과 단편화.md":"network/10.-ttl과-단편화.html","Network/11. 인터넷 자동 설정 - DHCP.md":"network/11.-인터넷-자동-설정-dhcp.html","Network/12. ARP.md":"network/12.-arp.html","Network/13. Ping과 RTT.md":"network/13.-ping과-rtt.html","Network/14. TCP와 UDP 개요.md":"network/14.-tcp와-udp-개요.html","Network/15. TCP 연결 과정.md":"network/15.-tcp-연결-과정.html","Network/16.  TCP 연결 종료 과정.md":"network/16.-tcp-연결-종료-과정.html","Network/17. DNS.md":"network/17.-dns.html","Network/18. HTTP.md":"network/18.-http.html","opencv/Video Capture.md":"opencv/video-capture.html","physics/physX.md":"physics/physx.html","physics/Untitled.md":"physics/untitled.html","Qt/opengl/OpenGL Sphere 그리기.md":"qt/opengl/opengl-sphere-그리기.html","Qt/opengl/OpenGL 인덱스 순서와 면 컬링 관계.md":"qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html","Qt/opengl/Qt OpenGL in macOS.md":"qt/opengl/qt-opengl-in-macos.html","Qt/opengl/Qt OpenGL 코드.md":"qt/opengl/qt-opengl-코드.html","Qt/Qt Quick 3D - 기본 개념 정리.md":"qt/qt-quick-3d-기본-개념-정리.html","Qt/자주 사용하는 단축키.md":"qt/자주-사용하는-단축키.html","robotics/ROS 2 핵심 통신 개념.md":"robotics/ros-2-핵심-통신-개념.html","robotics/ros2 명령어.md":"robotics/ros2-명령어.html","rust/asdf를 이용한 Rust 설치와 IntelliJ가 Path를 못 찾는 이슈 및 해결.md":"rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html","rust/Cargo.md":"rust/cargo.html","rust/Rust 기초 - Control, 연습 문제.md":"rust/rust-기초-control,-연습-문제.html","rust/Rust 기초 - Data Type.md":"rust/rust-기초-data-type.html","rust/Rust 기초 - Function.md":"rust/rust-기초-function.html","rust/Rust 기초 - Variable.md":"rust/rust-기초-variable.html","rust/Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵).md":"rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html","Tip/Git.md":"tip/git.html","Tip/Linux 명령어.md":"tip/linux-명령어.html","Tip/MCP Setting.md":"tip/mcp-setting.html","Tip/Tip.md":"tip/tip.html","Tip/vscode clang++ 설정.md":"tip/vscode-clang++-설정.html","Tip/비트 다루기.md":"tip/비트-다루기.html","Tip/터미널 명령어로 원하는 .gitignore를 빠르게 생성하기.md":"tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html","UE/Network 프레임워크/02.md":"ue/network-프레임워크/02.html","UE/Network 프레임워크/03. 커넥션과 오너십.md":"ue/network-프레임워크/03.-커넥션과-오너십.html","UE/AGDE와 UE연동.md":"ue/agde와-ue연동.html","UE/Audio_Stream_caching.md":"ue/audio_stream_caching.html","UE/BlendSpace와 BlendSpace1D 차이점.md":"ue/blendspace와-blendspace1d-차이점.html","UE/bool vs uint8.md":"ue/bool-vs-uint8.html","UE/Build System.md":"ue/build-system.html","UE/Console_Command 등록 하는 법.md":"ue/console_command-등록-하는-법.html","UE/Content Cooking & pak & chunk.md":"ue/content-cooking-&-pak-&-chunk.html","UE/DataTable_Asset_Ref.md":"ue/datatable_asset_ref.html","UE/enum vs enum class.md":"ue/enum-vs-enum-class.html","UE/ETriggerEvent.md":"ue/etriggerevent.html","UE/FGenricError.md":"ue/fgenricerror.html","UE/FIOSView insertText - objc_msgSend.md":"ue/fiosview-inserttext-objc_msgsend.html","UE/FTP Manager.md":"ue/ftp-manager.html","UE/Get_AudioTrackInfo_UMG.md":"ue/get_audiotrackinfo_umg.html","UE/insight.md":"ue/insight.html","UE/Invalidation Box.md":"ue/invalidation-box.html","UE/Mac에서 UE4 엔진 소스 빌드 시 유의사항.md":"ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html","UE/Media Framework.md":"ue/media-framework.html","UE/Navigation System.md":"ue/navigation-system.html","UE/PhysX iOS 빌드.md":"ue/physx-ios-빌드.html","UE/PSO (Pipeline State Object) 수집.md":"ue/pso-(pipeline-state-object)-수집.html","UE/Slate Architecture.md":"ue/slate-architecture.html","UE/Slate Overview.md":"ue/slate-overview.html","UE/Slate Widget Examples.md":"ue/slate-widget-examples.html","UE/Sounds 개념.md":"ue/sounds-개념.html","UE/Sounds 개선.md":"ue/sounds-개선.html","UE/UE4 Source iOS Debugging on MacOS.md":"ue/ue4-source-ios-debugging-on-macos.html","UE/UE4.27 iOS Background 앱 크래쉬.md":"ue/ue4.27-ios-background-앱-크래쉬.html","UE/UGameplayStatics.md":"ue/ugameplaystatics.html","UE/UI 애니메이션.md":"ue/ui-애니메이션.html","UE/UMG 클래스에 Delegate 추가하기.md":"ue/umg-클래스에-delegate-추가하기.html","UE/Unreal Engine만의 기본 타입이 있는 이유와 문자열.md":"ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html","UE/UPL.md":"ue/upl.html","UE/내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유.md":"ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html","UE/아틀라스.md":"ue/아틀라스.html","UE/언리얼 패키징 관련 Error.md":"ue/언리얼-패키징-관련-error.html","UE/언리얼엔진에서의 Lamda.md":"ue/언리얼엔진에서의-lamda.html","UE/월드의 생명주기.md":"ue/월드의-생명주기.html","Unity/13. Clear Counter - RayCast로 객체와 인터렉트하기.md":"unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html","Unity/14. Interact Action Events.md":"unity/14.-interact-action-events.html","Unity/15. Selected Counter Visual & Singleton Pattern.md":"unity/15.-selected-counter-visual-&-singleton-pattern.html","Unity/16. Kitchen Object, Scriptable Object.md":"unity/16.-kitchen-object,-scriptable-object.html","Unity/17. Kitchen Object Parent.md":"unity/17.-kitchen-object-parent.html","Unity/18. Player Pick up, CSharp Interfaces.md":"unity/18.-player-pick-up,-csharp-interfaces.html","Unity/19. Container Counter와 상속.md":"unity/19.-container-counter와-상속.html","Unity/20. Player Pick Up & Drop Object.md":"unity/20.-player-pick-up-&-drop-object.html","Unity/21. Cutting Counter, Interact Alternate.md":"unity/21.-cutting-counter,-interact-alternate.html","Unity/22. Cutting Recipe SO.md":"unity/22.-cutting-recipe-so.html","Unity/23. Cutting Progress, World Canvas.md":"unity/23.-cutting-progress,-world-canvas.html","Unity/24. Look At Camera.md":"unity/24.-look-at-camera.html","Unity/25. Trash Counter.md":"unity/25.-trash-counter.html","Unity/26. Stove Counter.md":"unity/26.-stove-counter.html","Unity/27. Plates Counter.md":"unity/27.-plates-counter.html","Unity/28. Plate Pick up Objects.md":"unity/28.-plate-pick-up-objects.html","Unity/Glow Effect 만들기.md":"unity/glow-effect-만들기.html","Unity/캐릭터 움직임과 Time.deltaTime.md":"unity/캐릭터-움직임과-time.deltatime.html","index.md":"index.html","":"site-lib/rss.xml"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1754545597828,"siteName":"psychehose.github.io","vaultName":"psychehose.github.io","exportRoot":"","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager mod-macos is-hidden-frameless native-scrollbars show-inline-title show-ribbon show-view-header minimal-default-light minimal-default-dark minimal-readable colorful-headings links-int-on links-ext-on full-width-media trim-cols sidebar-tabs-default is-focused","hasFavicon":false}