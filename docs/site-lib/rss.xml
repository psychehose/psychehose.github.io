<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[psychehose.github.io]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>psychehose.github.io</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 30 Dec 2024 17:14:57 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 30 Dec 2024 17:13:09 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Develop]]></title><description><![CDATA[ C / C++ 능력 블로그 읽기 - 모두의 코드 C++
Leetcode - blind 75 n회독 로보틱스 ROS 익히기
파이썬 물리엔진 회사에서 Flight 물리 숙지 및 포팅
물리 렌더러 ]]></description><link>hose/develop.html</link><guid isPermaLink="false">Hose/Develop.md</guid><pubDate>Mon, 30 Dec 2024 17:09:50 GMT</pubDate></item><item><title><![CDATA[thread..]]></title><description><![CDATA[프로세스끼리 메모리 공유하지 않음.쓰레드: 프로그램 내에서 동시에 실행될 수 있는 작은 실행 단위임쓰레드는 같은 프로세스 내에 있으면 같은 메모리 공유#include &lt;iostream&gt;
#include &lt;thread&gt;
using std::thread; void func1() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; "쓰레드 1 작동중! \n"; }
} void func2() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; "쓰레드 2 작동중! \n"; }
} void func3() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; "쓰레드 3 작동중! \n"; }
}
int main() { thread t1(func1); thread t2(func2); thread t3(func3); t1.join(); t2.join(); t3.join();
}
join은 쓰레드들이 실행을 종료하면 리턴하는 함수
detatch는 해당 쓰레드를 실행 시킨 후,&nbsp;잊어버리는 것&nbsp;이라 생각하시면 됩니다. 대신 쓰레드는 알아서 백그라운드에서 돌아감#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using std::thread;
using std::vector; void worker(vector&lt;int&gt;::iterator start, vector&lt;int&gt;::iterator end, int* result) { int sum = 0; for (auto itr = start; itr &lt; end; ++itr) { sum += *itr; } *result = sum; // 쓰레드의 id 를 구한다. thread::id this_id = std::this_thread::get_id(); printf("쓰레드 %x 에서 %d 부터 %d 까지 계산한 결과 : %d \n", this_id, *start, *(end - 1), sum);
} int main() { vector&lt;int&gt; data(10000); for (int i = 0; i &lt; 10000; i++) { data[i] = i; } // 각 쓰레드에서 계산된 부분 합들을 저장하는 벡터 vector&lt;int&gt; partial_sums(4); vector&lt;thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(thread(worker, data.begin() + i * 2500, data.begin() + (i + 1) * 2500, &amp;partial_sums[i])); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } int total = 0; for (int i = 0; i &lt; 4; i++) { total += partial_sums[i]; } std::cout &lt;&lt; "전체 합 : " &lt;&lt; total &lt;&lt; std::endl;
}
worker에서 std::cout 대신에 printf를 사용한 이유한 번 여러분이 컴퓨터라고 생각하고 위&nbsp;std::cout&nbsp;명령을 실행한다고 생각해보세요. 만약에&nbsp;std::cout &lt;&lt; "쓰레드 "&nbsp;까지 딱 실행했는데 운영체제가 갑자기 다른 쓰레드를 실행시키면 어떨까요? 그렇다면 화면에는&nbsp;쓰레드&nbsp;만 딱 나오고 그 뒤로 다른 쓰레드의 메세지가 표시될 것입니다.따라서 위와 같이&nbsp;std::cout&nbsp;의&nbsp;&lt;&lt;&nbsp;를 실행하는 과정 중간 중간에 계속 실행되는 쓰레드들이 바뀌면서 결과적으로 메세지가 뒤섞여서 나타나게 됩니다.std::cout&nbsp;의 경우&nbsp;std::cout &lt;&lt; A;&nbsp;를 하게 된다면 A 의 내용이 출력되는 동안 중간에 다른 쓰레드가 내용을 출력할 수 없게&nbsp;보장을 해줍니다 (그 사이에 컨텍스트 스위치가 되더라도 말이지요). 하지만&nbsp;std::cout &lt;&lt; A &lt;&lt; B;&nbsp;를 하게 되면&nbsp;A&nbsp;를 출력한 이후에&nbsp;B&nbsp;를 출력하기 전에 다른 쓰레드가 내용을 출력할 수 있습니다.반면에&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/35" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/35" target="_self">printf</a>&nbsp;는 조금 다릅니다.&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/35" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/35" target="_self">printf</a>&nbsp;는&nbsp;"..."&nbsp;안에 있는 문자열을 출력할 때, 컨텍스트 스위치가 되더라도 다른 쓰레드들이 그 사이에 메세지를 집어넣지 못하게 막습니다. (자세한 내용은 여기&nbsp;<a data-tooltip-position="top" aria-label="https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads" rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads" target="_self">참고</a>)따라서, 방해받지 않고 전체 메세지를 제대로 출력할 수 있게 해줍니다.#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using std::thread;
using std::vector; void worker(int&amp; counter) { for (int i = 0; i &lt; 10000; i++) { counter += 1; }
} int main() { int counter = 0; vector&lt;thread&gt; workers; for (int i = 0; i &lt; 4; i++) { // 레퍼런스로 전달하려면 ref 함수로 감싸야 한다 (지난 강좌 bind 함수 참조) workers.push_back(thread(worker, std::ref(counter))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
흠 결과가 조금 이상하네요? 분명히 각 쓰레드에서 10000 씩 더했기 때문에 정상적인 상황이였다면 40000 이 출력되어야 했을 것입니다. 그런데, 모든 쓰레드들이 종료되고 최종적으로&nbsp;Counter&nbsp;에 써진 값은 10000 이 되었습니다 -&gt; 레이스 컨디션]]></description><link>cpp/thread...html</link><guid isPermaLink="false">CPP/thread...md</guid><pubDate>Mon, 30 Dec 2024 17:04:41 GMT</pubDate></item><item><title><![CDATA[c, c++ 컴파일 과정]]></title><description><![CDATA[<img alt="build_process.png" src="images/build_process.png" target="_self">
전처리 과정
소스 코드 파일 (.c / .cpp)를 전처리된 파일 *.i로 변환한다. Header file Inclusion - #include를 actual content로 대체한 후에 소스코드에 삽입한다.
Macro Expansion - #define PI 3.14를 확인하고 PI를 3.14로 치환한다.
Comments Removal - 주석을 삭제한다. 컴파일 과정
컴파일러를 통해 전처리된 파일 *.i를 어셈블리어 파일 .*s로 변환한다. 이 과정에서 언어의 문법 검사를 수행하고 Static한 Section에 대한 메모리 할당을 이뤄진다. 그리고 코드 최적화를 수행하고 코드를 생성한다.
어셈블리어 과정
어셈블러를 통해 어셈블리어 파일(*.s)을 오브젝트 파일 (*.o)로 변환한다. 오브젝트 파일은 어셈블된 코드를 소스코드와 긱어 코드의 중간 형태로 저장하고 표현하는데 사용되는 파일 형식이다. 이러한 오브젝트 파일은 실행파일에 결합하는 링커에 대한 입력 역할을 한다.<br><img alt="object_file_header.png" src="images/object_file_header.png" target="_self">Object File Header: 일반적으로 아키텍처, 섹션의 크기, entry point에 대한 정보가 들어있다.Text Section: 변환된 기계어로 이뤄진 코드가 들어 있다.Data Section: 프로그램에서 사용되는 초기화된 / 되지 않은 데이터가 들어있다. (전역변수 / static 변수)Symbol Table Section: &nbsp;변수 및 함수 이름과 같이 코드에 사용된 기호에 대한 정보가 포함됩니다. 이 정보는 연결 및 디버깅에 필수적입니다.Relocation Information Section: 이 정보는 프로그램이 최종 실행 파일을 형성하기 위해 다른 개체 파일과 연결될 때 코드의 주소를 조정해야 하는 방법을 지정합니다. 이는 기호에 대한 참조가 올바르게 해석되도록 보장합니다. 링킹 전까지 심볼의 위치를 확정할 수 없으므로 심볼의 위치가 확정 나면 바꿔야 할 내용을 적어놓은 부분입니다.Debugging Information Section: 디버깅에 필요한 정보가 있는 부분입니다.심볼(Symbol)은&nbsp;함수나 변수를 식별할 때 사용하는 이름으로&nbsp;심볼 테이블(Symbol Table)&nbsp;안에는 오브젝트 파일에서 참조되고 있는 심볼 정보(이름과 데이터의 주소 등)를 가지고 있다.이때 오브젝트 파일의 심볼 테이블에는 해당 오브젝트 파일의 심볼 정보만 가지고 있어야 하기 때문에&nbsp;다른 파일에서 참조되고 있는 심볼 정보의 경우 심볼 테이블에 저장할 수 없다.<br><img alt="printf.png" src="images/printf.png" target="_self">이 소스 코드 파일을 컴파일하여 하나의 오브젝트 파일을 생성할 수 있다.
하지만, 이 오브젝트 파일은 독립적으로 실행할 수가 없다. 왜냐하면 이 소스코드에서 printf 함수를 구현한 내용이 없기 때문이다. 전처리 과정을 통해 include &lt;stdio.h&gt;로부터 printf()의 원형은 복사했지만 구현한 내용은 포함되어 있지 않다.
Symbol Table에는 자신의 심볼 정보만 가지고 있지 외부에서 참조하는 printf에 대한 심볼 정보는 가지고 있지 않다.이 오브젝트 파일을 실행하기 위해서 printf 함수를 구현한 libc.a와 연결시키는 작업이 필요하다. 이러한 연결 과정을 링킹이라고 한다. 링킹 이후에 심볼의 위치가 확정되고 이 위치들은 Relocation Information Section에 저장된다.참고: 개체 파일 형식은 플랫폼마다 다릅니다.
ELF(Executable and Linkable Format):&nbsp;Linux를 포함한 Unix 계열 시스템
Mach-O(Mach Object):&nbsp;macOS 및 iOS
COFF(Common Object File Format):&nbsp;이전 Windows PE(Portable Executable):&nbsp;최신 Windows 시스템 링킹
프로그램에서 사용되는 모든 Object 파일과 라이브러리를 실행파일로 결합하는 과정이다. 이 과정을 통해 다양한 소스파일에서 참조되는 모든 함수와 변수가 올바르게 링크된다.링커는 한 Object 파일에서 참조하는 Symbol을 다른 Object 파일의 Symbol 정의와 일치시켜 확인한다. 만약 Symbol을 찾을 수 없다면 Link Error가 발생한다. (Symbol Resolution)그리고 Object 파일의 데이터의 주소나 코드의 메모리 참조 주소를 조정하여 알맞게 배치한다.
각 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소가 실행 파일에서의 주소와 다르므로 알맞게 수정한다. (오브젝트 파일의 Relocation Information Section의 존재 이유)
이 과정을 Relocation 이라고 한다.링킹을 하기 전 오브젝트 파일을&nbsp;재배치 가능한 오브젝트 파일(Relocatable Object File)이라 부르고 링킹을 통해 만들어지는 오브젝트 파일을&nbsp;실행 가능한 오브젝트 파일(Executable Object File)이라 부른다.]]></description><link>cpp/c,-c++-컴파일-과정.html</link><guid isPermaLink="false">CPP/c, c++ 컴파일 과정.md</guid><pubDate>Mon, 30 Dec 2024 17:04:03 GMT</pubDate><enclosure url="images/build_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/build_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유]]></title><description><![CDATA[기본적으로 내비게이션 영역은 내비게이션 메쉬가 커버하고 있는 영역 중에서 월드의 충돌 지오메트리를 통해 길찾기 영역이 설정됩니다. 그리고 내비게이션 메시를 타일로 분할하기 때문에 벽은 영역에 표시되지 않습니다. 그리고 내비게이션 메시는 폴리곤으로 구성되고 각 폴리곤에 비용이 할당되는데, 이를 이용해 비용이 가장 낮은 최적의 경로를 찾으려고 시도합니다. 폴리곤에 할당하는 비용을 조절함으로써 고도화된 내비게이션 시스템을 만들 수 있습니다.<img alt="Navigation.png" src="images/navigation.png" target="_self">]]></description><link>ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html</link><guid isPermaLink="false">UE/내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유.md</guid><pubDate>Mon, 30 Dec 2024 16:59:09 GMT</pubDate><enclosure url="images/navigation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/navigation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ETriggerEvent]]></title><description><![CDATA[enum class ETriggerEvent : uint8
{ // No significant trigger state changes occurred and there are no active device inputs None = (0x0) UMETA(Hidden), // Triggering occurred after one or more processing ticks Triggered	= (1 &lt;&lt; 0),	// ETriggerState (None -&gt; Triggered, Ongoing -&gt; Triggered, Triggered -&gt; Triggered) // An event has occurred that has begun Trigger evaluation. Note: Triggered may also occur this frame, but this event will always be fired first. Started = (1 &lt;&lt; 1),	// ETriggerState (None -&gt; Ongoing, None -&gt; Triggered) // Triggering is still being processed. For example, an action with a "Press and Hold" trigger // will be "Ongoing" while the user is holding down the key but the time threshold has not been met yet. Ongoing = (1 &lt;&lt; 2),	// ETriggerState (Ongoing -&gt; Ongoing) // Triggering has been canceled. For example, the user has let go of a key before the "Press and Hold" time threshold. // The action has started to be evaluated, but never completed. Canceled	= (1 &lt;&lt; 3),	// ETriggerState (Ongoing -&gt; None) // The trigger state has transitioned from Triggered to None this frame, i.e. Triggering has finished. // Note: Using this event restricts you to one set of triggers for Started/Completed events. You may prefer two actions, each with its own trigger rules. // Completed will not fire if any trigger reports Ongoing on the same frame, but both should fire. e.g. Tick 2 of Hold (= Ongoing) + Pressed (= None) combo will raise Ongoing event only. Completed	= (1 &lt;&lt; 4),	// ETriggerState (Triggered -&gt; None)
};
ETriggerEvent는 Enum으로 6가지 타입이 있다.
None
Triggered,
Started
Ongoing
Canceled
Completed
이 타입들은 Action에서 Triggers를 어떻게 설정한지에 따라 달라진다.Action Triggers에 Pressed를 설정했을 때ETriggerEvent는 1틱씩None -&gt; Start -&gt; Triggered -&gt; Completed 순으로 발생한다.Action Triggers에 Pressed, Release로 설정할 시에는None -&gt; Start-&gt; Trigger -&gt; Ongoing -&gt; Trigger -&gt; CompletedAction Triggers에 Hold And Release로 설정하고 Hold Time Threshold를 0.5초로 설정이벤트를 주면None -&gt; Start -&gt; Ongoing -&gt; Triggered -&gt; Completed Hold Time Threshold를 5초로 설정하고 스페이스를 2초 후에 눌렀다 떼면None -&gt; Start -&gt; Ongoing -&gt; Canceled정리하면 기본상태는 None이고, 이벤트가 취해질 때 맨 처음 Start로 상태가 한틱 변경된다. 그리고 이벤트 요구사항이 충족 되기 전까지는 Ongoing을 유지하고 충족 되면 Triggered로, 충족되지 않는다면 Canceled로 상태가 변경된다. 그리고 다시 None으로 변경됨.]]></description><link>ue/etriggerevent.html</link><guid isPermaLink="false">UE/ETriggerEvent.md</guid><pubDate>Mon, 30 Dec 2024 16:58:59 GMT</pubDate></item><item><title><![CDATA[BlendSpace와 BlendSpace1D 차이점]]></title><description><![CDATA[ 애니메이션 블렌딩이란 하나의 캐릭터 또는 스켈레탈 메시에 둘 이상의 애니메이션이 부드럽게 전환되도록 만드는 것.언리얼엔진에서 블렌딩 하는 방법은 두 가지.
애님그래프에서 블루프린트로 블렌딩
블렌드스페이스 사용 블렌드 스페이스는 애님그래프에서 샘플링할 수 있는 특수 애셋 두 입력값에 따라서 애니메이션을 블렌딩시켜주는 것.블렌드스페이스와 블렌드스페이스1D의 차이점은 입력값의 차이 1D는 가로축 하나라서 기준이 단일 입력값으로 블렌딩을 하는 반면에 2D는 가로, 세로축이 존재해 두 입력에 따라 애니메이션을 블렌딩할 수 있습니다.언리얼엔진5에서 Legacy에 BlendSpace1D가 들어가있는 이유는 블렌드스페이스와 차이는 단순히 축뿐이기 때문입니다. 세로축을 사용하지 않으면 그게 바로 Blendspace1D이기 때문입니다.<img alt="Blendspace.png" src="images/blendspace.png" target="_self">]]></description><link>ue/blendspace와-blendspace1d-차이점.html</link><guid isPermaLink="false">UE/BlendSpace와 BlendSpace1D 차이점.md</guid><pubDate>Mon, 30 Dec 2024 16:58:42 GMT</pubDate><enclosure url="images/blendspace.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/blendspace.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[월드의 생명주기]]></title><description><![CDATA[월드는 액터와 컴포넌트가 존재하고 렌더링 되는 top level 오브젝트다. 쉽게 맵이라고 생각할 수 있다. 그렇다면 월드의 생명주기는 무엇일까?게임플로우의 일반적인 순서는 Engine 초기화 -&gt; GameInstance 생성 및 초기화 -&gt; Level 로드다. 월드는 레벨이 로드될 때 생성되고 초기화 되고 로드된다.월드는 레벨에 종속되어 있는 오브젝트라고 할 수 있다. 따라서 Level이 생성될 때 World도 같이 생성 및 초기화가 진행되고, Level이 사라질 때 월드도 같이 사라지는 것이라고 할 수 있다.<img alt="GameFlowChart.png" src="images/gameflowchart.png" target="_self">]]></description><link>ue/월드의-생명주기.html</link><guid isPermaLink="false">UE/월드의 생명주기.md</guid><pubDate>Mon, 30 Dec 2024 16:58:12 GMT</pubDate><enclosure url="images/gameflowchart.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gameflowchart.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FTP Manager]]></title><description><![CDATA[
개요 내용
기존 Wave M에서 FTP를 사용하는 기능은 펌웨어 업데이트 하나였음. 추가되는 R1 나스모 기능은 FTP를 이용함. FTPClient는 새로운 인스턴스를 만들어도, 플러그인 코드 내부 객체는 static으로 선언 되어 있음. FTP를 연결할 때 펌웨어와 R1 나스모는 다른 Username을 가지고 로그인하고 다른 역할을 수행함. 따라서 기존의 FTP에 R1 나스모에 필요한 기능을 추가하고 FTP 연결을 관리할 필요성이 생김.// U2Define.h에 정의
UENUM()
enum class EFTPAddress : uint8
{ None = 0, Firmware, SwingMotion
};
FTP는 Firmware , SwingMotion 두 가지 타입을 가지고 있음.
// Connecting &amp; Disconnecting
void ConnectToFTP(EFTPAddress InAddress);
void DisconnectFromFTP(); // Upload &amp; Download
void UploadDataToFTP(const FString&amp; LocalFilePath, const FString&amp; RemoteFilePath);
void DownloadDataFromFTP(const FString&amp; LocalFilePath, const FString&amp; RemoteFilePath); // Get List
void GotoDirectory(const FString&amp; Directory);
void ListCurrentDirectory(); 각 함수에 대한 결과를 바인딩을 통해 Callback으로 받을 수 있음. 아래 Delegate Binding을 참고
// U2FTPManager.h에 정의 DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FOnU2FTPConnection, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FOnU2FTPStatus, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_SevenParams(FOnU2FTPProgress, const EFTPAddress, Address, const bool, bUploaded, const bool, end, const float, megabyteLeft, const float, megabyteSent, const int32, percent, const float, speedInMegabit);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FiveParams(FOnU2FTPGotoDirectory, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage, FString, currentDir);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnFTPList, const EFTPAddress, Address, const TArray&lt;FString&gt;&amp;, files); FOnU2FTPConnection OnU2FTPConnection;
FOnU2FTPStatus OnU2FTPStatus;
FOnU2FTPProgress OnU2FTPProgress;
FOnU2FTPGotoDirectory OnU2FTPGotoDirectory;
FOnFTPList OnU2FTPList; Connecting &amp; Disconnecting에 대한 콜백을 받고 싶음 -&gt; OnU2FTPConnection에 바인딩. Uploading &amp; Downloading에 대한 콜백을 받고 싶음 -&gt; OnU2FTPProgress에 바인딩. FTP에서 워킹 폴더를 변경에 대한 콜백을 받고 싶음 -&gt; OnU2FTPGotoDirectory에 바인딩. FTP에서 해당 폴더에 있는 파일 이름들을 가져오고 싶음 -&gt; OnU2FTPList에 바인딩 ]]></description><link>ue/ftp-manager.html</link><guid isPermaLink="false">UE/FTP Manager.md</guid><pubDate>Mon, 30 Dec 2024 16:46:48 GMT</pubDate></item><item><title><![CDATA[Sounds 개선]]></title><description><![CDATA[
개요
컨텐츠 폴더 구조 (기획 ,디자인, 개발)
U2SoundDataTable - SoundType 카테고리 (기획, 디자인)
U2SoundManager - Init, Load (개발)
Audio Stream Caching 적용 (개발)
Sound 출력 Rule (기획, 디자인, 개발)
결과
P.S 사운드 작업 시 살펴봐야할 에셋들 기존에 사운드 관리자의 부재로 인해 유지보수가 지속적으로 이뤄지지 않았음. 기존의 사운드 시스템은 게임 시작 버튼 클릭시에 로딩바에서 SoundsDataTable에 있는 모든 사운드 에셋을 로딩하고, 이것들을 TMap에 저장한 후에 필요할 때 출력하는 방식으로 구성되어 있었음. 유지보수 하기 쉽고 안정적이지만 사용하지 않는 사운드 모두 메모리에 올리기 때문에 로비에서 메모리가 낭비되는 결과를 가져올 수 있음. <img src="images/foldering_to_be.png" target="_self"> ann_crash: 볼 맞추고 판정소리 () 아나운서가 벙커, OB 이런거 내주는 소리
SoundType:인게임
모두 ShotResult로 시작함.
ReplayState, U2GolfGameSoundComponent, UIIngameStrokePage에서 사용 ann_score: 찬스랑 결과 말해주는 소리 총 세가지 유형: 찬스, 홀인 결과, 컨시드 결과
SoundType: 인게임
찬스는 ScoreChane. 로 시작, UU2CaddieComponent에 종속
홀인 결과와 컨시드 결과는 UU2GolfGameSoundComponent에 종속
홀인원은 UMG(홀인원 결산)에서도 쓰임 ann_shot 스윙했을 때 나는 소리들 (굿샷, 나이스어프로치, 나이스온, 나이스플레이, 나이스샷)
SoundType: 인게임
모두 ShotResult. 로 시작함
ReplayState, U2GolfGameSoundComponent, UIIngameStrokePage에 종속
ann_crash와 거의 같음. ambient UU2GolfGameSoundComponent에 귀속
SoundType: 인게임 ball_crash BallCollidedDataTable에서 참조
SoundType: 인게임 bgm BGM
SoundType: BGM button 버튼 클릭 소리 SoundType: Common event 이벤트 소리
애니메이션에 넣지 못하는 소리 (분기처리 때문에 코드로 출력해야하는 사운드)
코드로 호출
SoundType: Common 또는 인게임 gallery 갤러리 사운드 (박수, 환호, 야유)
인게임 swing_shot 클럽별 임팩트 소리
인게임 swing_control - 전부 인게임 스윙게이지 소리
인게임 animation UMG 애니메이션에 넣는 소리
SoundType: Animation
<br><img src="images/u2_soundtype.png" target="_self"> None
사용 안함 표시 -&gt; 게임에서 사용하지 않겠다. In Game 게임 시작시에 로딩 됨
게임중에만 사용
스윙 임팩트, 스코어 사운드 등등
코드로 호출 BGM BGM
코드로 호출 Animation UMG에서 Animation - Audio Track에 추가할 사운드
코드로 호출 불가 Common 버튼 클릭 사운드
코드로 호출할 필요가 있는 사운드 (클럽, 의상 갓챠는 시네마틱 분기가 안되어서 어쩔 수 없이 여기 넣음)
코드 호출 가능 U2SoundManager 클래스는 게임 내 사운드 관리를 담당합니다. Init() 메서드를 통해 초기화되며, 다음과 같은 작업을 수행함 메시지 매니저 초기화 사운드 테이블 로드 콘솔 명령어 설정 (에디터 모드에서만) void UU2SoundManager::Init()
{ InitMessageManager(); LoadSoundTable(); #if WITH_EDITOR // 에디터에서만 콘솔 명령어 설정 if (CMD_LogSound == nullptr) { CMD_LogSound = UU2ConsoleManager::Instance()-&gt;RegisterConsoleCommand( DEF_CSC_LOG_SOUND, TEXT("테스트용: 사운드 로그"), FConsoleCommandWithArgsDelegate::CreateUObject(this, &amp;UU2SoundManager::CONSOLE_LogSound), ECVF_Default ); } #endif
} 등록된 콘솔 명령어는 런타임에서 사용할 수 있음.U2.Log.Sound 0 - Sound 로그 가리기U2.Log.Sound 1 - Sound 로그 보이기LoadSoundTable() SoundsDataTable의 모든 행을 읽음.각 행의 SoundType으로 각 사운드 에셋을 저장할 Map을 지정함.코드에서 None, Animation은 break; 처리함.None은 사용하지 않기 때문에 Map에 저장하지 않아도 되기 때문이고, Animation은 UMG에서 로드하고, 언로드하기 때문에 Map에 저장하지 않는다. (코드로 호출할 필요가 없기 때문)InGame, BGM, Common은 코드로 호출할 필요가 있기 때문에, 지정된 Map에 저장을 한다. 그 중 InGame 사운드는 사운드 큐를 넣을 곳 (Value) nullptr을 넣는다. 이유는 로비에서 InGame 사운드를 사용하지 않기 때문에 미리 로드하지 않기 때문이다. BGm, Common은 LoadSound를 하고 지정된 Map의 Value에 사운드 큐를 저장한다.void UU2SoundManager::LoadSoundTable()
{ if (IsAlreadyCalling) { return; } IsAlreadyCalling = true; TArray&lt;FU2SoundDataTable*&gt; RowArray; UU2DBManager::Instance()-&gt;GetDataTableRows&lt;FU2SoundDataTable&gt;(TEXT("SoundsDataTable"), RowArray); for (FU2SoundDataTable* it : RowArray) { switch (it-&gt;SoundType) { case EU2SoundType::None: break; case EU2SoundType::InGame: InGameSounds.Emplace(it-&gt;KeyValue, nullptr); break; case EU2SoundType::BGM: LoadSound(it-&gt;KeyValue, it-&gt;Sound, it-&gt;SoundType); break; case EU2SoundType::Animation: break; case EU2SoundType::Common: LoadSound(it-&gt;KeyValue, it-&gt;Sound, it-&gt;SoundType); break; default: break; } }
} 인게임 사운드 로드와 언로드는 UU2RoundLoadingState와, UU2GameToLobbyState에서 아래 함수를 통해서 이뤄진다.void UU2SoundManager::LoadInGameSounds()
{ for (auto&amp; Elem : InGameSounds) { if (!Elem.Value) { FU2SoundDataTable* Row = UU2DBManager::Instance()-&gt;GetDataTableRow&lt;FU2SoundDataTable&gt;(TEXT("SoundsDataTable"), FName(Elem.Key)); TSoftObjectPtr&lt;USoundBase&gt; SoundPtr(Row-&gt;Sound); LoadSoundInternalAsync(Elem.Key, SoundPtr, EU2SoundType::InGame); } }
} void UU2SoundManager::UnloadGameOnlySounds()
{ for (auto&amp; Elem : InGameSounds) { if (Elem.Value) { Elem.Value = nullptr; OutGameSounds.Remove(Elem.Key); } }
} Audio Stream Caching은 Unreal Engine에서 오디오 성능을 최적화하기 위한 기능 효과 쿡 타임에서 이 기능을 활성화하면 거의 모든 압축 오디오 데이터가 USoundWave 자산에서 분리되어 .pak 파일의 끝에 배치됨. 이를 통해 오디오가 어느 시점에서든 메모리에 로드되고 최근에 사용되지 않았을 때 다시 해제되는 것이 가능 Audio Stream Caching 사용법 각 Platform → iOS / Android → Audio → CookOverrides → Use Stream Caching
Max Cache Size 설정 Prime On Load 적용 Sound 재생 초기 부분을 미리 메모리에 올린다 → 재생 지연 방지 Sound Class - Loading 에서 적용 가능 BGM: 코드로 출력 (보통 State에서 출력함)Animation: UMG에서 오디오 트랙을 이용해서만 호출 (코드로 호출 X) In Game: 코드로 호출
swing impact, crash 등등: 코드로만 호출
Ingame UI: UMG 오디오 트랙으로 호출 가능Common
현재는 코드로 호출
추후 BP를 이용해서 호출할 예정
적용 전
로비, 게임: 132.275 MiB<br>
<img src="images/insight_before.png" target="_self">
적용 후 (Audio Stream Caching 사용)
Lobby ~ InGame 결과
초기화 ~ Lobby ~ 인게임: 132.275 MiB → 20~ 30 MiB (감소율 81.01%)<br>
<img src="images/insight_after.png" target="_self">]]></description><link>ue/sounds-개선.html</link><guid isPermaLink="false">UE/Sounds 개선.md</guid><pubDate>Mon, 30 Dec 2024 16:43:11 GMT</pubDate><enclosure url="images/foldering_to_be.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/foldering_to_be.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[패키징 관련 Error]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted" target="_self">https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted</a> 보고 적용-&gt; provisioning과 certificate matching을 다시 한번 확인하기
-&gt; 인증서와 모바일 프로비저닝 다시 임포트하기]]></description><link>error/패키징-관련-error.html</link><guid isPermaLink="false">Error/패키징 관련 Error.md</guid><pubDate>Mon, 30 Dec 2024 16:33:49 GMT</pubDate></item><item><title><![CDATA[Perforce 도움말]]></title><description><![CDATA[스트림 타입과 Depth: 스트림의 깊이(Depth)는 코드가 얼마나 안정적이어야 하는지를 나타냅니다. 상류에서 하류로 갈수록 코드는 더 안정적이고 검증된 상태가 됩니다.
Mainline (깊이: 1) 가장 기본이 되는 스트림입니다
프로젝트의 "진실의 원천(source of truth)"입니다
모든 안정적인 코드가 최종적으로 모이는 곳입니다 Development (깊이: 2) 실제 개발이 이루어지는 스트림입니다
Mainline에서 분기되어 새로운 기능을 개발합니다
여러 개발자들의 작업이 통합되는 곳입니다 Release (깊이: 2) 제품 출시를 위한 스트림입니다
Mainline에서 분기되어 특정 버전의 안정화를 담당합니다
버그 수정만 허용되며, 새로운 기능 개발은 제한됩니다 Task/Feature (깊이: 3) 가장 구체적인 작업이 이루어지는 스트림입니다
Development 스트림에서 분기됩니다
개별 기능 개발이나 버그 수정을 위해 사용됩니다 # Open command Windows here 선택 후
p4 changes -m1 "./...#have"
p4 set P4IGNORE=.p4ignore p4 depots # 현재 존재하는 depot 확인
p4 depot -t stream {streamdepotname}
p4 stream -t mainline //mystream/main #mainline 설정
p4 stream -t development -P //mystream/main //mystream/dev #development 설정 -t development: 스트림의 타입을 'development'로 지정. 이는 이 스트림이 개발 작업을 위한 것. -P //mystream/main: 부모 스트림을 지정. //mystream/main은 부모 스트림의 전체 경로.
//mystream/dev: 생성하려는 새 스트림의 전체 경로
p4 streams -a //{Depot_name}/...
#development 스트림 강제 삭제
p4 stream -F -d //{Depot_name}/develop #develop 스트림의 파일 삭제
p4 stream --obliterate -y //{Depot_name}/develop
p4 obliterate -y //{Depot_name}/...
p4 depot -f -d {Depot_name}
p4 edit -t +w -c {changing_list_number} ...
p4 user -f {username} # 아이디 생성
p4 passwd {username} # 비밀번호 설정
p4 users
# 1. 해당 사용자의 클라이언트 워크스페이스 삭제
p4 client -d username-workspace # 2. 그 다음 사용자 삭제
p4 user -d username # 3. 삭제가 제대로 되었는지 확인
p4 users | grep username
]]></description><link>infra/perforce-도움말.html</link><guid isPermaLink="false">Infra/Perforce 도움말.md</guid><pubDate>Mon, 30 Dec 2024 16:30:26 GMT</pubDate></item><item><title><![CDATA[Helix core,  Helix Swarm 구성]]></title><description><![CDATA[
저장소 설정
sudo tee /etc/yum.repos.d/perforce.repo &lt;&lt; 'EOF'
[perforce]
name=Perforce
baseurl=https://package.perforce.com/yum/rhel/9/x86_64
enabled=1
gpgcheck=1
gpgkey=https://package.perforce.com/perforce.pubkey
EOF 공개키 등록
sudo rpm --import https://package.perforce.com/perforce.pubkey 저장소 확인
# 저장소가 제대로 등록되었는지 확인
dnf repolist | grep perforce
# 패키지 검색이 되는지 확인
dnf search helix
# 패키지목록 초기화 하고 다시 받기
sudo dnf clean all
sudo dnf makecache
sudo dnf update Helix Core 서버 설치 (p4d) sudo dnf install helix-p4d p4d 초기 설정
sudo /opt/perforce/sbin/configure-helix-p4d.sh
export P4CHARSET=utf8 # 텍스트 인코딩
master가 config할 때 정한 이름이였던 거 같음 P4 설정 파일 경로: /etc/perforce/p4dctl.conf.d/master.conf P4 루트 디렉토리: /opt/perforce/servers/master/root 서버중지 - sudo systemctl stop p4d 또는 sudo -u perforce p4dctl stop master 서버 재시작 - sudo systemctl restart p4d 또는 sudo -u perforce p4dctl restart master 부팅 시 자동 시작 설정: sudo systemctl enable p4d aws인 경우 인바운드 추가해서 1666 포트 추가로 열기 Swram 필수 패키지 설치
sudo dnf install httpd php php-xml php-mbstring php-json php-gd php-curl Apache 웹 서버 활성화
sudo systemctl enable httpd
sudo systemctl start httpd Swarm 설치
sudo dnf install helix-swarm Swarm 초기설정
sudo /opt/perforce/swarm/bin/configure-swarm.sh
]]></description><link>infra/helix-core,-helix-swarm-구성.html</link><guid isPermaLink="false">Infra/Helix core,  Helix Swarm 구성.md</guid><pubDate>Mon, 30 Dec 2024 16:11:44 GMT</pubDate></item><item><title><![CDATA[Jenkins 설치 및 구성]]></title><description><![CDATA[자동화 시스템 구축
젠킨스에서 Java 11은 2024.07.31까지 지원 Deprecated 될 예정
OpenJDK 21로 구성 완료 sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:148) at java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:129) at java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297) at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:383)
Caused: sun.security.validator.ValidatorException: PKIX path building failed at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:388) at java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:271) at java.base/sun.security.validator.Validator.validate(Validator.java:256) at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:230) at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:132) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1302)
Caused: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:130) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:378) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:321) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:316) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1318) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.onConsumeCertificate(CertificateMessage.java:1195) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.consume(CertificateMessage.java:1138) at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:393) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:476) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:447) at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:201) at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:172) at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1506) at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1421) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:455) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:426) at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:586) at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:187) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect0(HttpURLConnection.java:2909) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect(HttpURLConnection.java:2818) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1929) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1599) at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:223) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1321)
Caused: java.io.IOException: Failed to load https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi to C:\ProgramData\Jenkins\.jenkins\plugins\mailer.jpi.tmp at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1332)
Caused: java.io.IOException: Failed to download from https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi (redirected to: https://get.jenkins.io/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1366) at hudson.model.UpdateCenter$DownloadJob._run(UpdateCenter.java:1923) at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:2235) at hudson.model.UpdateCenter$DownloadJob.run(UpdateCenter.java:1897) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) at hudson.remoting.AtmostOneThreadExecutor$Worker.run(AtmostOneThreadExecutor.java:121) at java.base/java.lang.Thread.run(Thread.java:1583)
suncertpathbuilderexception unable to find valid certification path to requested target를 인터넷에 검색했을 때 -Https를 사용하는 웹사이트에 연결을 시도할 때 Java에서 신뢰하는 인증서 목록에 해당 웹사이트의 인증서가 존재하지 않아서 발생하는 문제라고 한다.그래서 예전에 전달받은 인증서를 jdk(jre)/lib/securites/cacert에 keytool 명령어를 이용해 현재 사용하는 자바인증서에 인증서를 넣었음.keytool -importcert -alias {alias name} -keystore "C:\Program Files\Java\jdk-21.0.2\lib\security\cacerts" -storepass changeit -file C:\Users\psyche95\Desktop\CERT\{.cer}
suncertpathbuilderexception unable to find valid certification path to requested target는 해결 되었으나 아래의 문제가 발생java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
검색하니, openjdk에서 발생할 수 있다고 함 -&gt; oracle jdk의 cacert로 교체하면 된다고 해서 교체 -&gt; 같은 에러 반복 cacert 문제가 아님을 확인환경변수 JAVA_HOME 확인-&gt; java8 사용하고 있었음.
JAVA_HOME java21로 변경이로써 플러그인 업데이트 가능하게 됨. + 배치파일 작성 후 빌드 가능그래도 계속 안된다면, java cacert에서 회사 사내 인증서 없애고 JAVA_HOME 설정 다시 할 것java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty at java.base/java.security.cert.PKIXParameters.setTrustAnchors(PKIXParameters.java:200) at java.base/java.security.cert.PKIXParameters.&lt;init&gt;(PKIXParameters.java:120) at java.base/java.security.cert.PKIXBuilderParameters.&lt;init&gt;(PKIXBuilderParameters.java:104) at java.base/sun.security.validator.PKIXValidator.&lt;init&gt;(PKIXValidator.java:94) Caused: java.lang.RuntimeException: Unexpected error
해결한 줄 알았는데, 다시 발생해서 재설치 진행함.jdk 21은 젠킨스에 도입된 지 얼마 되지 않아서 jdk 17로 교체.sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target그냥 check certificate 하지 않는 게 정신건강에 이로울 거 같아서 skip-certificate-check 플러그인을 hpi로 받음. 그러고나서 C:\ProgramData\Jenkins.jenkins\plugins에 직접 hpi를 넣고 설치 젠킨스 재시작이로써 해결 완료되었고 현재까지는 잘 작동함.Unreal Engine4로 작업을 하고 있는데, ugs를 사용하지 않아 개발자가 주기적으로 binary를 depot에 올려줘야 하는 상황 (perforce helix core 사용)아래 batch 파일을 통해 일정 시간에 컴파일하고 만들어진 binary를 submit 함.@echo off
setlocal enabledelayedexpansion set ENGINE_PATH=C:\Users\owner\Perforce\psyche95_GZ-PSYCHE9503_8014\GolfzonMEngine
set PROJECT_PATH=C:\Users\owner\Perforce\psyche95_GZ-PSYCHE9503_8014\WaveM\U2Client_Wave :: 접근 권한 설정
icacls "%ENGINE_PATH%" /grant Everyone:(F)
icacls "%PROJECT_PATH%" /grant Everyone:(F) :: 필요한 폴더와 파일 삭제
echo Deleting unnecessary files and folders...
if exist "%PROJECT_PATH%\.vs" rmdir /s /q "%PROJECT_PATH%\.vs"
if exist "%PROJECT_PATH%\DerivedDataCache" rmdir /s /q "%PROJECT_PATH%\DerivedDataCache"
if exist "%PROJECT_PATH%\Intermediate" rmdir /s /q "%PROJECT_PATH%\Intermediate"
if exist "%PROJECT_PATH%\Saved" rmdir /s /q "%PROJECT_PATH%\Saved"
if exist "%PROJECT_PATH%\U2Client.sln" del /f /q "%PROJECT_PATH%\U2Client.sln" :: Unreal Engine을 이용해 비주얼 스튜디오 프로젝트 파일 생성
echo Generating Visual Studio project files...
"%ENGINE_PATH%\Engine\Binaries\DotNET\UnrealBuildTool.exe" -projectfiles -project="%PROJECT_PATH%\U2Client.uproject" -game -progress
if %errorlevel% neq 0 ( echo Failed to generate Visual Studio project files. curl -X POST -H "Content-type: application/json" --data "{\"text\":\"Failed to generate Visual Studio project files\", \"channel\":\"#dev_build\"}" "https://hooks.slack.com/services/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" exit /b %errorlevel%
) :: 비주얼 스튜디오를 이용해 U2Client.sln 빌드
echo Building the U2Client.sln...
"C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\Common7\IDE\devenv.com" "%PROJECT_PATH%\U2Client.sln" /Build "Development Editor|Win64" /Project "U2Client"
echo Errorlevel after build: %errorlevel%
if %errorlevel% neq 0 ( echo Build process failed, checking log... curl -X POST -H "Content-type: application/json" --data "{\"text\":\"Build process failed\", \"channel\":\"#dev_build\"}" "https://hooks.slack.com/services/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" exit /b %errorlevel%
) :: 변경된 PDB 및 DLL 파일 검사 및 Perforce로 체크아웃
pushd "%PROJECT_PATH%\Binaries\Win64"
set CHANGES_EXIST=
for %%f in (*.pdb *.dll) do ( :: 파일 접미사 체크 및 변경 검사 echo %%f | findstr /R /C:".*-[0-9][0-9][0-9][0-9]\." &gt; nul if errorlevel 1 ( :: 파일이 마지막으로 변경된 시간 가져오기 for /f "tokens=2 delims==" %%t in ('wmic datafile where name^="%%f" get lastmodified /value') do set LASTMOD=%%t :: Perforce에 저장된 파일의 수정 시간 비교 p4 -u psyche95 fstat -T headTime %%f | findstr /C:"headTime" set HEADTIME=!headTime! if "!LASTMOD:~0,14!" neq "!HEADTIME!" ( set CHANGES_EXIST=true p4 -u psyche95 edit %%f ) )
)
popd :: 변경점이 있으면 제출하고, 없으면 되돌리기
if defined CHANGES_EXIST ( echo Changes detected. Submitting to Perforce... p4 -u psyche95 submit -d "automate submit"
) else ( echo No changes detected. Reverting changes... pushd "%PROJECT_PATH%\Binaries\Win64" for %%f in (*.pdb *.dll) do ( p4 -u psyche95 revert %%f ) popd
) echo Finished: SUCCESS ]]></description><link>infra/jenkins-설치-및-구성.html</link><guid isPermaLink="false">Infra/Jenkins 설치 및 구성.md</guid><pubDate>Mon, 30 Dec 2024 16:01:41 GMT</pubDate></item><item><title><![CDATA[Jenkins 안드로이드 패키징]]></title><description><![CDATA[
Jenkins는 JAVA 11 지원 X -&gt; JDK 21
@echo off
setlocal enabledelayedexpansion :: Java 11 Setting -
set JAVA_HOME=C:\Program Files\Android\Android Studio\jre
set PATH=%JAVA_HOME%\bin;%PATH%
set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
:: Gradle 설정
set GRADLE_USER_HOME=%USERPROFILE%\.gradle_java11
:: Java 옵션 설정
set _JAVA_OPTIONS=-Djava.specification.version=11 :: 기본 경로 설정
set ENGINE_PATH=D:\Develop\GolfzonMEngine
set PROJECT_PATH=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client
set PROJECT_NAME=U2Client
set OUTPUT_DIR=C:\Users\psyche95\Desktop\Golfzon\M_Packaging :: Android SDK 및 NDK 설정
set ANDROID_HOME=C:\Users\psyche95\AppData\Local\Android\Sdk
set ANDROID_NDK_PATH=%ANDROID_HOME%\ndk\25.2.9519653
set NDKROOT=%ANDROID_NDK_PATH% :: 출력 폴더 설정
for /f "tokens=2 delims==" %%I in ('wmic os get localdatetime /value') do set TIMESTAMP=%%I
set NEW_OUTPUT_DIR=%OUTPUT_DIR%\Build_Android_%TIMESTAMP:~0,8%_%TIMESTAMP:~8,6% :: 필요한 디렉토리 생성
if not exist "%NEW_OUTPUT_DIR%" mkdir "%NEW_OUTPUT_DIR%" :: 프로젝트 파일 확인
if not exist "%PROJECT_PATH%\%PROJECT_NAME%.uproject" ( echo Error: Project file not found! exit /b 1
) echo Starting Android packaging for %PROJECT_NAME%... :: Project Build
call "%ENGINE_PATH%\Engine\Build\BatchFiles\RunUAT.bat" ^
BuildCookRun ^
-nocompileeditor ^
-installed -nop4 ^
-project=%PROJECT_PATH%\%PROJECT_NAME%.uproject ^
-cook -stage -archive -archivedirectory="%NEW_OUTPUT_DIR%" ^
-package ^
-ue4exe="%ENGINE_PATH%\Engine\Binaries\Win64\UE4Editor-Cmd.exe" ^
-compressed ^
-ddc=InstalledDerivedDataBackendGraph ^
-pak ^
-prereqs ^
-targetplatform=Android -cookflavor=ASTC ^
-build ^
-CrashReporter ^
-target=%PROJECT_NAME% ^
-clientconfig=Development ^
-utf8output ^
-AndroidSDK="%ANDROID_HOME%" ^
-AndroidNDK="%NDKROOT%" if %ERRORLEVEL% neq 0 ( echo Error: Build failed with exit code %ERRORLEVEL% exit /b %ERRORLEVEL%
) echo Android packaging completed successfully.
echo Output directory: %NEW_OUTPUT_DIR%
exit /b 0 -nocompileeditor: 에디터 컴파일을 건너뜀 -installed: 엔진 바이너리로 빌드 -nop4: Perforce 연동을 비활성화 -project: 프로젝트 파일의 경로를 지정 -cook: 콘텐츠 쿠킹을 수행 -stage: 패키징된 게임을 스테이징 디렉토리로 복사 -archive: 패키지된 게임을 아카이브 -archivedirectory: 아카이브 디렉토리를 지정 -package: 게임을 패키징 -ue4exe: 사용할 UE4 Editor 실행 파일의 경로를 지정 -compressed: 패키지를 압축 -ddc: 사용할 파생 데이터 캐시(DDC) 설정을 지정 DDC는 파생 데이터 캐시를 의미합니다. 이는 에셋 처리 결과를 저장하는 캐시 시스템입니다. 예를 들어, 텍스처의 압축 버전이나 머티리얼의 컴파일된 버전 등이 여기에 저장됩니다. DDC를 사용하면 에셋 처리 시간을 줄이고, 여러 사용자 간에 처리된 데이터를 공유할 수 있습니다. -pak: 콘텐츠를 PAK 파일로 패키징 -prereqs: 필요한 선행 요구사항을 포함 -targetplatform: 대상 플랫폼을 Android로 설정 -cookflavor: 쿠킹 설정을 ASTC(텍스처 압축 형식)로 지정 -build: 코드를 빌드 -CrashReporter: 크래시 리포터를 포함 -target: 빌드할 프로젝트 이름을 지정 -clientconfig: 클라이언트 구성을 Development or Shipping -utf8output: 출력을 UTF-8로 인코딩 -AndroidSDK: Android SDK 경로를 지정 -AndroidNDK: Android NDK 경로를 지정 Execution of commandlet took: 123.49 seconds LogShaderCompilers: Display: === FShaderJobCache stats === LogShaderCompilers: Display: Total job queries 0, among them cache hits 0 (0.00%) LogShaderCompilers: Display: Tracking 0 distinct input hashes that result in 0 distinct outputs (0.00%) LogShaderCompilers: Display: RAM used: 0.00 MB (0.00 GB) of 1638.40 MB (1.60 GB) budget. Usage: 0.00% LogShaderCompilers: Display: ================================================ LogShaderCompilers: Display: Shaders left to compile 0 LogShaderCompilers: Display: Shaders left to compile 0 OptickLog: Display: OptickPlugin UnLoaded! LogHttp: Display: cleaning up 0 outstanding Http requests. LogContentStreaming: Display: There are 1 unreleased StreamingManagers
Took 140.1294547s to run UE4Editor-Cmd.exe, ExitCode=0
********** COOK COMMAND COMPLETED **********
********** BUILD COMMAND STARTED **********
Running: D:\Develop\GolfzonMEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe U2Client Android Development -Project=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject -Manifest=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Manifest.xml -nobuilduht -NoHotReload -xgeexport C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject -NoUBTMakefiles -remoteini="C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client" -skipdeploy -log="C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UBT-U2Client-Android-Development.txt" Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client Adjust SDK found in C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Plugins\Adjust\Source\Adjust\../ThirdParty/Android Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client D:\Develop\GolfzonMEngine\Engine\Source\Runtime\Engine\Engine.Build.cs: warning: Referenced directory 'D:\Develop\GolfzonMEngine\Engine\Source\Launch\Public' does not exist. PLATFORM_ANDROID_NDK_VERSION = 250300 NDK toolchain: r25c, NDK version: 33, GccVersion: 4.9, ClangVersion: 14.0.7 Parsing headers for U2Client Running UnrealHeaderTool "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject" "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Android\U2Client\Development\U2Client.uhtmanifest" -LogCmds="loginit warning, logexit warning, logdatabase error" -Unattended -WarningsAsErrors -abslog="C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UHT-U2Client-Android-Development.txt" -installed LogInit: Display: Loading text-based GConfig.... Reflection code generated for U2Client in 3.4027725 seconds Compiling Native 64-bit code with NDK API 'android-33' Writing manifest to C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Manifest.xml XGEEXPORT: Exported 'D:\Develop\GolfzonMEngine\Engine\Intermediate\Build\UBTExport.000.xge.xml' Total execution time: 6.14 seconds
Took 6.2589684s to run UnrealBuildTool.exe, ExitCode=0
Running: C:\Program Files (x86)\Incredibuild\xgConsole.exe "C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread Fatal Error: File not found: C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml
Took 0.0520074s to run xgConsole.exe, ExitCode=3
BUILD FAILED: Command failed (Result:3): C:\Program Files (x86)\Incredibuild\xgConsole.exe "C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread. See logfile for details: 'xgConsole-2024.07.31-10.14.49.txt'
AutomationTool exiting with ExitCode=1 (Error_Unknown)
Error: AutomationTool execution failed. Check log: C:\Windows\system32\config\systemprofile\UnrealEngine\BuildTemp\UAT_Log.txt
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE
인크레디빌드 사용시에 패키징 에러가 발생함.
로그에서 실패한 이유가 File Not found인데 실제 경로에 가보니 해당 파일이 있었다.
그래서 권한을 주는 등 다양한 방법을 적용해봤으나 계속해서 같은 이유로 실패했다.인크레디빌드 Agent를 끄고 패키징을 하면 Incredibuild 관련 부분을 통과할 수 있었다. 또는 RunUAT 실행 인자에 -noxge를 추가해도 Incredibuild가 꺼져서 관련 부분을 통과할 수 있었다. 이를 통해, Incredibuild 관련 이슈라 판단하고 incredibuild support에 질문함.<img alt="inc_support.png" src="images/inc_support.png" target="_self">윈도우 젠킨스 설치시에 Windows Service에 등록된다.젠킨스를 이용해서 빌드를 할 때 Window Service에 등록된 사용자로 빌드를 하는데 기본 값이 SYSTEM 사용자다. 그래서 이를 바꿔줘야한다.WIN + R를 누르고 services.msc를 입력해서 서비스를 연다.Jenkins Service를 돌릴 윈도우 계정이 필요한데 회사 도메인을 이용한 사내아이디를 사용 해야했다.Jenkins - 속성 - 로그온 - 찾아보기
아이디 검색 - 비밀번호 입력하고 젠킨스 중지C:\Program Files\Jenkins 로 이동해서 jenkins.xml을 수정한다. xml을 열어서 &lt;arguments&gt; 있는 곳에 다음 값을 추가한다. (젠킨스 서비스가 시작할 때 domain 아이디로 로그인 하겠다고 알려줘야함)&lt;arguments&gt;-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar "C:\Program Files\Jenkins\jenkins.war" --httpPort=12000 --webroot="%ProgramData%\Jenkins\war --serviceLogonAccount={yourdomain\yourid} --serviceLogonPassword={your_passward}"&lt;/arguments&gt;
domain과 id를 하는 법은 cmd를 열고 whoami 입력<br><img alt="whoami.png" src="images/whoami.png" target="_self">젠킨스 다시 시작하고 젠킨스 빌드시에 Incredibuild에서 에러나는 부분을 넘어갈 수 있다. ====2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so.
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png.
[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)
Making .apk with Gradle...
To honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).
Daemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:
Build file 'Z:\build.gradle' line: 14 * What went wrong:
A problem occurred evaluating root project 'app'.
&gt; Could not open dsl generic class cache for script 'Z:\buildscriptAdditions.gradle' (C:\Users\psyche95\.gradle\caches\7.5\scripts\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:
&gt; Run with --stacktrace option to get the stack trace.
&gt; Run with --info or --debug option to get more log output.
&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)
* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s
ERROR: cmd.exe failed with args /c "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\rungradle.bat" :app:assembleDebug (see C:\Users\psyche95\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\Log.txt for full exception trace)
AutomationTool exiting with ExitCode=1 (Error_Unknown)
BUILD FAILED
Error: Build failed with exit code 1
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE
젠킨스 설정시에 java 버전을 21로 올렸기 때문에 발생하는 에러다. 현재 gradle 7.5를 사용하고 있는데 gradle 7.5가 지원하는 상방은 java 18이다. 그래서 패키징시에 명시적으로 java 11 path를 넣고 패키징을 했다.
:: batch 파일 상단 :: Java 11 Setting -
set JAVA_HOME=C:\Program Files\Android\Android Studio\jre
set PATH=%JAVA_HOME%\bin;%PATH%
set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
:: Gradle 설정
set GRADLE_USER_HOME=%USERPROFILE%\.gradle_java11
:: Java 옵션 설정
set _JAVA_OPTIONS=-Djava.specification.version=11 ]]></description><link>infra/jenkins-안드로이드-패키징.html</link><guid isPermaLink="false">Infra/Jenkins 안드로이드 패키징.md</guid><pubDate>Mon, 30 Dec 2024 16:00:29 GMT</pubDate><enclosure url="images/inc_support.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/inc_support.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Helix Core Workflow]]></title><description><![CDATA[Update: 2024/12/18
소개
Stream Depot 구조 이해하기
일반적인 작업 흐름
코드 리뷰 프로세스
주의사항
이 문서는 우리 팀의 Helix Core 작업 환경과 프로세스를 설명합니다. 개발팀과 아트팀이 효율적으로 협업할 수 있도록 설계되었습니다.우리는 Local Depot 대신 Stream Depot을 사용합니다. Stream Depot의 주요 장점은:
브랜치 관리의 용이성
변경사항의 명확한 추적
팀 간 협업 효율성 향상
자동화된 머지 충돌 감지 Mainline Stream: 제품의 안정된 버전을 포함하는 최상위 스트림
Development Stream: 활발한 개발이 이루어지는 주요 통합 스트림
Task/Feature Stream 개별 개발자나 아티스트의 작업 공간
Development 스트림에서 분기
특정 기능이나 작업을 위한 독립된 환경 Release Stream: 출시된 버전을 보관하는 스트림 작업 시작하기 Development 스트림에서 새로운 Task/Feature 스트림 생성
작업할 스트림으로 전환 변경사항 제출 자신의 Task/Feature 스트림에는 자유롭게 submit 가능
Development 스트림으로의 머지는 코드 리뷰 필수 머지 프로세스 작업 완료 후 Development 스트림과 머지 진행
Swarm을 통한 코드 리뷰 승인 필요
승인 후 머지 진행 Swarm 설정이 필요한 부분:
리뷰어 자동 할당 규칙 설정
승인 필요 인원 수 설정
머지 전 필수 리뷰 정책 설정
리뷰 만료 기간 설정
자동 알림 설정 스트림 접근 제한 Development와 Mainline 스트림에 직접 submit 금지
반드시 머지 프로세스를 통해서만 변경사항 반영 코드 품질 관리 Mainline 스트림에는 검증된 코드만 허용
모든 머지는 코드 리뷰 승인 필수 ]]></description><link>infra/helix-core-workflow.html</link><guid isPermaLink="false">Infra/Helix Core Workflow.md</guid><pubDate>Mon, 30 Dec 2024 15:54:02 GMT</pubDate></item><item><title><![CDATA[ue4.27 iOS Background 앱 크래쉬]]></title><description><![CDATA[
게임을 실행하고 플레이한다.
앱을 백그라운드로 전환한다.
일정 시간 지난 후에 (시간은 각각 다양합니다.) 앱을 켭니다.
앱 크래쉬 발생 렌더 스레드를 Flush 하고 suspend 하는 생성자
생성자 - 렌더링 스레드를 없애고 재생성할 지, 단순 일시정지인 지 결정
// 렌더링 스레드가 일시 중단되는 동안 렌더링 명령 대기열을 시작하지 않도록 비동기 로드 스레드를 일시 중단합니다.
if (IsAsyncLoadingMultithreaded())
{ SuspendAsyncLoading();
} Async Loading Thread는 렌더링에 필요한 리소스를 비동기적으로 로딩하고 사용하지 않는 리소스들을 언로드한다.앱이 백그라운드 전환시에 렌더링 스레드 일시 중지 -&gt; 비동기 로딩 중단 -&gt; 비동기 로딩 기다림 -&gt; 크래쉬앱이 Background 갈 때 FAppEntry::Suspend(true) -&gt; 스레드 중지
앱이 Foreground로 다시 돌아와서 팝업을 열어야 하는데 Async Loading Thread가 중지되어 있는 상태팝업을 여는 코드에서 Load Package를 하는 부분이 있는데 이때 ALT를 이용. 따라서 ALT가 돌지 않고 메인스레드는 ALT를 기다리고 있기 때문에 Stall 발생 UE5 5.3.2 git commit 적용 -&gt; 앱 시작하자마자 크래쉬 -&gt; 프로젝트 세팅에서 비동기화 로딩 스레드 끔 -&gt; 앱 크래쉬는 나지 않으나, 게임스레드가 모든 Asset을 로딩해서 속도 이슈가 있을 수 있음 (골엠은 맵이 크고 그래서 켜는 게 더 나을 것 같음, 그리고 기존에 켠 이유가 있다고 하셔서)&nbsp; 그리고 커밋을 제안한 버전이 ue5.1 ApplicationHasEnteredForegroundDelegate를 사용하지 말기(?) Step 1: app goes to background**
**FCoreDelegates::ApplicationWillDeactivateDelegate.Broadcast();
FCoreDelegates::ApplicationWillEnterBackgroundDelegate.Broadcast();
Suspend:&nbsp;RenderThread/ALT/GameThread
Step 2: app going to foreground
FCoreDelegates::ApplicationHasEnteredForegroundDelegate.Broadcast();&nbsp;&nbsp;&nbsp;&nbsp;//"Fatal error!" if FlushAsyncLoading is called. Because ALT is still being suspended
Resume:&nbsp;RenderThread/ALT/GameThread
FCoreDelegates::ApplicationHasReactivatedDelegate.Broadcast();
Is it standard rule to not call any asset loading in FCoreDelegates::ApplicationHasEnteredForegroundDelegate.Broadcast();&nbsp;
applicationDidBecomeActive에서 FAppEntry::Resume(true)가 있음. -&gt; package를 로드하려면 여기에서 해야할 것 같은 느낌.
IOSAppDelegate.cpp에 applicationDidEnterBackground
applicationWillEnterForeground
applicationDidBecomeActive
가 존재합니다. 각각 백그라운드로 갔을 때, Foreground로 돌아올 때 그리고 화면이 완전히 Active 되었을 때 호출되고 이는 각자 FIOSCoreDelegates::ApplicationWillEnterBackgroundDelegate
FIOSCoreDelegates::ApplicationHasEnteredForegroundDelegate
FIOSCoreDelegates.OnDidBecomeActive
를 브로드캐스팅 합니다.골엠에서 GSInstance에 이 Delegate에 바인딩을 걸어놓고 있는데 팝업을 여는게 ApplicationHasEnteredForegroundDelegate, ApplicationHasReactivatedDelegate에 걸려있습니다. (NetworkManager의 bBackgroud를 바꿔서)의심 정황: 이 부분에서 atomic하게 처리 되지 않아서 쓰레드가 살아나지 않고 packageload를 하면 죽고, 약간의 지연이 발생해서 쓰레드가 살아나면 package load하면 튕기지 않는 것 같습니다.그래서 ApplicationHasEnteredForegroundDelegate를 사용하지 않고 OnDidBecomeActive를 사용하면 해결될 가능성이 있는 것 같습니다.]]></description><link>error/ue4.27-ios-background-앱-크래쉬.html</link><guid isPermaLink="false">Error/ue4.27 iOS Background 앱 크래쉬.md</guid><pubDate>Mon, 30 Dec 2024 15:43:15 GMT</pubDate></item><item><title><![CDATA[UE4 Source iOS Debugging on MacOS]]></title><description><![CDATA[$ sudo chmod -R 755 ./
Setup.command는 엔진을 빌드하기 위한 의존성 컨텐트(PhysX, Make, Cmake etc.. ) 를 다운로드 합니다.(binary content for engiene)overwrite 할 것이냐고 묻는데 N 눌러야 합니다.(만약 덮어쓸 경우 PhysX iOS 라이브러리 뽑아서 덮어쓴 다음에 엔진 빌드 해야함)Engine Source를 빌드하는 IDE를 설정합니다. 기본적으로 값이 없거나 보통 VisualStudio로 되어 있습니다.$ vim {Engine Source}/Engine/Config/BaseEditorSetting
# BaseEditorSettings.ini ... [/Script/SourceCodeAccess.SourceCodeAccessSettings] PreferredAccessor=XCodeSourceCodeAccessor
엔진 워크 스페이스를 생성합니다.엔진 워크스페이스를 열고 타겟을 ShaderCompileWorker 변경하고 로제타를 이용해서 빌드합니다. 그런 다음에 타겟을 UE4로 변경 후 역시 로제타를 이용해서 빌드 합니다. 빌드가 성공하면 엔진 빌드 성공입니다.로제타 빌드가 없는 경우는'Xcode -&gt; Product -&gt; destination -&gt; Destination Archtectures -&gt; show rosseta destination'를 확인해서 체크하기맥에서 빌드를 하고 iOS 기기로 디버깅을 하기 위해서는 몇가지 번거로운 작업을 해야합니다. 먼저 Windows에서 필요한 작업이 있습니다. 윈도우 데스크탑에서 아래 경로 폴더들을 맥으로 가져옵니다.{프로젝트 경로}/Intermediate/IOS(info.plist 제외)
{프로젝트 경로}/Intermediate/Plugins (NativizedAssets)
그런 다음에 리모트 빌드를 하고 .ipa 파일을 뽑고 맥으로 가져옵니다.$ cd {엔진 소스 경로}/Build/BatchFiles/Mac
$ ./GenerateProjectFiles.sh -project={프로젝트 경로}/{프로젝트}.uproject -game
프로젝트를 생성하면 Intermediate 폴더가 생기는데 Intermediate안에 위에서 가져온 폴더들을 넣습니다.그러고나서 타겟을 프로젝트로 바꾸고 Edit Scheme을 눌러서 Run을 클릭하고 Configuration을 Debug Game으로 바꿉니다. iOS 기기를 연결하고 빌드 합니다.위에서 리모트 빌드로 뽑은 .ipa 파일을 .zip 확장자로 바꿉니다. unzip을 한 후 Payload-{프로젝트}.app을 클릭하고 Show package contents를 클릭합니다.$ cd {프로젝트소스}/Binaries/iOS/Payload
마찬가지로 .app에 Show package contents를 클릭하고 누락된 부분(cookeddata등)을 복사, 붙여넣기를 합니다.그런 다음에 빌드를 하고 XCode에서 Debug - Attach to Process를 클릭해서 중단점 찍어서 디버깅할 수 있게 됩니다.$ sudo chmod -R 755 ./
Permission Denied 시에 권한을 줘야함 Setup.command는 여러 스크립트를 실행 시키므로각 스크립트에
권한을 줘야함.
OS 자체적으로 막는 경우는 System preference에서 GateKeeper 검색하고 Open anyway 클릭함
Checking dependencies...
Updating dependencies: 0% (0/63485)...
Failed to download '<a rel="noopener nofollow" class="external-link is-unresolved" href="http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94" target="_self">http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94</a>': The remote server returned an error: (403) Forbidden. (WebException)
이 경우에 Engine/Build/Commit.gitdeps.xml을 적절한 버전의 Engine/Build/Commit.gitdeps.xml으로 교체예를 들어 Unreal 4.27 같은 경우는 Unreal Engine Github의 4.27-plus 브랜치를 받으면 됨
Running bundled mono, version: Mono JIT compiler version 5.16.0.220 (2018-06/bb3ae37d71a Fri Nov 16 17:12:11 EST 2018)
The domain/default pair of (com.epicgames.ue4, MonoAOT) does not exist
WARNING: Visual Studio C++ 2019 installation not found - ignoring preferred project file format.
While compiling /Users/choeseung-in/Desktop/GolfzonMEngineSource/Engine/Intermediate/Build/BuildRules/UE4Rules.dll:
../Plugins/GSDevices/CardReader/Source/CardReader/CardReader.Build.cs(58,10) : warning CS0219: The variable `RfdllIncludePath' is assigned but its value is never used
Generating data for project indexing...
Couldn't find PLCrashReporter in folder 'lib-Xcode-14.1', using default 'lib-Xcode-12.4'
Generating data for project indexing... 100%
Writing project files... 0%
ERROR: Visual Studio 2017 must be installed in order to build this target.Saving session...completed.
Source Code를 빌드하는 IDE에 대한 오류 Engine/Config/BaseEditorSettings.ini에 있는 [/Script/SourceCodeAccess.SourceCodeAccessSettings] 설정이 VisualStudio라서 발생한 이슈Mac에서는 Xcode로 설정 해야함[/Script/SourceCodeAccess.SourceCodeAccessSettings] PreferredAccessor=XCodeSourceCodeAccessor
// Engine/Source/Runtime/Engine/Private/Components/DeferredRoadComponent.cpp // TAtomic&lt;int&gt; OverlapCounter = 0;
int32 OverlapCounter = 0; // Engine/Source/Editor/UnrealEd/Private/EditorEngine.cpp int32 XIndex = FString(PackageName).Find(TEXT("_X"), ESearchCase::IgnoreCase, ESearchDir::FromEnd); int32 YIndex = FString(PackageName).Find(TEXT("_Y"), ESearchCase::IgnoreCase, ESearchDir::FromEnd);
// Engine/Source/Editor/TranslationEditor/Private/TranslationEditor.cpp if (!((AssetData.PackageFlags &amp; (PKG_ContainsMap | PKG_PlayInEditor | PKG_ContainsMapData)) == 0)) { OutFailureReason = FString::Printf(TEXT("The AssetData '%s' is not accessible because it is of type Map/Level."), *ObjectPath); return FAssetData(); }
Showing All Messages
Undefined symbols for architecture arm64:
"PxSetGSConf(physx::PxGSConf const&amp;)", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; "PxSetCoefftables(physx::PxCoefftableSource*)", referenced from:&nbsp;
UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; "PxSetHolecupRadius(float)", referenced from: &nbsp; &nbsp; &nbsp; UHoleContext::UpdateHole(unsigned char, EGreenType, EHoleType, FVector) in Module.U1Engine.cpp.o&nbsp; "PxSetGreenSpeedType(physx::GZGreenSpeedType)", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::UpdateGreenSpeedType(physx::GZGreenSpeedType) in Module.U1Engine.cpp.o&nbsp; "PxSetHolecupPosition(physx::PxVec3 const&amp;)", referenced from:&nbsp; &nbsp; &nbsp; UHoleContext::UpdateHole(unsigned char, EGreenType, EHoleType, FVector) in Module.U1Engine.cpp.o &nbsp; "PxSetSurfacetypeTable(physx::PxGSSurfacetypeTable*)", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; "PxSetWind(physx::PxVec3 const&amp;)", referenced from: &nbsp; &nbsp; &nbsp; UHoleContext::SetWind(FVector2D const&amp;) in Module.U1Engine.cpp.old: symbol(s) not found for architecture arm64
Module.U1Engine.cpp.o의 심볼을 확인할 때, PxSetGS... 같이 커스텀한 함수를 호출함. 근데, Engine은 PxSetGS 함수를 알지 못함.
$ cd&nbsp;{엔진소스}/Engine/Source/ThirdParty/PhysX3/Lib/IOS
$ nm libPxFoundationDEBUG.a
그리고 PxSetGS를 검색 -&gt; 심볼이 있으면 엔진 XCode DerivedData 삭제, 클린 빌드 후 엔진 리빌드, 프로젝트 재생성심볼이 없는 경우 PhysX를 빌드하고 Binary를 교체한 후에 위의 과정을 따라감NativizedAssets 관련 - 프로젝트 Run 이후<br><img alt="NativizedAssets.png" src="images/nativizedassets.png" target="_self">Blueprint로 작성한 내용들이 Native 코드로 변환되는 작업이 있음. 이를 윈도우에서 Intermediat/Plugin/IOS에서 가져 와야함.]]></description><link>ue/ue4-source-ios-debugging-on-macos.html</link><guid isPermaLink="false">UE/UE4 Source iOS Debugging on MacOS.md</guid><pubDate>Mon, 30 Dec 2024 15:42:57 GMT</pubDate><enclosure url="images/nativizedassets.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/nativizedassets.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SQLite]]></title><description><![CDATA[
FSQLiteDatabase instance 만들고 db file로 Open
FSQLitePreparedStatement를 만들기, Create() 함수를 이용해서, db랑 tie시킴
SQL과 파라미터를 Binding
Execute를 통해 INSERT or Update or Delete 같은 쿼리 실행
다 사용했으면 FSQLitePreparedStatement를 메모리에서 내리기.
FSQLiteDatabase Cloas() 하기
]]></description><link>ue/sqlite.html</link><guid isPermaLink="false">UE/SQLite.md</guid><pubDate>Mon, 30 Dec 2024 15:41:33 GMT</pubDate></item><item><title><![CDATA[Sounds 개념]]></title><description><![CDATA[사운드 큐는 하나 이상의 사운드 웨이브를 포함할 수 있는 오브젝트입니다. 이를 통해 복잡한 사운드 효과를 구성할 수 있습니다. 사운드 큐는 다양한 노드를 통해 사운드를 조작할 수 있습니다.
모듈레이션 노드: 피치나 볼륨을 변경할 수 있습니다.
믹서 노드: 여러 사운드를 믹싱할 수 있습니다.
랜덤 노드: 여러 사운드 중 랜덤으로 하나를 재생합니다.
시퀀스 노드: 여러 사운드를 순차적으로 재생합니다.
사운드 웨이브는 실제 오디오 데이터를 포함하는 가장 기본적인 사운드 자산입니다. WAV, MP3 등의 파일 형식을 사용할 수 있으며, 주파수, 볼륨, 피치 등의 기본 속성을 설정할 수 있습니다.사운드 클래스는 사운드를 그룹화하고 그 그룹에 공통된 설정을 적용할 수 있게 해줍니다. 예를 들어, 음악, 효과음, 대사를 각각의 사운드 클래스로 나누고, 볼륨이나 믹싱 설정을 개별적으로 조정할 수 있습니다.사운드 믹스는 여러 사운드 클래스의 볼륨이나 피치를 조정하는 데 사용됩니다. 특정 이벤트가 발생했을 때, 사운드 믹스를 적용하여 게임 내 모든 사운드의 특성을 변경할 수 있습니다.오디오 컴포넌트는 액터에 붙여서 사운드를 재생하는 데 사용됩니다. 이를 통해 액터의 위치에 따라 3D 공간에서 사운드를 재생할 수 있습니다.
리버브: 공간의 울림을 시뮬레이션하여 더 현실적인 사운드를 제공합니다.
필터: 특정 주파수를 강조하거나 감소시켜 다양한 효과를 만들 수 있습니다.
채널 (Channel)• 채널은 오디오 시스템에서 독립된 오디오 신호 경로를 의미합니다. 오디오의 방향성과 관련이 깊습니다.• 모노 (Mono), 스테레오 (Stereo), 서라운드 사운드 (Surround Sound) 같은 다양한 채널 구성은 사운드를 어떻게 분배하고 재생할지를 결정합니다.Mono (모노)• 모노는 단일 오디오 채널을 사용하여 소리를 재생합니다.
• 모든 스피커에서 동일한 오디오 신호를 재생하기 때문에, 공간적인 방향성 없이 하나의 소리 원천처럼 들립니다.Stereo (스테레오)• 스테레오는 두 개의 채널(좌, 우)을 사용합니다.
• 각 채널에 다른 오디오 신호를 보내어 공간감을 만들어냅니다. 예를 들어, 음악에서는 악기나 보컬이 왼쪽이나 오른쪽에서 더 크게 들릴 수 있습니다.Surround Sound (서라운드 사운드)
• 서라운드 사운드는 다수의 채널(5.1, 7.1 등)을 사용하여 모든 방향에서 소리가 나오는 듯한 환경을 만듭니다.
• 영화관, 홈시어터 시스템, 고급 게임 환경에서 주로 사용됩니다.Mono vs. Stereo의 차이• 모노는 단일 포인트에서 소리가 나오는 느낌을 줍니다.
• 스테레오는 소리가 좌우로 퍼져 나가며, 청취자에게 더 풍부하고 입체적인 경험을 제공합니다.근데 모노를 사용하는 이유?
용량
공간감 표현 (3d)
실제세계는 모노로 나가는게.. 좀 더 현실적임
SoundManager를 어떻게 고도화할 수 있을까? 사운드 풀링 시스템 구현: 사운드가 재생될 때마다 새로운 오디오 구성 요소를 만드는 대신 재사용 가능한 오디오 구성 요소 풀을 구현합니다. 이는 특히 자주 재생되는 사운드의 경우 성능을 향상시키고 메모리 할당 오버헤드를 줄일 수 있습니다. 사운드 우선순위 구현: 바쁜 오디오 환경에서도 중요한 오디오 신호가 항상 들리도록 사운드 우선순위 시스템을 만듭니다.(6) 로깅시스템 및 에러처리 (5) 사운드 로딩 최적화: 초기화 시 모든 사운드를 로드하는 대신 요청 시 또는 일괄적으로 사운드를 로드하는 시스템을 구현하여 초기 로딩 시간을 줄입니다. 8 동적 음악 시스템에 대한 지원 추가: 게임 상태 또는 이벤트에 따라 다양한 음악 트랙 간에 원활하게 전환하는 시스템을 구현합니다.7 현지화 지원 추가: 오디오 파일의 다양한 언어 버전 간을 쉽게 전환할 수 있는 시스템을 구현합니다 사운드 자산에 비동기 로딩 사용: 동기 로딩을 비동기 로딩으로 대체하여 특히 대용량 사운드 파일의 성능을 향상시킵니다. ]]></description><link>ue/sounds-개념.html</link><guid isPermaLink="false">UE/Sounds 개념.md</guid><pubDate>Mon, 30 Dec 2024 15:41:18 GMT</pubDate></item><item><title><![CDATA[PSO (Pipeline State Object) 수집]]></title><description><![CDATA[언리얼 엔진에서 PSO(Pipeline State Object)는 그래픽 렌더링 파이프라인의 상태를 정의하는 객체. PSO는 주로 Direct3D 12 및 Vulkan 같은 저수준 그래픽 API에서 사용되며, 그래픽 파이프라인의 다양한 설정(셰이더, 블렌딩)을 캡슐화합니다. 이를 통해 렌더링을 효율적으로 관리할 수 있습니다.
PSO는 그래픽 파이프라인 상태를 한 번에 정의하고 이를 캐시할 수 있습니다. 이는 매 프레임마다 상태를 변경하는 것보다 훨씬 효율적입니다. PSO는 다양한 파이프라인 상태를 하나의 객체로 관리할 수 있어 상태 변경 관리가 단순해집니다. Unreal Engine은 이러한 저수준 API들을 추상화하여 PSO를 통해 다양한 플랫폼에서 최적화된 렌더링을 제공합니다. PSO 데이터 수집 목적은 성능 최적화, 셰이더 컴파일 시간 단축, 일관된 성능 제공, 런타임 프레임 드롭 방지, 디버깅 및 최적화에 있다. PSO를 미리 컴파일하여 필요할 때 빠르게 사용할 수 있어 런타임 성능을 향상시킵니다. 사전 정의된 PSO를 사용하면 상태 설정 과정에서 발생할 수 있는 불필요한 연산을 피할 수 있습니다. PSO는 패키징 설정을 Development로 바꾸고 Share Material Shader Code 체크 PSO 데이터 수집을 위해서는 디버깅 정보를 포함해서 패키징 해야하므로 Dev 빌드
여러 머터리얼이 공통으로 사용하는 셰이더 코드를 공유하도록 함 → 중복된 셰이더 제거 → 메모리 효율 증가 맵 포함 패키징 맵에서 사용하는 모든 셰이더와 랜더링 상태를 로드하고 기록하기 위해 맵 전체 포함 .shk 파일을 백업 셰이더 키 캐시(Shader Key Cache) 파일
파일은 셰이더 컴파일 과정에서 생성되며, 특정 셰이더의 키 정보를 저장합니다. 이 키 정보는 셰이더가 변경되었는지 여부를 확인하고, 캐싱된 버전을 사용할 수 있는지를 판단
셰이더 키 캐시를 통해 게임 실행 시 셰이더 로딩 시간을 줄일 수 있음 위에서 뽑은 맵을 이용해서 PSO 데이터 수집 Android, iOS 각 플랫폼마다 게임을 플레이하면서 PSO 데이터를 수집 데이터 수집한 디바이스에서 .upipelinecache 확장자명을 가진 파일 추출 PSO 데이터가 저장된 .upipelinecache 백업한 파일과 upipelinecache 확장자명을 가진 파일을 이용해서 csv 파일로 추출 (with 최승인 프로) .shk 키와 .upipelinecache 데이터를 이용해서 PSO 데이터를 텍스트 형식으로 저장해 분석/수정 가능하게 수정 이를 {Project}/Build/{Platform}/PipelineCaches에 넣고, Shipping, Share Material Shader Code를 체크 해제하고 해당 맵을 포함한채로 패키징 해당 경로에 CSV 배치해두면 패키징 과정에서 해당 파일 참조하여 PSO 데이터 포함하게 된다. 모바일 디바이스를 PC에 연결하고 앱 Saved/CollectedPSOs 위치에 아래와 같은 파일들이 있다.
<img alt="collectpso.png" src="images/collectpso.png" target="_self">
셰이더 키 캐시 파일(.shk)과 upipelinecache 파일을 한 폴더에 넣고 UE4Editor-Cmd를 이용해서 csv 파일을 추출한다.
<br><img alt="pso_data.png" src="images/pso_data.png" target="_self">cd {your_engine folder}/Engine/Binaries/Win64 .\UE4Editor-Cmd.exe D:\Develop\WaveM\U2Client_Wave\U2Client.uproject -run=ShaderPipelineCacheTools expand C:\Users\psyche95\Desktop\WM_Backup\pso_2.1.1_backup\psodata\*.rec.upipelinecache C:\Users\psyche95\Desktop\WM_Backup\pso_2.1.1_backup\psodata\*.shk U2Client_SF_METAL.stablepc.csv 안드로이드는 GPU에 따라 OpenGL, 또는 Vulkan을 사용할 수 있다. (둘 다 지원할 수도 있음) 그렇기 때문에 안드로이드는 PSO 수집을 두 번 해야 한다.안드로이드 신버전은 앱에서 파일을 뽑는 것을 보안상 막아놓았기 때문에 구버전 (현재 가지고 있는 기기 s9, note9) 으로 진행한다.노트9, s9의 GPU는 Mali_72이고, OpenGL, Vulkan을 지원한다.따라서 Mali_72를 이용해서 OpenGL, Vulkan PSO 데이터를 수집하면 된다.
[Android_Mali_G72 DeviceProfile] DeviceType=Android BaseProfileName=Android_High; enable Vulkan on Android 9 and up, older versions crash on creating PSO with a compute shader that uses texel_buffer (eye adaptation) +CVars=r.Android.DisableVulkanSupport=0
+CVars=r.Vulkan.RobustBufferAccess=1 +CVars=r.Vulkan.DescriptorSetLayoutMode=2 +CVars=r.DefaultBackBufferPixelFormat=0 +CVars=r.Vulkan.RayTracing.AllowCompaction=0 +CVars=r.Vulkan.RayTracing.TLASPreferFastTraceTLAS=0
위의 코드가 들어가 있으면 Mali_72 GPU는 Vulkan API를 사용한다는 뜻이다. → 불칸용 PSO 데이터 수집위의 코드가 들어가 있지 않으면 Mali_72 GPU는 OpenGL API를 사용한다는 뜻이다 → OpenGL PSO 데이터 수집Saved/Cooked/Android_ASTC/{GameProject}/Metadata/PipelineCaches에 .shk 파일이 생김. 이를 백업해놓아야함.]]></description><link>ue/pso-(pipeline-state-object)-수집.html</link><guid isPermaLink="false">UE/PSO (Pipeline State Object) 수집.md</guid><pubDate>Mon, 30 Dec 2024 15:40:58 GMT</pubDate><enclosure url="images/collectpso.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/collectpso.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Media Framework]]></title><description><![CDATA[MediaPlayer, MediaSource, MediaTexture, UImage, UMaterialInstanceDynamic 관계 MediaSource 역할: 미디어 데이터의 원천을 정의
UFileMediaSource, UStreamMediaSource 등 부모 클래스
관계 MediaPlayer와 직접 연결 다른 컴포넌트들과는 직접적인 관계가 없음. MediaPlayer 역할: 미디어를 재생하고 제어합니다.
관계 MediaSource로부터 데이터를 받아 디코딩함.
MediaTexture에 디코딩된 비디오 프레임을 제공.
전체 시스템의 중심 역할 MediaTexture 역할: MediaPlayer가 제공하는 비디오 프레임을 텍스처로 변환
관계 MediaPlayer로부터 비디오 프레임을 받음
UMaterialInstanceDynamic의 텍스처 파라미터로 사용됨 UMaterialInstanceDynamic 역할: 동적으로 변경 가능한 머티리얼 인스턴스를 제공
관계 MediaTexture를 텍스처 파라미터로 사용
UImage의 브러시로 사용됨 UImage 역할: UI에 이미지나 비디오를 표시
관계 UMaterialInstanceDynamic을 브러시로 사용하여 비디오를 표시 ]]></description><link>ue/media-framework.html</link><guid isPermaLink="false">UE/Media Framework.md</guid><pubDate>Mon, 30 Dec 2024 15:37:41 GMT</pubDate></item><item><title><![CDATA[insight]]></title><description><![CDATA[insight를 위한 명령어를 넣어줘어야 함.ADB로 Trace를 위한 포트 오픈 (1980)리버스로 해야 들어온다. 포워드로 하면 반대로 가겠지Unreal Insight 실행해서 AutoStart 설정해두면 게임 실행시 Insight 프로세스가 자동실행된다.쭉 추적하고, Trace Sessions에 들어온 Insight 파일로 프로파일링 진행한다.UE4Editor.exe "D:\Develop\GolfzonM\U2Client\U2Client.uproject" -game -WINDOWED -ResX=1280 -ResY=720 -trace=cpu,gpu,memory,log,frame -engine="D:\Develop\GolfzonMEngine\Engine"
PowerShell로 할 경우 인자 추가가 안됨 (cpu,gpu...) -&gt; Cmd로 할 것이 명령어는 언리얼 엔진 4에서 Unreal Insights를 사용하기 위한 실행 인자들입니다. 각 인자에 대해 설명 -NetTrace=1
네트워크 트레이싱을 활성화합니다. -trace=cpu,frame,gpu,memory,log,counters
트레이스할 데이터 유형을 지정합니다. 여기서는 CPU, 프레임, GPU, 메모리, 로그, 카운터 데이터를 수집합니다. -tracehost=127.0.0.1
트레이스 데이터를 전송할 호스트 IP를 지정합니다. 여기서는 로컬호스트를 사용합니다. -Messaging
메시징 시스템을 활성화합니다. Unreal Insights와의 통신에 필요합니다. -SessionId=
세션 ID를 지정합니다. 여기서는 비어 있어 자동 생성됩니다. -SessionOwner=""
세션 소유자의 이름을 지정합니다. -SessionName=""
세션의 이름을 지정합니다. 여기서는 비어 있어 자동 생성됩니다. -iterative
반복적 빌드 모드를 활성화합니다. 개발 중 빠른 재컴파일을 위해 사용됩니다. -fileopenlog
파일 열기 작업에 대한 로깅을 활성화합니다. -tracefile=PathToSaveTraceTo.utrace
트레이스 데이터를 저장할 파일 경로를 지정합니다. .utrace 확장자를 사용합니다. 이 명령어는 Unreal Insights를 사용하여 상세한 성능 데이터를 수집하고 분석하는 데 사용됩니다. CPU, GPU, 메모리 사용량, 프레임 정보 등 다양한 성능 지표를 추적하며, 네트워크 활동도 모니터링합니다. 개발자 이름(chin)을 지정하고 있어, 팀 환경에서 누가 어떤 세션을 실행했는지 추적하는 데 유용할 수 있습니다. 또한 트레이스 파일을 지정된 경로에 저장하므로, 나중에 이 데이터를 Unreal Insights 툴에서 분석할 수 있습니다.언리얼 엔진 4에서 Unreal Insights와 관련된 추가적인 명령 인자들을 알려드리겠습니다. 이 목록은 주요 인자들을 포함하고 있지만, 모든 인자를 망라하지는 않을 수 있습니다. -TraceGameThread=1
게임 스레드의 트레이싱을 활성화합니다. -TraceRenderThread=1
렌더링 스레드의 트레이싱을 활성화합니다. -TraceAudioThread=1
오디오 스레드의 트레이싱을 활성화합니다. -TraceTasks=1
태스크 시스템의 트레이싱을 활성화합니다. -TraceMemory=1
메모리 할당 및 해제의 트레이싱을 활성화합니다. -TraceUI=1
사용자 인터페이스 관련 활동의 트레이싱을 활성화합니다. -TraceFrames=1
프레임 정보의 트레이싱을 활성화합니다. -TraceAnim=1
애니메이션 시스템의 트레이싱을 활성화합니다. -TraceLoadTime=1
자산 로딩 시간의 트레이싱을 활성화합니다. -TraceRHI=1
렌더링 하드웨어 인터페이스(RHI) 호출의 트레이싱을 활성화합니다. -InsightsBufferSize=
Insights 트레이스 버퍼의 크기를 설정합니다. (예: -InsightsBufferSize=100) -statnamedevents
네임드 이벤트에 대한 통계를 활성화합니다. -NoInsightsConsole
Insights 콘솔 출력을 비활성화합니다. -InsightsLatencyCompensation=
네트워크 지연 보상 값을 설정합니다. (밀리초 단위) -InsightsCollectorPort=
Insights 콜렉터가 사용할 포트 번호를 지정합니다. -InsightsCollectorHost=
Insights 콜렉터의 호스트 주소를 지정합니다. -TraceBookmarks=1
북마크 이벤트의 트레이싱을 활성화합니다. -TraceLiveInterval=
라이브 트레이싱 업데이트 간격을 설정합니다. (초 단위) -TraceMaxFileSize=
트레이스 파일의 최대 크기를 설정합니다. (MB 단위) -TraceScreenshots=1
스크린샷 캡처를 트레이스에 포함시킵니다. ]]></description><link>ue/insight.html</link><guid isPermaLink="false">UE/insight.md</guid><pubDate>Mon, 30 Dec 2024 15:35:51 GMT</pubDate></item><item><title><![CDATA[Get_AudioTrackInfo_UMG]]></title><description><![CDATA[UMG 사운드 출력은 애니메이션에서 오디오 트랙을 추가해서 할 것이다.
이때, UMG에서 사운드가 출력될 때 코드 처리가 필요하거나 로깅을 해야할 수 있다.UMG에서 오디오 트랙 정보를 얻고, 이 애니메이션이 재생될 때 브로드캐스팅을 받는 방법이다.
{Project}.Build.cs에 "MovieScene", "MovieSceneTracks" 의존성 추가해야함. // Dependency header
#include "Tracks/MovieSceneAudioTrack.h"
#include "Sections/MovieSceneAudioSection.h" void UUCustomWidget::OnAnimationStarted_Implementation(const UWidgetAnimation* Animation)
{ Super::OnAnimationStarted_Implementation(Animation); #if defined(WITH_EDITOR) &amp;&amp; defined(__FUNC_LOG_DETAIL_SOUND__) U2_LOG(U2Sound, Log, TEXT("Animation started: %s"), *Animation-&gt;GetName()); GetAudioTrackInfo(Animation);
#endif
} void UUCustomWidget::GetAudioTrackInfo(const UWidgetAnimation* Animation) const
{ if (!Animation) return; if (!Animation-&gt;GetMovieScene()) return; UMovieScene* MovieScene = Animation-&gt;GetMovieScene(); TArray&lt;UMovieSceneTrack*&gt; AudioTracks = MovieScene-&gt;GetMasterTracks(); for (UMovieSceneTrack* Track : AudioTracks) { if (UMovieSceneAudioTrack* AudioTrack = Cast&lt;UMovieSceneAudioTrack&gt;(Track)) { // Get Audio Tack info TArray&lt;UMovieSceneSection*&gt; Sections = AudioTrack-&gt;GetAllSections(); for (UMovieSceneSection* Section : Sections) { // Process Section if (UMovieSceneAudioSection* AudioSection = Cast&lt;UMovieSceneAudioSection&gt;(Section)) { if (AudioSection-&gt;HasStartFrame()) { FFrameNumber StartFrame = AudioSection-&gt;GetInclusiveStartFrame(); float StartTime = MovieScene-&gt;GetTickResolution().AsSeconds(StartFrame); U2_LOG(U2Sound, Log, TEXT("@@@@@@@@@@@@@@@@@@@@@@Audio Track Start Time: %f @@@@@@@@@@@@@@@@@@@"), StartTime); USoundBase* Sound = AudioSection-&gt;GetSound(); if (Sound) { FString SoundName = Sound-&gt;GetName(); FTimerHandle LogSoundTimer; // #TDBH - will later implement LogSound in Soundmanager //GetWorld()-&gt;GetTimerManager().SetTimer(LogSoundTimer, FTimerDelegate::CreateLambda([SoundName]() //	{ // UU2SoundManager::Instance()-&gt;LogSound(SoundName); //	}), StartTime, false); } } } } } }
} ]]></description><link>ue/get_audiotrackinfo_umg.html</link><guid isPermaLink="false">UE/Get_AudioTrackInfo_UMG.md</guid><pubDate>Mon, 30 Dec 2024 15:33:09 GMT</pubDate></item><item><title><![CDATA[DataTable_Asset_Ref]]></title><description><![CDATA[문제상황:
모든 사운드 에셋 USound는 USoundDatable에서 관리한다. USoundDatable은 TSoftObjectPtr로 사운드큐를 직접 가지고 있다. 그리고 다른 특정상황에서 사용하는 데이터테이블이 있다. (CollidedSoundDataTable - 이를 C데이터테이블이라 칭함.) C데이터테이블도 마찬가지로 사운드큐를 가지고 있다. 만약 충돌 소리가 변경된다면 USoundDataTable 사운드큐도 바꿔줘야하고, C데이터테이블 사운드큐도 바꿔줘야한다.
C데이터테이블에서 USoundDataTable의 특정 Row를 참조하면 된다.USTRUCT()
struct U2CLIENT_API FU2BallCollidedDataTable : public FU2TableRowBase
{ GENERATED_USTRUCT_BODY()
public: UPROPERTY(EditAnywhere) ESurfaceType surfaceType = ESurfaceType::None; UPROPERTY(EditAnywhere) FDataTableRowHandle SoundRowHandle; UPROPERTY(EditAnywhere) TSoftObjectPtr&lt;UParticleSystem&gt; PS_Collided = nullptr;
}; 결과<img src="images/datahandle_row_result.png" target="_self">코드에서 꺼내 쓰는 법.FU2SoundDataTable* row = resDT-&gt;SoundRowHandle.GetRow&lt;FU2SoundDataTable&gt;(TEXT("BallCollisionSound")); if (row == nullptr) return; if (row-&gt;bUseSound) { UU2SoundManager::Instance()-&gt;PlaySound(row-&gt;KeyValue); }
]]></description><link>ue/datatable_asset_ref.html</link><guid isPermaLink="false">UE/DataTable_Asset_Ref.md</guid><pubDate>Mon, 30 Dec 2024 15:31:49 GMT</pubDate><enclosure url="images/datahandle_row_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/datahandle_row_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Content Cooking & pak & chunk]]></title><description><![CDATA[게임 실행파일과 필수 에셋: pak0pak0을 설정하는 방법
DefaultGame.ini에서 DirectoriesToAlwaysCook로 설정
DataAsset에서 chunk id를 0로 설정한다.
언리얼 엔진 4.27의 DataAsset에 있는 해당 옵션들
Apply Recursively (재귀적 적용): 이 옵션을 활성화하면 선택한 디렉토리 내의 모든 하위 폴더와 파일에 대해서도 변경 사항이 적용됩니다. 즉, 현재 폴더뿐만 아니라 그 안에 포함된 모든 폴더와 에셋에 대해 동일한 설정이 적용됩니다.
Label Assets in My Directories (내 디렉토리의 에셋 라벨링): 이 옵션을 선택하면 현재 프로젝트의 콘텐츠 디렉토리 내에 있는 에셋들에 대해서만 라벨을 적용합니다. 엔진이나 플러그인의 콘텐츠는 제외됩니다.
Is Runtime Label (런타임 라벨 여부): 이 옵션을 활성화하면 해당 라벨이 게임 실행 중에도 사용 가능하도록 설정됩니다. 런타임에 라벨을 통해 에셋을 검색하거나 필터링해야 하는 경우에 유용합니다.
이 옵션들은 주로 에셋 관리와 조직화, 그리고 런타임 시 에셋 접근성을 향상시키는 데 사용됩니다. 프로젝트의 규모와 요구사항에 따라 적절히 설정하면 에셋 관리를 더욱 효율적으로 할 수 있습니다.
보완적 사용: 두 방식은 서로 보완적으로 사용될 수 있음. DirectoriesToAlwaysCook가 전체 디렉토리를 다룬다면, 0RequiredPak은 더 세밀한 제어가 필요한 개별 에셋을 관리함
중복 가능성: 0RequiredPak에 명시된 에셋이 DirectoriesToAlwaysCook에 지정된 디렉토리 내에 있을 수 있음. 이 경우 해당 에셋은 두 번 쿠킹되지 않고, 한 번만 처리됨
우선순위: 일반적으로 0RequiredPak의 설정이 더 구체적이므로, 충돌이 있을 경우 이 설정이 우선적으로 적용됨.
pak0 생성: 두 설정 모두 chunk id가 0인 에셋들을 지정하므로, 이들은 함께 pak0의 내용을 구성하는 데 기여 The required attribute "Include" is empty ...
error MSB4035: The required attribute "Include" is empty or missing from the element &lt;ModulesToBuild&gt;.
RunUAT 실행할 때 -compile 옵션을 없앴음. RunUAT에서 선택적으로 cooking이 되는 거 같지 않음
출처: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://forums.unrealengine.com/t/command-line-compilation-error-uat/467076/9" target="_self">https://forums.unrealengine.com/t/command-line-compilation-error-uat/467076/9</a> 현재 구조에서 맵이 없이 패키징 하는 것이 가능한가? 게임 실행 파일 + pak0만 쿠킹하고 싶음
많은 에셋 쿠킹이 오버라이드를 통해서 진행되어서 파악이 어려움
DefaultGame.ini와 Tables, DataAsset 여러개가 엮어있음
예를들면 CC데이터테이블을 DefaultGame.ini에서 always cook으로 사용함 -&gt;
맵이 패키징됨 Error: CDO Constructor (Canvas): EngineResources/WhiteSquareTexture
-&gt; DefaultGame.ini에서 +DirectoriesToAlwaysCook=(Path="/Game/StarterContent")로 변경 시간이 금.....요일 할 게 있으니까 먼저 우직하게 workspace 2개 만들고맵 없이, 맵 있는 채로먼저 해야할 것젠킨스로 s3 브라우저 자동 업로드 하는 방법 및 Manifest 생성]]></description><link>ue/content-cooking-&amp;-pak-&amp;-chunk.html</link><guid isPermaLink="false">UE/Content Cooking &amp; pak &amp; chunk.md</guid><pubDate>Mon, 30 Dec 2024 15:31:07 GMT</pubDate></item><item><title><![CDATA[Console_Command 등록 하는 법]]></title><description><![CDATA[
IConsoleCommand: 콘솔 명령어
IConsoleManager: 콘솔 명령어를 실행하는 주체
RegisterConsoleCommand: 콘솔 명령어 등록
UnregisterConsoleObject: 콘솔 명령어 해제 virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithArgsDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldAndArgsDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldArgsAndOutputDeviceDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithOutputDeviceDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, uint32 Flags) override; virtual void UnregisterConsoleObject( IConsoleObject* Object, bool bKeepState) override; /** Console command delegate type (takes no arguments.) This is a void callback function. */
DECLARE_DELEGATE( FConsoleCommandDelegate ); /** Console command delegate type (with arguments.) This is a void callback function that always takes a list of arguments. */
DECLARE_DELEGATE_OneParam( FConsoleCommandWithArgsDelegate, const TArray&lt; FString &gt;&amp; ); /** Console command delegate type with a world argument. This is a void callback function that always takes a world. */
DECLARE_DELEGATE_OneParam( FConsoleCommandWithWorldDelegate, UWorld* ); /** Console command delegate type (with a world and arguments.) This is a void callback function that always takes a list of arguments and a world. */
DECLARE_DELEGATE_TwoParams(FConsoleCommandWithWorldAndArgsDelegate, const TArray&lt; FString &gt;&amp;, UWorld*); /** Console command delegate type (with a world arguments and output device.) This is a void callback function that always takes a list of arguments, a world and output device. */
DECLARE_DELEGATE_ThreeParams(FConsoleCommandWithWorldArgsAndOutputDeviceDelegate, const TArray&lt; FString &gt;&amp;, UWorld*, FOutputDevice&amp;); /** Console command delegate type with the output device passed through. */
DECLARE_DELEGATE_OneParam( FConsoleCommandWithOutputDeviceDelegate, FOutputDevice&amp; ); FConsoleCommandDelegate: 인자 없이 실행되는 가장 단순한 콘솔 명령을 위한 델리게이트입니다. FConsoleCommandWithArgsDelegate: 문자열 배열(TArray&lt;FString&gt;&amp;)을 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 사용자가 입력한 추가 인자를 처리할 수 있습니다. FConsoleCommandWithWorldDelegate: UWorld* 타입의 인자를 받는 콘솔 명령을 위한 델리게이트입니다. 현재 게임 월드에 접근해야 하는 명령에 유용합니다. FConsoleCommandWithWorldAndArgsDelegate: 문자열 배열과 UWorld* 포인터를 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 인자와 함께 게임 월드에 접근해야 하는 명령에 사용됩니다. FConsoleCommandWithWorldArgsAndOutputDeviceDelegate: 문자열 배열, UWorld* 포인터, 그리고 FOutputDevice&amp; 참조를 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 출력 장치를 통해 결과를 직접 제어할 수 있는 고급 명령에 사용됩니다. FConsoleCommandWithOutputDeviceDelegate: FOutputDevice&amp; 참조만을 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 출력 제어가 필요하지만 다른 인자는 필요 없는 명령에 사용됩니다. enum EConsoleVariableFlags
{ /* Mask for flags. Use this instead of ~ECVF_SetByMask */ ECVF_FlagMask = 0x0000ffff, /** * Default, no flags are set, the value is set by the constructor */ ECVF_Default = 0x0, /** * Console variables marked with this flag behave differently in a final release build. * Then they are are hidden in the console and cannot be changed by the user. */ ECVF_Cheat = 0x1, /** * Console variables cannot be changed by the user (from console). * Changing from C++ or ini is still possible. */ ECVF_ReadOnly = 0x4, /** * UnregisterConsoleObject() was called on this one. * If the variable is registered again with the same type this object is reactivated. This is good for DLL unloading. */ ECVF_Unregistered = 0x8, /** * This flag is set by the ini loading code when the variable wasn't registered yet. * Once the variable is registered later the value is copied over and the variable is destructed. */ ECVF_CreatedFromIni = 0x10, /** * Maintains another shadow copy and updates the copy with render thread commands to maintain proper ordering. * Could be extended for more/other thread. * Note: On console variable references it assumes the reference is accessed on the render thread only * (Don't use in any other thread or better don't use references to avoid the potential pitfall). */ ECVF_RenderThreadSafe = 0x20, /* ApplyCVarSettingsGroupFromIni will complain if this wasn't set, should not be combined with ECVF_Cheat */ ECVF_Scalability = 0x40, /* those cvars control other cvars with the flag ECVF_Scalability, names should start with "sg." */ ECVF_ScalabilityGroup = 0x80, // ------------------------------------------------ /* Set flags */ ECVF_SetFlagMask = 0x00ff0000, // Use to set a cvar without calling all cvar sinks. Much faster, but potentially unsafe. Use only if you know the particular cvar/setting does not require a sink call ECVF_Set_NoSinkCall_Unsafe =	0x00010000, // ------------------------------------------------ /* to get some history of where the last value was set by ( useful for track down why a cvar is in a specific state */ ECVF_SetByMask = 0xff000000, // the ECVF_SetBy are sorted in override order (weak to strong), the value is not serialized, it only affects it's override behavior when calling Set() // lowest priority (default after console variable creation) ECVF_SetByConstructor = 0x00000000, // from Scalability.ini (lower priority than game settings so it's easier to override partially) ECVF_SetByScalability = 0x01000000, // (in game UI or from file) ECVF_SetByGameSetting = 0x02000000, // project settings (editor UI or from file, higher priority than game setting to allow to enforce some setting fro this project) ECVF_SetByProjectSetting = 0x03000000, // per project setting (ini file e.g. Engine.ini or Game.ini) ECVF_SetBySystemSettingsIni =	0x04000000, // per device setting (e.g. specific iOS device, higher priority than per project to do device specific settings) ECVF_SetByDeviceProfile = 0x05000000, // consolevariables.ini (for multiple projects) ECVF_SetByConsoleVariablesIni = 0x06000000, // a minus command e.g. -VSync (very high priority to enforce the setting for the application) ECVF_SetByCommandline = 0x07000000, // least useful, likely a hack, maybe better to find the correct SetBy... ECVF_SetByCode = 0x08000000, // editor UI or console in game or editor ECVF_SetByConsole = 0x09000000, // ------------------------------------------------
}; ECVF_Default (0x0): 기본값으로, 아무 플래그도 설정되지 않은 상태입니다.
ECVF_Cheat (0x1): 치트 플래그입니다. 최종 릴리스 빌드에서는 콘솔에 숨겨지고 사용자가 변경할 수 없습니다.
ECVF_ReadOnly (0x4): 읽기 전용 플래그입니다. 사용자가 콘솔에서 변경할 수 없지만, C++ 코드나 ini 파일을 통해 변경 가능합니다.
ECVF_Unregistered (0x8): UnregisterConsoleObject()가 호출되어 등록 해제된 상태를 나타냅니다.
ECVF_CreatedFromIni (0x10): ini 파일에서 로드되었지만 아직 등록되지 않은 변수를 나타냅니다.
ECVF_RenderThreadSafe (0x20): 렌더 스레드에서 안전하게 사용할 수 있는 변수임을 나타냅니다.
ECVF_Scalability (0x40): 스케일러빌리티 설정과 관련된 변수임을 나타냅니다.
ECVF_ScalabilityGroup (0x80): 스케일러빌리티 그룹을 제어하는 변수임을 나타냅니다.
ECVF_Set_NoSinkCall_Unsafe (0x00010000): 콜백 없이 빠르게 설정할 수 있는 플래그입니다.
ECVF_SetByXXX 플래그들: 변수가 어디서 설정되었는지를 나타내는 플래그들입니다. 예를 들어 ECVF_SetByConsole은 콘솔에서 설정되었음을 의미합니다.
이 플래그들은 비트 마스크로 사용되어 콘솔 변수의 특성과 동작을 제어합니다. 예를 들어, 치트 변수를 만들려면 ECVF_Cheat 플래그를, 읽기 전용 변수를 만들려면 ECVF_ReadOnly 플래그를 사용할 수 있습니다. ECVF_Default (0x0):
static FConsoleVariableRef CVarDefaultExample( TEXT("example.Default"), DefaultValue, TEXT("An example of a default console variable"), ECVF_Default
); 사용 사례: 특별한 제한이나 동작이 필요 없는 일반적인 콘솔 변수에 사용됩니다. ECVF_Cheat (0x1):
static FConsoleVariableRef CVarInfiniteAmmo( TEXT("cheat.InfiniteAmmo"), bInfiniteAmmo, TEXT("Enables infinite ammo"), ECVF_Cheat
); 사용 사례: 치트나 디버그 목적으로 사용되는 변수에 적용됩니다. ECVF_ReadOnly (0x4):
static FConsoleVariableRef CVarBuildVersion( TEXT("game.BuildVersion"), BuildVersion, TEXT("Current build version"), ECVF_ReadOnly
); 사용 사례: 사용자가 수정해서는 안 되는 정보를 저장하는 변수에 사용됩니다. ECVF_Unregistered (0x8):
// This flag is typically set internally by the engine
SomeConVar-&gt;SetFlags(SomeConVar-&gt;GetFlags() | ECVF_Unregistered); 사용 사례: 콘솔 변수가 언레지스터되었음을 나타냅니다. 주로 내부적으로 사용됩니다. ECVF_CreatedFromIni (0x10):
// This flag is typically set internally by the engine when loading from INI
NewConVar-&gt;SetFlags(NewConVar-&gt;GetFlags() | ECVF_CreatedFromIni); 사용 사례: INI 파일에서 생성된 콘솔 변수를 표시합니다. 주로 내부적으로 사용됩니다. ECVF_RenderThreadSafe (0x20):
static FConsoleVariableRef CVarShadowQuality( TEXT("r.ShadowQuality"), ShadowQuality, TEXT("Controls shadow quality (0-4)"), ECVF_RenderThreadSafe
); 사용 사례: 렌더 스레드에서 안전하게 접근할 수 있는 변수에 사용됩니다. ECVF_Scalability (0x40):
static FConsoleVariableRef CVarViewDistance( TEXT("sg.ViewDistanceQuality"), ViewDistanceQuality, TEXT("Controls view distance quality (0-3)"), ECVF_Scalability
); 사용 사례: 스케일러빌리티 설정의 일부로 사용되는 변수에 적용됩니다. ECVF_ScalabilityGroup (0x80):
static FConsoleVariableRef CVarScalabilityGroup( TEXT("sg.ResolutionQuality"), ResolutionQuality, TEXT("Controls the resolution quality"), ECVF_ScalabilityGroup
); 사용 사례: 다른 스케일러빌리티 설정을 제어하는 그룹 변수에 사용됩니다. ECVF_SetByConstructor (0x00000000):
// This is typically handled internally by the engine
SomeConVar-&gt;Set(InitialValue, ECVF_SetByConstructor); 사용 사례: 변수가 생성자에 의해 초기화되었음을 나타냅니다. ECVF_SetByScalability (0x01000000):
// This would be set when loading scalability settings
TextureQuality-&gt;Set(ScalabilityTextureQuality, ECVF_SetByScalability); 사용 사례: Scalability.ini 파일에서 설정된 값임을 나타냅니다. ECVF_SetByGameSetting (0x02000000):
// This would be set when the user changes a setting in the game menu
AudioVolume-&gt;Set(UserSelectedVolume, ECVF_SetByGameSetting); 사용 사례: 게임 내 설정에서 변경된 값임을 나타냅니다. ECVF_SetByProjectSetting (0x03000000):
// This would be set when loading project settings
MaxFPS-&gt;Set(ProjectMaxFPS, ECVF_SetByProjectSetting); 사용 사례: 프로젝트 설정에서 정의된 값임을 나타냅니다. ECVF_SetBySystemSettingsIni (0x04000000):
// This would be set when loading from Engine.ini or Game.ini
GravityZ-&gt;Set(IniGravityZ, ECVF_SetBySystemSettingsIni); 사용 사례: 시스템 설정 INI 파일에서 로드된 값임을 나타냅니다. ECVF_SetByDeviceProfile (0x05000000):
// This would be set when applying device-specific settings
MobileQualitySettings-&gt;Set(DeviceSpecificQuality, ECVF_SetByDeviceProfile); 사용 사례: 특정 디바이스 프로필에 의해 설정된 값임을 나타냅니다. ECVF_SetByConsoleVariablesIni (0x06000000):
// This would be set when loading from ConsoleVariables.ini
PoolSize-&gt;Set(IniPoolSize, ECVF_SetByConsoleVariablesIni); 사용 사례: ConsoleVariables.ini 파일에서 설정된 값임을 나타냅니다. ECVF_SetByCommandline (0x07000000):
// This would be set when parsing command line arguments
bStartInFullscreen-&gt;Set(CommandLineFullscreen, ECVF_SetByCommandline); 사용 사례: 명령줄 인자로 설정된 값임을 나타냅니다. ECVF_SetByCode (0x08000000):
// This would be set directly in game code
AILogicInterval-&gt;Set(CalculatedInterval, ECVF_SetByCode); 사용 사례: 코드에서 직접 설정된 값임을 나타냅니다. ECVF_SetByConsole (0x09000000):
// This would be set when a user enters a command in the console
DrawDebugLines-&gt;Set(UserInputDebugLines, ECVF_SetByConsole); 사용 사례: 콘솔에서 사용자가 직접 입력하여 설정된 값임을 나타냅니다. 이러한 플래그들은 콘솔 변수의 동작을 제어하고, 값이 어디서 설정되었는지를 추적하는 데 사용됩니다. 이를 통해 개발자는 게임의 다양한 설정과 동작을 효과적으로 관리하고 디버그할 수 있습니다.]]></description><link>ue/console_command-등록-하는-법.html</link><guid isPermaLink="false">UE/Console_Command 등록 하는 법.md</guid><pubDate>Mon, 30 Dec 2024 10:56:57 GMT</pubDate></item><item><title><![CDATA[AGDE와 UE연동]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.android.com/games/agde?hl=ko" target="_self">https://developer.android.com/games/agde?hl=ko</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.android.com/games/agde/quickstart?hl=ko" target="_self">https://developer.android.com/games/agde/quickstart?hl=ko</a>AGDE: Android Game Development Extension.
Visual Studio 다운로드
.NET CORE SDK 2.2 다운
Android SDK 및 NDK 설치
AGDE 설치
AGDE 버전에 맞게 JDK 설정
Android 게임 개발 확장 프로그램은 MSBuild를 호출하여 공유 라이브러리(.so)와 정적 라이브러리(.a)에 C/C++ 소스 코드를 빌드를 함.
Android 플랫폼을 추가
]]></description><link>ue/agde와-ue연동.html</link><guid isPermaLink="false">UE/AGDE와 UE연동.md</guid><pubDate>Mon, 30 Dec 2024 10:44:31 GMT</pubDate></item><item><title><![CDATA[Tip]]></title><description><![CDATA[UnrealPak.exe {추출할 pak 파일 경로} -Extract {추출 되는 경로}
현재 디렉토리와 하위 디렉토리들에서 읽기 전용이 아닌 파일을 찾는 방법Get-ChildItem -Recurse | Where-Object { !$_.PSIsContainer -and !$_.Attributes.HasFlag([System.IO.FileAttributes]::ReadOnly) } | Select-Object FullName
]]></description><link>tip/tip.html</link><guid isPermaLink="false">Tip/Tip.md</guid><pubDate>Mon, 30 Dec 2024 10:36:08 GMT</pubDate></item><item><title><![CDATA[physX]]></title><description><![CDATA[커스텀 물리를 적용하기 위해서 해야할 것?
물리 시뮬레이션 중 onAdvance()을 하이재킹 한 후 그곳에 코드를 작성해야함.PhysX는 물리 시뮬레이션 - 실행단계 - 적용(인터그레이션)를 가짐. // 예시코드 PxScene scene; scene-&gt;simulate(timestep); scene-&gt;fetchResults(true); 시뮬레이션 준비 단계 시뮬레이션 실행 실제 물리 계산 수행
충돌 해결 및 제약 조건 처리
힘과 토크 적용 통합 단계 계산된 물리 상태를 게임 객체에 반영
이벤트 처리 (충돌 콜백 등) PhysScene은 Unreal Engine에서 물리 시뮬레이션이 실행되는 독립된 공간 -&gt; 게임 월드의 물리적 표현PhysScene은 템플릿 클래스로 추상화 되어있음.구현체: PhysScene_Chaos, PhysScene_PhysX[1. 기본 초기화 및 업데이트 함수]void Init()
void Tick(float InDeltaSeconds)
Init(): 물리 씬의 초기 설정을 담당. 메모리 할당, 기본 파라미터 설정 등의 초기화 작업
Tick(): 매 프레임마다 호출되어 물리 시뮬레이션을 업데이트. InDeltaSeconds는 이전 프레임과의 시간 간격입니다.[2. 키네마틱 및 프레임 관련 함수]void SetKinematicUpdateFunction(...)
void SetStartFrameFunction(...)
void SetEndFrameFunction(...)
SetKinematicUpdateFunction:
키네마틱 객체들의 움직임을 제어하는 함수를 설정
애니메이션이나 스크립트로 제어되는 물리 객체의 업데이트를 담당
매개변수: 데이터, 델타 시간, 누적 시간, 반복 횟수SetStartFrameFunction:
각 물리 시뮬레이션 프레임 시작 시 실행될 함수 설정
초기 상태 설정, 데이터 준비 등을 수행SetEndFrameFunction:
각 물리 시뮬레이션 프레임 종료 시 실행될 함수 설정
결과 처리, 상태 저장 등을 수행[3. 물리 객체 생성 및 파라미터 관리]void SetCreateBodiesFunction(...)
void SetParameterUpdateFunction(...)
SetCreateBodiesFunction:
물리 객체(강체, 파티클 등)를 생성하는 함수 설정
새로운 물리 객체가 필요할 때 호출됨
매개변수: 물리 데이터 구조체 참조SetParameterUpdateFunction:
물리 시뮬레이션 파라미터 업데이트 함수 설정
질량, 마찰, 탄성 등의 물리 속성 업데이트
매개변수: 데이터, 델타 시간, 반복 횟수[4. 충돌 및 제약조건 관리]void SetDisableCollisionsUpdateFunction(...)
void AddPBDConstraintFunction(...)
SetDisableCollisionsUpdateFunction:
특정 객체 쌍 간의 충돌을 비활성화하는 함수 설정
매개변수: 충돌 비활성화할 객체 쌍의 인덱스 집합AddPBDConstraintFunction:
Position Based Dynamics 제약조건 추가 함수
물리 기반 애니메이션, 천 시뮬레이션 등에 사용
매개변수: 데이터, 델타 시간[5. 힘 적용 및 구현 접근]void AddForceFunction(...)
ImplType&amp; GetImpl()
AddForceFunction:
물리 객체에 힘을 적용하는 함수 추가
중력, 바람, 폭발 등의 외력 시뮬레이션
매개변수: 데이터, 델타 시간, 반복 횟수GetImpl():
실제 구현체에 대한 접근자
템플릿 구현체의 세부 기능 접근에 사용Unreal Engine에서 사용하는 PhysScene 구현체임. 물리 엔진은 PhysX를 사용.NVIDIA APEX는 PhysX 엔진을 확장한 물리 시뮬레이션 미들웨어[주요 기능]
파괴 시뮬레이션
건물이나 구조물의 사실적인 파괴 효과
동적인 파편(debris) 생성의류 시뮬레이션
캐릭터의 옷감 물리
실시간 의류 변형입자 시스템
연기, 불, 폭발 효과
대규모 입자 시뮬레이션CCD(Continuous Collision Detection, 연속 충돌 감지)
[핵심 개념]
CCD는 고속으로 움직이는 물체들의 충돌을 정확하게 감지하기 위한 물리 시뮬레이션 기술[장점]
정확한 충돌 감지
빠른 물체의 충돌도 놓치지 않음
얇은 물체 통과 현상 방지
더 나은 게임플레이 경험
물리 기반 게임에서 중요
총알, 발사체 등의 정확한 처리
[단점]
성능 오버헤드
더 많은 계산이 필요
모든 물체에 적용하면 성능 저하
ISimEventCallbackFactory를 상속받은 CallbackFactory 구현
실제 콜백 클래스도 구현
팩토리 등록 및 사용
// 커스텀 시뮬레이션 이벤트 콜백 팩토리
class FMySimEventCallbackFactory : public ISimEventCallbackFactory
{
public: // Create 메서드 구현 virtual physx::PxSimulationEventCallback* Create(FPhysScene_PhysX* PhysScene) override { // 새로운 콜백 객체 생성 return new FMySimulationCallback(PhysScene); } // Destroy 메서드 구현 virtual void Destroy(physx::PxSimulationEventCallback* Callback) override { // 콜백 객체 정리 delete Callback; }
}; // 커스텀 시뮬레이션 콜백
class FMySimulationCallback : public physx::PxSimulationEventCallback
{
public: FMySimulationCallback(FPhysScene_PhysX* InPhysScene) : PhysScene(InPhysScene) {} // 충돌 이벤트 처리 virtual void onContact(const physx::PxContactPairHeader&amp; PairHeader, const physx::PxContactPair* Pairs, PxU32 NumPairs) override { // 충돌 처리 로직 UE_LOG(LogPhysics, Log, TEXT("충돌 발생!")); } // 다른 필요한 이벤트 메서드들도 구현 virtual void onConstraintBreak(...) override { } virtual void onWake(...) override { } virtual void onSleep(...) override { } // ... private: FPhysScene_PhysX* PhysScene;
}; // 엔진 초기화 시점에서
void InitializePhysics()
{ // 전역 팩토리 설정 FPhysScene_PhysX::SimEventCallbackFactory = MakeShared&lt;FMySimEventCallbackFactory&gt;();
} Aggregate - 집합체Aggregate(집합체)는 여러 개의 Actor들을 하나의 그룹으로 관리하는 PhysX의 개념[차이점]성능 최적화
Aggregate: 여러 물체를 하나의 broad-phase 영역으로 처리
Actor: 개별적으로 broad-phase 검사 수행메모리 관리
Aggregate: 그룹 단위로 메모리 관리 가능
Actor: 개별적인 메모리 관리 필요메서드 안에서 PhysScene에 대한 플래그를 설정함.PxSceneFlagActive Actors/Transform 관련
eENABLE_ACTIVE_ACTORS // 활성화된 액터 알림 기능
eENABLE_ACTIVETRANSFORMS // 활성화된 트랜스폼 알림 기능
움직이는 물체들의 상태를 추적할 때 사용
성능에 영향을 줄 수 있으므로 필요한 경우에만 활성화
충돌 감지 관련
eENABLE_CCD // 연속 충돌 감지(CCD) 활성화
eDISABLE_CCD_RESWEEP // CCD 재스윕 비활성화
eENABLE_PCM // GJK 기반 거리 충돌 감지
CCD는 고속 이동 물체의 터널링을 방지
PCM은 더 정확한 충돌 감지를 제공
키네마틱 상호작용
eENABLE_KINEMATIC_STATIC_PAIRS // 키네마틱-정적 물체 간 상호작용
eENABLE_KINEMATIC_PAIRS // 키네마틱 물체들 간 상호작용
키네마틱 물체들의 충돌 필터링을 제어
기본적으로는 비활성화
[중요한 성능 관련 플래그]
캐시와 버퍼
eDISABLE_CONTACT_CACHE // 접촉 캐시 비활성화
eDISABLE_CONTACT_REPORT_BUFFER_RESIZE // 접촉 보고 버퍼 크기 조정 비활성화
메모리 사용량과 성능 사이의 균형을 조절
안정성 향상
eENABLE_STABILIZATION // 추가적인 안정화 패스 활성화
eENABLE_AVERAGE_POINT // 접촉 매니폴드의 평균점 활성화PxSceneFlag::eENABLE_ACTIVE_ACTORS; 플래그를 켜야 onAdvance() 하이재킹 가능]]></description><link>physics/physx.html</link><guid isPermaLink="false">physics/physX.md</guid><pubDate>Mon, 30 Dec 2024 10:32:35 GMT</pubDate></item><item><title><![CDATA[Fat Framework]]></title><description><![CDATA[환경 : Apple Silicon (M1), Xcode 14.3Fat Framework 또는 Universal Framework는 xcframework와 다르다. xcframework가 나오기전에 프레임워크를 사용하는 방법은 .framework를 사용하는 것이었다.Xcode에서 프로젝트로 framework를 생성하고 Logger.swift를 만들고 간단한 코드 작성
// Logger.swift import Foundation public class LoggerInFramework { public static func Logging(_ args: String) -&gt; String { debugPrint(args) return args } } 그러고나서 시뮬레이터로 빌드로 하고 Product - Show Build Folder in Finder를 클릭<img alt="framework_path.png" src="images/framework_path.png" target="_self">LoggerFramework.swiftmodule 안에 arm64-apple-ios-simulator가 있는 것을 확인이제 이 프레임워크를 테스트 해보기 위해 새로운 앱 프로젝트를 하나 만듬<br><img alt="hostapp_file.png" src="images/hostapp_file.png" target="_self">위처럼 프레임워크를 네비게이터에 추가해주고 Project - Targets에서 Embed를 Embed &amp; Sign으로 변경하기
// ViewController.swift import UIKit
import LoggerFramework class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() LoggerInFramework.Logging("Hello World") } } Simulator로 빌드 시 성공, 그러나 실제 기기로 빌드 하면 다음과 같은 에러를 뱉음
Could not find module 'LoggerFramework' for target 'arm64-apple-ios'; found: arm64-apple-ios-simulator, at: /Users/psychehose/Study/iOSLaboratory/HostingLoggingFrameworkApp/HostingLoggingFrameworkApp/LoggerFramework.framework/Modules/LoggerFramework.swiftmodule
swiftmodule 안에 arm64-apple-ios-simulator만 존재하기 때문그렇다면 swiftmodule 안에 arm64-apple-ios와 x86_64-apple-ios-simulator가 있다면 M1 Mac과 Intel Mac에서 모두 시뮬레이터를 돌리고 실기기에 빌드할 수 있을 것이다.framework에 저 위의 경우를 다 때려넣어서 만든 것이 Fat Framework이다.Fat Framework를 만드는 법은 Framework 프로젝트에서 Aggreate 타겟을 만들고 script를 짜서 만드는 것이 가장 간단하다.<br><img alt="aggregate.png" src="images/aggregate.png" target="_self">Product 이름은 FatFramework로 만듬
타겟에서 FatFramework - Build Phases에서 Target Dependency Framework (LoggerFramework) 추가하기 버튼 누르고 run script 추가하기 #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal mkdir -p "${UNIVERSAL_OUTPUTFOLDER}" xcodebuild BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS="-fembed-bitcode" -target "${PROJECT_NAME}" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR="${BUILD_DIR}" BUILD_ROOT="${BUILD_ROOT}" clean build xcodebuild BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS="-fembed-bitcode" -target "${PROJECT_NAME}" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR="${BUILD_DIR}" BUILD_ROOT="${BUILD_ROOT}" EXCLUDED_ARCHS="arm64" clean build cp -R "${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework" "${UNIVERSAL_OUTPUTFOLDER}/" cp -R "${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule/." 그리고 FatFramework Scheme을 편집을 누르고 Run에서 Build Configuration을 Release로 변경하고 기기를 Any iOS Device로 하고 빌드한다<br><img alt="sandbox_error.png" src="images/sandbox_error.png" target="_self">위의 에러가 발생하면 Build Setting - User Script Sandboxing을 No로 설정하고 다시 빌드이제 framework의 swiftmodule을 보면 arm64-apple-ios, x86_64-apple-ios-simulator가 있게 된다.
(arm64-apple-ios-simulator가 없는 이유는 스크립트에서 EXCLUDED_ARCHS를 했기 때문)<br><img alt="fatframework_path.png" src="images/fatframework_path.png" target="_self">아까 만든 테스트앱에서 프레임워크를 교체하고 실기기를 빌드하면 성공한다. 그리고 intel mac에서도 simulator로 빌드하면 성공할 것임. 근데 Apple Silicon을 사용하는 맥에서 시뮬레이터로 빌드할 수 없다.swiftmodule에 arm64-apple-ios-simulator를 추가할 수는 있다. 그런데, m1 맥 테스트 앱에서 시뮬레이터로 빌드하면 다음과 같은 에러가 뜬다.<br><img alt="simulator_device_error.png" src="images/simulator_device_error.png" target="_self">왜 이런 이유가 발생할까?Derived Data를 삭제하고, Aggregate가 아닌 프레임워크를 iOS 디바이스, 시뮬레이터 빌드를 각각 하고 프레임워크 path로 가서 손수 lipo 명령어를 사용하자lipo -create -output UniversalFramework.framework/UniversalFramework \ Debug-iphonesimulator/LoggerFramework.framework/LoggerFramework \ Debug-iphoneos/LoggerFramework.framework/LoggerFramework 그러면 아래와 같은 에러가 발생할 것이다.
fatal error: /Library/Developer/CommandLineTools/usr/bin/lipo: Debug-iphonesimulator/LoggerFramework.framework/LoggerFramework and Debug-iphoneos/LoggerFramework.framework/LoggerFramework have the same architectures (arm64) and can't be in the same fat output file
정확한 이유는 아니지만, 위의 에러 로그처럼 simulator와 실제 device의 아키텍쳐가 같아서 프레임워크를 호스팅하는 앱(Test App)이 arm64-apple-ios-simulator를 못찾는 것 같다.그래서 M1 Mac이 등장한 이후로 Fat Framework를 잘 사용하지 않는 것 같다. 대신 대부분의 경우에 xcframework를 사용한다.]]></description><link>ios/fat-framework.html</link><guid isPermaLink="false">iOS/Fat Framework.md</guid><pubDate>Mon, 30 Dec 2024 10:28:12 GMT</pubDate><enclosure url="images/framework_path.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/framework_path.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FIOSView insertText - objc_msgSend]]></title><description><![CDATA[ Crashed: com.apple.main-thread
0 libobjc.A.dylib 0x3020 objc_msgSend + 32
1 U2Client 0x246e35c -[FIOSView insertText:] + 636 (IOSView.cpp:636)
2 U2Client 0x246eaac -[FIOSView unmarkText] + 811 (IOSView.cpp:811)
3 UIKitCore 0xdc95d0 -[UIResponder(UITextInput_Internal) _unmarkText] + 68
4 UIKitCore 0xa7d590 -[UIKBInputDelegateManager unmarkText] + 48
5 UIKitCore 0x4d3e18 -[UIKeyboardImpl _teardownExistingDelegate:forSetDelegate:force:delayEndInputSession:] + 2180
6 UIKitCore 0x4d2808 -[UIKeyboardImpl setDelegate:force:delayEndInputSession:] + 624
7 UIKitCore 0x2c4b68 -[UIKeyboardSceneDelegate _reloadInputViewsForKeyWindowSceneResponder:force:fromBecomeFirstResponder:] + 2584
8 UIKitCore 0x325d3c -[UIKeyboardSceneDelegate _reloadInputViewsForResponder:force:fromBecomeFirstResponder:] + 88
9 UIKitCore 0x364d8c -[UIResponder _finishResignFirstResponderFromBecomeFirstResponder:] + 328
10 UIKitCore 0x3643d0 -[UIResponder resignFirstResponder] + 352
11 U2Client 0x246e8fc -[FIOSView resignFirstResponder] + 740 (IOSView.cpp:740)
12 UIKitCore 0x52cfa8 -[UIView(UITextField) endEditing:] + 136
13 U2Client 0x246e7bc 30-[FIOSView DeactivateKeyboard]_block_invoke + 102 (IOSInputInterface.h:102)
14 libdispatch.dylib 0x213c _dispatch_call_block_and_release + 32
15 libdispatch.dylib 0x3dd4 _dispatch_client_callout + 20
16 libdispatch.dylib 0x125a4 _dispatch_main_queue_drain + 988
17 libdispatch.dylib 0x121b8 _dispatch_main_queue_callback_4CF + 44
18 CoreFoundation 0x56710 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE + 16
19 CoreFoundation 0x53914 CFRunLoopRun + 1996
20 CoreFoundation 0x52cd8 CFRunLoopRunSpecific + 608
21 GraphicsServices 0x11a8 GSEventRunModal + 164
22 UIKitCore 0x40a90c -[UIApplication _run] + 888
23 UIKitCore 0x4be9d0 UIApplicationMain + 340
24 U2Client 0xdb1650 main + 568 (LaunchIOS.cpp:568)
25 ??? 0x1ac721e4c (누락)- (void)insertText:(NSString*)theText
{ if (nil != CachedMarkedText) { [CachedMarkedText release] ; CachedMarkedText = nil; } // insert text one key at a time, as chars, not keydowns for (int32 CharIndex = 0; CharIndex &lt; [theText length]; CharIndex++) { int32 Char = [theText characterAtIndex : CharIndex]; // FPlatformMisc::LowLevelOutputDebugStringf(TEXT("sending key '%c' to game\n"), Char); if (Char == '\n') { // send the enter keypress FIOSInputInterface::QueueKeyInput(KEYCODE_ENTER, Char); // hide the keyboard [self resignFirstResponder] ; } else { FIOSInputInterface::QueueKeyInput(Char, Char); } }
} 원인 예상
이미 해제한 CachedMarkedText를 접근하려고 했기 때문에
theText에 nil 값이 들어오기 때문에
해결
iOS - UI 관련된 작업은 main - thread에서 실행
]]></description><link>error/fiosview-inserttext-objc_msgsend.html</link><guid isPermaLink="false">Error/FIOSView insertText - objc_msgSend.md</guid><pubDate>Mon, 30 Dec 2024 10:23:35 GMT</pubDate></item><item><title><![CDATA[Two Pointer]]></title><description><![CDATA[
두 개의 포인터를 사용하여 배열을 순회하면서 문제를 해결
주로 배열이나 리스트와 같은 선형 자료구조를 다룰 때 사용
시간 복잡도 O(n^2) -&gt; O(n)
예시
정렬된 배열에서 두 수의 합이 특정 값이 되는 쌍 찾기
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt; std::vector&lt;std::pair&lt;int, int&gt;&gt; findAllPairsWithSum(const std::vector&lt;int&gt;&amp; arr, int targetSum) { std::vector&lt;std::pair&lt;int, int&gt;&gt; result; int left = 0; int right = arr.size() - 1; while (left &lt; right) { int currentSum = arr[left] + arr[right]; if (currentSum == targetSum) { result.push_back({arr[left], arr[right]}); // 중복 원소 건너뛰기 while (left &lt; right &amp;&amp; arr[left] == arr[left + 1]) left++; while (left &lt; right &amp;&amp; arr[right] == arr[right - 1]) right--; left++; right--; } else if (currentSum &lt; targetSum) { left++; } else { right--; } } return result;
} int main() { std::vector&lt;int&gt; sortedArray = {1, 2, 3, 4, 5, 5, 6, 7, 8, 9}; int target = 10; auto pairs = findAllPairsWithSum(sortedArray, target); if (!pairs.empty()) { std::cout &lt;&lt; "합이 " &lt;&lt; target &lt;&lt; "인 모든 쌍:" &lt;&lt; std::endl; for (const auto&amp; pair : pairs) { std::cout &lt;&lt; pair.first &lt;&lt; ", " &lt;&lt; pair.second &lt;&lt; std::endl; } } else { std::cout &lt;&lt; "합이 " &lt;&lt; target &lt;&lt; "인 쌍을 찾지 못했습니다." &lt;&lt; std::endl; } return 0;
} 배열에서 중복 요소 제거
#include &lt;iostream&gt;
#include &lt;vector&gt; int removeDuplicates(std::vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int writePointer = 1; for (int readPointer = 1; readPointer &lt; nums.size(); readPointer++) { if (nums[readPointer] != nums[writePointer - 1]) { nums[writePointer] = nums[readPointer]; writePointer++; } } return writePointer;
} int main() { std::vector&lt;int&gt; nums = {1, 1, 2, 2, 3, 4, 4, 5}; int newLength = removeDuplicates(nums); std::cout &lt;&lt; "새로운 배열 길이: " &lt;&lt; newLength &lt;&lt; std::endl; std::cout &lt;&lt; "중복이 제거된 배열: "; for (int i = 0; i &lt; newLength; i++) { std::cout &lt;&lt; nums[i] &lt;&lt; " "; } std::cout &lt;&lt; std::endl; return 0;
} writePointer: 고유한 요소를 쓸 위치를 가리킴
readPointer: 배열을 순회하며 각 요소를 확인 readPointer가 새로운 요소를 발견하면, 그 요소를 writePointer 위치에 씀
미리 readPointer가 들여다보고 중복여부 파악 후 쓸 지 결정 부분 배열의 합이 특정 값이 되는 구간 찾기 (정렬되어 있어야함)
#include &lt;iostream&gt;
#include &lt;vector&gt; std::pair&lt;int, int&gt; findSubarrayWithSum(const std::vector&lt;int&gt;&amp; nums, int targetSum) { int left = 0, right = 0; int currentSum = 0; while (right &lt; nums.size()) { currentSum += nums[right]; while (currentSum &gt; targetSum &amp;&amp; left &lt; right) { currentSum -= nums[left]; left++; } if (currentSum == targetSum) { return {left, right}; } right++; } return {-1, -1}; // 합이 targetSum인 부분 배열을 찾지 못한 경우
} int main() { std::vector&lt;int&gt; nums = {1, 4, 20, 3, 10, 5}; int targetSum = 33; auto result = findSubarrayWithSum(nums, targetSum); if (result.first != -1) { std::cout &lt;&lt; "합이 " &lt;&lt; targetSum &lt;&lt; "인 부분 배열을 찾았습니다: "; std::cout &lt;&lt; "인덱스 " &lt;&lt; result.first &lt;&lt; "부터 " &lt;&lt; result.second &lt;&lt; "까지" &lt;&lt; std::endl; } else { std::cout &lt;&lt; "합이 " &lt;&lt; targetSum &lt;&lt; "인 부분 배열을 찾지 못했습니다." &lt;&lt; std::endl; } return 0;
} left: 부분 배열의 시작을 가리킴.
right: 부분 배열의 끝을 가리킴 현재 부분 배열의 합이 목표값보다 크면 left를 오른쪽으로 이동시켜 합을 줄이고, 작으면 right를 오른쪽으로 이동시켜 합을 늘림 펠린드롬
#include &lt;iostream&gt;
#include &lt;string&gt; bool isPalindrome(const std::string&amp; s) { int left = 0; int right = s.length() - 1; while (left &lt; right) { if (s[left] != s[right]) { return false; } left++; right--; } return true;
} int main() { std::string str1 = "racecar"; std::string str2 = "hello"; std::cout &lt;&lt; str1 &lt;&lt; " 은 팰린드롬" &lt;&lt; (isPalindrome(str1) ? "입니다." : "이 아닙니다.") &lt;&lt; std::endl; std::cout &lt;&lt; str2 &lt;&lt; " 은 팰린드롬" &lt;&lt; (isPalindrome(str2) ? "입니다." : "이 아닙니다.") &lt;&lt; std::endl; return 0;
}
]]></description><link>algorithm/study/two-pointer.html</link><guid isPermaLink="false">Algorithm/Study/Two Pointer.md</guid><pubDate>Mon, 30 Dec 2024 10:20:00 GMT</pubDate></item><item><title><![CDATA[Heap & 우선순위 큐]]></title><description><![CDATA[완전 이진 트리의 일종으로 두가지 조건 충족
완전 이진 트리
최대 힙 (부모 노드값 &gt; 자식 노드값) , 최소 힙 (부모 노드 값 &lt; 자식 노드값)
우선순위 큐는 각 요소가 우선순위를 가지고 있으며, 우선순위가 높은 요소가 먼저 나가는 특수한 큐
힙을 사용하여 효율적으로 구현 가능
삽입 - 새로운 요소를 힙의 마지막에 추가한 후 힙 정렬
삭제 - 힙의 루트 요소를 제거 하고 마지막 요소를 루트로 이동시킨 후 힙 정렬 삽입: O(log n)
삭제 (Olog n)
탐색 (루트 요소 확인): O(1)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; heap = {10, 20, 30, 5, 15}; // 힙으로 변환 std::make_heap(heap.begin(), heap.end()); std::cout &lt;&lt; "Initial max-heap: "; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; std::endl; // 힙에 요소 추가 heap.push_back(99); std::push_heap(heap.begin(), heap.end()); std::cout &lt;&lt; "After adding an element: "; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; std::endl; // 힙에서 최대 요소 제거 std::pop_heap(heap.begin(), heap.end()); heap.pop_back(); std::cout &lt;&lt; "After removing the max element: "; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt; int main() { std::priority_queue&lt;int&gt; pq; // 아래처럼 생성하면 최소힙 // std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; min_pq; // 요소 삽입 pq.push(10); pq.push(20); pq.push(30); pq.push(5); pq.push(15); std::cout &lt;&lt; "Priority queue elements: "; while (!pq.empty()) { std::cout &lt;&lt; pq.top() &lt;&lt; " "; pq.pop(); } std::cout &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt; struct Task { int priority; std::string description; // 커스텀 비교 함수 (작은 값이 높은 우선순위) bool operator&lt;(const Task&amp; other) const { return priority &gt; other.priority; }
}; int main() { std::priority_queue&lt;Task&gt; taskQueue; // 요소 삽입 taskQueue.push({1, "Low priority task"}); taskQueue.push({3, "High priority task"}); taskQueue.push({2, "Medium priority task"}); std::cout &lt;&lt; "Tasks in priority order: "; while (!taskQueue.empty()) { Task t = taskQueue.top(); std::cout &lt;&lt; "(" &lt;&lt; t.priority &lt;&lt; ", " &lt;&lt; t.description &lt;&lt; ") "; taskQueue.pop(); } std::cout &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; class MaxHeap {
private: std::vector&lt;int&gt; heap; void heapifyUp(int index) { while (index &gt; 0) { int parent = (index - 1) / 2; if (heap[index] &gt; heap[parent]) { std::swap(heap[index], heap[parent]); index = parent; } else { break; } } } void heapifyDown(int index) { int size = heap.size(); while (index * 2 + 1 &lt; size) { int left = index * 2 + 1; int right = index * 2 + 2; int largerChild = left; if (right &lt; size &amp;&amp; heap[right] &gt; heap[left]) { largerChild = right; } if (heap[index] &lt; heap[largerChild]) { std::swap(heap[index], heap[largerChild]); index = largerChild; } else { break; } } } public: void insert(int value) { heap.push_back(value); heapifyUp(heap.size() - 1); } int extractMax() { if (heap.empty()) { throw std::runtime_error("Heap is empty"); } int maxValue = heap[0]; heap[0] = heap.back(); heap.pop_back(); heapifyDown(0); return maxValue; } void printHeap() { for (int value : heap) { std::cout &lt;&lt; value &lt;&lt; " "; } std::cout &lt;&lt; std::endl; } void preorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; " "; // 왼쪽 자식 노드 방문 preorderTraversal(2 * index + 1); // 오른쪽 자식 노드 방문 preorderTraversal(2 * index + 2); } void inorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 왼쪽 자식 노드 방문 inorderTraversal(2 * index + 1); // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; " "; // 오른쪽 자식 노드 방문 inorderTraversal(2 * index + 2); } void postorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 왼쪽 자식 노드 방문 postorderTraversal(2 * index + 1); // 오른쪽 자식 노드 방문 postorderTraversal(2 * index + 2); // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; " "; }
}; int main() { MaxHeap heap; heap.insert(10); heap.insert(20); heap.insert(30); heap.insert(5); heap.insert(15); std::cout &lt;&lt; "Heap elements: "; heap.printHeap(); std::cout &lt;&lt; "Preorder traversal: "; heap.preorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Inorder traversal: "; heap.inorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Postorder traversal: "; heap.postorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Extracted max: " &lt;&lt; heap.extractMax() &lt;&lt; std::endl; std::cout &lt;&lt; "Heap after extraction: "; heap.printHeap(); return 0;
}
]]></description><link>algorithm/study/heap-&amp;-우선순위-큐.html</link><guid isPermaLink="false">Algorithm/Study/Heap &amp; 우선순위 큐.md</guid><pubDate>Mon, 30 Dec 2024 10:19:36 GMT</pubDate></item><item><title><![CDATA[DP]]></title><description><![CDATA[
Top down -&gt; 재귀
Bottom up -&gt; 배열 작은 상황을 이용해서 큰 상황을 구할 때 dp[n]을 잘 정의하는 것
관계식, 점화식 잘 세우기
]]></description><link>algorithm/study/dp.html</link><guid isPermaLink="false">Algorithm/Study/DP.md</guid><pubDate>Mon, 30 Dec 2024 10:19:31 GMT</pubDate></item><item><title><![CDATA[2. BLE 프로토콜 스택]]></title><description><![CDATA[BLE stack은 BLE 디바이스의 구조를 나타냄.블루투스 표준에서 정의하고 있는 LE 모드로 동작하는 디바이스가 갖춰야 하는 기능들을 포함하고 있다.<img alt="ble_host_controller.png" src="images/ble_host_controller.png" target="_self">스택은 Host와 Controller로 구성 되어 있음 (Host는 아이폰, Controller는 애플워치, 에어팟 등등)
신호를 송수신하기 위한 하드웨어로 구성
2.4 GHZ ISM 주파수 대역에서 동작
GFSK, FHSS 방식으로 데이터 송수신
주파수 영역 일부를 40개의 구간으로 나누어 신호를 주고 받음 - 각 구간을 채널이라고 함 PHY와 직접적으로 상호 작용하는 레이어
하드웨어와 소프트웨어 사이에서 동작함
하드웨어와 연결되어 BLE 디바이스 간의 연결을 직접적으로 관리
암호, 연결 상태 및 채널 업데이트 등의 역할 수행
<br><img alt="images/ble-link-layer.png" src="images/ble-link-layer.png" target="_self">!BLE 디바이스는 LL에서 하나의 상태로 동작함
Standby
Advertising
Scanning
Initiating
Connected
<br><img alt="ble-connection 1.png" src="images/ble-connection-1.png" target="_self">두 개의 BLE 디바이스가 연결을 할 때의 동작 모습이러한 BLE 연결 과정은 GAP에 의해 관리됨
Host와 Controller가 분리되어 있는 경우 두 모듈 사이의 상호작용을 담당 상위 레이어 (GATT / GAP) 하위 레이어 사이의 상호작용 담당
BLE 패킷에 데이터를 포함하거나, 추출하는 역할
// 상위 레이어와 하위 레이어는 BLE 패킷으로 데이터를 송수신 함<br><img alt="images/ble-l2cap.png" src="images/ble-l2cap.png" target="_self">
Security Manager는 자주 연결하는 디바이스 (Peer) 사이의 보안 코드 (Key)를 관리 배포하는 역할 서버와 클라이언트 사이의 데이터 교환에 대한 규칙
데이터 교환의 주체
정보를 가지고 있는 Device를 GATT server
요청하는 디바이스를 GATT client 연결 및 Advertising 동작을 관리하는 최상위 레이어
각 디바이스의 LL 상태를 결정
서로 다른 BLE 디바이스 사이의 상호 작용을 관리하는 모듈
GAP는 동작 상태 중 하나를 가짐 Broadcaster
Observer
Peripheral
Central
Peripheral (주변기기 - 에어팟과 같은)로 동작하는 디바이스는 LL에서 Advertising 상태를 유지함 일반적으로 Advertising에서 디바이스 이름과 간단한 정보만을 송신한다. 그리고 이러한 Peripheral 디바이스를 Scanning 해서 연결까지 가능한 디바이스를 Central(중앙장치)로서 동작하는 디바이스라고 함.Peripheral 디바이스가 연결 과정 없이 Advertising 동작을 수행하는 경우 이러한 디바이스를 Broadcater라고 한다. 이 때 이름 이외에도 실질적인 데이터를 실어서 전송 이러한 장치를 비콘이라고 부름역시 Central 디바이스가 연결 과정 없이 Scanning 동작만을 수행할 때 Observer라고 일컫고 일반적으로 Advertising 패킷 내의 데이터를 타겟으로 하므로 비콘 신호를 수신할 때 사용한다.]]></description><link>ble/2.-ble-프로토콜-스택.html</link><guid isPermaLink="false">BLE/2. BLE 프로토콜 스택.md</guid><pubDate>Mon, 30 Dec 2024 09:53:41 GMT</pubDate><enclosure url="images/ble_host_controller.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_host_controller.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. BLE 개요]]></title><description><![CDATA[Bluetooth Low Energy (BLE)
WPAN 기술의 일종
Bluetooth 4.0부터 저전력 프로토콜 지원
Bluetooth 5.0부터 확장 기능 제공
BD/EDR과의 차이점
BD/EDR은 데이터 전송 속도와 연속성에 초점 BLE는 전력 소모를 줄이는 것에 초점
BLE는 대량의 정보를 빠르게 전송하는 것보다 소량의 정보를 주기적으로 또는 간헐적으로 보내는 시스템에 적합한 기술응용 분야 - 헬스케어, 무선 센서 네트워크]]></description><link>ble/1.-ble-개요.html</link><guid isPermaLink="false">BLE/1. BLE 개요.md</guid><pubDate>Mon, 30 Dec 2024 09:53:01 GMT</pubDate></item><item><title><![CDATA[5. BLE 적용]]></title><description><![CDATA[
FSeonsorManager는&nbsp;C++ 싱글톤임
FSeonsorManager는&nbsp;GFlexTcpSocketConnection을 프로퍼티로 가지고 있음
외부에서 FSensorManager의 멤버 함수를 통해서&nbsp;GFlexTcpSocketConnection의 멤버 함수를 실행함
센서는&nbsp;GFlexTcpSocketConnection에서 값을 받고&nbsp;FSensorManager의&nbsp;ThrowBallBySensor(SensorShotData); 을 통해서 외부코드 (UI)에게 브로드캐스트함
BLE는 기본적으로 TCP와 같은 명령어를 공유하며 같은 로직을 가지고 있음. 따라서 TCP 로직을 크게 벗어나지 않으나, 몇가지 예외사항 (퍼팅 센서)이 존재한다.
GFlexTcpSocketConnection처럼 로직을 구성하는&nbsp;UBLEConnection 클래스가 있음
BLEConnection은 게임 라이프 사이클에서 계속 살아있어야 하기 때문에 싱글톤으로 만들어야함 -&gt; 언리얼엔진에서 제공하는 Subsystem을 이용해서 UU2BLESystem 만듬
UU2BLESystem는 내부적으로 BLEConnection을 프로퍼티로 가지고 있고 BLEConnection에 있는 함수를 래핑해서 사용함
외부 (UI 로직)에서&nbsp;BLEConnection 함수들을 UU2BLESystem를&nbsp;통해서 호출하고 BLEConnection에서&nbsp;FSeonsorManager의&nbsp;ThrowBallBySensor()를 통해서 값을 브로드캐스팅 해줘야함.
<img alt="ble_configuration.png" src="images/ble_configuration.png" target="_self"> #pragma once #include "CoreMinimal.h" #include "U2Define.h" #include "Subsystems/GameInstanceSubsystem.h" #include "Sensor/NetworkConnectionInterface.h" #include "Sensor/U2SensorInterface.h" #include "U2BLESystem.generated.h" /** * */ UCLASS() class U2CLIENT_API UU2BLESystem : public UGameInstanceSubsystem { GENERATED_BODY() public: UU2BLESystem(); virtual void Initialize(FSubsystemCollectionBase&amp; Collection) override; virtual void Deinitialize() override; UFUNCTION() void ScanForAdvertisement(); UFUNCTION() bool IsExistingConnectableRadar(); UFUNCTION() bool IsExistingConnectablePutt(); /* * Connect To Radar */ UFUNCTION() void ConnectToServer(); /* * Connect To Putt */ UFUNCTION() void RequestConnectPuttingSensor(); /* * Disconnect From Radar */ UFUNCTION() void DisconnectFromServer(); /* * Disconnect From Putt */ UFUNCTION() void DisconnectFromPuttingSensor(); Sensor::ESensorConnectionState GetSensorConnectionState(); Sensor::ESensorConnectionState GetPuttingSensorConnectionState(); /* * */ UFUNCTION() void SubscribeCharacteristic(EBLEDeviceType DeviceType); // FOR Test UFUNCTION() void SendMessageToServer(const FString&amp; InMessageString, EBLEDeviceType DeviceType); // UFUNCTION() void SensorReady(EClubType InClubType, bool bInRightHand = true); private: UPROPERTY() class UBLEConnection* BleConnection = nullptr; };
Server가 의미하는 바는 Radar 센서를 의미하고 PuttingSensor는 Putt이다.&nbsp;외부에서 BLE 기능을 이용할 때 아래와 같이 U2BLESystem을 이용한다.UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;();
FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ConnectToServer(); BLE를 이용하기 위해서는 스캔 - 연결 - Subscribe Characteristic - Write&nbsp;Characteristic를 순서대로 진행 해야 한다. 이 때&nbsp;'비동기적'으로 코드가 실행 되면&nbsp;안된다.&nbsp;또한 각 함수 call에&nbsp;딜레이가 있어야 한다.&nbsp;(매우 중요)아래와 같이 타이머를 사용해서 동기적으로 코드를 실행 해야 한다. 안그러면 BLE는 명령어가 씹힌다. (자세한 예시는 U2UIWifi_Wave_play.cpp를 참고)void UU2UIWifi_Wave_Play::OnClicked_btn_BLE_test() { U2_LOG(BLE, Warning, TEXT("Connect To Server (Radar)")); FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ScanForAdvertisement() // 싱글톤 객체라서 람다 사용 - CreateUObject 안됨 FTimerDelegate ConnectTimerDelegate = FTimerDelegate::CreateLambda([]() { UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;(); if (GameInstance-&gt;BleSystem-&gt;IsExistingConnectableRadar()) { FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ConnectToServer(); } }); SetDelayAndCall(2.0f, ConnectTimerDelegate); FTimerDelegate SubscribeTimerDelegate = FTimerDelegate::CreateLambda([]() { UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;(); if (GameInstance-&gt;BleSystem-&gt;GetSensorConnectionState() == Sensor::ESensorConnectionState::WaitingResult) { FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;SubscribeCharacteristic(EBLEDeviceType::Radar); } }); SetDelayAndCall(5.0f, SubscribeTimerDelegate); } void UU2UIWifi_Wave_Play::OnClicked_btn_NetworkType() { FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ScanForAdvertisement(); FTimerDelegate ConnectTimerDelegate = FTimerDelegate::CreateLambda([]() { UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;(); if (GameInstance-&gt;BleSystem-&gt;IsExistingConnectablePutt()) { FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;RequestConnectPuttingSensor(); } }); SetDelayAndCall(2.0f, ConnectTimerDelegate); FTimerDelegate SubscribeTimerDelegate = FTimerDelegate::CreateLambda([]() { UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;(); if (GameInstance-&gt;BleSystem-&gt;GetPuttingSensorConnectionState() == Sensor::ESensorConnectionState::WaitingResult) { FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;SubscribeCharacteristic(EBLEDeviceType::Putt); } }); SetDelayAndCall(5.0f, SubscribeTimerDelegate); }
초기에 FSesnroManager에 GFlex처럼 프로퍼티로 달았는데 라이프 사이클 이슈 때문에 통합하지 못했음 -&gt; 추후 Subsystem으로 리팩토링 하고 공통으로 GFlex와, BLE를 관리하게 해야한다.]]></description><link>ble/5.-ble-적용.html</link><guid isPermaLink="false">BLE/5. BLE 적용.md</guid><pubDate>Mon, 30 Dec 2024 09:52:27 GMT</pubDate><enclosure url="images/ble_configuration.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_configuration.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4. BLE 디바이스 연결]]></title><description><![CDATA[GAP periphral로 동작하는 디바이스에서 advertising 함 Device Name, Mac Address, TxPower 등과 같은 간단한 정보를 GAP Central로 동작하는 근처 BLE 디바이스에 알리는 동작이다.PHY의 40개 채널 중 3개 (37 ~ 39)를 이용하고 각 채널은 2.4 GHz 대역 중에서도 Wifi 간섭이 가장 적을 것을 예상되는 주파수를 중심 주파수로 가짐<img alt="images/ble-conn-fig-1.png" src="images/ble-conn-fig-1.png" target="_self">GAP Central로 동작하는 디바이스는 BLE 무선 연결을 위해 근처에 연결 가능한 디바이스가 있는지 찾는다. 즉 근처에 Advertising 하고 있는 디바이스를 탐색하는 작업이다. Scanning도 advertising 채널(37 ~ 39) 에 대해 수행한다.<br><img alt="images/ble-conn-fig-2.png" src="images/ble-conn-fig-2.png" target="_self">peripheral 디바이스는 한 번에 3개의 채널을 advertising 하고 central 디바이스는 일정 간격으로 하나의 채널을 scanning 한다.주요 scanning parameter는 scan interval, scan window가 있다.
scan interval은 scanning 시작시간 사이의 간격을 정의한다.scan window는 한 채널에서 실제로 scanning 하는 구간을 정의한다.advertising 채널과 scanning 채널이 일치하는 경우에만&nbsp;Scanner&nbsp;에서 advertising 데이터를 수신할 수 있으며, advertising 시간은 수 ms 인 반면&nbsp;Scanner&nbsp;에서는 수십에서 수백 ms 동안 scanning 동작을 수행한다. 따라서,&nbsp;Scanner&nbsp;에서는 기본적으로&nbsp;Advertiser&nbsp;에 비해 보다 많은 양의 전류를 소비하게 된다.<br><img alt="images/ble-conn-fig-3.png" src="images/ble-conn-fig-3.png" target="_self">peripheral 디바이스에서 advertising 직후 해당 채널의 신호를 수신하는 시간을 갖는다. peripheral 디바이스에서 advertising 주기와 scanning 주기가 겹치는 시점에 채널을 통해서 central 디바이스의 연결 요청 신호 (CREQ: connection request)를 수신하게 되면 무선 연결이 시작된다. 무선 연결이 시작되고나서 먼저 본격적인 데이터 교환 전에 하드웨어 단에서 필요한 파라미터를 포함한 연결 파라미터를 주고 받는다. 또 이 시점에 연결 주기, 타임아웃 시간 등을 정보를 주고 받고 이 파라미터는 대부분 central 디바이스가 결정한다.
다만 peripheral 디바이스도 연결 파라미터를 제안할 수 있다. 제안할 수 있는 항목은 아래와 같다.
minimum connection interval
maximum connection interval
slave latency
connection supervision timeout
advertising 채널을 제외한 37개 채널을 이용해 FHSS 방식으로 데이터를 주고 받는다.연결파라미터에 대한 추가connection interval은 BLE 패킷을 주고 받는 시간 간격이다.
connection supervision timeout은 BLE 디바이스가 연결된 상태에서 얼마 동안 패킷을 교환하지 못할 때 연결을 끊을 것일지 판단하는 값이다.slave latency BLE 디바이스가 무선을 연결된 상태에서의 패킷 교환 주기는 최대 4초이다. 그런데 slava latency 파라미터를 사용하면 연결 주기를 늘릴 수 있다. 무선 연결을 유지하기 위해 교환하는 더미 패킷을 몇 번까지 무시할 것인지 결정하는 파라미터이다.예를 들면 Slave latency 를 이용하면&nbsp;GAP peripheral&nbsp;디바이스에 전송할 유효한 데이터가 없는 경우,&nbsp;GAP central&nbsp;디바이스에 더미 패킷을 전송하는 과정을 건너뛸 수 있고, 따라서 불필요한 전력 소모를 줄일 수 있게 된다. 만약 connection interval 값을 4 secs 로 설정하고, slave latency 를 2 로 설정하는 경우, 유효한 데이터가 없는 상황에서는&nbsp;GAP peripheral&nbsp;디바이스의 더미 패킷 전송을 두 번 스킵할 수 있으므로 연결 주기가 12 secs 정도가 되는 셈이다.]]></description><link>ble/4.-ble-디바이스-연결.html</link><guid isPermaLink="false">BLE/4. BLE 디바이스 연결.md</guid><pubDate>Mon, 30 Dec 2024 06:59:22 GMT</pubDate><enclosure url="images/ble-conn-fig-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. BLE ATT, GATT]]></title><description><![CDATA[ATT는 서버와 클라이언트 사이의 데이터 교환에 대한 규칙이다. 데이터 교환은 ATT를 기반으로 이뤄지고 각각의 데이터 구조는 GATT에 의해 정의 된다.GATT에 의해 정의되는 데이터 구조는 Service와 Characteristic으로 표현된다.<img alt="images/ble-gatt-structure.png" src="images/ble-gatt-structure.png" target="_self">Service는 characteristic의 집합이고 데이터들은 Characteristic에 의해 정의된다.이러한 Service와 Characteristic은 attribute 라는 최소 데이터 유닛에 의해 정의된다. 이러한 attribute에 대한 것들은 attribute table 내에 저장된다.attribute는 type (uuid), handle, permission에 대한 정보를 포함<br><img alt="images/ble-attribute-table.png" src="images/ble-attribute-table.png" target="_self">각 행은 하나의 attribute를 나타냄handle은 attribute의 주소 값에 해당
permission에 service 또는 characteristic의 접근 권한에 대한 정보 저장
UUID는 고유 식별자<br><img alt="images/ble-data-exchange.png" src="images/ble-data-exchange.png" target="_self">데이터를 가지고 있는 디바이스가 GATT Server
요청하는 쪽이 GATT client]]></description><link>ble/3.-ble-att,-gatt.html</link><guid isPermaLink="false">BLE/3. BLE ATT, GATT.md</guid><pubDate>Mon, 30 Dec 2024 06:59:22 GMT</pubDate><enclosure url="images/ble-gatt-structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-gatt-structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Home]]></title><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Sun, 29 Dec 2024 18:26:12 GMT</pubDate></item><item><title><![CDATA[ThreadPool]]></title><description><![CDATA[#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; namespace ThreadPool {
class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); // job 을 추가한다. void EnqueueJob(std::function&lt;void()&gt; job); private: // 총 Worker 쓰레드의 개수. size_t num_threads_; // Worker 쓰레드를 보관하는 벡터. std::vector&lt;std::thread&gt; worker_threads_; // 할일들을 보관하는 job 큐. std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 위의 job 큐를 위한 cv 와 m. std::condition_variable cv_job_q_; std::mutex m_job_q_; // 모든 쓰레드 종료 bool stop_all; // Worker 쓰레드 void WorkerThread();
}; ThreadPool::ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_all(false) { worker_threads_.reserve(num_threads_); for (size_t i = 0; i &lt; num_threads_; ++i) { worker_threads_.emplace_back([this]() { this-&gt;WorkerThread(); }); }
} void ThreadPool::WorkerThread() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(m_job_q_); cv_job_q_.wait(lock, [this]() { return !this-&gt;jobs_.empty() || stop_all; }); if (stop_all &amp;&amp; this-&gt;jobs_.empty()) { return; } // 맨 앞의 job 을 뺀다. std::function&lt;void()&gt; job = std::move(jobs_.front()); jobs_.pop(); lock.unlock(); // 해당 job 을 수행한다 :) job(); }
} ThreadPool::~ThreadPool() { stop_all = true; cv_job_q_.notify_all(); for (auto&amp; t : worker_threads_) { t.join(); }
} void ThreadPool::EnqueueJob(std::function&lt;void()&gt; job) { if (stop_all) { throw std::runtime_error("ThreadPool 사용 중지됨"); } { std::lock_guard&lt;std::mutex&gt; lock(m_job_q_); jobs_.push(std::move(job)); } cv_job_q_.notify_one();
} } // namespace ThreadPool void work(int t, int id) { printf("%d start \n", id); std::this_thread::sleep_for(std::chrono::seconds(t)); printf("%d end after %ds\n", id, t);
} int main() { ThreadPool::ThreadPool pool(3); for (int i = 0; i &lt; 10; i++) { pool.EnqueueJob([i]() { work(i % 3 + 1, i); }); }
}
한계: 우리가 전달한 함수가 어떠한 값을 리턴할 때 입니다. 물론 그 함수에 포인터로 리턴값을 저장할 변수를 전달하면 되기는 합니다. 하지만, 기존의&nbsp;future&nbsp;처럼 그 값이 설정될 때 까지 기다리는 것은 불가능따라서 더 나은 구조로는&nbsp;EnqueueJob&nbsp;함수가 임의의 형태의 함수를 받고, 그 함수의 리턴값을 보관하는&nbsp;future&nbsp;를 리턴#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; namespace ThreadPool {
class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); // job 을 추가한다. template &lt;class F, class... Args&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; EnqueueJob( F f, Args... args); private: // 총 Worker 쓰레드의 개수. size_t num_threads_; // Worker 쓰레드를 보관하는 벡터. std::vector&lt;std::thread&gt; worker_threads_; // 할일들을 보관하는 job 큐. std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 위의 job 큐를 위한 cv 와 m. std::condition_variable cv_job_q_; std::mutex m_job_q_; // 모든 쓰레드 종료 bool stop_all; // Worker 쓰레드 void WorkerThread();
}; ThreadPool::ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_all(false) { worker_threads_.reserve(num_threads_); for (size_t i = 0; i &lt; num_threads_; ++i) { worker_threads_.emplace_back([this]() { this-&gt;WorkerThread(); }); }
} void ThreadPool::WorkerThread() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(m_job_q_); cv_job_q_.wait(lock, [this]() { return !this-&gt;jobs_.empty() || stop_all; }); if (stop_all &amp;&amp; this-&gt;jobs_.empty()) { return; } // 맨 앞의 job 을 뺀다. std::function&lt;void()&gt; job = std::move(jobs_.front()); jobs_.pop(); lock.unlock(); // 해당 job 을 수행한다 :) job(); }
} ThreadPool::~ThreadPool() { stop_all = true; cv_job_q_.notify_all(); for (auto&amp; t : worker_threads_) { t.join(); }
} template &lt;class F, class... Args&gt;
std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; ThreadPool::EnqueueJob( F f, Args... args) { if (stop_all) { throw std::runtime_error("ThreadPool 사용 중지됨"); } using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto job = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(std::bind(f, args...)); std::future&lt;return_type&gt; job_result_future = job-&gt;get_future(); { std::lock_guard&lt;std::mutex&gt; lock(m_job_q_); jobs_.push([job]() { (*job)(); }); } cv_job_q_.notify_one(); return job_result_future;
} } // namespace ThreadPool int work(int t, int id) { printf("%d start \n", id); std::this_thread::sleep_for(std::chrono::seconds(t)); printf("%d end after %ds\n", id, t); return t + id;
} int main() { ThreadPool::ThreadPool pool(3); std::vector&lt;std::future&lt;int&gt;&gt; futures; for (int i = 0; i &lt; 10; i++) { futures.emplace_back(pool.EnqueueJob(work, i % 3 + 1, i)); } for (auto&amp; f : futures) { printf("result : %d \n", f.get()); }
}
EnqueueJob&nbsp;함수의 경우 인자들의 복사본을 받는다는 것 하지만 이는 불필요한 복사를 야기하므로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/228" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/228" target="_self">완벽한 전달</a>&nbsp;패턴을 사용EnqueueJob 파라미터에서 우측값 레퍼런스로 변경, bind 함수에 forward로 인자 전달#include &lt;condition_variable&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); template &lt;class F, class... Args&gt; std::future&lt;typename std::invoke_result&lt;F, Args...&gt;::type&gt; EnqueueJob( F&amp;&amp; f, Args&amp;&amp;... args) { if (stop_all) { throw std::runtime_error("ThreadPool is stopped"); } using return_type = typename std::invoke_result&lt;F, Args...&gt;::type; auto job = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)); std::future&lt;return_type&gt; job_result_future = job-&gt;get_future(); jobs_.push([job]() { (*job)(); }); cv_job_q_.notify_one(); return job_result_future; } private: size_t num_threads_; std::vector&lt;std::thread&gt; worker_threads_; std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; std::condition_variable cv_job_q_; std::mutex m_job_q_; bool stop_all; void WorkerThread(); };
ThreadPool은 Thread에 일을 시키는 거야. 그러니까 Thread에 일을 시키기 위해서는 어떤 일을 할당할 지 함수를 매개변수로 넘겨 줘야해. c에서는 이걸 함수 포인터로 처리해 하지만 c++에서는 다른 방법이 있어. (1.이 부분을 좀 더 풀어서 설명하고 싶어. 지금과 같은 상황에서는 어떤 용어를 써야하지? )
그걸 템플릿 메서드를 이용해서 F f 로 받을거야.
우리가 넘겨줄 함수 f에는 매개변수가 들어갈수도 있어. 이 매개변수를 처리하기 위해 파라미터 팩을 이용할거야. class ... Args를 이용해서 함수 f의 매개변수의 값을 받는거지.return type은 비동기 처리를 위해서 future로 설정했어.
(2.이 부분이 비동기 처리를 위해서 future를 사용했는 지 확실하지 않아.)
그리고 invoke_result 함수를 통해서 함수 f의 리턴 값을 추론 할 수 있어.invoke_result를 이용해서 함수 f의 리턴 값 추론 하고 비동기 지원을 위해 future에 담아서 return 하는거지. (3.만약 future가 아니라면 어떻게 될까?)이제 함수 내용을 살펴보자stop_all 플래그가 이미 true면 runtime_error를 던져주자.리턴 타입이 너무 길어 그래서 using을 이용해서 return_type을 정의할게.이제 우리는 함수 f, f에 들어갈 파라미터 args, 그리고 함수 f의 리턴값이 준비되었어.이제 job을 만들거야. 이걸 shared_ptr로 만들자.
(4. 왜 인지 보충 설명이 필요해) 타입은 std::packaged_task&lt;return_type()&gt;이거야. (5.return_type을 packaged_task로 감싼 이유를 알려줘. 그냥 return_type을 사용하면 안되는건지..)그리고 bind 함수를 통해서 f와, args를 결합할거야.job_result_future = job-&gt;get_future();를 해서 패키지된 task에서 future를 추출했어.<br>(6. jobs_.push(<a data-tooltip-position="top" aria-label="" rel="noopener nofollow" class="external-link is-unresolved" href="" target="_self">job</a> { (*job)(); });를 하는 이유가 뭘까? 이 부분은 문법적으로 이해가 잘 가지 않아.)그런 다음에 job_result_future을 리턴할거야.main에서 사용법을 보자. EnqueueJob을 하고 값을 futres에 넣을거야.
futures는 job_result_future를 원소로 가지고 있고 이걸 .get을 하면 그 함수 내용이 실행될거야. get을 하면 함수가 실행되니까.
C와 C++의 함수 처리 방식 차이에 대해 설명하자면: C에서는 함수 포인터를 사용해서 콜백 함수를 전달하는데, 이는 문법이 복잡하고 타입 안전성이 떨어집니다. 반면 C++에서는 std::function이라는 개념을 사용합니다. 이것을 "함수 객체" 또는 "콜러블(callable) 객체"라고 부릅니다.
std::function은 일반 함수, 멤버 함수, 람다 함수 등 모든 종류의 호출 가능한 객체를 저장할 수 있어서 더 유연하고 안전합니다.
future의 비동기 처리 역할: 네, 정확합니다. std::future는 비동기 작업의 결과를 나중에 가져올 수 있게 해주는 객체입니다. 쓰레드 풀에서 작업이 완료되면, 그 결과를 future를 통해 메인 쓰레드에서 받아올 수 있습니다.
future를 사용하지 않았다면: 만약 future를 사용하지 않았다면: 작업의 완료 여부를 알 수 없습니다
작업의 결과값을 받아올 방법이 없습니다
작업이 실패했을 때 예외 처리를 할 수 없습니다
비동기 작업의 동기화가 매우 어려워집니다 shared_ptr을 사용하는 이유: shared_ptr을 사용하는 이유는 메모리 관리 때문입니다. job은 여러 쓰레드에서 공유될 수 있고, 마지막 쓰레드가 작업을 완료했을 때 자동으로 메모리가 해제되어야 합니다. shared_ptr은 이런 참조 카운팅을 자동으로 처리해줍니다.
packaged_task를 사용하는 이유: std::packaged_task는 함수와 그 결과를 연결해주는 래퍼(wrapper)입니다. 이것을 사용하는 이유는: 함수의 실행을 지연시킬 수 있습니다
함수의 결과를 future를 통해 받을 수 있습니다
예외 처리를 안전하게 할 수 있습니다
그냥 return_type만 사용하면 이런 기능들을 구현할 수 없습니다.
jobs_.push(job { (*job)(); }); 설명: 이 부분은 람다 함수를 만들어 큐에 push하는 것입니다. [job]은 람다 함수가 캡처할 변수입니다 (job을 람다 안에서 사용하기 위함)
()는 람다 함수의 매개변수입니다 (여기서는 없음)
{ (*job)(); }는 람다 함수의 본문입니다
이렇게 하는 이유는 job(packaged_task)을 나중에 실행하기 위해서입니다. 실제 실행은 WorkerThread에서 이루어집니다.왜 Mutex가 필요한지// mutex가 없다면 발생할 수 있는 문제 예시
std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 공유 자원 // 쓰레드 1이 작업을 추가하려고 함
jobs_.push(new_job); // 이 순간에 // 쓰레드 2가 작업을 가져가려고 함
auto job = jobs_.front(); // 동시 접근! 데이터 손상 발생!
왜 꼭 packaged_task를 사용해야하는 지 - 함수 실행 지연 &amp; 예외처리packaged_task는 "작업의 패키징"이 주 목적이고, future는 "결과값을 받는 것"이 주 목적// 1. std::future만 사용할 경우
std::future&lt;int&gt; future = std::async(작업함수);
// 이 시점에서 작업이 이미 시작됨! // 2. std::packaged_task 사용
std::packaged_task&lt;int()&gt; task(작업함수);
std::future&lt;int&gt; future = task.get_future();
// 이 시점에서는 작업이 시작되지 않음
// 나중에...
task(); // 이 시점에 작업 시작
[ThreadPool에서 필요한 이유]
작업 큐잉(Queueing)class ThreadPool { std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 작업 대기열 // packaged_task를 사용하면: void addJob(std::packaged_task&lt;int()&gt; task) { jobs_.push([task = std::move(task)]() { task(); // 나중에 실행 가능 }); }
};
// ThreadPool이 하는 일:
1. 작업 받기
auto future = pool.EnqueueJob(work, args...); 2. 내부적으로는:
- packaged_task로 작업을 감싸서
- 큐에 저장했다가
- worker 쓰레드가 나중에 실행 // future만 사용하면:
- 작업이 즉시 시작되어 버림
- 큐잉이 불가능
- 쓰레드 풀의 의미가 없어짐
WorkerThread()에서 job(); 할 때 실제 실행// 1. main에서:
auto future = pool.EnqueueJob(work, 1, 2); // 2. EnqueueJob 내부:
jobs_.push([task]() { (*task)(); }); // 3. WorkerThread에서:
job(); // 실제로 work(1, 2)가 실행되는 시점!
]]></description><link>cpp/threadpool.html</link><guid isPermaLink="false">CPP/ThreadPool.md</guid><pubDate>Sun, 29 Dec 2024 06:35:25 GMT</pubDate></item><item><title><![CDATA[비동기, promise & future, callback, async, ThreadPool]]></title><description><![CDATA[
개념: "나중에 끝날 작업을 시작하고, 다른 일을 하는 것"
일종의 프로그래밍 패러다임
Promise &amp; Future, Callback은 비동기를 구현하는 서로 다른 방식
// 상황: 오래 걸리는 파일 읽기 작업 // 1. Promise/Future 방식
std::future&lt;string&gt; readFile(string path) { return std::async([path]() { // 파일 읽기 return content; });
} // 사용
auto future = readFile("data.txt");
// 다른 작업 수행
string content = future.get(); // 필요할 때 결과를 가져옴 // 2. Callback 방식
void readFile(string path, function&lt;void(string)&gt; callback) { std::thread([path, callback]() { // 파일 읽기 callback(content); // 완료되면 callback 호출 }).detach();
} // 사용
readFile("data.txt", [](string content) { // 여기서 결과 처리
}); 결과 처리 방식 Promise/Future: 결과가 필요한 시점에 우리가 직접 가져옴 (get)
Callback: 결과가 준비되면 자동으로 호출 코드 구조 Promise/Future: 선형적
Callback: 중첩될 수록 복잡 예외처리
// Promise/Future
try { auto result = future.get();
} catch (exception&amp; e) { // 에러 처리
} // Callback
readFile("data.txt", [](string content) { /* 성공 처리 */ }, [](error_code e) { /* 에러 처리 */ }
); Promise/Future 선호 상황 결과를 특정 시점에 확실히 필요로 할 때
여러 비동기 작업의 결과를 한번에 모아야 할 때
예외 처리가 중요할 때 Callback 선호 상황 이벤트 기반 프로그래밍
GUI 프로그래밍
결과를 즉시 처리해야 할 때 std::async는 C++11에서 도입된 고수준 비동기 실행 도구. 쓰레드 생성과 관리를 자동으로 처리해주는 편리한 함수// 기본적인 async 사용
std::future&lt;int&gt; result = std::async([]() { return 42; // 비동기로 실행될 작업
});
[async의 장점]
쓰레드 관리 자동화 직접 std::thread를 생성/관리할 필요가 없습니다
리소스 정리가 자동으로 이루어집니다. 예외 처리 용이
try { auto future = std::async([]() { throw std::runtime_error("에러 발생!"); }); future.get(); // 예외가 여기서 캐치됩니다
} catch (const std::exception&amp; e) { std::cout &lt;&lt; "에러: " &lt;&lt; e.what() &lt;&lt; std::endl;
}
[std::async vs ThreadPool] std::async 간단한 비동기 작업에 적합
시스템이 쓰레드 관리
작업량이 적을 때 사용 ThreadPool 많은 작업을 효율적으로 처리
쓰레드 재사용으로 성능 향상
대규모 작업에 적합 ]]></description><link>cpp/비동기,-promise-&amp;-future,-callback,-async,-threadpool.html</link><guid isPermaLink="false">CPP/비동기, promise &amp; future, callback, async, ThreadPool.md</guid><pubDate>Sun, 29 Dec 2024 06:28:13 GMT</pubDate></item><item><title><![CDATA[future, async, promise]]></title><description><![CDATA[c++ 초기에는 비동기 하려면 쓰레드로 직접 했어야 했다.c++11 std에서 도구 제공 되기 시작.동기적 실행으로 하고 싶은 일은, 어떠한 데이터를 다른 쓰레드를 통해 처리해서 받아내는 것
어떤 쓰레드 T 를 사용해서, 비동기적으로 값을 받아내겠다 라는 의미는,&nbsp;미래에 (future) 쓰레드 T 가 원하는 데이터를 돌려 주겠다 라는 약속 (promise) 라고 볼 수 있습니다.#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
using std::string; void worker(std::promise&lt;string&gt;* p) { // 약속을 이행하는 모습. 해당 결과는 future 에 들어간다. p-&gt;set_value("some data");
}
int main() { std::promise&lt;string&gt; p; // 미래에 string 데이터를 돌려 주겠다는 약속. std::future&lt;string&gt; data = p.get_future(); std::thread t(worker, &amp;p); // 미래에 약속된 데이터를 받을 때 까지 기다린다. data.wait(); // wait 이 리턴했다는 뜻이 future 에 데이터가 준비되었다는 의미. // 참고로 wait 없이 그냥 get 해도 wait 한 것과 같다. std::cout &lt;&lt; "받은 데이터 : " &lt;&lt; data.get() &lt;&lt; std::endl; t.join(); }
promise&nbsp;객체는 자신이 가지고 있는&nbsp;future&nbsp;객체에 값을 넣어주게 됩니다.
대응되는&nbsp;future&nbsp;객체의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수를 통해 얻어낼 수 있습니다. 한 가지 중요한 점은&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 값을 전달하기 전 까지&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수가 기다린다는 점입니다.&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수가 리턴을 하였다면&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 통해서&nbsp;future&nbsp;에 전달된 객체를 얻을 수 있습니다.<br>참고로 굳이&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수를 따로 호출할 필요는 없는데,&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수를 바로 호출하더라도 알아서&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 객체를 전달할 때 까지 기다린다음에 리턴합니다. 참고로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 호출하면&nbsp;future&nbsp;내에 있던 데이터가 이동 됩니다. 따라서&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 다시 호출하면 안됩니다.`future`&nbsp;에서 get 을 호출하면, 설정된 객체가&nbsp;이동&nbsp;됩니다. 따라서 절대로&nbsp;get을 두 번 호출하면 안됩니다.
<br>그냥&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;을 하였다면&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 전달할 때 까지 기다리게 됩니다. 하지만&nbsp;wait_for&nbsp;을 사용하면, 정해진 시간 동안만 기다리고 그냥 진행할 수 있습니다.#include &lt;chrono&gt;
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt; void worker(std::promise&lt;void&gt;* p) { std::this_thread::sleep_for(std::chrono::seconds(10)); p-&gt;set_value();
}
int main() { // void 의 경우 어떠한 객체도 전달하지 않지만, future 가 set 이 되었냐 // 안되었느냐의 유무로 마치 플래그의 역할을 수행할 수 있습니다. std::promise&lt;void&gt; p; // 미래에 string 데이터를 돌려 주겠다는 약속. std::future&lt;void&gt; data = p.get_future(); std::thread t(worker, &amp;p); // 미래에 약속된 데이터를 받을 때 까지 기다린다. while (true) { std::future_status status = data.wait_for(std::chrono::seconds(1)); // 아직 준비가 안됨 if (status == std::future_status::timeout) { std::cerr &lt;&lt; "&gt;"; } // promise 가 future 를 설정함. else if (status == std::future_status::ready) { break; } } t.join();
}
future_status&nbsp;는 총 3 가지 상태를 가질 수 있습니다. 먼저&nbsp;future&nbsp;에 값이 설정 됬을 때 나타나는&nbsp;future_status::ready&nbsp;가 있고,&nbsp;wait_for&nbsp;에 지정한 시간이 지났지만 값이 설정되지 않아서 리턴한 경우에는&nbsp;future_status::timeout&nbsp;이 리턴됩니다.마지막으로&nbsp;future_status::deferred&nbsp;가 있는데 이는 결과값을 계산하는 함수가 채 실행되지 않았다는 의미인데, 뒤에서 좀더 자세히 다루도록 하겠습니다.<br>앞서&nbsp;future&nbsp;의 경우 딱 한 번만&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 할 수 있다고 하였습니다. 왜냐하면&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 호출하면&nbsp;future&nbsp;내부의 객체가 이동되기 때문<br>but 종종 여러 개의 다른 쓰레드에서&nbsp;future&nbsp;를&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;할 필요성이 있음#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using std::thread; void runner(std::shared_future&lt;void&gt; start) { start.get(); std::cout &lt;&lt; "출발!" &lt;&lt; std::endl;
} int main() { std::promise&lt;void&gt; p; std::shared_future&lt;void&gt; start = p.get_future(); thread t1(runner, start); thread t2(runner, start); thread t3(runner, start); thread t4(runner, start); // 참고로 cerr 는 std::cout 과는 다르게 버퍼를 사용하지 않기 때문에 터미널에 // 바로 출력된다. std::cerr &lt;&lt; "준비..."; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cerr &lt;&lt; "땅!" &lt;&lt; std::endl; p.set_value(); t1.join(); t2.join(); t3.join(); t4.join();
}
C++ 에서는 위&nbsp;promise-future&nbsp;패턴을 비동기적 함수(정확히는 Callable - 즉 람다 함수, Functor 포함) 의 리턴값에 간단히 적용할 수 있는&nbsp;packaged_task&nbsp;라는 것을 지원<br>
<img alt="cpp_14.png" src="images/cpp_14.png" target="_self">#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt; int some_task(int x) { return 10 + x; } int main() { // int(int) : int 를 리턴하고 인자로 int 를 받는 함수. (std::function 참조) std::packaged_task&lt;int(int)&gt; task(some_task); std::future&lt;int&gt; start = task.get_future(); std::thread t(std::move(task), 5); std::cout &lt;&lt; "결과값 : " &lt;&lt; start.get() &lt;&lt; std::endl; t.join();
}
<br>생성된&nbsp;packaged_task&nbsp;를 쓰레드에 전달하면 됩니다. 참고로&nbsp;packaged_task&nbsp;는 복사 생성이 불가능하므로 (promise&nbsp;도 마찬가지 입니다.) 명시적으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/301" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/301" target="_self">move</a>&nbsp;해줘야만 합니다.<br>비동기적으로 실행된 함수의 결과값은 추후에&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수로 받을 수 있게 됩니다. 이와 같이&nbsp;packaged_task&nbsp;를 사용하게 된다면 쓰레드에 굳이&nbsp;promise&nbsp;를 전달하지 않아도 알아서&nbsp;packaged_task&nbsp;가 함수의 리턴값을 처리해줘서 매우 편리 -&gt; some_task 함수에 set_value() 같은 거 없음std::async&nbsp;에 어떤 함수를 전달한다면, 아예 쓰레드를 알아서 만들어서 해당 함수를 비동기적으로 실행하고, 그 결과값을&nbsp;future&nbsp;에 전달즉 thread 만들 필요 없음parallel&nbsp;함수는 1 부터 1000 까지의 덧셈을 총 2 개의 쓰레드에서 실행한다고 보면 됩니다. 1 부터 500 까지의 합은,&nbsp;async&nbsp;를 통해 생성된 새로운 쓰레드에서 더하게 되고, 나머지 501 부터 1000 까지의 합은 원래의 쓰레드에서 처리하게 되죠.#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; // std::accumulate 와 동일
int sum(const std::vector&lt;int&gt;&amp; v, int start, int end) { int total = 0; for (int i = start; i &lt; end; ++i) { total += v[i]; } return total;
} int parallel_sum(const std::vector&lt;int&gt;&amp; v) { // lower_half_future 는 1 ~ 500 까지 비동기적으로 더함 // 참고로 람다 함수를 사용하면 좀 더 깔끔하게 표현할 수 도 있다. // --&gt; std::async([&amp;v]() { return sum(v, 0, v.size() / 2); }); std::future&lt;int&gt; lower_half_future = std::async(std::launch::async, sum, cref(v), 0, v.size() / 2); // upper_half 는 501 부터 1000 까지 더함 int upper_half = sum(v, v.size() / 2, v.size()); return lower_half_future.get() + upper_half;
} int main() { std::vector&lt;int&gt; v; v.reserve(1000); for (int i = 0; i &lt; 1000; ++i) { v.push_back(i + 1); } std::cout &lt;&lt; "1 부터 1000 까지의 합 : " &lt;&lt; parallel_sum(v) &lt;&lt; std::endl;
}
async&nbsp;함수는 인자로 받은 함수를 비동기적으로 실행한 후에, 해당 결과값을 보관할&nbsp;future&nbsp;를 리턴합니다. 첫 번째 인자로는 어떠한 형태로 실행할지를 전달하는데 두 가지 값이 가능합니다.
std::launch::async&nbsp;: 바로 쓰레드를 생성해서 인자로 전달된 함수를 실행한다. <br>std::launch::deferred&nbsp;:&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수가 호출되었을 때 실행한다. (새로운 쓰레드를 생성하지 않음) <br>즉&nbsp;launch::async&nbsp;옵션을 주면 바로 그 자리에서 쓰레드를 생성해서 실행하게 되고,&nbsp;launch::deferred&nbsp;옵션을 주면,&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 하였을 때 비로소 (동기적으로) 실행하게 됩니다. 다시 말해, 해당 함수를 굳이 바로 당장 비동기적으로 실행할 필요가 없다면&nbsp;deferred&nbsp;옵션을 주면 됩니다.]]></description><link>cpp/future,-async,-promise.html</link><guid isPermaLink="false">CPP/future, async, promise.md</guid><pubDate>Fri, 27 Dec 2024 14:41:28 GMT</pubDate><enclosure url="images/cpp_14.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_14.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_14]]></title><description><![CDATA[<img src="images/cpp_14.png" target="_self">]]></description><link>images/cpp_14.html</link><guid isPermaLink="false">images/cpp_14.png</guid><pubDate>Fri, 27 Dec 2024 14:19:22 GMT</pubDate><enclosure url="images/cpp_14.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_14.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[memory order, atomic]]></title><description><![CDATA[CPU 와 컴퓨터 메모리인 RAM 은 물리적으로 떨어져 있습니다. 따라서 CPU 가 메모리에서 데이터를 읽어 오기 위해서는 꽤 많은 시간이 걸립니다. 실제로, 인텔의 i7-6700 CPU 의 경우 최소 42 사이클 정도 걸린다고 보시면 됩니다. CPU 에서 덧셈 한 번을 1 사이클에 끝낼 수 있는데, 메모리에서 데이터 오는 것을 기다리느라, 42 번 덧셈을 연산할 시간을 놓치게 되는 것CPU 에서 연산을 수행하는 부분이랑 거의 붙어 있다 싶이 해서, 읽기 / 쓰기 속도가 매우 빠르다는 점입니다.
CPU 에서 가장 많이 접근하는 메모리 영역은 L1 캐시에 가져다 놓게 되고, 그 다음으로, 자주 접근하는 부분은 L2, 마지막으로 L3 캐시 순임CPU 가 특정한 주소에 있는 데이터에 접근하려 한다면, 일단 캐시에 있는지 확인한 후, 캐시에 있다면 해당 값을 읽고, 없다면 메모리 까지 갔다 오는 방식으로 진행됩니다. 이렇게 캐시에 있는 데이터를 다시 요청해서 시간을 절약하는 것을&nbsp;Cache hit&nbsp;이라과 하며 반대로 캐시에 요청한 데이터가 없어서 메모리 까지 갔다 오는 것을&nbsp;Cache miss&nbsp;라고 부릅니다.&nbsp;CPU 가 어떻게 어느 영역의 메모리에 자주 접근할 지 어떻게 아는 것일까요? 답은&nbsp;알 수 없다&nbsp;입니다. 따라서 보통 CPU 에서 캐시가 작동하는 방식은 다음과 같습니다.&nbsp;
메모리를 읽으면 일단 캐시에 저장해놓는다.
만일 캐시가 다 찼다면 특정한 방식에 따라 처리한다. (LRU: Least Recently Used)
예를 들어서 캐시 크기가 1 KB 밖에 안되고 LRU 방식을 사용하는 CPU 가 있다고 했을 때 첫 번째 코드가 더 빠르게 작동할까요? 아니면 두 번째 코드가 더 빨리 작동할까요? 두 코드는 동일한 연산을 수행합니다.for (int i = 0; i &lt; 10000; i++) { for (int j = 0; j &lt; 10000; j++) { s += data[j]; }
}
for (int j = 0; j &lt; 10000; j++) { for (int i = 0; i &lt; 10000; i++) { s += data[j]; }
}
답은 두 번째 방식입니다. 왜냐하면 첫 번째 경우에서&nbsp;data[0]&nbsp;를 접근하는 것을 생각해봅시다. 일단 첫 번째 루프에서&nbsp;data[0]&nbsp;는 캐시에 들어가게 됩니다. 하지만, CPU 캐시가 매우 작기 때문에&nbsp;j = 256&nbsp;이 되었을 때&nbsp;data[0]&nbsp;는 캐시에서 사라지게 되지요 (1KB = 1024 byte = int 256 개).따라서&nbsp;i = 1&nbsp;인 루프에서&nbsp;data[0]&nbsp;에 다시 접근했을 때 이미&nbsp;data[0]&nbsp;는 캐시에서 사라진 이후기에 Cache Miss 가 발생하게 됩니다. 따지고 보면&nbsp;data&nbsp;원소의 모든 접근이 Cache Miss 가 되서 느리겠지요.반면에 후자의 경우&nbsp;data[0]&nbsp;을&nbsp;10000&nbsp;번 연속으로 접근하므로, 처음에 접근할 때 빼고 나머지&nbsp;9999&nbsp;번 접근이 Cache hit 이 되어서 빠르게 덧셈을 수행할 수 있게 됩니다.컴파일러는 지 알아서 명령어 재배치를 함.이와 같이, 한 작업 (세탁 - 건조 - 개기) 이 끝나기 전에, 다음 작업을 시작하는 방식으로 동시에 여러 개의 작업을 동시에 실행하는 것을&nbsp;파이프라이닝(pipelining)&nbsp;이라고 합니다.
CPU 에서 명령어를 실행할 때 여러 단계를 거치게 됩니다. 명령어를 읽어야 하고 (fetch), 읽은 명령어가 무엇 인지 해석해야 하고 (decode), 해석된 명령어를 실행하고 (execute), 마지막으로 결과를 써야 하지요 (write).따라서, 컴파일러는 우리가 어떠한 최대한 CPU 의 파이프라인을 효율적으로 활용할 수 있도록 명령어를 재배치함.그리고 CPU도 캐시에 따라 실행 순서를 변경할 수 있음.명령어 순서도 뒤죽 박죽 바꾸고 심지어 CPU 에서도 명령어들을 제대로 된 순서로 실행하지 않는다면, 도대체 무엇을 믿을 수 있을까?C++ 의 모든 객체들은&nbsp;수정 순서(modification order)&nbsp;라는 것을 정의
C++ 에서 보장하는 사실은, 원자적 연산을 할 경우에 모든 쓰레드에서 같은 객체에 대해서 동일한 수정&nbsp;순서&nbsp;를 관찰할 수 있다는 사실입니다.같은 시간에 변수&nbsp;a&nbsp;의 값을 관찰했다고 해서 굳이&nbsp;모든 쓰레드들이 동일한 값을 관찰할 필요는 없다 라는 점원자적 연산이란, CPU 가 명령어 1 개로 처리하는 명령으로, 중간에 다른 쓰레드가 끼어들 여지가 전혀 없는 연산
C++ 에서는 몇몇 타입들에 원자적인 연산을 쉽게 할 수 있도록 여러가지 도구들을 지원하고 있습니다. 또한 이러한 원자적 연산들은 올바른 연산을 위해 굳이 뮤텍스가 필요하지 않습니다! 즉 속도가 더 빠름#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void worker(std::atomic&lt;int&gt;&amp; counter) { for (int i = 0; i &lt; 10000; i++) { counter++; }
} int main() { std::atomic&lt;int&gt; counter(0); std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, ref(counter))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
어셈블리를 까보면lock add DWORD PTR [rdi], 1
이런 부분이 나오는데, x86 컴파일러가 알고 있었기 때문에 사용가능한거.CPU에 따라 사용 못할 수도 있음. 이러한 연산이 가능한지 확인하는 방법std::atomic&lt;int&gt; x;
std::cout &lt;&lt; "is lock free ? : " &lt;&lt; boolalpha &lt;&lt; x.is_lock_free() &lt;&lt; std::endl;
atomic&nbsp;객체들의 경우 원자적 연산 시에 메모리에 접근할 때 어떠한 방식으로 접근하는지 지정할 수 있습니다.가장&nbsp;느슨한&nbsp;조건입니다. 다시 말해,&nbsp;memory_order_relaxed&nbsp;방식으로 메모리에서 읽거나 쓸 경우, 주위의 다른 메모리 접근들과 순서가 바뀌어도 무방#include &lt;atomic&gt;
#include &lt;cstdio&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using std::memory_order_relaxed; void t1(std::atomic&lt;int&gt;* a, std::atomic&lt;int&gt;* b) { b-&gt;store(1, memory_order_relaxed); // b = 1 (쓰기) int x = a-&gt;load(memory_order_relaxed); // x = a (읽기) printf("x : %d \n", x);
} void t2(std::atomic&lt;int&gt;* a, std::atomic&lt;int&gt;* b) { a-&gt;store(1, memory_order_relaxed); // a = 1 (쓰기) int y = b-&gt;load(memory_order_relaxed); // y = b (읽기) printf("y : %d \n", y);
} int main() { std::vector&lt;std::thread&gt; threads; std::atomic&lt;int&gt; a(0); std::atomic&lt;int&gt; b(0); threads.push_back(std::thread(t1, &amp;a, &amp;b)); threads.push_back(std::thread(t2, &amp;a, &amp;b)); for (int i = 0; i &lt; 2; i++) { threads[i].join(); }
}
x : 1 y : 0 or x : 0 y : 1 or y : 1 x : 1 이 경우는 가능할까?
x : 0 y : 0 x : 0
y : 0위 명령어들이 순서대로 실행된다면 이는 불가능 하다는 사실을 알 수 있습니다.
하지만, 메모리 연산들 사이에서 어떠한 제약조건도 없다고 하였습니다. 다시 말해 서로 다른 변수의&nbsp;relaxed&nbsp;메모리 연산은 CPU 마음대로 재배치 할 수 있습니다 (단일 쓰레드 관점에서 결과가 동일하다면)..emory_order_relaxed&nbsp;는 CPU 에서 메모리 연산 순서에 관련해서 무한한 자유를 주는 것과 같습니다. 덕분에 CPU 에서 매우 빠른 속도로 실행할 수 있게됩니다.#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void producer(std::atomic&lt;bool&gt;* is_ready, int* data) { *data = 10; is_ready-&gt;store(true, std::memory_order_release);
} void consumer(std::atomic&lt;bool&gt;* is_ready, int* data) { // data 가 준비될 때 까지 기다린다. while (!is_ready-&gt;load(std::memory_order_acquire)) { } std::cout &lt;&lt; "Data : " &lt;&lt; *data &lt;&lt; std::endl;
} int main() { std::vector&lt;std::thread&gt; threads; std::atomic&lt;bool&gt; is_ready(false); int data = 0; threads.push_back(std::thread(producer, &amp;is_ready, &amp;data)); threads.push_back(std::thread(consumer, &amp;is_ready, &amp;data)); for (int i = 0; i &lt; 2; i++) { threads[i].join(); }
}
data&nbsp;에 0 이 들어가는 일 불가능!memory_order_release&nbsp;는&nbsp;해당 명령 이전의 모든 메모리 명령들이 해당 명령 이후로 재배치 되는 것을 금지
또한, 만약에 같은 변수를&nbsp;memory_order_acquire&nbsp;으로 읽는 쓰레드가 있다면,&nbsp;memory_order_release&nbsp;이전에 오는 모든 메모리 명령들이 해당 쓰레드에 의해서&nbsp;관찰&nbsp;될 수 있어야 합니다.쉽게 말해&nbsp;is_ready-&gt;store(true, std::memory_order_release);&nbsp;밑으로&nbsp;*data = 10&nbsp;이 올 수 없게 됩니다. 또한&nbsp;is_ready&nbsp;가&nbsp;true&nbsp;가 된다면,&nbsp;memory_order_acquire&nbsp;로&nbsp;is_ready&nbsp;를 읽는 쓰레드에서&nbsp;data&nbsp;의 값을 확인했을 때&nbsp;10&nbsp;임을 관찰할 수 있어야하죠.memory_order_acquire&nbsp;의 경우,&nbsp;release&nbsp;와는 반대로&nbsp;해당 명령 뒤에 오는 모든 메모리 명령들이 해당 명령 위로 재배치 되는 것을 금지&nbsp;합니다.이와 같이 두 개의 다른 쓰레드들이 같은 변수의&nbsp;release&nbsp;와&nbsp;acquire&nbsp;를 통해서&nbsp;동기화 (synchronize)&nbsp;를 수행하는 것을 볼 수 있습니다.memory_order_acq_rel&nbsp;은 이름에서도 알 수 있듯이,&nbsp;acquire&nbsp;와&nbsp;release&nbsp;를 모두 수행하는 것입니다. 이는, 읽기와 쓰기를 모두 수행하는 명령들, 예를 들어서&nbsp;fetch_add&nbsp;와 같은 함수에서 사용될 수 있습니다.memory_order_seq_cst&nbsp;는 메모리 명령의&nbsp;순차적 일관성(sequential consistency)&nbsp;을 보장해줍니다.순차적 일관성이란, 메모리 명령 재배치도 없고, 모든 쓰레드에서 모든 시점에 동일한 값을 관찰할 수 있는, 여러분이 생각하는 그대로 CPU 가 작동하는 방식#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt; std::atomic&lt;bool&gt; x(false);
std::atomic&lt;bool&gt; y(false);
std::atomic&lt;int&gt; z(0); void write_x() { x.store(true, std::memory_order_release); } void write_y() { y.store(true, std::memory_order_release); } void read_x_then_y() { while (!x.load(std::memory_order_acquire)) { } if (y.load(std::memory_order_acquire)) { ++z; }
} void read_y_then_x() { while (!y.load(std::memory_order_acquire)) { } if (x.load(std::memory_order_acquire)) { ++z; }
} int main() { thread a(write_x); thread b(write_y); thread c(read_x_then_y); thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); std::cout &lt;&lt; "z : " &lt;&lt; z &lt;&lt; std::endl;
}
실행결과
z : 0
or
z : 1
or
z : 2
왜 0이 나올 수 있을까?memory_order_seq_cst&nbsp;를 사용하게 된다면, 해당 명령을 사용하는 메모리 연산들 끼리는 모든 쓰레드에서 동일한 연산 순서를 관찰할 수 있도록 보장#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using std::memory_order_seq_cst;
using std::thread; std::atomic&lt;bool&gt; x(false);
std::atomic&lt;bool&gt; y(false);
std::atomic&lt;int&gt; z(0); void write_x() { x.store(true, memory_order_seq_cst); } void write_y() { y.store(true, memory_order_seq_cst); } void read_x_then_y() { while (!x.load(memory_order_seq_cst)) { } if (y.load(memory_order_seq_cst)) { ++z; }
} void read_y_then_x() { while (!y.load(memory_order_seq_cst)) { } if (x.load(memory_order_seq_cst)) { ++z; }
} int main() { thread a(write_x); thread b(write_y); thread c(read_x_then_y); thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); std::cout &lt;&lt; "z : " &lt;&lt; z &lt;&lt; std::endl;
}
z : 2 or z : 1
z&nbsp;의 값이 0 이 되는 경우는 발생X]]></description><link>cpp/memory-order,-atomic.html</link><guid isPermaLink="false">CPP/memory order, atomic.md</guid><pubDate>Thu, 26 Dec 2024 13:09:42 GMT</pubDate></item><item><title><![CDATA[Mutex, deadlock]]></title><description><![CDATA[한 쓰레드에서만 위 코드를 실행시키기
race condition을 방지하기 위함#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt;
#include &lt;vector&gt; void worker(int&amp; result, std::mutex&amp; m) { for (int i = 0; i &lt; 10000; i++) { m.lock(); result += 1; m.unlock(); }
} int main() { int counter = 0; std::mutex m; // 우리의 mutex 객체 std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, std::ref(counter), std::ref(m))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
m.lock();
result += 1;
m.unlock();
m.lock()&nbsp;은&nbsp;뮤텍스&nbsp;m&nbsp;을 내가 쓰게 달라!&nbsp;라고 이야기 하는 것입니다. 이 때 중요한 사실은,&nbsp;한 번에 한 쓰레드에서만&nbsp;m&nbsp;의 사용 권한을 갖는다는 것입니다. 그렇다면, 다른 쓰레드에서&nbsp;m.lock()&nbsp;을 하였다면 어떻게될까요? 이는&nbsp;m&nbsp;을 소유한 쓰레드가&nbsp;m.unlock()&nbsp;을 통해&nbsp;m&nbsp;을 반환할 때 까지 무한정 기다리게 됩니다.m.unlock을 만약 하지 않는다면 다른 쓰레드에서 무한정 기다림 -&gt; 데드락위와 같은 문제를 해결하기 위해서는 취득한 뮤텍스는 사용이 끝나면 반드시 반환을 해야 합니다. 하지만 코드 길이가 길어지게 된다면 반환하는 것을 까먹을 수 있기 마련입니다.곰곰히 생각해보면 이전에 비슷한 문제를 해결한 기억이 있습니다.&nbsp;unique_ptr&nbsp;를 왜 도입을 하였는지 생각을 해보자면, 메모리를 할당 하였으면 사용 후에 반드시 해제를 해야 하므로, 아예 이 과정을&nbsp;unique_ptr&nbsp;의 소멸자에서 처리하도록 했었습니다.뮤텍스도 마찬가지로 사용 후 해제 패턴을 따르기 때문에 동일하게 소멸자에서 처리#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt;
#include &lt;vector&gt; void worker(int&amp; result, std::mutex&amp; m) { for (int i = 0; i &lt; 10000; i++) { // lock 생성 시에 m.lock() 을 실행한다고 보면 된다. std::lock_guard&lt;std::mutex&gt; lock(m); result += 1; // scope 를 빠져 나가면 lock 이 소멸되면서 // m 을 알아서 unlock 한다. }
} int main() { int counter = 0; std::mutex m; // 우리의 mutex 객체 std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, std::ref(counter), std::ref(m))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
데드락을 방지하기 위해서 한 쓰레드에 우선권을 주면, 다른 쓰레드만 일하고 남은 쓰레드는 일하지 않는 경우가 생김 -&gt; Starvation이 생길 가능성이 있음.#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt; void worker1(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { m1.lock(); m2.lock(); std::cout &lt;&lt; "Worker1 Hi! " &lt;&lt; i &lt;&lt; std::endl; m2.unlock(); m1.unlock(); }
} void worker2(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { while (true) { m2.lock(); // m1 이 이미 lock 되어 있다면 "야 차 빼" 를 수행하게 된다. if (!m1.try_lock()) { m2.unlock(); continue; } std::cout &lt;&lt; "Worker2 Hi! " &lt;&lt; i &lt;&lt; std::endl; m1.unlock(); m2.unlock(); break; } }
} int main() { std::mutex m1, m2; // 우리의 mutex 객체 std::thread t1(worker1, std::ref(m1), std::ref(m2)); std::thread t2(worker2, std::ref(m1), std::ref(m2)); t1.join(); t2.join(); std::cout &lt;&lt; "끝!" &lt;&lt; std::endl;
}
worker 1에 우선권을 줬음.#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt; void worker1(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { m1.lock(); m2.lock(); std::cout &lt;&lt; "Worker1 Hi! " &lt;&lt; i &lt;&lt; std::endl; m2.unlock(); m1.unlock(); }
} void worker2(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { while (true) { m2.lock(); // m1 이 이미 lock 되어 있다면 "야 차 빼" 를 수행하게 된다. if (!m1.try_lock()) { m2.unlock(); continue; } std::cout &lt;&lt; "Worker2 Hi! " &lt;&lt; i &lt;&lt; std::endl; m1.unlock(); m2.unlock(); break; } }
} int main() { std::mutex m1, m2; // 우리의 mutex 객체 std::thread t1(worker1, std::ref(m1), std::ref(m2)); std::thread t2(worker2, std::ref(m1), std::ref(m2)); t1.join(); t2.join(); std::cout &lt;&lt; "끝!" &lt;&lt; std::endl;
}
데드락을 해결하는건 매우매우 복잡하고 완벽하지 않음. 그래서, 데드락 상황이 발생하지 않게 잘 설계하는 것이 중요데드락 상황을 피하기 위해 다음과 같은 가이드라인을 제시모든 쓰레드들이 최대 1 개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;만을 소유한다면 (일반적인 경우에) 데드락 상황이 발생하는 것을 피할 수 있습니다. 또한 대부분의 디자인에서는 1 개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;으로도 충분합니다. 만일 여러개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;을 필요로 한다면&nbsp;정말 필요로 하는지&nbsp;를 되물어보는 것이 좋습니다.<br>사실 이 가이드라인 역시 위에서 말한 내용과 자연스럽게 따라오는 것이긴 한데, 유저 코드에서&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;을 소유할 수 도 있기에 중첩된&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;을 얻는 것을 피하려면&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;소유시 유저 코드를 호출하는 것을 지양해야 합니다.<br>만일 여러개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;들을 획득해야 할 상황이 온다면,&nbsp;반드시 이 Lock 들을 정해진 순서로 획득해야 합니다. 우리가 앞선 예제에서 데드락이 발생했던 이유 역시,&nbsp;worker1&nbsp;에서는&nbsp;m1, m2&nbsp;순으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;을 하였지만&nbsp;worker2&nbsp;에서는&nbsp;m2, m1&nbsp;순으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;을 하였기 때문이지요. 만일&nbsp;worker2&nbsp;에서 역시&nbsp;m1, m2&nbsp;순으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;을 하였다면 데드락은 발생하지 않았을 것입니다.
#include &lt;chrono&gt; // std::chrono::miliseconds
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void producer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int index) { for (int i = 0; i &lt; 5; i++) { // 웹사이트를 다운로드 하는데 걸리는 시간이라 생각하면 된다. // 각 쓰레드 별로 다운로드 하는데 걸리는 시간이 다르다. std::this_thread::sleep_for(std::chrono::milliseconds(100 * index)); std::string content = "웹사이트 : " + std::to_string(i) + " from thread(" + std::to_string(index) + ")\n"; // data 는 쓰레드 사이에서 공유되므로 critical section 에 넣어야 한다. m-&gt;lock(); downloaded_pages-&gt;push(content); m-&gt;unlock(); }
} void consumer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int* num_processed) { // 전체 처리하는 페이지 개수가 5 * 5 = 25 개. while (*num_processed &lt; 25) { m-&gt;lock(); // 만일 현재 다운로드한 페이지가 없다면 다시 대기. if (downloaded_pages-&gt;empty()) { m-&gt;unlock(); // (Quiz) 여기서 unlock 을 안한다면 어떻게 될까요? // 10 밀리초 뒤에 다시 확인한다. std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; } // 맨 앞의 페이지를 읽고 대기 목록에서 제거한다. std::string content = downloaded_pages-&gt;front(); downloaded_pages-&gt;pop(); (*num_processed)++; m-&gt;unlock(); // content 를 처리한다. std::cout &lt;&lt; content; std::this_thread::sleep_for(std::chrono::milliseconds(80)); }
} int main() { // 현재 다운로드한 페이지들 리스트로, 아직 처리되지 않은 것들이다. std::queue&lt;std::string&gt; downloaded_pages; std::mutex m; std::vector&lt;std::thread&gt; producers; for (int i = 0; i &lt; 5; i++) { producers.push_back(std::thread(producer, &amp;downloaded_pages, &amp;m, i + 1)); } int num_processed = 0; std::vector&lt;std::thread&gt; consumers; for (int i = 0; i &lt; 3; i++) { consumers.push_back( std::thread(consumer, &amp;downloaded_pages, &amp;m, &amp;num_processed)); } for (int i = 0; i &lt; 5; i++) { producers[i].join(); } for (int i = 0; i &lt; 3; i++) { consumers[i].join(); }
}
먼저&nbsp;producer&nbsp;쓰레드에서는 웹사이트에서 페이지를 계속 다운로드 하는 역할을 하게 됩니다. 이 때, 다운로드한 페이지들을&nbsp;downloaded_pages&nbsp;라는 큐에 저장<br>
<img alt="cpp_13.png" src="images/cpp_13.png" target="_self">그리고 다운 받은 웹사이트 내용이&nbsp;content&nbsp;라고 생각해봅시다.그렇다면, 이제 다운 받은 페이지를 작업 큐에 집어 넣어야 합니다. 이 때 주의할 점으로,&nbsp;producer&nbsp;쓰레드가 1 개가 아니라 5 개나 있다는 점입니다. 따라서&nbsp;downloaded_pages&nbsp;에 접근하는 쓰레드들 사이에&nbsp;race condition&nbsp;이 발생할 수 있습니다.이를 방지 하기 위해서 뮤텍스&nbsp;m&nbsp;으로 해당 코드를 감싸서 문제가 발생하지 않게 해줍니다.먼저&nbsp;consumer&nbsp;쓰레드의 입장에서는&nbsp;언제 일이 올지 알 수 없습니다. 따라서&nbsp;downloaded_pages&nbsp;가 비어있지 않을 때 까지 계속&nbsp;while&nbsp;루프를 돌아야겠지요. 한 가지 문제는 컴퓨터 CPU 의 속도에 비해 웹사이트 정보가 큐에 추가되는 속도는 매우 느리다는 점입니다.우리의&nbsp;producer&nbsp;의 경우 대충 100ms 마다 웹사이트 정보를 큐에 추가하게 되는데, 이 시간 동안&nbsp;downloaded_pages-&gt;empty()&nbsp;이 문장을 수십 만 번 호출할 수 있을 것입니다. 이는 상당한 CPU 자원의 낭비가 아닐 수 없지요. 그래서 empty인 경우 10 밀리 세컨드 후에 다시 실행 (continue;) <br>정상 작동함..근데 consumer가 10밀리 세컨드마다 downloaded_pages에 할일이 있는 지 확인하고 있으면 하고 없으면 기다리는 형태라서 비효율임 매 번 언제 올지 모르는 데이터를 확인하기 위해 지속적으로&nbsp;mutex&nbsp;를&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;하고, 큐를 확인해야 하기 때문어떻게 개선할까?consumer는 그냥 재워놓고 producer에서 할 일이 온다면 그때 consumer를 깨우자.위와 같은 상황에서 쓰레드들을 10 밀리초 마다 재웠다 깨웠다 할 수 밖에 없었던 이유는&nbsp;어떠 어떠한 조건을 만족할 때 까지 자라!&nbsp;라는 명령을 내릴 수 없었기 때문입니다.위 경우&nbsp;downloaded_pages&nbsp;가&nbsp;empty()&nbsp;가 참이 아닐 때 까지 자라&nbsp;라는 명령을 내리고 싶었겠지요.#include &lt;chrono&gt; // std::chrono::miliseconds
#include &lt;condition_variable&gt; // std::condition_variable
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void producer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int index, std::condition_variable* cv) { for (int i = 0; i &lt; 5; i++) { // 웹사이트를 다운로드 하는데 걸리는 시간이라 생각하면 된다. // 각 쓰레드 별로 다운로드 하는데 걸리는 시간이 다르다. std::this_thread::sleep_for(std::chrono::milliseconds(100 * index)); std::string content = "웹사이트 : " + std::to_string(i) + " from thread(" + std::to_string(index) + ")\n"; // data 는 쓰레드 사이에서 공유되므로 critical section 에 넣어야 한다. m-&gt;lock(); downloaded_pages-&gt;push(content); m-&gt;unlock(); // consumer 에게 content 가 준비되었음을 알린다. cv-&gt;notify_one(); }
} void consumer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int* num_processed, std::condition_variable* cv) { while (*num_processed &lt; 25) { std::unique_lock&lt;std::mutex&gt; lk(*m); cv-&gt;wait( lk, [&amp;] { return !downloaded_pages-&gt;empty() || *num_processed == 25; }); if (*num_processed == 25) { lk.unlock(); return; } // 맨 앞의 페이지를 읽고 대기 목록에서 제거한다. std::string content = downloaded_pages-&gt;front(); downloaded_pages-&gt;pop(); (*num_processed)++; lk.unlock(); // content 를 처리한다. std::cout &lt;&lt; content; std::this_thread::sleep_for(std::chrono::milliseconds(80)); }
} int main() { // 현재 다운로드한 페이지들 리스트로, 아직 처리되지 않은 것들이다. std::queue&lt;std::string&gt; downloaded_pages; std::mutex m; std::condition_variable cv; std::vector&lt;std::thread&gt; producers; for (int i = 0; i &lt; 5; i++) { producers.push_back( std::thread(producer, &amp;downloaded_pages, &amp;m, i + 1, &amp;cv)); } int num_processed = 0; std::vector&lt;std::thread&gt; consumers; for (int i = 0; i &lt; 3; i++) { consumers.push_back( std::thread(consumer, &amp;downloaded_pages, &amp;m, &amp;num_processed, &amp;cv)); } for (int i = 0; i &lt; 5; i++) { producers[i].join(); } // 나머지 자고 있는 쓰레드들을 모두 깨운다. cv.notify_all(); for (int i = 0; i &lt; 3; i++) { consumers[i].join(); }
}
std::unique_lock&lt;std::mutex&gt; lk(*m); cv-&gt;wait(lk, [&amp;] { return !downloaded_pages-&gt;empty() || *num_processed == 25; });
<br>condition_variable&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수에 어떤 조건이 참이 될 때 까지 기다릴지 해당 조건을 인자로 여러 쓰레드에서 같은 객체의 값을 수정한다면 Race Condition 이 발생합니다. 이를 해결하기 위해서는 여러가지 방법이 있지만, 한 가지 방법으로 뮤텍스를 사용하는 방법이 있습니다. 뮤텍스는 한 번에 한 쓰레드에서만 획득할 수 있습니다. 획득한 뮤텍스는&nbsp;반드시&nbsp;반환해야 합니다.&nbsp;lock_guard&nbsp;나&nbsp;unique_lock&nbsp;등을 이용하면 뮤텍스의 획득-반환을 손쉽게 처리할 수 있습니다. 뮤텍스를 사용할 때 데드락이 발생하지 않도록 주의해야 합니다. 데드락을 디버깅하는 것은 매우 어렵습니다.&nbsp;condition_variable&nbsp;을 사용하면 생산자-소비자 패턴을 쉽게 구현할 수 있습니다.]]></description><link>cpp/mutex,-deadlock.html</link><guid isPermaLink="false">CPP/Mutex, deadlock.md</guid><pubDate>Thu, 26 Dec 2024 11:20:29 GMT</pubDate><enclosure url="images/cpp_13.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_13.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_13]]></title><description><![CDATA[<img src="images/cpp_13.png" target="_self">]]></description><link>images/cpp_13.html</link><guid isPermaLink="false">images/cpp_13.png</guid><pubDate>Thu, 26 Dec 2024 10:56:21 GMT</pubDate><enclosure url="images/cpp_13.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_13.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[callable etc.]]></title><description><![CDATA[Callable&nbsp;이란, 이름 그대로 나타내듯이 호출(Call) 할 수 있는 모든 것을 의미C++ 에서는 이러한&nbsp;Callable&nbsp;들을 객체의 형태로 보관할 수 있는&nbsp;std::function&nbsp;이라는 클래스를 제공합니다. C 에서의 함수 포인터는 진짜 함수들만 보관할 수 있는 객체라고 볼 수 있다면 이&nbsp;std::function&nbsp;의 경우 함수 뿐만이 아니라 모든&nbsp;Callable&nbsp;들을 보관할 수 있는 객체#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int some_func1(const std::string&amp; a) { std::cout &lt;&lt; "Func1 호출! " &lt;&lt; a &lt;&lt; std::endl; return 0;
} struct S { void operator()(char c) { std::cout &lt;&lt; "Func2 호출! " &lt;&lt; c &lt;&lt; std::endl; }
}; int main() { std::function&lt;int(const std::string&amp;)&gt; f1 = some_func1; std::function&lt;void(char)&gt; f2 = S(); std::function&lt;void()&gt; f3 = []() { std::cout &lt;&lt; "Func3 호출! " &lt;&lt; std::endl; }; f1("hello"); f2('c'); f3();
}
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class A { int c; public: A(int c) : c(c) {} int some_func() { std::cout &lt;&lt; "내부 데이터 : " &lt;&lt; c &lt;&lt; std::endl; }
}; int main() { A a(5); std::function&lt;int()&gt; f1 = a.some_func;
}
이건 컴파일 오류test2.cc: In function 'int main()':
test2.cc:17:26: error: invalid use of non-static member function 'int A::some_func()' std::function&lt;int()&gt; f1 = a.some_func; ~~^~~~~~~~~
test2.cc:10:9: note: declared here int some_func() { ^~~~~~~~~
f1&nbsp;을 호출하였을 때, 함수의 입장에서 자신을 호출하는 객체가 무엇인지 알 길이 없기 때문에&nbsp;c&nbsp;를 참조 하였을 때 어떤 객체의&nbsp;c&nbsp;인지를 알 수 없겠지요. 따라서 이 경우&nbsp;f1&nbsp;에&nbsp;a&nbsp;에 관한 정보도 추가로 전달해야 합니다.사실 멤버 함수들은 구현 상 자신을 호출한 객체를 인자로 암묵적으로 받고 있었습니다.#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class A { int c; public: A(int c) : c(c) {} int some_func() { std::cout &lt;&lt; "비상수 함수: " &lt;&lt; ++c &lt;&lt; std::endl; return c; } int some_const_function() const { std::cout &lt;&lt; "상수 함수: " &lt;&lt; c &lt;&lt; std::endl; return c; } static void st() {}
}; int main() { A a(5); std::function&lt;int(A&amp;)&gt; f1 = &amp;A::some_func; std::function&lt;int(const A&amp;)&gt; f2 = &amp;A::some_const_function; /*
위와 같이 원래 인자에 추가적으로 객체를 받는 인자를 전달해주면 됩니다. 이 때 상수 함수의 경우 당연히 상수 형태로 인자를 받아야 하고 (`const A&amp;`), 반면에 상수 함수가 아닌 경우 단순히 `A&amp;` 의 형태로 인자를 받으면 되겠습니다. f1(a); f2(a);
*/
}
vector&nbsp;들을 가지는&nbsp;vector&nbsp;가 있을 때, 각각의&nbsp;vector&nbsp;들의 크기들을 벡터로 만들어주는 코드를 생각해봅시다.#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(b); container.push_back(d); container.push_back(a); container.push_back(c); vector&lt;int&gt; size_vec(4); std::transform(container.begin(), container.end(), size_vec.begin(), &amp;vector&lt;int&gt;::size); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; "벡터 크기 :: " &lt;&lt; *itr &lt;&lt; std::endl; }
}
위 코드를 컴파일 하면 아래와 같은 컴파일 오류왜 그럴까요? 이 역시 전달된&nbsp;size&nbsp;함수가 멤버 함수여서 발생하는 문제 입니다. 위 템플릿에&nbsp;&amp;vector&lt;int&gt;::size&nbsp;가 들어간다면 해당&nbsp;unary_op&nbsp;를 호출하는 부분은 아래와 같이 변환
// from
unary_op(*first1); // to로 변환됨
&amp;vector&lt;int&gt;::size(*first); // 멤버함수의 경우
(*first).(*&amp;vector&lt;int&gt;::size) // or
first-&gt;(*&amp;vector&lt;int&gt;::size)
// 둘중 하나로 호출해야함. c++ 규칙이니까 그래서 std::function을 이용해야함. std::function&nbsp;으로 변환해서 전달#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(a); container.push_back(b); container.push_back(c); container.push_back(d); std::function&lt;size_t(const vector&lt;int&gt;&amp;)&gt; sz_func = &amp;vector&lt;int&gt;::size; vector&lt;int&gt; size_vec(4); std::transform(container.begin(), container.end(), size_vec.begin(), sz_func); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; "벡터 크기 :: " &lt;&lt; *itr &lt;&lt; std::endl; }
}
근데 매번 function&nbsp;객체를 따로 만들어서 전달하는 것은 매우 귀찮습니다. 따라서 C++ 개발자들은 라이브러리에 위&nbsp;function&nbsp;객체를 리턴해버리는 함수를 추가#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(a); container.push_back(b); container.push_back(c); container.push_back(d); vector&lt;int&gt; size_vec(4); transform(container.begin(), container.end(), size_vec.begin(), std::mem_fn(&amp;vector&lt;int&gt;::size)); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; "벡터 크기 :: " &lt;&lt; *itr &lt;&lt; std::endl; }
}
참고로&nbsp;mem_fn&nbsp;은 그리 자주 쓰이지는 않는데, 람다 함수로도 동일한 작업을 수행할 수 있기 때문입니다. 위 코드의 경우&nbsp;mem_fn(&amp;vector&lt;int&gt;::size)&nbsp;대신에&nbsp;[](const auto&amp; v){ return v.size()}&nbsp;를 전달해도 동일한 작업을 수행합니다.mem_fn&nbsp;을 사용하기 위해서는&nbsp;&lt;functional&gt;&nbsp;헤더를 추가해야 하지만 람다함수는 그냥 쓸 수 있으니 좀 더 편리한 면이 있습니다. 물론, 코드 길이 면에서는&nbsp;mem_fn&nbsp;을 사용하는 것이 좀더 깔끔한 편입니다.std::bind는 함수 객체를 생성하는 도구로, 함수의 일부 인자를 고정하거나 인자의 순서를 변경할 수 있게 해줍니다.#include &lt;functional&gt;
#include &lt;iostream&gt; void add(int x, int y) { std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y &lt;&lt; std::endl;
} void subtract(int x, int y) { std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x - y &lt;&lt; std::endl;
}
int main() { auto add_with_2 = std::bind(add, 2, std::placeholders::_1); add_with_2(3); // 두 번째 인자는 무시된다. add_with_2(3, 4); auto subtract_from_2 = std::bind(subtract, std::placeholders::_1, 2); auto negate = std::bind(subtract, std::placeholders::_2, std::placeholders::_1); subtract_from_2(3); // 3 - 2 를 계산한다. negate(4, 2); // 2 - 4 를 계산한다
}
bind를 사용할 때 레퍼런스로 넘길 때 주의 해야함.#include &lt;functional&gt;
#include &lt;iostream&gt; struct S { int data; S(int data) : data(data) { std::cout &lt;&lt; "일반 생성자 호출!" &lt;&lt; std::endl; } S(const S&amp; s) { std::cout &lt;&lt; "복사 생성자 호출!" &lt;&lt; std::endl; data = s.data; } S(S&amp;&amp; s) { std::cout &lt;&lt; "이동 생성자 호출!" &lt;&lt; std::endl; data = s.data; }
}; void do_something(S&amp; s1, const S&amp; s2) { s1.data = s2.data + 3; } int main() { S s1(1), s2(2); std::cout &lt;&lt; "Before : " &lt;&lt; s1.data &lt;&lt; std::endl; // s1 이 그대로 전달된 것이 아니라 s1 의 복사본이 전달됨! auto do_something_with_s1 = std::bind(do_something, s1, std::placeholders::_1); do_something_with_s1(s2); std::cout &lt;&lt; "After :: " &lt;&lt; s1.data &lt;&lt; std::endl;
}
일반 생성자 호출!
일반 생성자 호출!
Before : 1
복사 생성자 호출!
After :: 1
그 이유는 위 생성자 호출 메세지에서 확인할 수 있듯이&nbsp;bind&nbsp;함수로 인자가&nbsp;복사&nbsp;되서 전달되기 때문입니다. 따라서 이를 해결 하기 위해서는 명시적으로&nbsp;s1&nbsp;의 레퍼런스를 전달해줘야 합니다.#include &lt;functional&gt;
#include &lt;iostream&gt; struct S { int data; S(int data) : data(data) { std::cout &lt;&lt; "일반 생성자 호출!" &lt;&lt; std::endl; } S(const S&amp; s) { std::cout &lt;&lt; "복사 생성자 호출!" &lt;&lt; std::endl; data = s.data; } S(S&amp;&amp; s) { std::cout &lt;&lt; "이동 생성자 호출!" &lt;&lt; std::endl; data = s.data; }
}; void do_something(S&amp; s1, const S&amp; s2) { s1.data = s2.data + 3; } int main() { S s1(1), s2(2); std::cout &lt;&lt; "Before : " &lt;&lt; s1.data &lt;&lt; std::endl; // s1 이 그대로 전달된 것이 아니라 s1 의 복사본이 전달됨! auto do_something_with_s1 = std::bind(do_something, std::ref(s1), std::placeholders::_1); do_something_with_s1(s2); std::cout &lt;&lt; "After :: " &lt;&lt; s1.data &lt;&lt; std::endl;
}
일반 생성자 호출!
일반 생성자 호출!
Before : 1
After :: 5
]]></description><link>cpp/callable-etc..html</link><guid isPermaLink="false">CPP/callable etc..md</guid><pubDate>Thu, 26 Dec 2024 09:45:34 GMT</pubDate></item><item><title><![CDATA[shared, weak]]></title><description><![CDATA[러 개의 스마트 포인터가 하나의 객체를 같이 소유 해야 하는 경우가 발생합니다. 예를 들어서 여러 객체에서 하나의 자원을 사용하고자 합니다. 후에 자원을 해제하기 위해서는 이 자원을 사용하는 모든 객체들이 소멸되야 하는데, 어떤 객체가 먼저 소멸되는지 알 수 없기 때문에 이 자원 역시 어느 타이밍에 해제 시켜야 할 지 알 수 없게 됩니다.특정 자원을&nbsp;몇 개의 객체에서 가리키는지를 추적한 다음에, 그 수가 0 이 되야만 비로소 해제를 시켜주는 방식의 포인터가 필요 : reference countstd::shared_ptr&lt;A&gt; p1(new A());
std::shared_ptr&lt;A&gt; p2(p1); // p2 역시 생성된 객체 A 를 가리킨다.
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt; class A { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; }
}; int main() { std::vector&lt;std::shared_ptr&lt;A&gt;&gt; vec; vec.push_back(std::shared_ptr&lt;A&gt;(new A())); vec.push_back(std::shared_ptr&lt;A&gt;(vec[0])); vec.push_back(std::shared_ptr&lt;A&gt;(vec[1])); // 벡터의 첫번째 원소를 소멸 시킨다. std::cout &lt;&lt; "첫 번째 소멸!" &lt;&lt; std::endl; vec.erase(vec.begin()); // 그 다음 원소를 소멸 시킨다. std::cout &lt;&lt; "다음 원소 소멸!" &lt;&lt; std::endl; vec.erase(vec.begin()); // 마지막 원소 소멸 std::cout &lt;&lt; "마지막 원소 소멸!" &lt;&lt; std::endl; vec.erase(vec.begin()); std::cout &lt;&lt; "프로그램 종료!" &lt;&lt; std::endl;
}
자원을 획득함!
첫 번째 소멸!
다음 원소 소멸!
마지막 원소 소멸!
소멸자 호출!
프로그램 종료!
shared_ptr&nbsp;들은 참조 개수가 몇 개 인지 알고 있어야만 합니다. 이 경우 어떻게 하면 같은 객체를 가리키는&nbsp;shared_ptr&nbsp;끼리 동기화를 시킬 수 있을까요?처음으로 실제 객체를 가리키는&nbsp;shared_ptr&nbsp;가&nbsp;제어 블록(control block)&nbsp;을 동적으로 할당한 후,&nbsp;shared_ptr&nbsp;들이 이 제어 블록에 필요한 정보를 공유하는 방식으로 구현<img alt="cpp_10.png" src="images/cpp_10.png" target="_self">shared_ptr&nbsp;는 복사 생성할 때 마다 해당 제어 블록의 위치만 공유하면 되고,&nbsp;shared_ptr&nbsp;가 소멸할 때 마다 제어 블록의 참조 개수를 하나 줄이고, 생성할 때 마다 하나 늘리는 방식으로 작동shared_ptr&nbsp;은 인자로 주소값이 전달된다면, 마치 자기가 해당 객체를 첫번째로 소유하는&nbsp;shared_ptr&nbsp;인 것 마냥 행동A* a = new A();
std::shared_ptr&lt;A&gt; pa1(a);
std::shared_ptr&lt;A&gt; pa2(a);
<br><img alt="cpp_11.png" src="images/cpp_11.png" target="_self">따라서 위와 같이 각각의 제어 블록들은, 다른 제어 블록들의 존재를 모르고 참조 개수를 1 로 설정하게 되겠지요. 만약에&nbsp;pa1&nbsp;이 소멸된다면, 참조 카운트가 0 이 되어서 자신이 가리키는 객체 A 를 소멸시켜 버립니다.&nbsp;pa2&nbsp;가 아직 가리키고 있는데도 말이지요!물론&nbsp;pa2&nbsp;의 참조 카운트는 계속 1 이기 때문에 자신이 가리키는 객체가 살아 있을 것이라 생각할 것입니다. 설사 운 좋게도&nbsp;pa2&nbsp;를 사용하지 않아도,&nbsp;pa2&nbsp;가 소멸되면 참조 개수가 0 으로 떨어지고 자신이 가리키고 있는 (이미 해제된) 객체를 소멸시키기 때문에 오류가 발생#include &lt;iostream&gt;
#include &lt;memory&gt; class A { int* data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; }
}; int main() { A* a = new A(); std::shared_ptr&lt;A&gt; pa1(a); std::shared_ptr&lt;A&gt; pa2(a); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;
}
자원을 획득함!
1
1
소멸자 호출!
소멸자 호출!
test(37272,0x11254d5c0) malloc: *** error for object 0x4000000000000000: pointer being freed was not allocated
test(37272,0x11254d5c0) malloc: *** set a breakpoint in malloc_error_break to debug
[1] 37272 abort ./test
이와 같은 상황을 방지하려면&nbsp;shared_ptr&nbsp;를 주소값을 통해서 생성하는 것을 지양해야 합니다.하지만, 어쩔 수 없는 상황도 있습니다. 바로 객체 내부에서 자기 자신을 가리키는&nbsp;shared_ptr&nbsp;를 만들 때 를 생각해봅시다.#include &lt;iostream&gt;
#include &lt;memory&gt; class A { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; } std::shared_ptr&lt;A&gt; get_shared_ptr() { return std::shared_ptr&lt;A&gt;(this); }
}; int main() { std::shared_ptr&lt;A&gt; pa1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;A&gt; pa2 = pa1-&gt;get_shared_ptr(); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;
}
자원을 획득함!
1
1
소멸자 호출!
소멸자 호출!
test(38479,0x10e0945c0) malloc: *** error for object 0x7fa1e0e02700: pointer being freed was not allocated
test(38479,0x10e0945c0) malloc: *** set a breakpoint in malloc_error_break to debug
[1] 38479 abort ./test
위와 같이 이전과 같은 이유로 오류가 발생하게 됩니다.&nbsp;get_shared_ptr&nbsp;함수에서&nbsp;shared_ptr&nbsp;을 생성할 때, 이미 자기 자신을 가리키는&nbsp;shared_ptr&nbsp;가 있다는 사실을 모른채 새로운 제어 블록을 생성하기 때문이 문제는&nbsp;enable_shared_from_this&nbsp;를 통해 깔끔하게 해결#include &lt;iostream&gt;
#include &lt;memory&gt; class A : public std::enable_shared_from_this&lt;A&gt; { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; } std::shared_ptr&lt;A&gt; get_shared_ptr() { return shared_from_this(); }
}; int main() { std::shared_ptr&lt;A&gt; pa1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;A&gt; pa2 = pa1-&gt;get_shared_ptr(); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;
}
근데 위의 코드는 보통 언제쯤 사용하는걸까?콜백이나 비동기 작업에서 객체의 안전한 수명 관리가 필요할 때 주로 사용한다고 함. 순환참조 문제 발생 이러한 순환 참조 문제를 해결하기 위해 나타난 것이 바로&nbsp;weak_ptr우리는 트리 구조를 지원하는 클래스를 만드려고 합니다. 트리 구조라 함은 아래와 가계도와 비슷하다고 생각하시면 됩니다.<br><img alt="cpp_12.png" src="images/cpp_12.png" target="_self">class Node { std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children; /* 어떤 타입이 와야할까? */ parent; public: Node(){}; void AddChild(std::shared_ptr&lt;Node&gt; node) { children.push_back(node); }
}; 만약에 일반 포인터(Node *) 로 하게 된다면, 메모리 해제를 까먹고 하지 않을 경우 혹은 예외가 발생하였을 경우 적절하게 자원을 해제하기 어렵습니다. 물론 이미 해제된 메모리를 계속 가리키고 있을 위험도 있습니다. 하지만 이를&nbsp;shared_ptr&nbsp;로 하게 된다면 앞서 본 순환 참조 문제가 생깁니다. 부모와 자식이 서로를 가리키기 때문에 참조 개수가 절대로 0 이 될 수 없습니다. 따라서, 이들 객체들은 프로그램 끝날 때 까지 절대로 소멸되지 못하고 남아있게 됩니다.
weak_ptr&nbsp;는 일반 포인터와&nbsp;shared_ptr&nbsp;사이에 위치한 스마트 포인터로, 스마트 포인터 처럼 객체를 안전하게 참조할 수 있게 해주지만,&nbsp;shared_ptr&nbsp;와는 다르게 참조 개수를 늘리지는 않습니다. 이름 그대로&nbsp;약한&nbsp;포인터 인것이지요.따라서 설사 어떤 객체를&nbsp;weak_ptr&nbsp;가 가리키고 있다고 하더라도, 다른&nbsp;shared_ptr&nbsp;들이 가리키고 있지 않다면 이미 메모리에서 소멸되었을 것입니다.이 때문에&nbsp;weak_ptr&nbsp;자체로는 원래 객체를 참조할 수 없고, 반드시&nbsp;shared_ptr&nbsp;로 변환해서 사용해야 합니다. 이 때 가리키고 있는 객체가 이미 소멸되었다면 빈&nbsp;shared_ptr&nbsp;로 변환되고, 아닐경우 해당 객체를 가리키는&nbsp;shared_ptr&nbsp;로 변환#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt; class A { std::string s; std::weak_ptr&lt;A&gt; other; public: A(const std::string&amp; s) : s(s) { std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; } void set_other(std::weak_ptr&lt;A&gt; o) { other = o; } void access_other() { std::shared_ptr&lt;A&gt; o = other.lock(); if (o) { std::cout &lt;&lt; "접근 : " &lt;&lt; o-&gt;name() &lt;&lt; std::endl; } else { std::cout &lt;&lt; "이미 소멸됨 ㅠ" &lt;&lt; std::endl; } } std::string name() { return s; }
}; int main() { std::vector&lt;std::shared_ptr&lt;A&gt;&gt; vec; vec.push_back(std::make_shared&lt;A&gt;("자원 1")); vec.push_back(std::make_shared&lt;A&gt;("자원 2")); vec[0]-&gt;set_other(vec[1]); vec[1]-&gt;set_other(vec[0]); // pa 와 pb 의 ref count 는 그대로다. std::cout &lt;&lt; "vec[0] ref count : " &lt;&lt; vec[0].use_count() &lt;&lt; std::endl; std::cout &lt;&lt; "vec[1] ref count : " &lt;&lt; vec[1].use_count() &lt;&lt; std::endl; // weak_ptr 로 해당 객체 접근하기 vec[0]-&gt;access_other(); // 벡터 마지막 원소 제거 (vec[1] 소멸) vec.pop_back(); vec[0]-&gt;access_other(); // 접근 실패!
}
]]></description><link>cpp/shared,-weak.html</link><guid isPermaLink="false">CPP/shared, weak.md</guid><pubDate>Wed, 25 Dec 2024 07:13:27 GMT</pubDate><enclosure url="images/cpp_10.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_10.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_12]]></title><description><![CDATA[<img src="images/cpp_12.png" target="_self">]]></description><link>images/cpp_12.html</link><guid isPermaLink="false">images/cpp_12.png</guid><pubDate>Wed, 25 Dec 2024 07:10:47 GMT</pubDate><enclosure url="images/cpp_12.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_12.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_11]]></title><description><![CDATA[<img src="images/cpp_11.png" target="_self">]]></description><link>images/cpp_11.html</link><guid isPermaLink="false">images/cpp_11.png</guid><pubDate>Wed, 25 Dec 2024 06:50:44 GMT</pubDate><enclosure url="images/cpp_11.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_11.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_10]]></title><description><![CDATA[<img src="images/cpp_10.png" target="_self">]]></description><link>images/cpp_10.html</link><guid isPermaLink="false">images/cpp_10.png</guid><pubDate>Wed, 25 Dec 2024 06:47:16 GMT</pubDate><enclosure url="images/cpp_10.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_10.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[RAII]]></title><description><![CDATA[C++ 창시자인 비야네 스트로스트룹은 C++ 에서 자원을 관리하는 방법으로 다음과 같은 디자인 패턴을 제안하였습니다. 바로 흔히&nbsp;RAII&nbsp;라 불리는&nbsp;자원의 획득은 초기화다&nbsp;- Resource Acquisition Is Initialization&nbsp;입니다. 이는 자원 관리를 스택에 할당한 객체를 통해 수행하는 것포인터는 객체가 아님. delete를 하지 않고 포인터가 유실되면 힙에 저장되어 있는 데이터는 그대로 남아있음.객체는 소멸될 떄 소멸자를 호출함.포인터 '객체' 로 만들어서 자신이 소멸 될 때 자신이 가리키고 있는 데이터도 같이&nbsp;delete&nbsp;하게 하면 됩니다. 즉, 자원 (이 경우 메모리) 관리를 스택의 객체 (포인터 객체) 를 통해 수행하게 되는 것임이러한 타입을 스마트 포인터라고 함.특정 객체에 유일한 소유권을 부여하는 포인터 객체를&nbsp;unique_ptr여기서 퀴즈!&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/301" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/301" target="_self">std::move</a>&nbsp;가 왜 필요할까요?void do_something() { std::unique_ptr&lt;A&gt; pa(new A()); std::cout &lt;&lt; "pa : "; pa-&gt;some(); // pb 에 소유권을 이전. std::unique_ptr&lt;A&gt; pb = std::move(pa); std::cout &lt;&lt; "pb : "; pb-&gt;some();
} unique_ptr는 리소스의 독점적 소유권을 보장하기 위해 복사를 허용하지 않습니다. 즉, 복사 생성자와 복사 대입 연산자가 delete되어 있죠.
대신 소유권을 이전하는 방법으로 이동 연산자와 이동 생성자를 사용할 수 있습니다. 이들은 rvalue 참조를 매개변수로 받도록 설계되어 있습니다.
그런데&nbsp;pa와 같은 기존 unique_ptr은 lvalue입니다. 이동 연산자/생성자는 rvalue 참조만 받을 수 있으므로, lvalue인&nbsp;pa를 직접 전달할 수는 없습니다.
여기서 std::move가 필요한 것입니다! move는 lvalue를 rvalue로 캐스팅해주는 역할을 합니다. 이렇게 rvalue가 된 포인터는 이동 연산자/생성자가 받을 수 있는 형태가 되어 소유권 이전이 가능해집니다.
결국 이는 C++의 타입 시스템이 value category(lvalue/rvalue)를 통해 리소스의 소유권 이전을 안전하게 관리하는 방식이라고 볼 수 있습니다.void do_something(std::unique_ptr&lt;A&gt;&amp; ptr) { ptr-&gt;do_sth(3); } int main() { std::unique_ptr&lt;A&gt; pa(new A()); do_something(pa);
}
void do_something(A* ptr) { ptr-&gt;do_sth(3); } int main() { std::unique_ptr&lt;A&gt; pa(new A()); do_something(pa.get());
}
두 차이점은?첫 번째 방식 (참조로 전달):void do_something(std::unique_ptr&lt;A&gt;&amp; ptr)
이 방식은 unique_ptr 자체를 참조로 받습니다. 이는 다음을 의미합니다:
함수가 unique_ptr의 전체 기능에 접근할 수 있습니다. 예를 들어 reset()을 호출하거나, 다른 객체로 재할당할 수 있습니다.
소유권 관점에서 보면, 함수가 포인터의 소유권에 영향을 미칠 수 있는 권한을 가집니다.
함수가 unique_ptr만 받을 수 있고, 일반 포인터는 받을 수 없습니다.
두 번째 방식 (raw 포인터로 전달):void do_something(A* ptr)
이 방식은 get()을 통해 내부의 raw 포인터만 전달합니다:
함수는 단순히 객체의 멤버에만 접근할 수 있습니다.
소유권과 관련된 어떤 작업도 할 수 없습니다.
이 함수는 더 유연합니다. unique_ptr 뿐만 아니라 shared_ptr, raw 포인터 등 다양한 소스로부터 포인터를 받을 수 있습니다.
일반적으로 두 번째 방식이 더 선호됩니다. 그 이유는:
함수의 의도가 더 명확합니다 - "나는 객체를 사용만 할 뿐, 소유권은 건드리지 않겠다"
더 유연합니다 - 다양한 포인터 타입과 함께 사용할 수 있습니다
SOLID 원칙 중 인터페이스 분리 원칙(Interface Segregation Principle)에 더 부합합니다 - 함수는 실제로 필요한 기능만 받습니다
만약 함수가 정말로 포인터의 소유권을 조작해야 한다면, 그때는 첫 번째 방식을 사용하는 것이 적절할 것입니다.c++14 std::make_unique#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt; class A { int *data; public: A(int i) { std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; data = new int[100]; data[0] = i; } void some() { std::cout &lt;&lt; "일반 포인터와 동일하게 사용가능!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "자원을 해제함!" &lt;&lt; std::endl; delete[] data; }
}; int main() { std::vector&lt;std::unique_ptr&lt;A&gt;&gt; vec; std::unique_ptr&lt;A&gt; pa(new A(1)); vec.push_back(pa); // 에러 발생 <br>삭제된&nbsp;unique_ptr&nbsp;의 복사 생성자에 접근하였기 때문이지요. 기본적으로&nbsp;vector&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/185" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/185" target="_self">push_back</a>&nbsp;함수는 전달된 인자를 복사해서 집어 넣기 때문에 위와 같은 문제가 발생하게 되는 것이지요.<br>이를 방지하기 위해서는 명시적으로&nbsp;pa&nbsp;를&nbsp;vector&nbsp;안으로 이동 시켜주어야만 합니다. 즉&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/185" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/185" target="_self">push_back</a>&nbsp;의 우측값 레퍼런스를 받는 버전이 오버로딩 될 수 있도록 말이지요. -&gt; move 이용int main() { std::vector&lt;std::unique_ptr&lt;A&gt;&gt; vec; std::unique_ptr&lt;A&gt; pa(new A(1)); vec.push_back(std::move(pa)); // 잘 실행됨
}
아니면 emplace_back 이용.먼저 perfect forwarding의 핵심을 상기해보면, 이는 함수 템플릿이 인자를 받아서 다른 함수로 전달할 때 인자의 값 카테고리(lvalue/rvalue)와 const/volatile 등의 특성을 그대로 보존하는 것입니다.emplace_back은 이 perfect forwarding을 활용해서 컨테이너 내부에서 객체를 직접 생성합니다. 기본적인 구현은 대략 이렇게 됩니다:template&lt;typename... Args&gt;
reference emplace_back(Args&amp;&amp;... args) { // 메모리 재할당이 필요한지 확인하고 처리 // perfect forwarding을 사용해 객체를 직접 생성 construct_at(data_ + size_, std::forward&lt;Args&gt;(args)...); ++size_; return back();
}
여기서 중요한 점은 Args&amp;&amp;...가 forwarding reference(universal reference)로 사용되어, 어떤 타입의 인자든 받을 수 있고, std::forward를 통해 그 특성을 완벽하게 보존주의할점은 아래 코드를 조심해야함. 어떤 생성자가 호출되는 지.std::vector&lt;std::vector&lt;int&gt;&gt; v;
v.emplace_back(100000); // 100000개의 원소를 가진 벡터를 추가하게 됨.
이건 생성자 정의.vector(size_type count); // count개의 기본값으로 초기화된 원소
vector(size_type count, const T&amp; value); // count개의 value로 초기화된 원소
]]></description><link>cpp/raii.html</link><guid isPermaLink="false">CPP/RAII.md</guid><pubDate>Tue, 24 Dec 2024 08:48:41 GMT</pubDate></item><item><title><![CDATA[move, 레퍼런스 겹침 규칙]]></title><description><![CDATA[lvalue는 "주소가 있는 값"으로 생각할 수 있음
마치 우리가 집 주소로 찾아갈 수 있는 집처럼, 프로그램에서 다시 찾아갈 수 있는 위치를 가진 값rvalue는 "임시 값"으로 생각할 수 있음.
마치 계산기로 계산한 결과 값처럼, 잠시 존재했다가 사라지는 값int x = 10; // x는 lvalue
int y = x; // x는 lvalue
int z = x + y; // (x + y)는 rvalue
class String { char* data;
public: // 이동 생성자 String(String&amp;&amp; other) noexcept { data = other.data; // 데이터 포인터만 가져옴 other.data = nullptr; // 원본은 무효화 } // 이동 대입 연산자 String&amp; operator=(String&amp;&amp; other) noexcept { if (this != &amp;other) { delete[] data; // 기존 데이터 해제 data = other.data; // 새 데이터 이동 other.data = nullptr; // 원본 무효화 } return *this; }
}; // 사용 예시
String str1("Hello");
String str2 = std::move(str1); // str1의 내용이 str2로 이동됨
여기서 std::move는 실제로 객체를 이동시키지 않고, 단지 lvalue를 rvalue로 캐스팅하는 역할. 실제 이동은 이동 생성자나 이동 대입 연산자에서 일어남Perfect forwarding은 함수 템플릿에서 인자의 값 카테고리(lvalue/rvalue)를 그대로 유지하면서 전달하는 기능template&lt;typename T&gt;
void wrapper(T&amp;&amp; param) { // 보편 참조(universal reference) foo(std::forward&lt;T&gt;(param)); // perfect forwarding
} // 사용 예시
std::string str = "hello";
wrapper(str); // str은 lvalue로 전달됨
wrapper(std::string("world")); // 임시 객체는 rvalue로 전달됨
std::forward가 하는 일을 자세히 살펴보면:
lvalue가 전달되면 lvalue 참조로 전달
rvalue가 전달되면 rvalue 참조로 전달
이를 통해 얻는 이점:
불필요한 복사를 방지할 수 있습니다
인자의 원래 특성(lvalue/rvalue)을 그대로 보존할 수 있음
템플릿 기반의 제네릭 코드를 효율적으로 작성할 수 있음
class Widget { std::vector&lt;int&gt; data;
public: // 생성자에서 perfect forwarding 사용 template&lt;typename... Args&gt; Widget(Args&amp;&amp;... args) : data(std::forward&lt;Args&gt;(args)...) {}
}; // 사용 예시
std::vector&lt;int&gt; vec = {1, 2, 3};
Widget w1(vec); // lvalue로 전달 - 복사 발생
Widget w2(std::vector&lt;int&gt;{1,2,3}); // rvalue로 전달 - 이동 발생
move 의미론과 perfect forwarding은 현대 C++에서 성능 최적화의 핵심 요소이며, 특히 대용량 데이터를 다루는 프로그램에서 매우 중요한 역할.
이를 통해 불필요한 복사를 줄이고 더 효율적인 코드를 작성할 수 있음]]></description><link>cpp/move,-레퍼런스-겹침-규칙.html</link><guid isPermaLink="false">CPP/move, 레퍼런스 겹침 규칙.md</guid><pubDate>Wed, 18 Dec 2024 11:46:05 GMT</pubDate></item><item><title><![CDATA[rvalue rvalue 참조]]></title><description><![CDATA[
rvalue란? 메모리상의 임시 값입니다
프로그램에서 곧 사라질 값입니다
주소를 가질 수 없는 값입니다 int a = 5 + 3; // 여기서 5 + 3이 rvalue
std::string str = std::string("hello"); // std::string("hello")가 rvalue rvalue 참조(&amp;&amp;)란? rvalue를 참조할 수 있는 특별한 참조 타입
C++11 // 1. 기본적인 rvalue와 참조
int&amp;&amp; rref = 42; // 42는 rvalue, rref는 rvalue 참조
int x = 10;
int&amp;&amp; rref2 = x; // 컴파일 에러! x는 lvalue이므로 rvalue 참조 불가능
int&amp;&amp; rref3 = std::move(x); // OK! std::move는 lvalue를 rvalue로 변환 // 2. 문자열 예제
std::string getName() { return "John"; // "John"은 임시 객체(rvalue)
} std::string&amp;&amp; name = getName(); // 임시 객체를 rvalue 참조로 받음
성능 최적화, 불필요한 복사 방지class BigData { int* data; size_t size;
public: // 이동 생성자 (rvalue 참조 사용) BigData(BigData&amp;&amp; other) noexcept { // 포인터만 복사 (매우 빠름) data = other.data; size = other.size; // 원본 무효화 other.data = nullptr; other.size = 0; }
}; rvalue 참조 변수는 lvalue
void process(int&amp;&amp; x) { int&amp;&amp; y = x; // 에러! x는 rvalue 참조지만, 그 자체는 lvalue입니다 int&amp;&amp; y = std::move(x); // OK
} std::move는 실제로 객체 이동X
std::string str = "hello";
std::move(str); // 아무 일도 일어나지 않음
std::string str2 = std::move(str); // 여기서 실제 이동 발생 rvalue: 임시적이고 곧 사라질 값
rvalue 참조(&amp;&amp;): 이러한 임시 값을 참조할 수 있는 방법
주요 용도: 이동 생성자와 이동 대입 연산자 구현
성능 최적화: 불필요한 복사를 줄이고 효율적인 리소스 이동 가능
]]></description><link>cpp/rvalue-rvalue-참조.html</link><guid isPermaLink="false">CPP/rvalue rvalue 참조.md</guid><pubDate>Wed, 18 Dec 2024 11:46:05 GMT</pubDate></item><item><title><![CDATA[18. HTTP]]></title><description><![CDATA[HTTP는 문자열으로 날라옴헤더 + Payload헤더
일반
요청
응답
엔티티
]]></description><link>network/18.-http.html</link><guid isPermaLink="false">Network/18. HTTP.md</guid><pubDate>Mon, 09 Dec 2024 13:10:48 GMT</pubDate></item><item><title><![CDATA[17. DNS]]></title><description><![CDATA[Domain name
www - 호스트 네임
naver.com - 도메인 네임naver.com의 www 호스트를 찾아라ISP ( KT, LG , SK etc)에 호스트가 붙어있음.<a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.naver.com" target="_self">http://www.naver.com</a> 라고 씀<br>DNS 서버한테 질의를 함 - <a data-tooltip-position="top" aria-label="http://www.naver.com" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.naver.com" target="_self">www.naver.com</a> ip 주소를 알려줘ip 받으면 접속하기질의 했을 때 응답으로 유효시간이 옮.
한번이라도 질의 하면 pc가 DNS 캐싱함. (DNS 캐시)DNS Cache, host 파일, 공유기 DNS 포워딩 기능은 DNS 서버에 직접 질의하는 걸 줄여줌.<br>DNS에 질의를 했는데 모를수도 있음. (예를들어 <a data-tooltip-position="top" aria-label="http://www.naver.com" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.naver.com" target="_self">www.naver.com</a>)
그러면, Root DNS한테 요청함
Root DNS는 com 담당하는 DNS 목록을 알려줌.
naver 목록을 알려줘
naver 목록을 알려줌
www인 호스트 알려줘
naver 목록을 알려줌]]></description><link>network/17.-dns.html</link><guid isPermaLink="false">Network/17. DNS.md</guid><pubDate>Mon, 09 Dec 2024 13:08:08 GMT</pubDate></item><item><title><![CDATA[Metal]]></title><description><![CDATA[<img alt="metal_rendering_pipeline.png" src="images/metal_rendering_pipeline.png" target="_self">MTLDevice
GPU에 대한 추상화된 인터페이스
리소스(버퍼, 텍스처 등) 생성을 담당
커맨드 큐 생성
GPU 메모리 할당 관리
일반적으로 MTLCreateSystemDefaultDevice()로 생성
MTLCommandQueue
GPU에 전송할 명령어들의 큐
커맨드 버퍼들을 순차적으로 관리
렌더링 명령을 GPU에 전달하는 파이프라인
device.makeCommandQueue()로 생성
MTLRenderPipelineState
그래픽스 렌더링 파이프라인의 상태를 캡슐화
셰이더 프로그램, 버텍스 레이아웃, 블렌딩 모드 등 포함
렌더링 설정을 고정하여 성능 최적화
MTLBuffer
GPU 메모리에 할당된 데이터 버퍼
버텍스 데이터, 변환 행렬 등을 저장
CPU-GPU 간 데이터 전송에 사용
MTLDepthStencilState
깊이(Z) 테스트와 스텐실 테스트 설정을 관리
3D 렌더링에서 물체의 앞뒤 관계 처리
Camera
가상 카메라의 속성과 행렬을 관리하는 커스텀 클래스
View와 Projection 행렬 계산
렌더링과정
MTLDevice로 필요한 리소스들 생성
MTLBuffer에 데이터 저장
MTLRenderPipelineState로 렌더링 파이프라인 설정
MTLCommandQueue를 통해 커맨드 버퍼 생성
커맨드 버퍼에 렌더링 명령 인코딩
커맨드 버퍼 커밋하여 GPU 실행
// 1. 깊이 버퍼 포맷 설정 // 32비트 부동소수점 형식의 깊이 버퍼 사용
metalView.depthStencilPixelFormat = .depth32Float // 2. 깊이 테스트 설정
let depthDescriptor = MTLDepthStencilDescriptor()
// 새로운 픽셀의 깊이 값이 기존 깊이 값보다 작거나 같을 때만 렌더링
depthDescriptor.depthCompareFunction = .lessEqual // 깊이 비교 함수
// 렌더링된 픽셀의 깊이값을 깊이 버퍼에 저장
// 왜 있을까? - 다음 렌더링 할 물체와의 깊이 비교
depthDescriptor.isDepthWriteEnabled = true // 깊이 값 쓰기 활성화
이유: 3D 객체들의 앞뒤 관계를 올바르게 표현하기 위해서import Foundation
import MetalKit
import simd class Camera { var position: SIMD3&lt;Float&gt; var target: SIMD3&lt;Float&gt; var up: SIMD3&lt;Float&gt; = [0, 1, 0] var aspect: Float = 1.0 var fov: Float = Float.pi / 3 var near: Float = 0.1 var far: Float = 100 init(position: SIMD3&lt;Float&gt;, target: SIMD3&lt;Float&gt;) { self.position = position self.target = target } var viewMatrix: float4x4 { // 시선 방향 계산 let direction = normalize(target - position) let right = normalize(cross(direction, up)) let newUp = normalize(cross(right, direction)) let translation = float4x4(columns: ( SIMD4&lt;Float&gt;(1, 0, 0, 0), SIMD4&lt;Float&gt;(0, 1, 0, 0), SIMD4&lt;Float&gt;(0, 0, 1, 0), SIMD4&lt;Float&gt;(-position.x, -position.y, -position.z, 1) )) let rotation = float4x4(columns: ( SIMD4&lt;Float&gt;(right.x, newUp.x, -direction.x, 0), SIMD4&lt;Float&gt;(right.y, newUp.y, -direction.y, 0), SIMD4&lt;Float&gt;(right.z, newUp.z, -direction.z, 0), SIMD4&lt;Float&gt;(0, 0, 0, 1) )) return rotation * translation } var projectionMatrix: float4x4 { let y = 1 / tan(fov * 0.5) let x = y / aspect let z = far / (far - near) let w = -z * near return float4x4(columns: ( SIMD4&lt;Float&gt;(x, 0, 0, 0), SIMD4&lt;Float&gt;(0, y, 0, 0), SIMD4&lt;Float&gt;(0, 0, z, 1), SIMD4&lt;Float&gt;(0, 0, w, 0) )) }
}
// SIMD3&lt;Float&gt;
- Single Instruction Multiple Data 벡터 타입
- 3D 공간의 x, y, z 좌표를 표현
- 고성능 벡터 연산을 위해 사용 // float4x4
- 4x4 부동소수점 행렬
- 3D 변환(이동, 회전, 크기 조절)을 표현
- 뷰와 투영 변환에 사용 // viewMatrix
- 월드 공간을 카메라 공간으로 변환
- 카메라의 위치와 방향을 기준으로 모든 객체의 위치 계산
- 구성: 회전 행렬 × 이동 행렬
- Translation: 물체들을 카메라 위치만큼 이동
- Rotation: 카메라 방향으로 회전 // projectionMatrix
- 3D 공간을 2D 화면으로 투영
- 원근감 표현 (가까운 물체는 크게, 먼 물체는 작게)
- fov, aspect, near, far 평면으로 계산
- 원근 투영을 위한 4x4 행렬
- fov와 aspect ratio로 시야 영역 정의
- near/far로 보이는 범위 제한 fov (시야각):
- 작은 값: 망원 렌즈 효과 (확대)
- 큰 값: 광각 렌즈 효과 (축소) near/far 평면:
- near: 너무 가까운 물체 잘림
- far: 너무 먼 물체 잘림 aspect ratio:
- 화면 비율에 맞춰 이미지 왜곡 방지 CPU와 GPU 간의 효율적인 데이터 공유
동적으로 업데이트되는 데이터 처리에 적합
메모리 정렬과 크기 관리 중요
적절한 에러 처리 필요
device.makeBuffer( length: MemoryLayout&lt;Uniforms&gt;.size, // 버퍼 크기 options: .storageModeShared // 메모리 저장 모드
)
// MTLDevice의 메서드
func makeBuffer( length: Int, // 버퍼 크기 (바이트) options: MTLResourceOptions // 메모리 관리 옵션
) -&gt; MTLBuffer? // 생성된 Metal 버퍼 반환
// 가능한 옵션들:
.storageModeShared // CPU와 GPU가 모두 접근 가능
.storageModePrivate // GPU만 접근 가능
.storageModeManaged // CPU와 GPU 각각 별도 복사본 관리 // .storageModeShared 사용 시
CPU (Swift) ⟷ 공유 메모리 ⟷ GPU (Metal)
- 양방향 직접 접근 가능
- 동기화 오버헤드 최소화
- 작은 크기의 자주 업데이트되는 데이터에 적합 // Uniform 버퍼 생성
let uniformBuffer = device.makeBuffer( length: MemoryLayout&lt;Uniforms&gt;.size, options: .storageModeShared
) // 데이터 업데이트
let uniforms = Uniforms( modelMatrix: modelMatrix, viewMatrix: camera.viewMatrix, projectionMatrix: camera.projectionMatrix
)
memcpy(uniformBuffer.contents(), &amp;uniforms, MemoryLayout&lt;Uniforms&gt;.size)
구를 그릴 때 지구본처럼 위도 경도를 이용해서 그림.// 구면 좌표계에서 데카르트 좌표계로 변환하는 공식:
x = r * cos(θ) * cos(φ)
y = r * sin(θ)
z = r * cos(θ) * sin(φ) 여기서:
r = radius (골프공 반지름)
θ (theta) = 위도 (-π/2 ~ π/2)
φ (phi) = 경도 (0 ~ 2π) // 1. 위도(latitude) 계산
let lat = Float.pi * (-0.5 + Float(i) / Float(segments))
/*
i = 0 일 때: -π/2 (-90°) i = segments/2 일 때: 0° (적도)
i = segments 일 때: π/2 (90°)
*/ // 2. y 좌표 계산
let y = radius * sin(lat)
/*
lat = -π/2 일 때: y = -radius (아래)
lat = 0 일 때: y = 0 (중간)
lat = π/2 일 때: y = radius (위)
*/ // 3. 현재 위도에서의 원의 반지름
let conLat = radius * cos(lat)
/*
lat = -π/2 일 때: conLat = 0 (점)
lat = 0 일 때: conLat = radius (가장 큰 원)
lat = π/2 일 때: conLat = 0 (점)
*/ // 경도에 따른 x,z 좌표 계산
let lng = 2 * Float.pi * Float(j) / Float(segments)
let x = conLat * cos(lng)
let z = conLat * sin(lng) /*
j = 0 일 때: (x,z) = (conLat, 0) [0°]
j = segments/4 일 때: (x,z) = (0, conLat) [90°]
j = segments/2 일 때: (x,z) = (-conLat, 0) [180°]
j = 3*segments/4 일 때: (x,z) = (0, -conLat) [270°]
j = segments 일 때: (x,z) = (conLat, 0) [360°]
*/ import MetalKit class GolfBallRenderer: NSObject, MTKViewDelegate { // MARK: - Geometry Creation static func createGeometry(device: MTLDevice) -&gt; (MTLBuffer?, MTLBuffer?) { // 골프공 메시 데이터 생성 (UV 구) var ballVertices: [Float] = [] let segments = 32 let radius: Float = 0.0213 // 실제 골프공 크기 (미터) for i in 0...segments { let lat = Float.pi * (-0.5 + Float(i) / Float(segments)) let y = radius * sin(lat) let cosLat = radius * cos(lat) for j in 0...segments { let lng = 2 * Float.pi * Float(j) / Float(segments) let x = cosLat * cos(lng) let z = cosLat * sin(lng) // 위치 ballVertices.append(x) ballVertices.append(y) ballVertices.append(z) // 법선 벡터 ballVertices.append(x/radius) ballVertices.append(y/radius) ballVertices.append(z/radius) } } // 지면 메시 데이터 생성 let groundVertices: [Float] = [ -50, 0, -50, 0, 1, 0, 50, 0, -50, 0, 1, 0, 50, 0, 50, 0, 1, 0, -50, 0, -50, 0, 1, 0, 50, 0, 50, 0, 1, 0, -50, 0, 50, 0, 1, 0 ] guard let ballBuffer = device.makeBuffer(bytes: ballVertices, length: ballVertices.count * MemoryLayout&lt;Float&gt;.stride, options: []), let groundBuffer = device.makeBuffer(bytes: groundVertices, length: groundVertices.count * MemoryLayout&lt;Float&gt;.stride, options: []) else { return (nil, nil) } return (ballBuffer, groundBuffer) }
}
let library = device.makeDefaultLibrary() let vertexFunction = library.makeFunction(name: "vertexShader") let fragmentFunction = library.makeFunction(name: "fragmentShader") 컴파일된 셰이더 코드를 로드
버텍스와 프래그먼트 셰이더 함수 참조 획득
let pipelineDescriptor = MTLRenderPipelineDescriptor()
pipelineDescriptor.vertexFunction = vertexFunction
pipelineDescriptor.fragmentFunction = fragmentFunction
pipelineDescriptor.colorAttachments[0].pixelFormat = metalView.colorPixelFormat 렌더링 파이프라인 구성 설정
셰이더 함수 연결
색상 출력 포맷 지정
]]></description><link>golf-simulator/metal.html</link><guid isPermaLink="false">Golf Simulator/Metal.md</guid><pubDate>Mon, 25 Nov 2024 13:33:02 GMT</pubDate><enclosure url="images/metal_rendering_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/metal_rendering_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[metal_rendering_pipeline]]></title><description><![CDATA[<img src="images/metal_rendering_pipeline.png" target="_self">]]></description><link>images/metal_rendering_pipeline.html</link><guid isPermaLink="false">images/metal_rendering_pipeline.png</guid><pubDate>Sun, 24 Nov 2024 06:54:43 GMT</pubDate><enclosure url="images/metal_rendering_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/metal_rendering_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FGenricError]]></title><description><![CDATA[2c90 Crashed: Thread
0 libsystem_kernel.dylib 0xc2ec __pthread_kill + 8
1 libsystem_pthread.dylib 0x7c0c pthread_kill + 268
2 libsystem_c.dylib 0x75ba0 abort + 180
3 U2Client 0x2417084 auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()&lt;FLogCategoryLogGenericPlatformMisc, char16_t [31], bool&gt;(FLogCategoryLogGenericPlatformMisc const&amp;, char16_t const (&amp;) [31], bool const&amp;) const + 653 (GenericPlatformMisc.cpp:653)
4 U2Client 0x24d2e54 FIOSErrorOutputDevice::Serialize(char16_t const*, ELogVerbosity::Type, FName const&amp;) + 31 (IOSErrorOutputDevice.cpp:31)
5 U2Client 0x254cf6c FOutputDevice::LogfImpl(char16_t const*, ...) + 178 (UnrealMemory.h:178)
6 U2Client 0x250e55c FDebug::ProcessFatalError() + 482 (AssertionMacros.cpp:482)
7 U2Client 0x277e668 UObjectBase::~UObjectBase() + 212 (UObjectArray.h:212)
8 U2Client 0x26d9534 FAsyncPurge::TickDestroyGameThreadObjects(bool, float, double) + 366 (GarbageCollection.cpp:366)
9 U2Client 0x26d8f3c FAsyncPurge::TickPurge(bool, float, double) + 489 (GarbageCollection.cpp:489)
10 U2Client 0x26ce4b4 IncrementalPurgeGarbage(bool, float) + 1783 (GarbageCollection.cpp:1783)
11 U2Client 0x4626ef4 UEngine::ConditionalCollectGarbage() + 1378 (IConsoleManager.h:1378)
12 U2Client 0x421ca50 UWorld::Tick(ELevelTick, float) + 1691 (LevelTick.cpp:1691)
13 U2Client 0x41064a4 UGameEngine::Tick(float, bool) + 224 (CoreGlobals.h:224)
14 U2Client 0x106c3c4 FEngineLoop::Tick() + 4902 (LaunchEngineLoop.cpp:4902)
15 U2Client 0x27e4410 -[IOSAppDelegate MainAppThread:] + 429 (IOSAppDelegate.cpp:429)
16 Foundation 0xde428 __NSThread__start__ + 732
17 libsystem_pthread.dylib 0x606c _pthread_start + 136
18 libsystem_pthread.dylib 0x10d8 thread_start + 8 9f40 Crashed: Thread
0 libsystem_kernel.dylib 0x7674 __pthread_kill + 8
1 libsystem_pthread.dylib 0x71ac pthread_kill + 268
2 libsystem_c.dylib 0x20c8c abort + 180
3 U2Client 0x2417084 auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()&lt;FLogCategoryLogGenericPlatformMisc, char16_t [31], bool&gt;(FLogCategoryLogGenericPlatformMisc const&amp;, char16_t const (&amp;) [31], bool const&amp;) const + 653 (GenericPlatformMisc.cpp:653)
4 U2Client 0x24d2e54 FIOSErrorOutputDevice::Serialize(char16_t const*, ELogVerbosity::Type, FName const&amp;) + 31 (IOSErrorOutputDevice.cpp:31)
5 U2Client 0x254cf6c FOutputDevice::LogfImpl(char16_t const*, ...) + 178 (UnrealMemory.h:178)
6 U2Client 0x250e55c FDebug::ProcessFatalError() + 482 (AssertionMacros.cpp:482)
7 U2Client 0x2624598 FAsyncLoadingThread::FlushLoading(int) + 7003 (AsyncLoading.cpp:7003)
8 U2Client 0x2787174 LoadPackageInternal(UPackage*, char16_t const*, unsigned int, FLinkerLoad*, FArchive*, FLinkerInstancingContext const*) + 1147 (UObjectGlobals.cpp:1147)
9 U2Client 0x2785ddc LoadPackage(UPackage*, char16_t const*, unsigned int, FArchive*, FLinkerInstancingContext const*) + 1469 (UObjectGlobals.cpp:1469)
10 U2Client 0x2784960 ResolveName(UObject*&amp;, FString&amp;, bool, bool, unsigned int, FLinkerInstancingContext const*) + 791 (UObjectGlobals.cpp:791)
11 U2Client 0x2785fe4 StaticLoadObjectInternal(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*, bool, FLinkerInstancingContext const*) + 853 (UObjectGlobals.cpp:853)
12 U2Client 0x2774930 StaticLoadObject(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*, bool, FLinkerInstancingContext const*) + 928 (UObjectGlobals.cpp:928)
13 U2Client 0x278662c StaticLoadClass(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*) + 1322 (UObjectGlobals.h:1322)
14 U2Client 0x1dc2248 UUIScreenController::CreatePopupUI(EU2UIScreenLayerType, FString, bool) + 1332 (UObjectGlobals.h:1332)
15 U2Client 0x1dc285c UUIScreenController::OpenPopupUI(FString, bool) + 294 (UIScreenController.cpp:294)
16 U2Client 0x1dc2950 UUIScreenController::OpenPopupUI(FString, FAnchors const&amp;, FVector2D const&amp;, bool) + 306 (UIScreenController.cpp:306)
17 U2Client 0x1bf67d8 UUIErrorPopup* UUIScreenController::OpenPopup&lt;UUIErrorPopup&gt;(EUIComponentPopup, bool) + 149 (UIScreenController.h:149)
18 U2Client 0x1dcea48 UU2NetworkManager::MessageManagerEnum(EU2MsgType, UMsgC_Base*) + 105 (U2NetworkManager.cpp:105)
19 U2Client 0x1e5f708 TBaseUObjectMethodDelegateInstance&lt;false, UManagerObject, void (EU2MsgType, UMsgC_Base*), FDefaultDelegateUserPolicy&gt;::ExecuteIfSafe(EU2MsgType, UMsgC_Base*) const + 598 (DelegateInstancesImpl.h:598)
20 U2Client 0x1e5f8a8 UE4Function_Private::TFunctionRefCaller&lt;UMessageManager::SendThreadSafeMsgManager(EU2MsgType, UMsgC_Base*)::$_49, void ()&gt;::Call(void*) + 955 (DelegateSignatureImpl.inl:955)
21 U2Client 0x1079fdc TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(TArray&lt;FBaseGraphTask*, TSizedDefaultAllocator&lt;32&gt;&gt;&amp;, ENamedThreads::Type) + 681 (Function.h:681)
22 U2Client 0x23f7be0 FNamedTaskThread::ProcessTasksUntilIdle(int) + 711 (TaskGraph.cpp:711)
23 U2Client 0x2bc2d9c FlushRenderingCommands(bool) + 1264 (RenderingThread.cpp:1264)
24 U2Client 0x27eb754 invocation function for block in FIOSApplication::OrientationChanged(UIInterfaceOrientation) + 465 (SharedPointerInternals.h:465)
25 U2Client 0x24d1fcc -[FIOSAsyncTask CheckForCompletion] + 69 (IOSAsyncTask.cpp:69)
26 U2Client 0x24d2044 +[FIOSAsyncTask ProcessAsyncTasks] + 107 (IOSAsyncTask.cpp:107)
27 U2Client 0x27e424c -[IOSAppDelegate MainAppThread:] + 297 (CoreGlobals.h:297)
28 Foundation 0x5b518 __NSThread__start__ + 716
29 libsystem_pthread.dylib 0x16cc _pthread_start + 148
30 libsystem_pthread.dylib 0xba4 thread_start + 8 FAsyncLoadingThread
0 libsystem_kernel.dylib 0x1268 __semwait_signal + 8
1 libsystem_c.dylib 0x57d8 nanosleep + 220
2 libsystem_c.dylib 0x64a4 usleep + 68
3 U2Client 0x261e12c FAsyncLoadingThread::Run() + 4772 (AsyncLoading.cpp:4772)
4 U2Client 0x2440214 FRunnableThreadPThread::Run() + 25 (PThreadRunnableThread.cpp:25)
5 U2Client 0x24236a8 FRunnableThreadPThread::_ThreadProc(void*) + 186 (PThreadRunnableThread.h:186)
6 libsystem_pthread.dylib 0x16cc _pthread_start + 148
7 libsystem_pthread.dylib 0xba4 thread_start + 8 FAsyncPurge
0 libsystem_kernel.dylib 0x167c __psynch_cvwait + 8
1 libsystem_pthread.dylib 0x806c _pthread_cond_wait + 1232
2 U2Client 0x2418fc4 FPThreadEvent::Wait(unsigned int, bool) + 443 (GenericPlatformProcess.cpp:443)
3 U2Client 0x26d9134 FAsyncPurge::Run() + 537 (GarbageCollection.cpp:537)
4 U2Client 0x2440214 FRunnableThreadPThread::Run() + 25 (PThreadRunnableThread.cpp:25)
5 U2Client 0x24236a8 FRunnableThreadPThread::_ThreadProc(void*) + 186 (PThreadRunnableThread.h:186)
6 libsystem_pthread.dylib 0x16cc _pthread_start + 148
7 libsystem_pthread.dylib 0xba4 thread_start + 8
Tip.FAsyncPurge는 언리얼엔진에서 가비지 컬렉션을 담당하는 비동기 스레드 -더 이상 사용되지 않는 객체들을 식별하고 정리(Purge)함
비동기 로딩 프로세스:
StaticLoadObject
-&gt; LoadPackage // 패키지 로딩 시작
-&gt; AsyncLoading 큐에 작업 등록
-&gt; FlushLoading // 로딩 완료 대기
-&gt; 로딩된 객체 반환 FlushLoading이 필요한 이유: LoadClass는 동기(Synchronous) 함수임 - 호출한 즉시 결과(UClass*)를 반환해야 함
하지만 실제 리소스 로딩은 비동기로 처리
따라서 비동기 로딩이 완료될 때까지 기다려야 함
이 "기다림"을 위해 FlushLoading 사용 FlushLoading의 역할:
void FAsyncLoadingThread::FlushLoading(int32 PackageId)
{ // 1. 현재 진행중인 비동기 로딩 작업들이 완료될 때까지 대기 // 2. 로딩된 객체들의 초기화/링킹 작업 // 3. 참조 관계 설정 // 4. 모든 작업이 완료되면 리턴
} 만약 FlushLoading이 없다면:
UClass* LoadedClass = LoadClass(...); // 비동기 로딩 시작
// 이 시점에서 실제 로딩이 안 된 상태로 반환될 수 있음
CreateWidget(LoadedClass); // 크래시! 아직 로딩 안 된 Class 사용 시도
UE의 FlushLoading은:큐에 있는 모든 비동기 로딩 작업을 처리할 때까지 대기
각 작업의 완료를 보장
모든 작업이 완료될 때까지 호출 스레드를 블록즉, "Flush"는 파이프라인이나 큐에 있는 모든 작업을 강제로 처리 완료시키는 동작을 의미
즉, FlushLoading은 비동기 로딩 시스템에서 동기적 결과가 필요할 때 사용되는 "동기화 포인트(Synchronization Point)"
이는 UE의 리소스 로딩 시스템에서 필수적인 메커니즘 크래쉬 발생 경로 UUIScreenController::CreatePopupUI()
-&gt; StaticLoadClass() -&gt; LoadPackage()
-&gt; FAsyncLoadingThread::FlushLoading()
-&gt; Fatal Error (Cannot Flush Async Loading while async loading is suspended) 상황:
1. ALT Status: Suspended (작업은 있지만 실행 못하는 상태)
[Task1] -&gt; [Task2] -&gt; [LoadClass Task] -&gt; [Task4]
하지만 실행 불가 (Suspended) 2. CreatePopupUI에서 LoadClass 호출
-&gt; StaticLoadObject -&gt; LoadPackage
-&gt; FlushLoading 호출 1. 교착 상태 발생:
FlushLoading: "모든 작업이 완료될 때까지 기다린다"
ALT: "Suspended 상태라 작업을 처리할 수 없다"
결과: ⚠️ 영원히 대기하게 됨 이유
AsyncLoadingThread가 suspend 상태일 때 LoadClass를 호출
LoadClass는 내부적으로 리소스 로딩을 위해 FlushLoading 호출
UE는 ALT가 Suspend 상태일 때 FlushLoading을 명시적으로 금지
UE_CLOG(IsAsyncLoadingSuspendedInternal(), LogStreaming, Fatal, TEXT("Cannot Flush Async Loading while async loading is suspended (%d)"), GetAsyncLoadingSuspendedCount()); UE가 이를 명시적으로 금지하는 이유
교착 상태 방지
리소스 로딩의 안전성 보장
명확한 에러 메시지로 개발자에게 문제 상황 전달 해결방안
ALT 상태를 먼저 체크하고 Suspend 상태일 때 지연 로딩을 하기 ]]></description><link>error/fgenricerror.html</link><guid isPermaLink="false">Error/FGenricError.md</guid><pubDate>Sun, 24 Nov 2024 06:53:10 GMT</pubDate></item><item><title><![CDATA[insight_before]]></title><description><![CDATA[<img src="images/insight_before.png" target="_self">]]></description><link>images/insight_before.html</link><guid isPermaLink="false">images/insight_before.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/insight_before.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/insight_before.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[insight_after]]></title><description><![CDATA[<img src="images/insight_after.png" target="_self">]]></description><link>images/insight_after.html</link><guid isPermaLink="false">images/insight_after.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/insight_after.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/insight_after.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vertext_shader_parallel]]></title><description><![CDATA[<img src="images/vertext_shader_parallel.png" target="_self">]]></description><link>images/vertext_shader_parallel.html</link><guid isPermaLink="false">images/vertext_shader_parallel.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/vertext_shader_parallel.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/vertext_shader_parallel.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vertex_shader]]></title><description><![CDATA[<img src="images/vertex_shader.png" target="_self">]]></description><link>images/vertex_shader.html</link><guid isPermaLink="false">images/vertex_shader.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/vertex_shader.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/vertex_shader.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[using_uniform]]></title><description><![CDATA[<img src="images/using_uniform.png" target="_self">]]></description><link>images/using_uniform.html</link><guid isPermaLink="false">images/using_uniform.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/using_uniform.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/using_uniform.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[use_vertex_attirbute_arrays]]></title><description><![CDATA[<img src="images/use_vertex_attirbute_arrays.png" target="_self">]]></description><link>images/use_vertex_attirbute_arrays.html</link><guid isPermaLink="false">images/use_vertex_attirbute_arrays.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/use_vertex_attirbute_arrays.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/use_vertex_attirbute_arrays.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[type_structure]]></title><description><![CDATA[<img src="images/type_structure.png" target="_self">]]></description><link>images/type_structure.html</link><guid isPermaLink="false">images/type_structure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/type_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/type_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[shader_program_structure]]></title><description><![CDATA[<img src="images/shader_program_structure.png" target="_self">]]></description><link>images/shader_program_structure.html</link><guid isPermaLink="false">images/shader_program_structure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/shader_program_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/shader_program_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rasterization_mean]]></title><description><![CDATA[<img src="images/rasterization_mean.png" target="_self">]]></description><link>images/rasterization_mean.html</link><guid isPermaLink="false">images/rasterization_mean.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/rasterization_mean.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rasterization_mean.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[register_vec]]></title><description><![CDATA[<img src="images/register_vec.png" target="_self">]]></description><link>images/register_vec.html</link><guid isPermaLink="false">images/register_vec.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/register_vec.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/register_vec.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[programmable_pipeline]]></title><description><![CDATA[<img src="images/programmable_pipeline.png" target="_self">]]></description><link>images/programmable_pipeline.html</link><guid isPermaLink="false">images/programmable_pipeline.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/programmable_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/programmable_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[prog_debugging]]></title><description><![CDATA[<img src="images/prog_debugging.png" target="_self">]]></description><link>images/prog_debugging.html</link><guid isPermaLink="false">images/prog_debugging.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/prog_debugging.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/prog_debugging.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[primitive_assembly_rasterization]]></title><description><![CDATA[<img src="images/primitive_assembly_rasterization.png" target="_self">]]></description><link>images/primitive_assembly_rasterization.html</link><guid isPermaLink="false">images/primitive_assembly_rasterization.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/primitive_assembly_rasterization.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/primitive_assembly_rasterization.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[opengl_shader_program_process]]></title><description><![CDATA[<img src="images/opengl_shader_program_process.png" target="_self">]]></description><link>images/opengl_shader_program_process.html</link><guid isPermaLink="false">images/opengl_shader_program_process.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/opengl_shader_program_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/opengl_shader_program_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[paralle_processing]]></title><description><![CDATA[<img src="images/paralle_processing.png" target="_self">]]></description><link>images/paralle_processing.html</link><guid isPermaLink="false">images/paralle_processing.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/paralle_processing.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/paralle_processing.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[matrix_row_prior]]></title><description><![CDATA[<img src="images/matrix_row_prior.png" target="_self">]]></description><link>images/matrix_row_prior.html</link><guid isPermaLink="false">images/matrix_row_prior.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/matrix_row_prior.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/matrix_row_prior.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[linear_interpolation]]></title><description><![CDATA[<img src="images/linear_interpolation.png" target="_self">]]></description><link>images/linear_interpolation.html</link><guid isPermaLink="false">images/linear_interpolation.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/linear_interpolation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/linear_interpolation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[math_func]]></title><description><![CDATA[<img src="images/math_func.png" target="_self">]]></description><link>images/math_func.html</link><guid isPermaLink="false">images/math_func.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/math_func.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/math_func.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[layout_qualifier]]></title><description><![CDATA[<img src="images/layout_qualifier.png" target="_self">]]></description><link>images/layout_qualifier.html</link><guid isPermaLink="false">images/layout_qualifier.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/layout_qualifier.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/layout_qualifier.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glsl_debugging_1]]></title><description><![CDATA[<img src="images/glsl_debugging_1.png" target="_self">]]></description><link>images/glsl_debugging_1.html</link><guid isPermaLink="false">images/glsl_debugging_1.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/glsl_debugging_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glsl_debugging_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[gpu_structure]]></title><description><![CDATA[<img src="images/gpu_structure.png" target="_self">]]></description><link>images/gpu_structure.html</link><guid isPermaLink="false">images/gpu_structure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/gpu_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gpu_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glsl_debugging2]]></title><description><![CDATA[<img src="images/glsl_debugging2.png" target="_self">]]></description><link>images/glsl_debugging2.html</link><guid isPermaLink="false">images/glsl_debugging2.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/glsl_debugging2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glsl_debugging2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[gl_error_flag]]></title><description><![CDATA[<img src="images/gl_error_flag.png" target="_self">]]></description><link>images/gl_error_flag.html</link><guid isPermaLink="false">images/gl_error_flag.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/gl_error_flag.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gl_error_flag.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glVertexAttribPointer]]></title><description><![CDATA[<img src="images/glvertexattribpointer.png" target="_self">]]></description><link>images/glvertexattribpointer.html</link><guid isPermaLink="false">images/glVertexAttribPointer.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/glvertexattribpointer.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glvertexattribpointer.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fragment_shader_execute]]></title><description><![CDATA[<img src="images/fragment_shader_execute.png" target="_self">]]></description><link>images/fragment_shader_execute.html</link><guid isPermaLink="false">images/fragment_shader_execute.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/fragment_shader_execute.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/fragment_shader_execute.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[func_1]]></title><description><![CDATA[<img src="images/func_1.png" target="_self">]]></description><link>images/func_1.html</link><guid isPermaLink="false">images/func_1.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/func_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/func_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fragment_shader]]></title><description><![CDATA[<img src="images/fragment_shader.png" target="_self">]]></description><link>images/fragment_shader.html</link><guid isPermaLink="false">images/fragment_shader.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/fragment_shader.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/fragment_shader.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[export_shader_code]]></title><description><![CDATA[<img src="images/export_shader_code.png" target="_self">]]></description><link>images/export_shader_code.html</link><guid isPermaLink="false">images/export_shader_code.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/export_shader_code.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/export_shader_code.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[debugging_failure]]></title><description><![CDATA[<img src="images/debugging_failure.png" target="_self">]]></description><link>images/debugging_failure.html</link><guid isPermaLink="false">images/debugging_failure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/debugging_failure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/debugging_failure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[debugging_success]]></title><description><![CDATA[<img src="images/debugging_success.png" target="_self">]]></description><link>images/debugging_success.html</link><guid isPermaLink="false">images/debugging_success.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/debugging_success.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/debugging_success.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bi_linear_interpolation]]></title><description><![CDATA[<img src="images/bi_linear_interpolation.png" target="_self">]]></description><link>images/bi_linear_interpolation.html</link><guid isPermaLink="false">images/bi_linear_interpolation.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/bi_linear_interpolation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bi_linear_interpolation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02. 프로그래머블 그래픽스 파이프라인]]></title><description><![CDATA[<img alt="paralle_processing.png" src="images/paralle_processing.png" target="_self">그래픽스 파이프라인이 병렬화되면서, 병렬 처리를 고려한 small size 프로그램이 필요해짐.
-&gt; Shader의 등장shader = small, special - purpose program
small size
병렬 처리
<br><img alt="programmable_pipeline.png" src="images/programmable_pipeline.png" target="_self"> 그래픽스가 fixed VLSI 칩으로 구현 -&gt; fixed pipeline 병렬처리 도입, 일부는 shader로 구현 -&gt; programmable pipeline vertex shader: vertex processing을 대체
fragment shader: fragment processing을 대체 shader 용어는 모호할 때가 많음 -&gt; 문맥으로 파악하자 vertex processing에 대응되는 프로세싱에 사용되는 코어를 의미하는 경우
실제 GPU에서 수행되고 있는 프로그램을 의미하는 경우 DirectX HLSL(high-level shader language)
OpenGL SL(OpenGL shader language)
]]></description><link>graphics/opengl/02/02.-프로그래머블-그래픽스-파이프라인.html</link><guid isPermaLink="false">graphics/opengl/02/02. 프로그래머블 그래픽스 파이프라인.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/paralle_processing.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/paralle_processing.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[03. GPU 내부 구조]]></title><description><![CDATA[<img alt="gpu_structure.png" src="images/gpu_structure.png" target="_self">기본 구조는 인풋 레지스터가 있고, 프로세서가 처리한 후 아웃풋 레지스터로 넘겨주는 형식.
vertext shader와 fragment shader는 GPU Core임
버텍스 쉐이더와 프래그먼트 쉐이더는 독립적이며 그 사이에 fixed hardware가 있음.
각각 쉐이더 프로세서는 임시 변수를 저장할 레지스터를 가지고 있음. (tempory variable)
글로벌 변수가 필요할 수도 있기 때문에 글로벌 레지스터도 있음 (uniform register)
버텍스 쉐이더 프로세서 처리 값인 varying 레지스터의 값과 rasterization을 거친 varying 레지스터의 값은 다름.
레지스터는 하나는 내부적으로 4차원 좌표 (x,y,z,w)로 처리하고 타입은 float.
primitive assembly 단계에서 적용 가능
꼭지점이 2개가 주어지면, 나머지 좌표가 결정됨 (보간법)
컬러도 보간할 수 있음
<br><img alt="linear_interpolation.png" src="images/linear_interpolation.png" target="_self"><br><img alt="bi_linear_interpolation.png" src="images/bi_linear_interpolation.png" target="_self">
rasterization의 핵심 기능
처음에 선분으로 연결하고 보간함
선분끼리 보간함
두번 보간해서 이중 선형 보간
<br><img alt="vertex_shader.png" src="images/vertex_shader.png" target="_self">
vertex processor가 a vertex data -&gt; normalized vertex data로 변환함
각각의 버텍스에 적용
gl_Position, gl_PointSize 같은 pre - defined 되어 있는 레지스터에 값을 넣으면 후처리 단계에서 바로 사용 가능
<br><img alt="primitive_assembly_rasterization.png" src="images/primitive_assembly_rasterization.png" target="_self">
3개의 버텍스 정보가 병렬처리를 거쳐서 3개의 버텍스 위치를 gl_Position 레지스터에 동시에 넣어줌
primitive assembly로 오면서 3개의 정보가 결합해 삼각형인지 판단
3개의 버텍스로 시작했지만, 수천개 수만개의 프래그먼트가 생성됨
이 삼각형 내부에 있는 픽셀을 선택하고 각 픽셀마다 프레그먼트 쉐이더를 진행함.
<br> <img alt="fragment_shader.png" src="images/fragment_shader.png" target="_self">이중선형보간을 통해 삼각형 내부에 속한 픽셀 하나하나 대응되는 데이터를 가지고 있음.
이 프래그먼트마다 Fragment Shader를 돌리면 픽셀의 최종값을 결정함. output이 나오고 이는 곧 framebuffer에 업데이트 되는 값임.]]></description><link>graphics/opengl/02/03.-gpu-내부-구조.html</link><guid isPermaLink="false">graphics/opengl/02/03. GPU 내부 구조.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/gpu_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gpu_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04. GLSL]]></title><description><![CDATA[
C style
새로운 자료형 도입, 연산 추가 vector, matrix
벡터, 행렬 연산
샘플러 for 텍스쳐 맵핑
GL Master Library GLM으로 발전
C++ style <img alt="opengl_shader_program_process.png" src="images/opengl_shader_program_process.png" target="_self">
OpenGL 소스코드를 컴파일 .exe 프로그램을 실행 (OpenGL 프로그램)
OpenGL 프로그램 내에서 vertext shader, fragment shader를 위한 소스코드를 내부에서 컴파일함.
GPU는 shader 프로그램 동시 실행
OpenGL 프로그램에서 user data를 vertex input으로 보냄
그래픽스 파이프라인 통과 -&gt; 화면 출력
<br><img alt="shader_program_structure.png" src="images/shader_program_structure.png" target="_self">
OpenGL은 내부적으로 컴파일러와 실행환경을 가지고 있음
Vertext Shader Object, Fragment Shader
glCreateShader -&gt; Shader object를 만듦
glShaderSource -&gt; 소스코드 내보내기
glCompileShader -&gt; vertex shader 를 위한 소스코드가 컴파일
내부적으로 obj 파일을 저장하게 됨
Shader 프로그램이 두 obj 파일을 묶어서 다운로드 함 (glAttachProgram)
glLinkProgram: GPU 쉐이더 Processor에서 실행 가능한 형태로 결합
glUseProgram: 최종적으로 그래픽 카드에서 실행 #version // 3.3 버전 코어 피쳐 사용
in vec4 vertexPos; // in은 input 레지스터 사용, x,y,z,w 사용 void main(void)
{ gl_Polsition = vertexPos
} <br><img alt="vertext_shader_parallel.png" src="images/vertext_shader_parallel.png" target="_self"><br><img alt="rasterization_mean.png" src="images/rasterization_mean.png" target="_self">#version 330 core out vec4 FragColor; // 프레임버퍼 업데이트. void main()
{ FragColor = vec4(1.0, 0.0, 0.0, 1.0); // red color
} <br><img alt="fragment_shader_execute.png" src="images/fragment_shader_execute.png" target="_self">]]></description><link>graphics/opengl/02/04.-glsl.html</link><guid isPermaLink="false">graphics/opengl/02/04. GLSL.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/opengl_shader_program_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/opengl_shader_program_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. Shader Programming 코드 분석]]></title><description><![CDATA[
shader program 컴파일 방법
const char* vertSource = "#version 330 core \n\
in vec4 vertexPos; \n\
void main(void) { \n\ gl_Position = vertexPos; \n\
}"; const char* fragSource = "#version 330 core \n\
out vec4 FragColor; \n\
void main(void) { \n\ FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n\
}"; GLuint vert = 0; // vertex shader ID number
GLuint frag = 0; // fragment shader ID number
GLuint prog = 0; // shader program ID number
C 프로그램 내에 gl 소스코드를 작성해야해서 스트링 형태로 저장void initFunc(void) { // vert: vertex shader vert = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vert, 1, &amp;vertSource, NULL); glCompileShader(vert); // compile to get .OBJ // frag: fragment shader frag = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(frag, 1, &amp;fragSource, NULL); glCompileShader(frag); // compile to get .OBJ // prog: program prog = glCreateProgram(); glAttachShader(prog, vert); glAttachShader(prog, frag); glLinkProgram(prog); // link to get .EXE // execute it! glUseProgram(prog); // 그래픽 카드에 exe 파일을 실행시키라는 명령어
} 컴파일 해서 최종적으로 executable 형태로 만들어서 그래픽 카드에 전송하는 것 GLunit glCreateShader(GLenum shaderType); shaderType: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER 버텍스 쉐이더인지, 프래그먼트 쉐이더인지 shaderID를 return 함 void glShaderSource(GLunit shaderID, Glsizei count, const GLChar* string, const GLint length); 소스 전달 함수
GLSizei - 문자열 개수가 몇개냐
GLChar** string - 각 문자열 시작주소
GLint* 각 문자열의 길이 void glCompileShader(GLuint shaderID); 소스를 컴파일 하고 obj 파일을 생성 GLuint glCreateProgram(); shader program을 생성
programID을 리턴함 void glAttachShader(GLuint programID, GLuint shaderID); 쉐이더를 프로그램에 어태치함
두번 불려야함 (vertex shader, fragment shader) void glLinkProgram(GLuint programID); 쉐이더 obj를 링크하고 executable을 만듦 void glUseProgram(GLuint programID); 프로그램을 GPU에 설치함 void drawFunc(void) { // clear in gray color glClear(GL_COLOR_BUFFER_BIT); // provide the vertex attributes GLuint loc = glGetAttribLocation(prog, "vertexPos"); glEnableVertexAttribArray(loc); glVertexAttribPointer(loc, 4, GL_FLOAT, GL_FALSE, 0, vertPos); // draw a triangle glDrawArrays(GL_TRIANGLES, 0, 3); // done glFinish();
} <img alt="use_vertex_attirbute_arrays.png" src="images/use_vertex_attirbute_arrays.png" target="_self"> GLint glGetAttribLocation(GLuint programID, const GLchar* name); 입력값: 프로그램 ID와, 대응되는 인풋 레지스터 이름
인풋 레지스터 인덱스가 리턴됨 void glEnableVertexAttribArray(GLuint index); 인풋 레지스터를 enable void glDisableVertexAttribArray(GLuint index); 인풋 레지스터를 Disable void glFinish(void); OpenGL 명령어 큐에 있는 모든 명령을 Finish 시키는 함수 void glVertexAttribPointer(GLuint index, GLint size, gLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer); <br><img alt="glVertexAttribPointer.png" src="images/glvertexattribpointer.png" target="_self">
void glDrawArrays(GLenum mode, GLint first, Glsizei count); Vertex 데이터를 Primitive Assembly 단계에서 어떻게 해석할 지를 결정
mode: 하나씩 사용할건지, 2개식 사용할건지, 3개씩 묶어서 사용할건지
first: 어디서부터 사용할건지 보통 0
count: 갯수 ]]></description><link>graphics/opengl/02/05.-shader-programming-코드-분석.html</link><guid isPermaLink="false">graphics/opengl/02/05. Shader Programming 코드 분석.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/use_vertex_attirbute_arrays.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/use_vertex_attirbute_arrays.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[06. 재사용가능한 코드]]></title><description><![CDATA[const char* vertSource = "#version 330 core \n\
in vec4 vertexPos; \n\
void main(void) { \n\ gl_Position = vertexPos; \n\
}"; const char* fragSource = "#version 330 core \n\
out vec4 FragColor; \n\
void main(void) { \n\ FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n\
}"; vertex / fragment shader source code는 const char* 임
별도의 파일로 저장하고, 읽어오는 함수를 사용하는 것이 편함.
const char* loadFile( const char* filename ) { FILE* fp = fopen( filename, "r" ); if (fp == NULL) { fprintf(stderr, "Error: cannot open \"%s\"\n", filename); return NULL; } // get file size to allocate a buffer fseek(fp, 0, SEEK_END); size_t len = ftell(fp); rewind(fp); char* buf = (char*)malloc(sizeof(char) * (len + 4)); // read in the whole contents: (ASSUMPTION: small file size) size_t size = fread(buf, sizeof(char), len, fp); fclose(fp); buf[size] = '\0'; // done return (const char*)buf;
}
<img alt="export_shader_code.png" src="images/export_shader_code.png" target="_self">loadFile에서 malloc을 사용 했기 때문에 free 꼭 해줘야함 (InitFunc에서 free 시키기)const char* vertSource = loadFile( vertFileName );
const char* fragSource = loadFile( fragFileName );
free( (void*)vertSource );
free( (void*)fragSource ); 현재 = Old
input attribute = attribute
output varying register = varying
FragColor = gl_FragColor GLSL 변수-&gt; Register 사용 어느 Register를 사용할것인가? GLSL 컴파일러가 할당
프로그래머가 강제로 할당 가능 -&gt; layout 키워드 n번째 register 할당<br>
<img alt="layout_qualifier.png" src="images/layout_qualifier.png" target="_self"> GLuint loc = glGetAttribLocation(prog, "vertexPos");
vertexPos가 저장된 레지스터 번호 가져 오는 방법 prog는 뭐지? - glProgram같은 layout에 할당할 시 컴파일러가 화냄 (에러 발생)OpenGL은 오래되어서 컴파일 안되는 레거시 코드가 많음.Example.
glBegin / glEnd
glVertex3f, 4f, 3fv, 4fv
glColor3f, 4f, 3fv, 4fv
glNormal3f, 3fv
GLUT function 사용 -&gt; 현재 GLUT 사용자 없음.
]]></description><link>graphics/opengl/02/06.-재사용가능한-코드.html</link><guid isPermaLink="false">graphics/opengl/02/06. 재사용가능한 코드.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/export_shader_code.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/export_shader_code.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[07. GLSL 자료형]]></title><description><![CDATA[
GLSL 자료형 Vector GLSL Matrix GLSL 언어적 특징
GLSL Qualifiers varying colors 프로그램
<img alt="type_structure.png" src="images/type_structure.png" target="_self">
basic type int, uint, float, double, bool 주로 float을 사용함<br>
<img alt="register_vec.png" src="images/register_vec.png" target="_self"> vectors float형: vec2, vec3, vec4
int형: ivecn
boolean형: bvecn Matrices float형: mat2, mat3, mat4
주의: 열 우선임<br>
<img alt="matrix_row_prior.png" src="images/matrix_row_prior.png" target="_self"> 기본적으로 attribute는 4개의 float을 담음.vec4를 주로 이용하는데 attribute의 멤버에 따라 어떻게 해석할 지 달라짐.
단순 value
배열로 나타내기
xyzw -&gt; 좌표
stpq -&gt; 텍스처 좌표
rgba -&gt; rgba 색상 a.xyzw = v.xyzw; // default
a = v.wzyx; // shuffled
단! 서로 다른 도메인끼리는 불가
xyzw, rgba, stpq 혼용불가 -&gt; .xgt 불가능
2차원 배열
float 형만 있음
열 우선임 -&gt; mat (n x m)일 때 n이 열, m이 행
레지스터에서 Matrix -&gt; mat4인 경우 -&gt; 4개의 register 포인터 자료형 없음
vector, matrix가 기본 자료형
c++스타일 구조체 사용가능
<br><img alt="func_1.png" src="images/func_1.png" target="_self">
파라미터에 in, out, inout을 넣을 수 있음기본적으로 안붙이면 in (call by value)고
out을 붙이면 y에 대한 call by ref임<br><img alt="math_func.png" src="images/math_func.png" target="_self">]]></description><link>graphics/opengl/02/07.-glsl-자료형.html</link><guid isPermaLink="false">graphics/opengl/02/07. GLSL 자료형.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/type_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/type_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[08. Uniform Variable]]></title><description><![CDATA[N개의 삼각형을 그린다고 가정하면, 각 삼각형은 각각의 3개의 Vertex Pos를 가질 거임.GLfloat vertPosFirst[] = { -0.5F, -0.5F, 0.0F, 1.0F, +0.0F, -0.5F, 0.0F, 1.0F, -0.5F, +0.0F, 0.0F, 1.0F,
}; GLfloat vertPosSecond[] = { 0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.0F, 0.0F, 1.0F, 0.0F, 0.5F, 0.0F, 1.0F,
}; ... n개가 필요함. 이렇게 n개의 삼각형 vertPos를 가지기 보다는 잘 정의된 vertex pos를 가지고 값을 더해서 새로운 삼각형을 표현할 수가 있음. -&gt; uniform variable을 사용하자.Uniform Variable은 일종의 전역변수임<img alt="using_uniform.png" src="images/using_uniform.png" target="_self">uniform variable은 uniform vec4로 선언함.#version 330 core in vec4 aPos; // vertex position: attribute
in vec4 aColor; // vertex color: attribute
out vec4 vColor; // varying color: varying
uniform vec4 uMove; // movement vector: uniform void main(void) { gl_Position = aPos + uMove; vColor = aColor;
} void drawFunc(void) { // clear in gray color glClear(GL_COLOR_BUFFER_BIT); // provide the vertex attributes GLuint locPos = glGetAttribLocation(prog, "aPos"); glEnableVertexAttribArray(locPos); glVertexAttribPointer(locPos, 4, GL_FLOAT, GL_FALSE, 0, vertPos); // provide the color attributes GLuint locColor = glGetAttribLocation(prog, "aColor"); glEnableVertexAttribArray(locColor); glVertexAttribPointer(locColor, 4, GL_FLOAT, GL_FALSE, 0, vertColor); // draw the first triangle GLuint locMove = glGetUniformLocation(prog, "uMove"); glUniform4f(locMove, -0.5F, -0.5F, 0.0F, 0.0F); glDrawArrays(GL_TRIANGLES, 0, 3); // draw the second triangle glUniform4f(locMove, 0.0F, 0.0F, 0.0F, 0.0F); glDrawArrays(GL_TRIANGLES, 0, 3); // done glFinish();
} // prog: Program
// name: string for uniform variable name
// return: location index of the specified uniform variable GLint glGetUniformLocation(GLuint prog, const GLchar* name); // 아래 함수는 값을 넣을 수 있음
void glUniform1f(GLint loc, Glfloat v0);
void glUniform2f(GLint loc, Glfloat v0 ...v1);
void glUniform3f(GLint loc, Glfloat v0 ... v1 ... v2);
void glUniform4f(GLint loc, Glfloat v0 ... v1 ... v2 ... v3); // 벡터도 넣을 수 있음. 예시 const GLfloat uMoveValue[] = {0.5f, 0.5f 0.5f, 0.5f }; void glUniform1fv(GLint loc, GLsizei count, const GLfloat* value);
void glUniform2fv(GLint loc, GLsizei count, const GLfloat* value);
void glUniform3fv(GLint loc, GLsizei count, const GLfloat* value);
void glUniform4fv(GLint loc, GLsizei count, const GLfloat* value); // transpose 전치 되어 있는 지?
void glUniformMatrix4fv(GLint loc, GLsizei count, GLbooleadn transpose,const GLfloat* value); count는 몇개를 보낼건지에 대한 거임. 예시를 보면 이해감// 단일 float 값 설정
GLfloat brightness = 0.8f;
glUniform1fv(brightnessLocation, 1, &amp;brightness); // 3D 벡터 (색상) 설정
GLfloat color[] = {1.0f, 0.0f, 0.0f}; // 빨간색
glUniform3fv(colorLocation, 1, color); // 여러 개의 2D 벡터 설정
GLfloat positions[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f}; // 3개의 2D 위치
glUniform2fv(positionsLocation, 3, positions);
]]></description><link>graphics/opengl/02/08.-uniform-variable.html</link><guid isPermaLink="false">graphics/opengl/02/08. Uniform Variable.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/using_uniform.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/using_uniform.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[09. GLSL 디버그 함수들]]></title><description><![CDATA[
GLSL 디버그 함수들
OpenGL 함수의 디버깅
OpenGL debug output
#version 330 core in vec3 vColor; // LINK ERROR: type mismatch ! out vec4 FragColor; // fragment color: framebuffer void main(void) { FragColor = vColor; // ERROR: type mismatch!
}
위의 코드는 error 가 있는 frag 파일임. 이를 컴파일 했을 때 문제가 생김. 그러나 프로그램은 실행이 됨. - 회색 화면이 출력됨.디버그를 하기 위해서는 아래의 GLSL 함수를 이용 해야함.void glGetShaderiv(GLuint shader, GLenum pname, GLint* params); pname: 어떤 값을 전달 받을 것인가에 대한 정의임. GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH ... params: pname에 대한 결과 GL_COMPILE_STATUS을 지정했다면, 성공: true(1) 실패: false(0) void glGetShaderInfoLog(GLuint shader, GLsizei maxLen, GLsizei* length, GLchar* infoLog); maxLen: infoLog array의 최대 길이
length: infoLog array의 길이
infoLog: 로그 정보 (버퍼에 담겨서 옴)
prog에서 디버깅 하기 (링킹, 실행)<img alt="prog_debugging.png" src="images/prog_debugging.png" target="_self">실제 사용 vert, frag에서<br>
<img alt="glsl_debugging_1.png" src="images/glsl_debugging_1.png" target="_self"> prog에서<br>
<img alt="glsl_debugging2.png" src="images/glsl_debugging2.png" target="_self"> 디버깅 결과 정상<br>
<img alt="debugging_success.png" src="images/debugging_success.png" target="_self"> 에러 발생<br>
<img alt="debugging_failure.png" src="images/debugging_failure.png" target="_self"> OpenGL 드라이버 내부에 error flag 변수를 이용
GLenum glGetError(); 함수를 이용.
GLenum glGetError(); returns: errorFlag
리턴 되고나면 error flag 변수를 GL_NO_ERROR로 초기화
<br><img alt="gl_error_flag.png" src="images/gl_error_flag.png" target="_self">
OpenGL debug extension - 크로노스 그룹에서 만들었음.
OpenGL 4.3에서 core feature가 되었음.
new 이벤트 드라이븐 모델임 OpenGL Error는 event임.
event handler는 callback function임 debug event 원인: API, WINDOW_SYSTEM, SHADER_COMPILER, …
종류: ERROR, UNDEFINED_BEHAVIOR, PERFORMANCE, MARKER (사용자가 표시한것), …
심각성의 정도: severe levels, HIGH, MEDIUM, LOW, NOTIFICATION 그 중 DONT_CARE는 everything임 glEnable(GL_DEBUG_OUTPUT); // 디버그 사용 활성화
glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); // 결과 즉시 출력
glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0 ,NULL, GL_TRUE); // -&gt; 모든 디버그 메세지 받음
glDebugMessageCallback(DebugLog, NULL); // DebugLog라는 함수를 콜백으로 등록함.
void glEnable(GLenum cap);
void glDisable(Glenum cap);
OpenGL 내부의 특정 기능을 on/off함void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled); debug 이벤트 설정 - source, type, severity
enabled: 기능을 끌 것인지 켤 것인지.
ids: 에러 id 넘버에 따라서 기능을 끌 것인지 켤 것인지 - ids다보니까 배열임
count: ids는 포인터 타입이라 길이가 없음. 길이를 여기에 넣으면 됨
콜백함수 등록에 관하여.typedef void (*DEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam); userParam: 사용자가 특정한 파라미터를 넣을 수 있음 -&gt; 추가적인 컨텍스트나 데이터 전달 가능
void APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam) { MyLogger* logger = (MyLogger*)userParam; logger-&gt;log(message);
} // 콜백 설정 시
MyLogger myLogger;
glDebugMessageCallback(debugCallback, &amp;myLogger); MyLogger 객체의 포인터가 userParam으로 전달되어, 콜백 함수 내에서 로깅에 사용
userParam은 const void* 타입이므로, 사용 시 적절한 타입으로 캐스팅해야 함
전달된 객체나 데이터의 생명주기 관리해야함
]]></description><link>graphics/opengl/02/09.-glsl-디버그-함수들.html</link><guid isPermaLink="false">graphics/opengl/02/09. GLSL 디버그 함수들.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/prog_debugging.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/prog_debugging.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Audio_Stream_caching]]></title><description><![CDATA[Audio Stream Caching은 Unreal Engine에서 오디오 성능을 최적화하기 위한 기능
메모리 최적화: 전체 오디오 파일을 메모리에 로드하는 대신 필요한 부분만 캐시에 저장
스트리밍 성능 향상: 자주 사용되는 오디오 데이터를 캐시에 유지하여 디스크 액세스를 줄입니다. When this feature is enabled at cook time, almost all compressed audio data is separated from the USoundWave asset and placed at the end of the .pak file. This makes it possible for audio to be loaded into memory at any point, and released again when it has not been recently used. 전체 오디오 파일 로드 X -&gt; 메모리 사용량 감소
전체 오디오 파일 로드 X -&gt; 로딩 시간 단축
대용량 오디오 파일 처리 효율 증가 SoundWave가 로드되었다고, 오디오가 즉시 재생 가능하다고 보장 X -&gt; 재생이 재연될 수 있음.
스트리밍 오버헤드 -&gt; 재생 중 지속적인 데이터 로딩 -&gt; CPU 연산 증가
디스크 I/O: 디스크 성능 중요성 커짐 캐시 크기 설정에 따라 성능이 좌지우지됨 -&gt; 적절한 사이즈를 결정해야함.
재생 지연은 캐시 크기에 따라 관련이 있을 확률이 높음 사운드 로드 후 맵에 저장하는 방식은 모든 오디오 데이터가 메모리에 상주
오디오 스트림 캐싱 사용을 하고 맵에 저장하는 방식은 오디오 파일에 대한 참조와 메타데이터 저장 맵에 저장한다는 것이 반드시 전체 데이터를 메모리에 올린다는 의미X
오디오 스트림 캐싱을 사용할 때, TMap에 저장되는 것은 주로 오디오 파일에 대한 참조와 메타데이터임
실제 오디오 데이터는 디스크에 남아있고, 필요한 부분만 작은 청크(chunk) 단위로 캐시에 로드됨 스트림 캐싱을 사용하면, 대부분의 오디오 데이터는 디스크에 남아있음
메인 메모리에는 작은 캐시와 오디오 파일 참조만 존재함 초기 로드 과정 오디오 파일의 메타데이터와 스트리밍에 필요한 정보를 로드 캐시프라이밍 - 오디오 데이터 일부를 메모리에 로드 재생을 빠르게 시작 -&gt; 재생 지연 낮춤
Prime On Load 옵션 사용 스트리밍 준비 실제 오디오 데이터의 위치와 접근 방법에 대한 정보를 설정 런타임 로딩 오디오 재생 시, 필요한 부분을 그때그때 캐시로 로드
백그라운드에서 비동기적으로 이뤄짐 전통적인 방식: 전체 오디오 파일을 한 번에 메모리에 로드스트림 캐싱 방식: 메타데이터와 초기 캐시 데이터만 로드하고, 나머지는 필요할 때 스트리밍 Inherited: 기본 설정
사운드 클래스나 전역 설정에서 로딩 동작을 상속 RetainOnLoad: 사운드 전체를 메모리에 로드하고 유지
작고 자주 사용되는 사운드에 적합 (예: UI 효과음, 짧은 캐릭터 음성)
장점: 빠른 재생 시작, 지연 없음.
단점: 메모리 사용량 증가. PrimeOnLoad: 사운드의 시작 부분만 메모리에 로드
큰 사운드 파일의 빠른 초기 재생이 필요할 때 유용
장점: 빠른 초기 재생, 상대적으로 적은 메모리 사용.
단점: 전체 사운드가 필요할 때 추가 로딩 시간 발생 가능 LoadOnDemand: 필요할 때만 사운드 데이터를 로드
큰 사운드 파일이나 자주 사용되지 않는 사운드에 적합
장점: 메모리 사용 최소화.
단점: 초기 재생 시 약간의 지연 발생 가능. ForceInline: 사운드를 스트리밍 가능한 에셋 패키지에 강제로 인라인화
특수한 경우에 사용됨(예: 패키징 요구사항이 특별한 경우). 사용시 고려사항 게임의 메모리 제약: 모바일 게임의 경우 LoadOnDemand나 PrimeOnLoad가 유용할 수 있음
사운드의 크기와 사용 빈도: 작고 자주 사용되는 사운드는 RetainOnLoad, 큰 배경음악은 LoadOnDemand가 적합
초기 로딩 시간 vs 런타임 성능: RetainOnLoad는 초기 로딩 시간을 증가시키지만 런타임 성능이 좋음 실제 적용 예시: UI 효과음: RetainOnLoad (빠른 반응성 필요)
배경 음악: LoadOnDemand 또는 PrimeOnLoad (파일 크기가 크지만 즉각적인 재생 시작이 필요하지 않을 수 있음)
레벨별 특수 효과음: LoadOnDemand (필요할 때만 로드)
자주 사용되는 캐릭터 음성: RetainOnLoad 또는 PrimeOnLoad (반응성과 메모리 사용의 균형) ]]></description><link>ue/audio_stream_caching.html</link><guid isPermaLink="false">UE/Audio_Stream_caching.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[언리얼엔진에서의 Lamda]]></title><description><![CDATA[참조로 변수를 캡쳐하는데 람다가 실행되기 전에 해당 '객체'가 파괴되면 널 포인터 참조가 발생함. 이 현상이 언리얼엔진의 Deferred Execution(지연 실행), 비동기 작업, 생명주기 같은 것들과 맞물려서 위험할 수 있음. Prefer Capturing by Value
가능하다면 참조 캡쳐보다 값 캡쳐를 사용할 것. 람다는 값을 복사해서 사용할 것이므로 독립적인 생명주기를 가지게 됨 Use TWeakObjectPtr
Unreal 객체에 대한 포인터를 캡처할 때 raw 포인터 대신 TWeakObjectPtr를 사용하는 것. TWeakObjectPtr는 객체가 파괴되는 경우를 안전하게 처리하여 객체에 액세스하기 전에 객체가 여전히 유효한지 확인 Check for Validity
캡쳐된 포인터나 레퍼런스에 접근하기 전에 nullptr 또는 TWeakObjectPtr를 체크한다. Using a Weak Lambda
Weak Lamda를 사용하면 람다 내부의 객체를 안전하게 참조할 수 있음. 소유 객체가 유효하지 않다면 대리자를 통해 람다를 호출하지 않음.
if (const UWorld* World = OwnerComp.GetWorld())
{ const float DeltaTime = NumTicksExecuting * FAITestHelpers::TickInterval; World-&gt;GetTimerManager().SetTimer(TaskMemory-&gt;TimerHandle, FTimerDelegate::CreateWeakLambda(this, [&amp;OwnerComp, TaskMemory, this]() // &lt;---- This is the declaration of a weak lambda { TaskMemory-&gt;TimerHandle.Invalidate(); ensure(!TaskMemory-&gt;bIsAborting); LogExecution(OwnerComp, LogIndexExecuteFinish); FinishLatentTask(OwnerComp, LogResult); }), DeltaTime, false);
} ]]></description><link>ue/언리얼엔진에서의-lamda.html</link><guid isPermaLink="false">UE/언리얼엔진에서의 Lamda.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[broadcastip_address]]></title><description><![CDATA[<img src="images/broadcastip_address.png" target="_self">]]></description><link>images/broadcastip_address.html</link><guid isPermaLink="false">images/broadcastip_address.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/broadcastip_address.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/broadcastip_address.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ip4v_header]]></title><description><![CDATA[<img src="images/ip4v_header.png" target="_self">]]></description><link>images/ip4v_header.html</link><guid isPermaLink="false">images/ip4v_header.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/ip4v_header.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ip4v_header.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[subnetmask]]></title><description><![CDATA[<img src="images/subnetmask.png" target="_self">]]></description><link>images/subnetmask.html</link><guid isPermaLink="false">images/subnetmask.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/subnetmask.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subnetmask.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[16.  TCP 연결 종료 과정]]></title><description><![CDATA[
4-way handshaking
클라가 FIN + ACK를 보냄
서버가 ACK를 보냄 그리고 다음 스텝에서 FIN + ACK를 보냄
클라이언트가 FIN + ACK를 받고 ACK를 보냄
서버가 ACK를 받음 -&gt; 종료완료
클라이언트가 Active하게 종료해야함
서버는 Passive하게 종료해야함
]]></description><link>network/16.-tcp-연결-종료-과정.html</link><guid isPermaLink="false">Network/16.  TCP 연결 종료 과정.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[07. IPv4 Header 형식]]></title><description><![CDATA[
MTU: 1500 bytes
Header: 20 bytes
Payload: 1500 - 20 bytes
<img alt="ip4v_header.png" src="images/ip4v_header.png" target="_self"> Version IPv4는 항상 4
4비트 IHL 헤더의 길이를 나타냄. 최소값은 5행(20bytes)임. 위의 스샷에서 20bytes가 헤더 길이임.
4비트 QOS(Quality of Service) or TOS QOS, TOS 정보를 포함
8비트 Total Length 헤더와 데이터를 포함한 전체 패킷의 길이 (bytes)
16비트 Identification 패킷 조각들을 구분하는 데 사용
16비트 Flag 패킷의 단편화와 관련된 제어 플래그
3비트 Fragment offset 원본 패킷에서의 데이터 오프셋을 8바이트 단위로 나타냄
13비트 TTL (Time To Live) 패킷의 수명을 제한
8비트 Protocol 위 계층 프로토콜(예: TCP, UDP)을 식별
8비트 Header checksum 헤더의 무결성을 검증
16비트 Source address 송신자의 IP 주소
32비트 Destination Address 수신자의 IP 주소
32비트 Options 선택적 필드로, 추가 기능을 제공
가변 길이 0 ~ 40 bytes Data Up to 65515 bytes까지지만 대부분의 경우 MTU - Header 길이를 넘지 않음! ]]></description><link>network/07.-ipv4-header-형식.html</link><guid isPermaLink="false">Network/07. IPv4 Header 형식.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/ip4v_header.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ip4v_header.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[08. 서브넷 마스크와 CIDR]]></title><description><![CDATA[IP 주소에서 Net ID와 Host ID는 Subnet mask와 함께 고려해야 함.
192.168.23.5 이라는 IP 주소가 있다고 가정
Subnet Mask가 255.255.255.0임
192.168.23 은 Net ID
5은 Host ID
즉 Subnet Mask란, IP주소에서 NetID와 Host ID를 구분하기 위한 용도 Class A -&gt;Network ID는 8비트
Class B-&gt; Network ID는 16비트
Class C -&gt; Network ID는 24비트 서브넷 마스크와 IP 주소를 AND 연산하면 Net ID는 본래의 값이 나오고 Host ID는 0이 나옴 -&gt; Host ID 마스킹 함
Net ID 구분이 중요한 이유 패킷이 올 때, 네트워크 ID가 같으면 우리쪽으로 유입하는 것임을 알 수 있음. <img alt="subnetmask.png" src="images/subnetmask.png" target="_self"> 요즘은 CIDR 표기방식을 사용함. 서브넷마스크를 이용
192.168.23.5
255.255.255.0 CIDR 이용
192.168.23.5 / 24 ]]></description><link>network/08.-서브넷-마스크와-cidr.html</link><guid isPermaLink="false">Network/08. 서브넷 마스크와 CIDR.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/subnetmask.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subnetmask.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[09. Broadcast IP 주소 & Loopback 주소]]></title><description><![CDATA[
패킷을 보낼때 dst를 보고 Gateway로 전달을 함.
Gateway는 Internet으로 보냄
dst가 특정 IP면 Unicast임 (콕 집어서 보내는 거)
<img alt="broadcastip_address.png" src="images/broadcastip_address.png" target="_self">
Net ID를 제외한 Host ID를 모두 1로 채우면 Broadcast IP 주소임
dst가 Broadcast 주소면 전체한테 다 보냄
브로드캐스팅은 효율성이 떨어짐 Host ID가 0 인 경우 -&gt; 서브넷 마스크와 일치
Host ID가 255인 경우 -&gt; 브로드캐스트 주소 IP 주소를 사용해 통신하는 주체는 Process임.
내 Process간의 통신 이뤄질 때 사용하는 주소: Loopback address -&gt; 127.0.0.1
이 주소를 사용하면 패킷을 H/W영역에 보내지 않아도 됨
]]></description><link>network/09.-broadcast-ip-주소-&amp;-loopback-주소.html</link><guid isPermaLink="false">Network/09. Broadcast IP 주소 &amp; Loopback 주소.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/broadcastip_address.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/broadcastip_address.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[10. TTL과 단편화]]></title><description><![CDATA[인터넷은 라우터와 DNS의 집합체임.Router의 역할은 라우터 테이블을 보고 패킷을 포워딩하는 것. (물류센터, 택배 기사 역할)
Router에서 Router로 이동하는 걸 Hop(깡총)이라고 함.
Hop을 하게 되면 TTL 값이 1씩 감소함.
Time To Live
IP 패킷 수명을 제한하는 메커니즘
라우터를 통과할 때마다 TTL 값 1씩 감소
수명을 제한 하지 않는다면 패킷이 네트워크를 무한 순회 -&gt; 좀비 패킷
대부분 패킷의 최대 사이즈 (MTU = 1500 bytes)임. 간혹 서로 다른 네트워크 구간의 MTU 차이가 발생할 수 있음 (어떤 건 1400bytes, 1500 bytes) 이럴 때 패킷을 보내기 위해 쪼개는 걸 단편화라고 함.
쪼개진 단편들은 수신자(Endpoint)에서 조립함.
단편화된 패킷은 각각 다른 경로로 전송될 수 있음 (TTL이 만료되어 폐기 가능성 있음)
단편화는 비효율적 -&gt; 처음부터 패킷을 보낼 때 하향 표준화해서 보내는 방법도 있음(처음부터 작은 사이즈 패킷을 보냄)
VPN 터널링 기술에서 단편화 발생할 가능성 높음
]]></description><link>network/10.-ttl과-단편화.html</link><guid isPermaLink="false">Network/10. TTL과 단편화.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[11. 인터넷 자동 설정 - DHCP]]></title><description><![CDATA[인터넷을 사용하려면 해야할 게 있음.
IP 주소
Subnet mask
Gateway IP
DNS 서버
일반 사용자는 이러한 설정을 하지 않음. 그럼 누가 해주나?DHCP가 해준다. Dynamic Host Configuration Protocol 기능 IP 주소 할당: 네트워크에 연결된 장치에 고유한 IP 주소를 자동으로 할당
서브넷 마스크 제공: IP 네트워크의 범위를 정의하는 서브넷 마스크를 제공
기본 게이트웨이 설정: 로컬 네트워크 외부와 통신하기 위한 게이트웨이 주소를 제공
DNS 서버 정보: 도메인 이름을 IP 주소로 변환하는 DNS 서버의 주소를 제공 DHCP는 내가 사용할 위의 네가지 것들을 DHCP 서버가 알려주는 것임 DHCP 작동 과정 클라이언트가 네트워크에 연결되면 DHCP 서버를 찾아야함 -&gt; 브로드캐스트
DHCP 서버가 위의 정보들을 보내줌 (IP주소, 서브넷마스크 등등)
클라이언트가 수락하고 요청 보냄
DHCP 서버가 최종 승인함. 즉 DHCP 서버는 주소값을 관리하는 pool이라고 할 수 있음 DHCP는 브로드캐스트 도메인에 묶여있음. 브로드캐스트 도메인: 브로드캐스트 패킷이 도달할 수 있는 네트워크 범위 DHCP 브로드 캐스트 메세지는 Gateway를 넘을 수 없음. DHCP는 기본적으로 로컬 브로드캐스트 도메인 내에서 작동하며, 브로드캐스트 트래픽은 일반적으로 라우터를 통과X 라우터는 주로 다른 네트워크 범위로 트래픽을 이동 시키는데 사용.
같은 네트워크면 ARP or 스위치나 허브를 통해 직접 통신 ]]></description><link>network/11.-인터넷-자동-설정-dhcp.html</link><guid isPermaLink="false">Network/11. 인터넷 자동 설정 - DHCP.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[12. ARP]]></title><description><![CDATA[Address Resolution Protocol
브로드 캐스팅
IP 주소로 게이트웨이의 MAC 주소를 알아내려할 때 활용.
DHCP로 먼저 게이트웨이의 IP를 알고 ARP Request를 보내고 Reply로 게이트웨이의 MAC 주소를 얻음
왜? 인터넷을 연결하기 위해서는 게이트웨이의 MAC 주소를 알아야함.인터넷 저 너머의 호스트(네이버 같은)에 접속할 때 L2 수준의 Frame에서 Header에 MAC 주소가 적혀있다. Packet에는 네이버의 IP가 적혀있겠지만, Header의 도착 정보에는 Gateway의 MAC 주소가 적혀있음.]]></description><link>network/12.-arp.html</link><guid isPermaLink="false">Network/12. ARP.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[13. Ping과 RTT]]></title><description><![CDATA[
Ping은 RTT(Round To Time)를 측정할 목적으로 사용되는 프로그램임
핑은 ICMP 프로토콜을 이용해서 RTT를 측정함.
Dos 공격용을 악용되기도 함.
]]></description><link>network/13.-ping과-rtt.html</link><guid isPermaLink="false">Network/13. Ping과 RTT.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[14. TCP와 UDP 개요]]></title><description><![CDATA[
TCP는 연결 개념이 있음
TCP는 기본적으로 Client / Server가 있음.
Client는 연결을 시도하는 주체.
PID를 가진 프로세스가 Socket를 오픈함. 운영체제가 TCP 포트를 열어줌Server는 연결을 기다리는 객체
Socket을 오픈함. 운영체제가 TCP 포토를 열어놓고 대기함 (Listen)즉 연결하기 위해서는 서버의 IP 주소와 포트 번호를 알아야함.연결대기 상태도 아닌데, TCP 쪽에서 연결하자고 오면 운영체제 수준에서 연결을 못받아준다는 응답을 보내줌.]]></description><link>network/14.-tcp와-udp-개요.html</link><guid isPermaLink="false">Network/14. TCP와 UDP 개요.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[15. TCP 연결 과정]]></title><description><![CDATA[
3-way handshaking
통신되는 데이터 단위는 segment
클라이언트에서 랜덤 sequence number를 SYN으로 서버에 보냄
서버는 이를 받고 받은 숫자에 + 1을 더해 Ack르 클라에 보냄
또한 서버는 랜덤 sequence number를 SYN으로 보낸다.
클라는 Ack와 서버의 seq number을 받고 연결되었다고 판단함
또한 클라는 서버의 seq number에 + 1을 더해 ack를 보냄
서버는 이를 받고 연결되었다고 판단
TCP 연결 과정에서
Sequence number 교환
정책 교환: Maximum segment size (MSS) 사이즈가 다르다면 클라가 서버에 맞춤 ]]></description><link>network/15.-tcp-연결-과정.html</link><guid isPermaLink="false">Network/15. TCP 연결 과정.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[u2_soundtype]]></title><description><![CDATA[<img src="images/u2_soundtype.png" target="_self">]]></description><link>images/u2_soundtype.html</link><guid isPermaLink="false">images/u2_soundtype.png</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/u2_soundtype.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/u2_soundtype.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01. 그래픽스 파이프라인]]></title><description><![CDATA[vertex input -&gt; vertex processing -&gt; primitive assembly -&gt; rasterization -&gt; fragment processing -&gt; blend -&gt; framebuffer<img alt="graphic_pipeline.png" src="images/graphic_pipeline.png" target="_self">
Vertex: 꼭지점
fragment = pixel + 색상, 깊이 ... 사용자의 vertex data -&gt; 좌표 변환
카메라 효과 vertex 결합 -&gt; graphics primitive
1 vertex -&gt; 점
2 vertices -&gt; 선분
3 vertices -&gt; 삼각형 primitive에 포함되는 pixel 선정
프레임 버퍼에서 출력될 pixel들이 선택됨 각 픽셀이 어떤 색을 가져야할 지 계산됨. fragment 단위 처리로 다양한 효과
후처리 단계 프레임 버퍼에 하나의 primitive로 저장됨
그래픽 파이프라인이란 vertex input이 각 단계를 거쳐 프레임버퍼에 하나의 primitive로 저장되는 과정이다.]]></description><link>graphics/opengl/02/01.-그래픽스-파이프라인.html</link><guid isPermaLink="false">graphics/opengl/02/01. 그래픽스 파이프라인.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/graphic_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/graphic_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[foldering_to_be]]></title><description><![CDATA[<img src="images/foldering_to_be.png" target="_self">]]></description><link>images/foldering_to_be.html</link><guid isPermaLink="false">images/foldering_to_be.png</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/foldering_to_be.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/foldering_to_be.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[graphic_pipeline]]></title><description><![CDATA[<img src="images/graphic_pipeline.png" target="_self">]]></description><link>images/graphic_pipeline.html</link><guid isPermaLink="false">images/graphic_pipeline.png</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/graphic_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/graphic_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01. 기본]]></title><description><![CDATA[
GL과 윈도우 시스템(OS가 아님 창을 여는)은 같이 가야함
윈도우
윈도우 시스템은 각 OS에 종속되어 있음
X윈도우 (리눅스), MS 윈도우(MS), Cocoa 윈도우(애플)
멀티플랫폼을 지원하는게 좋음 -&gt; freeglut 등등 라이브러리가 나왔으나 현재는 GLFW (그래픽 라이브러리 프레임워크) 사용
GLEW: OpenGL Extension
편의를 위한 추가 기능
<a data-tooltip-position="top" aria-label="https://www.glfw.org/download.html%EC%97%90%EC%84%9C" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/download.html%EC%97%90%EC%84%9C" target="_self">https://www.glfw.org/download.html에서</a> 프리 컴파일드 바이너리 다운로드 64bit압축을 풀면 있는 Include 폴더 안에 있는 GLFW 폴더와 자신의 컴파일러에 맞는 폴더를 찾아야함.
ex) 비쥬얼 스튜디오 2022는 lib-vc2022비쥬얼 스튜디오가 설치되어 있는 폴더에서 컴파일러 폴더 찾기ex) C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\XX.YY.ZZZZZ경로 안에 있는 Include에 GLFW 복붙
lib\x64\ 에 static library 3개 (glfw3.lib, glfw3_mt.lib, glfw3dll.lib) 복붙
bin\Hostx64\x64 에 dynamic library (glfw3.dll) 복붙
설치 완료.테스트로 300 x 300 윈도우 생성#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glfw3.lib")
#include &lt;stdio.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300; int main(void) { // start GLFW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, "Hello GLFW", NULL, NULL); glfwMakeContextCurrent(window); // main loop while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } // done glfwTerminate(); return 0;
}
Run 할 때, Config를 Release, x64로 변경하고 Run C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\XX.YY.ZZZZZ경로 안에 있는 Include에 GLEW 복붙
lib\x64\ 에 static library (lib) 복붙
bin\Hostx64\x64 에 dynamic library (dll) 복붙
다운로드 된 파일 중 glewinfo.exe 클릭 -&gt;glewinfo.txt 생성glewinfo는 지원하는 opengl 버전, 함수가 적혀 있음visualinfo.ext 클릭 -&gt; visualinfo.txt 생성
visualinfo는 opengl extension 리스트와 가능한 프레임버퍼 설정 적혀있음// HelloGLEW.cpp : This file contains the 'main' function. Program execution begins and ends there.
// #include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib")
#include &lt;stdio.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300; int main() { // start GLFW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, "Hello GLEW", NULL, NULL); glfwMakeContextCurrent(window); // start GLEW glewInit(); // checking OpenGL version (optional) const char* strVersion = (const char*)(glGetString(GL_VERSION)); printf("version = %s\n", strVersion); fflush(stdout); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
}
<br><img alt="glew32_install_error.png" src="images/glew32_install_error.png" target="_self">위 같은 오류가 뜨는 이유는 운영체제가 DLL 파일을 못 찾는 경우에 발생glew32.dll, glfw3.dll를 C:Windws/System32에 붙여 넣으면 해결됨GLAD는 Multi-language GL/GLX/WGL loader - generator의 약자임.
OpenGL 함수 포인터를 로드하고 관리하는 데 사용<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://glad.dav1d.de" target="_self">https://glad.dav1d.de</a> 에 접속하고 버전 선택하고 generateinclude 안에 있는 두 폴더 glad, KHR은 위에서 GLEW, GLFW 설치한 것처럼 복붙src에 있는 glad.c는 내 c++ 프로젝트에 복붙해서 사용]]></description><link>graphics/opengl/01.기본/01.-기본.html</link><guid isPermaLink="false">graphics/opengl/01.기본/01. 기본.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/glew32_install_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glew32_install_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용]]></title><description><![CDATA[윈도우 시스템 추상화기능
초기화
윈도우 관리 윈도우 생성 / 파괴 callback registration 다양한 콜백 제공
마우스, 키보드, 스크린 등의 이벤트 처리 기능 대표 함수 void glfwInit() void glfwTerminate() GLFWwindow glfwCreateWindow(int width, int height, const char title, GLFWmonitor monitor, GLFWwindow share); 윈도우와 이것과 연관된 OpenGL context 생성하는 함수
context는 현재 OpenGL state와 internal variables임 void glfwMakeContextCurrent(GLFWwindow* win); 앞으로 모든 gl 명령어는 지정한 window에 적용하겠다. int glfwWindowShouldClose(GLFWwindow* win); void glfwPollEvents(); 현재 어떤 이벤트들이 발생했는지 체크 void glfwSwapBuffers(GLFWwindow* win); 윈도우 화면 업데이트 좌표계 윈도우 시스템 좌표계 프레임버퍼 / 픽셀 = 2차원 배열
integer 좌표 사용
upper-left cornet에 원점 (오른쪽: x축 양수, 아래쪽: y축 양수) 3D 그래픽스 좌표계 수학에서 사용하는 3차원 좌표계
float 좌표 사용
오른손 좌표계 GLFW의 보일러 플레이트...
glfwInit();
GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, "Hello GLFW", NULL, NULL);
glfwMakeContextCurrent(window); // prepare initial setting for gl
glewInit(); // glew init
...
// // main loop
while (!glfwWindowShouldClose(window)) { // draw ... draw an image ... //GLFW actions - update glfwSwapBuffers(win); glfwPollEvents();
}
// done
glfwTerminate();
return 0;
... ]]></description><link>graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html</link><guid isPermaLink="false">graphics/opengl/01.기본/02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate></item><item><title><![CDATA[03. 콜백함수와 컬러 기초 이론 - Callback 함수]]></title><description><![CDATA[
전체 윈도우를 그려야하는 상황일 때 콜됨
윈도우가 resized 될 때
iconified 되고, 화면에 re-mapped 될 때
콜백 함수를 만들 때 아래 형태로 만들어야함.typedef void (*GLFWwindowrefreshfun)(GLFWwindow* win);
// win은 refresh될 윈도우임.
win에 콜백 함수 등록을 하는 함수GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* win, GLFWwindowrefreshfun func);
func가 NULL이면 current callback function은 제거된다.// HelloRefreshCallback.cpp : This file contains the 'main' function. Program execution begins and ends there.
// #include "GL/glew.h"
#include "GLFW/glfw3.h" #pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib") #include &lt;iostream&gt;
#include &lt;string.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300;
const unsigned int WIN_X = 100; // window position in pixels, (X, Y) const unsigned int WIN_Y = 100; // 등록할 콜백 함수
void refreshFunc(GLFWwindow* window) { printf("refresh called\n"); fflush(stdout); // 설정된 컬러로 화면을 지움 glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW action - update glfwSwapBuffers(window);
} int main(int argc, char* argv[])
{ // get your program name
#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\') + 1);
#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);
#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare - callback 등록 glfwSetWindowRefreshCallback(window, refreshFunc); // 화면을 지울 때 어떤 색깔로 지울지 설정함. glClearColor(0.5F, 0.8F, 0.8F, 1.0F); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
}
OpenGL: state machineOpenGL 내부 변수:GLclampf colorClearValue[4]; // RGBA 값
효율성을 높이기 위해, 명령어 큐에 기록하고 return
실행은 명령어 큐에서 지연 실행함
OpenGL 응용 프로그램 - 명령어 큐 (지연 실행) - OpenGL rendering pipelinedelayed execution 관련함수
void glFlush(); OpenGL 명령 큐를 flush
주의할점: 대부분은 바로 실행되지만, 일부는 시간이 더 필요할 수 있음. void glFinish(); OpenGL 명령어 큐를 flush하고 모두 완료되는 것을 확인 후에 return
주의할 점: 시간이 오래 걸릴 수도 있음 두 함수 다 명령어 큐에 있는 걸 다 업데이트 하기 때문에 명령어 큐가 전체 비워짐 -&gt; 내가 글리길 원하는 그림을 실행하면 바로 그릴 수 있음. 다만 명령어 큐를 다 비워야하기 때문에 약간의 시간지연이 발생등록할 함수 typedeftypedef void(*GLFWkeyfun)(GLFWwindow* win, int key, int scancode, int action, int mods);
parameter
win: 윈도우
key: keyboard key
scancode: system specific scancode -&gt; 사용하지 않음
action: GLFW_PRESS, GLFW_RELEASE, GLFW_REPEAT
mods: modifier keys (GLFW_MOD_SHIFT, CONTROL, ALT, SUPER)
해당하는 윈도우에 함수 등록GLFWkeyfun glfwSetKeyCallback(GLFWwindow* win, GLFWkeyfun func);
함수에 null을 넣으면 함수 등록 취소.예시.
CTRL + SHIFT + 'C' 인 경우
key: 'C'
mods: GLFW_MOD_SHIFT | GLFW_MOD+CONTROL
action: GLFW_PRESS (GLFW_RELEASE 이벤트도 발생하긴 함) #include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib")
#pragma warning(disable: 4711 4710 4100)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; // for strrchr() const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300;
const unsigned int WIN_X = 100; // window position in pixels, (X, Y) const unsigned int WIN_Y = 100; void refreshFunc(GLFWwindow* window) { // refresh glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW action glfwSwapBuffers(window);
} void keyFunc(GLFWwindow* window, int key, int scancode, int action, int mods) { switch (key) { case GLFW_KEY_ESCAPE: if (action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } break; }
} int main(int argc, char* argv[]) { // get your program name
#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\') + 1);
#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);
#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare glfwSetWindowRefreshCallback(window, refreshFunc); glfwSetKeyCallback(window, keyFunc); glClearColor(0.933F, 0.769F, 0.898F, 1.0F); // main loop while (! glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
} GLFW 함수 설명
void glfwSetWindowShouldClose(GLFWwindow* win, int value);
// 특정 윈도우의 close flag를 설정할 수 있음 int glfwWindowShouldClose(GLFWwindow* win);
// 특정 윈도우의 close flag를 리턴함.
// return 하는 값이 0이 아니면 윈도우를 close 해야하는 상황
]]></description><link>graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html</link><guid isPermaLink="false">graphics/opengl/01.기본/03. 콜백함수와 컬러 기초 이론 - Callback 함수.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate></item><item><title><![CDATA[04. 컬러 기초이론]]></title><description><![CDATA[모든 색을 Red, Green, Blue를 조정해서 만들 수 있음.
컬러모델 컴퓨터 / 소프트웨어에서 컬러를 표현하는 방법
다양한 모델: RGB, CMY(잉크), grayscale ... color gamut (컬러 개멋), 색 영역 특정 컬러 모델에서 표현 가능한 모든 색상 영역 Color cube, Color solid 3원색을 쓰는 컬러모델에서
Color gamut은 cube 정육면체 형태 <img alt="rgb_color_model.png" src="images/rgb_color_model.png" target="_self"><br><img alt="cmy_model.png" src="images/cmy_model.png" target="_self"> RGB color system 가산 색계 - 더할 수록 밝아짐
모니터, LCD 형광물질로 RGB 색상 컴퓨터 그래픽스의 주된 관심사 CMY color system 감산 색계 - 더할 수록 어두워짐
프린터, 인쇄용 두 모델은 서로 변환 가능함 <br><img alt="rgb_cmy_conversion.png" src="images/rgb_cmy_conversion.png" target="_self">]]></description><link>graphics/opengl/01.기본/04.-컬러-기초이론.html</link><guid isPermaLink="false">graphics/opengl/01.기본/04. 컬러 기초이론.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/rgb_color_model.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rgb_color_model.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. 컬러 이미지 저장 방식]]></title><description><![CDATA[
이미지 -&gt; (색깔 있는) 사각형의 2차원 배열
픽셀 pixel (= picture element)로 프레임버퍼를 표현함 컬러 심도 (색 깊이), bit depth 픽셀 당 몇 bit를 사용할 것인가 (메모리 비용) 인간의 시각은 200단계 색상 차이를 인식 그래서 256 즉 8bit를 사용하는 것이 일반적 <img alt="bw_grayscale.png" src="images/bw_grayscale.png" target="_self"><br><img alt="3colorchannel.png" src="images/3colorchannel.png" target="_self">
gray scale을 확장함 rgb 픽셀 값을 그레이스케일 형태로 저장
red 채널만 뽑아서, g 채널만, b 채널만 3개의 그레이스케일 이미지 저장
합성 -&gt; 컬러 이미지 <br><img alt="color_image.png" src="images/color_image.png" target="_self">
color image 한 픽셀마다 3개의 채널을 사용함
각 채널마다 8비트로 저장
그러면 한 픽셀당 24bit 사용 -&gt; 24bit 컬러 모델 각 픽셀마다 3개의 채널을 가지는 것을 Direct Color System이라고 부름 그래픽 카드 내부 구조 framebuffer: 각 픽셀마다 3 채널을 사용 (rgb)
각 채널마다 n bit 할당: - 총 2^3n Color
3n = 8, 12, 24, 30 .... 사용 True Color System 3n = 24 -&gt; 현재 가장 많이 사용 HDRI = high dynamic range imaging 3n = 30 ]]></description><link>graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html</link><guid isPermaLink="false">graphics/opengl/01.기본/05. 컬러 이미지 저장 방식.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/bw_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bw_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[06. RGBA 컬러 모델]]></title><description><![CDATA[ True Color System with alpha channel 4n = 32
픽셀당 4byte -&gt; (R, G, B, A)
0~255 사이의 정수 OpenGL은 float 사용 void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
<img alt="color_vs_grayscale.png" src="images/color_vs_grayscale.png" target="_self">흑백 -&gt; 컬러는 이론상 불가능하지만, 수요가 있다보니 수작업으로 작업했음.
요즘은 인공지능을 도입해서 변환하고 있음.<br><img alt="grey_to_color_using_ai.png" src="images/grey_to_color_using_ai.png" target="_self">
키보드 콜백 등록 q w e - &gt; 각각 r g b 값 높임
a s d -&gt; 각각 r g b 값 낮춤 // ChangeColor.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib")
#pragma warning(disable: 4711 4710 4100)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; const unsigned int WIN_W = 300;
const unsigned int WIN_H = 300;
const unsigned int WIN_X = 100;
const unsigned int WIN_Y = 100; GLfloat clr[4] = { 0.933F, 0.769F, 0.898F, 1.0F }; void refresh_callback(GLFWwindow* window);
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods); void refresh_callback(GLFWwindow* window)
{ glClear(GL_COLOR_BUFFER_BIT); glFinish(); glfwSwapBuffers(window);
} void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{ switch (key) { case 'Q': clr[0] += 0.01F; if (clr[0] &gt; 1.0F) clr[0] = 1.0F; break; case 'W': clr[1] += 0.01F; if (clr[1] &gt; 1.0F) clr[1] = 1.0F; break; case 'E': clr[2] += 0.01F; if (clr[2] &gt; 1.0F) clr[2] = 1.0F; break; case 'A': clr[0] -= 0.01F; if (clr[0] &lt; 0.0F) clr[0] = 0.0F; break; case 'S': clr[1] -= 0.01F; if (clr[1] &lt; 0.0F) clr[1] = 0.0F; break; case 'D': clr[2] -= 0.01F; if (clr[2] &lt; 0.0F) clr[2] = 0.0F; break; case GLFW_KEY_ESCAPE: if (action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } break; } glClearColor(clr[0], clr[1], clr[2], clr[3]);
} int main(int argc, char* argv[])
{ // get your program name
#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\') + 1);
#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);
#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare glfwSetWindowRefreshCallback(window, refresh_callback); glfwSetKeyCallback(window, key_callback); glClearColor(clr[0], clr[1], clr[2], clr[3]); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
}
]]></description><link>graphics/opengl/01.기본/06.-rgba-컬러-모델.html</link><guid isPermaLink="false">graphics/opengl/01.기본/06. RGBA 컬러 모델.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/color_vs_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/color_vs_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[var_error]]></title><description><![CDATA[<img src="images/var_error.jpg" target="_self">]]></description><link>images/var_error.html</link><guid isPermaLink="false">images/var_error.jpg</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/var_error.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/var_error.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[pso]]></title><description><![CDATA[<img src="images/pso.png" target="_self">]]></description><link>images/pso.html</link><guid isPermaLink="false">images/pso.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/pso.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/pso.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[foldering_as_is]]></title><description><![CDATA[<img src="images/foldering_as_is.png" target="_self">]]></description><link>images/foldering_as_is.html</link><guid isPermaLink="false">images/foldering_as_is.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/foldering_as_is.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/foldering_as_is.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02]]></title><description><![CDATA[스탠드얼론: 로컬 플레이어클라이언트: 프록시만 보여주는 리슨 서버: 로컬 플레이어를 서버에 직접 배치, 자기 자신도 플레이어임데디케이티드서버: 로컬 플레이어 없음. 대규모 멀티플레이 게임에 사용리슨서버 예시: 스타크래프트 정도? 서버와 클라가 결합리슨서버 구동방식
로그인 플로우 리슨서버가 될 호스트가 스탠드얼론으로 게임모드 + 플레이어컨트롤러 생성
게임 서비스 시작 (스탠드얼론 -&gt; 리슨서버로 변경)
클라이언트가 리슨서버에게 요청
리슨 서버의 콘텐츠가 클라이언트에게 콘텐츠 복제 게임모드의 주요함수
PreLogin: 클라이언트의 접속 요청을 처리하는 함수 - 받아들일까 말까 (서버에서는 이 과정 없음)
Login: 접속을 허용한 클라에 대응하는 플레이어 컨트롤러 만듬
PostLogin: 플레이어 입장을 위해 플레이어에 필요한 기본 설정을 모두 마무리함
StartPlay: 게임 시작 지시
BeginPlay: 게임이 시작할 때 레벨에 있는 모든 액터에서 호출하는 함수
클라이언트에 게임모드가 없음 그럼 어떻게 게임 시작?
-&gt; 게임 스테이트 엑터를 사용함 (서버와 클라 둘 다 존재)게임모드가 StartPlay() -&gt; 게임스테이트한테 명령 내림 -&gt; HandleBeginPlay() // 이건 서버로직임
OnRep_ReplicatedHasBegunPlay()는 클라가 호출함]]></description><link>ue/network-프레임워크/02.html</link><guid isPermaLink="false">UE/Network 프레임워크/02.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[03. 커넥션과 오너십]]></title><description><![CDATA[
원격 엑터 초기화 이해
네트워크 처리 방식
오너십 개념 게임과 무관한 액터 설정 초기화 -&gt; PostInitializeComponents
원격 클라에서 네트워크 관련 설정 초기화 -&gt; PostNetInit
게임 진행에 필요한 초기화 -&gt; BeginPlay
네트워크 통신을 담당하는 주요 클래스
PlayerController: 네트워크 통신에 접근 가능한 게임 내 대표 엑터
UNetConnection: 주고 받는 패킷 데이터의 인코딩, 디코딩, 네트워크 통신량 조절, 채널 관리
UNetDriver: 로우 레벨에서의 소켓 관리와 패킷 처리 및 네트워크 통신 설정
넷드라이버는 다수의 커넥션을 관리하고, 서버와 클라이언트에 따라 다르게 동작함.
클라이언트에서의 넷드라이버는 항상 하나의 서버 커넥션을 가진다.
서버에서의 넷드라이버는 다수의 클라이언트 커넥션을 가진다.'GameMode PostLogin()에서 다수의 클라이언트 커넥션을 확인할 수 있었고,void AABGameMode::PostLogin(APlayerController* NewPlayer)
{ AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("Begin")); Super::PostLogin(NewPlayer); UNetDriver* NetDriver = GetNetDriver(); if (NetDriver) { if (NetDriver-&gt;ClientConnections.Num() == 0) { AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("No Client Connection")); } else { for (const auto&amp; Connection : NetDriver-&gt;ClientConnections) { AB_LOG(LogABNetwork, Log, TEXT("Client Connection: %s"), *Connection-&gt;GetName()); } } } else { AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("No NetDriver")); } AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("End"));
}
PlayerController PostNetInit()에서 서버 커넥션을 확인할 수 있었다.
(네트워크로부터 속성 값을 전달받은 상황이기 떄문에 PostNetInit에서 확인할 수 있었다.)void AABPlayerController::PostNetInit()
{ AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("Start")); Super::PostNetInit(); UNetDriver* NetDriver = GetNetDriver(); if (NetDriver) { AB_LOG(LogABNetwork, Log, TEXT("Server Connection: %s"), *NetDriver-&gt;ServerConnection-&gt;GetName()); } else { AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("No NetDriver")); } AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("End"));
} 아래와 같은 작업을 거침 커넥션: 모든 데이터를 전달하는 네트워크 통로
패킷: 네트워크를 통해 전달되는 단위 데이터. 숫자 혹은 문자로 구성
채널: 구분된 데이터를 전달하는 논리적인 통로(음성, 액터 정보 etc ..)
번치: 채널의용도에 맞게 묶인 데이터 데이터 통신을 관리하기 위한 대표 액터 - 플레이어 컨트롤러 커넥션을 담당하는 대표 액터는 커넥션에 대한 오너십을 가진다고 표현 어떤 액터가 통신을 하기 위해서는 자신을 소유한 액터가 커넥션을 소유하고 있어야함.
일반적으로 플레이어 컨트롤러는 넷커넥션을 소유하고 있음.
넷커넥션도 플레이어 컨트롤러를 소유하고 있음.
AACtor::GetNetConnection()
APlayerController::GetNetConnection()
PostLogin이 시작된 후 빙의가 시작됨LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Start
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner: No Owner
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner : BP_ABPlayerController_C_0
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy End
LogABNetwork: [SERVER] AABPlayerController::OnPossess End
Player 액터는 슈퍼 호출 이전에는 오너가 설정되어 있지 않지만, 이후에 오너가 컨트롤러로 설정됨클라이언트를 추가하면LogABNetwork: [SERVER] AABGameMode::PreLogin Begin
LogABNetwork: [SERVER] AABGameMode::PreLogin End
LogABNetwork: [SERVER] AABGameMode::Login Begin
LogABNetwork: [SERVER] AABPlayerController::PostInitializeComponents Start
LogABNetwork: [SERVER] AABPlayerController::PostInitializeComponents End
LogABNetwork: [SERVER] AABGameMode::Login End
LogABNetwork: [SERVER] AABGameMode::PostLogin Begin
LogABNetwork: [SERVER] AABPlayerController::OnPossess Start
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Start
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner: No Owner
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner : BP_ABPlayerController_C_1
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy End
LogABNetwork: [SERVER] AABPlayerController::OnPossess End
LogABNetwork: [SERVER] AABGameMode::PostLogin Client Connection: IpConnection_1
LogABNetwork: [SERVER] AABGameMode::PostLogin End
LogABNetwork: [Client0] AABPlayerController::PostInitializeComponents Start
LogABNetwork: [Client0] AABPlayerController::PostInitializeComponents End
LogABNetwork: [Client0] AABPlayerController::PostNetInit Start
LogABNetwork: [Client0] AABPlayerController::PostNetInit Server Connection: IpConnection_0
LogABNetwork: [Client0] AABPlayerController::PostNetInit End
역시 오너가 설정되지만 서버에서만 오너가 설정 로그가 찍힘
클라이언트에서도 오너가 설정되어야 함 -&gt; PostNetInit()에서 오너가 설정될거라고 예상플레이어는 언제 오너가 바뀔까? 플레이어는 스스로 빙의를 하지 않음.
클라이언트에서는 빙의가 일어나지 않음. OnPossess가 호출되지 않음플레이어가 가지고 있는 오너의 값이 복제가 됨OnRep_Owner()에 의해서 오너값이 동기화가 됨플레이어가 복제될 때 클라이언트의 플레이어도 복제가 되겠지만, 서버의 플레이어도 복제가 되어야함 서버의 플레이어는 오너가 리플리케이션 되지 않는 상태로 초기화가 됨.하지만 클라이언트는 서버에서 생성된 플레이어 오너값이 복제가 되면서 OnRep_Owner()가 호출됨.]]></description><link>ue/network-프레임워크/03.-커넥션과-오너십.html</link><guid isPermaLink="false">UE/Network 프레임워크/03. 커넥션과 오너십.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[grey_to_color_using_ai]]></title><description><![CDATA[<img src="images/grey_to_color_using_ai.png" target="_self">]]></description><link>images/grey_to_color_using_ai.html</link><guid isPermaLink="false">images/grey_to_color_using_ai.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/grey_to_color_using_ai.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/grey_to_color_using_ai.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rgb_cmy_conversion]]></title><description><![CDATA[<img src="images/rgb_cmy_conversion.png" target="_self">]]></description><link>images/rgb_cmy_conversion.html</link><guid isPermaLink="false">images/rgb_cmy_conversion.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/rgb_cmy_conversion.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rgb_cmy_conversion.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rgb_color_model]]></title><description><![CDATA[<img src="images/rgb_color_model.png" target="_self">]]></description><link>images/rgb_color_model.html</link><guid isPermaLink="false">images/rgb_color_model.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/rgb_color_model.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rgb_color_model.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[color_vs_grayscale]]></title><description><![CDATA[<img src="images/color_vs_grayscale.png" target="_self">]]></description><link>images/color_vs_grayscale.html</link><guid isPermaLink="false">images/color_vs_grayscale.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/color_vs_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/color_vs_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[color_image]]></title><description><![CDATA[<img src="images/color_image.png" target="_self">]]></description><link>images/color_image.html</link><guid isPermaLink="false">images/color_image.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/color_image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/color_image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bw_grayscale]]></title><description><![CDATA[<img src="images/bw_grayscale.png" target="_self">]]></description><link>images/bw_grayscale.html</link><guid isPermaLink="false">images/bw_grayscale.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/bw_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bw_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cmy_model]]></title><description><![CDATA[<img src="images/cmy_model.png" target="_self">]]></description><link>images/cmy_model.html</link><guid isPermaLink="false">images/cmy_model.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/cmy_model.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cmy_model.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3colorchannel]]></title><description><![CDATA[<img src="images/3colorchannel.png" target="_self">]]></description><link>images/3colorchannel.html</link><guid isPermaLink="false">images/3colorchannel.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/3colorchannel.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/3colorchannel.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[UGameplayStatics]]></title><description><![CDATA[UGameplayStatics는 Unreal Engine에서 제공하는 유틸리티 클래스로, 게임플레이와 관련된 다양한 정적(static) 함수들을 포함하고 있습니다. 이 클래스는 게임 개발 시 자주 사용되는 여러 기능들을 쉽게 접근할 수 있게 해줍니다. 주요 기능들은 다음과 같습니다:
게임 관리: GetGameMode, GetGameState, GetGameInstance 등을 통해 현재 게임의 주요 객체들에 접근
OpenLevel을 통해 새로운 레벨 로드 플레이어 관리: GetPlayerController, GetPlayerCharacter, GetPlayerPawn 등을 통해 플레이어 관련 객체에 접근
CreatePlayer를 통해 새로운 플레이어 생성 액터 관리: SpawnActor를 통해 새로운 액터 스폰
GetAllActorsOfClass를 통해 특정 클래스의 모든 액터 찾기 사운드 및 오디오: PlaySound2D, PlayDialogueAtLocation 등을 통해 사운드 재생 시간 관리: GetTimeSeconds, GetRealTimeSeconds 등을 통해 게임 시간 정보 얻기 저장 및 로드: SaveGameToSlot, LoadGameFromSlot 등을 통해 게임 저장 및 로드 물리 및 추적: LineTraceSingleByChannel 등을 통해 물리적 충돌 검사 UI 및 HUD: GetPlayerCameraManager를 통해 카메라 관리자에 접근
ProjectWorldToScreen을 통해 3D 위치를 2D 스크린 좌표로 변환 디버깅: PrintString을 통해 화면에 디버그 메시지 출력 이러한 기능들을 통해 UGameplayStatics는 게임 개발 과정에서 자주 필요한 작업들을 편리하게 수행할 수 있게 해줍니다. 특히 이 클래스의 함수들은 대부분 정적이므로, 객체를 생성하지 않고도 직접 호출할 수 있어 사용이 간편합니다.]]></description><link>ue/ugameplaystatics.html</link><guid isPermaLink="false">UE/UGameplayStatics.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[UMG 클래스에 Delegate 추가하기]]></title><description><![CDATA[
목표: UMultiLineEditableTextBox에 FOnFocusReceviced와 FOnFocusLost를 구현하기
UMultiLineEditableTextBox은 SMultiLineEditableTextBox를 래핑하고 있다. SMultiLineEditableTextBox는 SMultiLineEditableText를 내부적으로 사용하고 있다. 이벤트 전파 체인 이해 따라서 SMultiLineEditableText - &gt; SMultiLineEditableTextBox -&gt; UMultiLineEditableTextBox 체인을 따라 포커스 이벤트가 전파된다. 각 단계에서 처리하고 상위 레벨로 전달함. SMultiLineEditableText 수정 실제 텍스트 편집 기능 담당
포커스 이벤트가 발생하는 가장 하위 레벨
Slate Event 추가
OnFocusReceived와, OnFocusLost 델리게이트를 추가 (.h에)
cpp에서 construct()에서 값 할당 OnFocusReceivedDelegate = InArgs._OnFocusReceivedDelegate;
OnFocusLostDelegate = InArgs._OnFocusLostDelegate; SWidget Interface의 OnFocusReceived, OnFocusLost 오버라이딩 후에 그곳에서 이벤트 Execute 하기 virtual FReply OnFocusReceived(const FGeometry&amp; MyGeometry, const FFocusEvent&amp; InFocusEvent) override;
virtual void OnFocusLost(const FFocusEvent&amp; InFocusEvent) override; SMultiLineEditableTextBox 수정 SMultiLineEditableText를 포함하는 컨테이너 역할
SMultiLineEditableText의 포커스 이벤트를 받아 상위로 전달
UMultiLineEditableTextBox와 직접 연결되는 Slate 레벨의 위젯 UMultiLineEditableTextBox 수정 UMG 레벨의 위젯으로 BP에서 사용 가능
SMultiLineEditableTextBox의 포커스 이벤트를 받아 BP 이벤트로 변환 캡슐화와 책임 분리: 각 레벨의 위젯이 자신의 역할에 맞는 기능만 담당합니다. SMultiLineEditableText는 실제 편집 기능을, SMultiLineEditableTextBox는 컨테이너 역할을, UMultiLineEditableTextBox는 UMG 연동을 담당 유연성: 각 레벨에서 포커스 이벤트를 처리할 수 있어, 필요에 따라 다양한 방식으로 대응할 수 있음 일관성: 언리얼 엔진의 기존 위젯 구조와 일관성을 유지 가능. 다른 위젯들도 비슷한 구조로 이벤트를 처리. 확장성: 나중에 추가적인 기능이나 이벤트가 필요할 때 각 레벨에서 쉽게 확장할 수 있음. 블루프린트 지원: UMultiLineEditableTextBox에서 UPROPERTY와 UFUNCTION을 사용하여 블루프린트에서도 이 이벤트를 쉽게 사용할 수 있음. ]]></description><link>ue/umg-클래스에-delegate-추가하기.html</link><guid isPermaLink="false">UE/UMG 클래스에 Delegate 추가하기.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[datahandle_row_result]]></title><description><![CDATA[<img src="images/datahandle_row_result.png" target="_self">]]></description><link>images/datahandle_row_result.html</link><guid isPermaLink="false">images/datahandle_row_result.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/datahandle_row_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/datahandle_row_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[usermode_kernalmode]]></title><description><![CDATA[<img src="images/usermode_kernalmode.png" target="_self">]]></description><link>images/usermode_kernalmode.html</link><guid isPermaLink="false">images/usermode_kernalmode.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/usermode_kernalmode.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/usermode_kernalmode.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[packet]]></title><description><![CDATA[<img src="images/packet.png" target="_self">]]></description><link>images/packet.html</link><guid isPermaLink="false">images/packet.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/packet.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/packet.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[data_transfer_struct]]></title><description><![CDATA[<img src="images/data_transfer_struct.png" target="_self">]]></description><link>images/data_transfer_struct.html</link><guid isPermaLink="false">images/data_transfer_struct.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/data_transfer_struct.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/data_transfer_struct.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02. L2]]></title><description><![CDATA[NIC + (L2) Frame + LAN card + MACNIC = Network Interface Card .
랜(LAN (Local Area Network))카드랑 같음.
NIC은 HW이면 MAC주소를 갖는다. MAC주소는 NIC의 식별자임.Packet: L2 수준에서 언급하는 인터넷에서의 단위
L2 수준의 데이터 단위는 프레임L2 Acess Switch라고 불림
End - point와 직접 연결되는 스위치
MAC 주소를 근거로 스위칭
랜 케이블이 연결되고 정상 작동한다(녹색불) - Link up
랜 케이블이 연결이 빠졌다 - Link down호스트에 랜 케이블을 꽂았는데 상위 L3로 나아가는 것 - 업 링크
쉽게 생각하면 L2 Access 스위치를 위한 스위치
VLAN(Virtual LAN) 기능 제공
Unicast는 하나에 알리는 것 -&gt; 효율 높
Broadcast는 전체에 알리는 것 -&gt; 효율 떨어짐Broadcast의 주소라는 특별한 주소가 존재함 (MAC, IP 둘다 존재)MAC은 48Bit로 이루어져있는데, 모든 비트가 1이면 그게 바로 MAC의 브로드캐스트 주소임
FF:FF:FF:FF:FF:FFL2 수준에서의 데이터 단위가 프레임이라고 했는데 프레임에는 헤더가 있음
헤더에는 주소 두개가 있음 출발지, 목적지만약 목적지가 FF:FF:FF:FF:FF:FF다? 그럼 브로드캐스팅 한다는거겠지?브로드캐스팅은 매우 값 비싼 행동임 일단 한 호스트가 브로드캐스팅이 되면 브로드캐스팅 끝날 때까지 통신을 못함 -&gt; 그러니까 브로드캐스팅은 최소화 해야함예시)
L브로드캐스팅의 범위를 축소하면 됨
브로드 캐스팅 범위는 IP 주소상에서 어떤 레인지로 제한
정확한 개념은 아니지만 LAN은 물리적으로 설명 가능 (랜 카드, 무선신호 등) L2까지 커버할 수 있음WAN은 주로 인터넷인데 이것들부터는 실체가 존재하지 않는 Logical(virtual)임 L3부터는 소프트웨어 영역임]]></description><link>network/02.-l2.html</link><guid isPermaLink="false">Network/02. L2.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[03. L3]]></title><description><![CDATA[
Host의 식별자
32bit 주소체계
ex) 192.168.0.10 ( 8bit * 4 = 32bit) 앞 24 bit는 Network ID
뒤 8 bit는 Host ID Packet 이라고하면 L3 IP Packet을 떠올리자.
Header와 Payload (Header에는 출발지(src) 목적지(dst) 정보가 있음)로 구성
Header + Payload 의 최대 크기 = MTU MTU는 보통 1500byte임 마트료시카 인형을 떠올리자
L2 Frame은 = Header + Payload
L2의 Payload에 L3 Packet(Header + Payload)가 있음
L3의 Payload에 L4의 Header + Payload가 있겠지?
]]></description><link>network/03.-l3.html</link><guid isPermaLink="false">Network/03. L3.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[04. 패킷의 생성과 전달]]></title><description><![CDATA[<img alt="packet.png" src="images/packet.png" target="_self">상황: 철수가 영희에게 책을 택배로 전달하기 원함.
철수, 영희: Process
책: Data
택배: Packet
택배 기사: Gateway
송장: Packet Header src: IPv4
dst: IPv4
이름: 영희 (port) 집: Host
]]></description><link>network/04.-패킷의-생성과-전달.html</link><guid isPermaLink="false">Network/04. 패킷의 생성과 전달.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/packet.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/packet.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. 계층별 데이터 단위]]></title><description><![CDATA[User Mode
Process: 크롬 같은 데이터를 Write, Read함
Socket: 유저 모드에서 TCP에 W/R 하는 인터페이스 (파일) 데이터 덩어리 (Stream) 관리함 Kernel mode (OS) TCP 데이터 단위: Segment
데이터 한번에 받는 최대치: MSS (Maximum Segment Size)
Stream을 분할해서 Segment로 만듬 (Segmentation) IP 데이터 단위: Packet
데이터 한번에 받는 최대치: MTU (보통 1500bytes) L2 (Driver) 데이터 단위: Frame ]]></description><link>network/05.-계층별-데이터-단위.html</link><guid isPermaLink="false">Network/05. 계층별 데이터 단위.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[06. TCP IP 송수신 구조]]></title><description><![CDATA[<img alt="data_transfer_struct.png" src="images/data_transfer_struct.png" target="_self">A.bmp 파일을 서버에서 다운로드 받는 상황을 가정 서버 사이드 Process에서 HDD / SDD에 있는 A.bmp를 Copy 함 -&gt; Process의 버퍼 위에 올라감 Process는 이를 Socket을 이용해서 I/O Buffer에 Copy 함. (Send) 이때의 데이터 덩어리를 Stream 이라고함 Stream을 분해해서 Segment로 만듦 Sement를 Packet으로 만듦 (Encapsulation) Packet을 Frame 만든 (Encapsulation) 후에 전송 시작 Frame은 수시로 바뀜 (내용물인 Packet은 유지됨) 클라이언트 사이드에서 L2 단계에서 Frame으로 전달 받음 Decapsulation -&gt; Packet을 얻음 Decapsulation -&gt; Segment을 얻음 L4 TCP (Network) 단계에서 Segment를 Stream으로 변환 후에, 이를 I/O 버퍼에 채움 애플리케이션은 I/O buffer에 있는 데이터 덩어리를 Read(Receive)함. 이렇게 데이터를 송수신 하다가, 서버는 클라이언트가 데이터를 잘 받았는지 기다리기 때문에
서버는 어느 순간 데이터를 보내지 않고 Acknowledgement를 기다림 (wait for ACK)클라이언트가 Server에 ACK# (number) + 여유 버퍼 (window size) 보냄(데이터를 잘 받았으니 다음 거 보내달라는 요청) 그러면 서버사이드는 다시 미리 준비된 패킷을 클라이언트에게 보냄.이러한 순서를 반복함.
Loss - 데이터 유실 (Network 이슈)
Re-transmission -&gt; ACK 중복 (네트워크 or 엔드포인트 이슈)
Out of order - 순서가 이상함 Ex. 1 -&gt; 2 -&gt; 4 -&gt; 3 (보통 네트워크 이슈)
Zero Window - I/O 버퍼 여유 공간 없음 (엔드포인트 이슈)
TCP 보고 한번 더 보자]]></description><link>network/06.-tcp-ip-송수신-구조.html</link><guid isPermaLink="false">Network/06. TCP IP 송수신 구조.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/data_transfer_struct.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/data_transfer_struct.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bpgi_onbeginplay]]></title><description><![CDATA[<img src="images/bpgi_onbeginplay.png" target="_self">]]></description><link>images/bpgi_onbeginplay.html</link><guid isPermaLink="false">images/bpgi_onbeginplay.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/bpgi_onbeginplay.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bpgi_onbeginplay.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[wbp_ui_transition]]></title><description><![CDATA[<img src="images/wbp_ui_transition.png" target="_self">]]></description><link>images/wbp_ui_transition.html</link><guid isPermaLink="false">images/wbp_ui_transition.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/wbp_ui_transition.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/wbp_ui_transition.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01. Network]]></title><description><![CDATA[L7 - Http
L6 - 안중요
L5 - SSL (TLS)
L4 - TCP / UDP
L3 - 인터넷
L2 - 이더넷
L1 - X 물리적인 영역MAC: L2 계층 (이더넷)의 식별자 - 즉 랜카드(NIC)의 식별자IP주소: L3 계층 (인터넷)의 식별자 - 즉 호스트의 식별자Port 번호: 관점에 따라 식별할 수 있음 L2 계층: 인터페이스 식별자 L3, L4: Service 식별자 (네트워크 수준)
* 엔드포인트: Process 식별자정의: 네트워크에 연결된 컴퓨터Host를 지칭할 때 둘로 나눔 Switch: Network 그 자체를 이루는 Host (인프라) Router
IPS .. End-Point: 인프라를 써먹는 이용 주체 클라이언트
서버
Peer 비유 패킷: 자동차
네트워크: 고속도로망
스위치(라우터): 교차로
인터페이스를 선택한다 (스위칭) -&gt; 교차로에서 경로 선택
이정표: 라우팅테이블 용어가 아래처럼 만들어짐
Mac 주소로 스위칭한다 -&gt; L2 스위치
Http 정보로 스위치한다 -&gt; L7 스위치비용이 낮은쪽으로 패킷이 이동함.
비용은 Matric이라 함]]></description><link>network/01.-network.html</link><guid isPermaLink="false">Network/01. Network.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[Common_ui_plugin]]></title><description><![CDATA[<img src="images/common_ui_plugin.png" target="_self">]]></description><link>images/common_ui_plugin.html</link><guid isPermaLink="false">images/Common_ui_plugin.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/common_ui_plugin.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/common_ui_plugin.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[UI 애니메이션]]></title><description><![CDATA[언리얼엔진은 UMG에서 각 UI Component에 대해서 애니메이션을 설정할 수 있음UI Component의 종류에 따라 제공하는 애니메이션이 다름.Border의 경우 Content Color and Opacity와 Transform 등 같은 요소 애니메이션을 제공함.Image 같은 경우는 Brush.Brush.Material와 같은 머터리얼을 이용한 애니메이션을 제공함.머터리얼을 이용하면 단순한 색상이나 이미지 이상의 복잡한 시각 효과를 UI 요소에 적용할 수 있음.머터리얼을 이용한 애니메이션 예시
동적인 색상 변화
텍스처 블렌딩
애니메이션 효과
특수 셰이더 효과
UI 전환을 만들수도 있음.
페이드 인/아웃 효과
디졸브 전환
색상 변화를 통한 상태 표시 Blend Type은 머티리얼이 다른 머티리얼이나 배경과 어떻게 상호작용 하는지를 정의함
Blend Type은 전환효과의 시각적 특성에 큰 영향을 줌.
세가지 타입이 존재 Additive: 머티리얼의 색상 값을 기존 배경에 더합니다.
주로 밝은 효과나 빛나는 요소를 추가할 때 사용
글로우 효과나 하이라이트 애니메이션에 적합
Ex. 버튼에 마우스를 올렸을 때 발생하는 글로우 효과 Additive from Base: 기본 색상(Base Color)을 시작점으로 사용
머티리얼의 색상이 기본 색상에서 시작하여 추가되는 방식으로 블렌딩
기존 UI 요소에 점진적으로 밝아지는 효과를 줄 때 유용
Ex. UI 패널이 점점 밝아지는 강조 효과 Absolute: 머티리얼의 색상을 있는 그대로 표시
배경이나 다른 요소와의 블렌딩 없이 머티리얼의 색상이 그대로 적용
완전히 불투명한 UI 요소나 배경을 덮는 전체 화면 효과에 사용
Ex. 전체 화면 페이드 인/아웃 전환 효과 두 키프레임 사이의 값을 어떻게 계산할지 결정. 총 세가지 타입. Linear: 선형 보간
Constant: 다음 키 프레임까지 값 유지
Cubic: 부드러운 곡선 사용 즉 Linear, Constant인 경우에는 Tangent가 필요 없음. Cubic인 경우 부드러운 곡선 보간을 한다는 것인데 부드러운 곡선을 어떻게 제어하냐 그 방식이 바로 Tangent임
키프레임 사이의 Interpolation 방식을 결정
Interpolation(보간)이란? 데이터 지점들 사이의 새로운 데이터 지점을 구하는 방법 다음과 같은 옵션이 존재 (Smart) Auto: 시스템이 자동으로 가장 적절한 탄젠트를 계산
부드러운 애니메이션에 적합하지만, 세밀한 제어는 어려움 Linear: 키프레임 사이를 직선으로 연결
움직임이 일정하고 기계적인 느낌을 줌
예시 UI 요소가 1초 동안 100%에서 200%로 커지는 애니메이션
Linear Tangent: 0.5초 지점에서 정확히 150% 크기가 됨 Constant: 키프레임 사이에 변화가 없음. 다음 키프레임에서 갑자기 변함
순간적인 변화나 디지털 효과에 유용 User: 사용자가 직접 탄젠트를 조절할 수 있음
가장 세밀한 제어가 가능하지만, 설정에 시간이 걸림 Break: 입력(In)과 출력(Out) 탄젠트를 독립적으로 조절 가능
복잡한 움직임을 만들 때 유용함 양수 값: 커브가 키프레임에서 위로 올라감
음수 값: 커브가 키프레임에서 아래로 내려감
0: 커브가 키프레임에서 평평해짐
값의 크기에 따른 영향: 높은 값 급격한 변화
애니메이션이 빠르게 시작하거나 끝남 낮은 값 부드러운 변화
애니메이션이 천천히 시작하거나 끝남
느린 가속 또는 감속 효과 Arrive Tangent 키프레임에 도착할 때의 탄젠트 값 Leave Tangent 키프레임에서 탈출할 때의 탄젠트 값 ]]></description><link>ue/ui-애니메이션.html</link><guid isPermaLink="false">UE/UI 애니메이션.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[Overloading2]]></title><description><![CDATA[friend 키워드는 클래스 내부에서 다른 클래스나 함수를 friend로 정의할 수 있음.friend로 정의 되면 원래 클래스의 private로 정의된 변수, 함수들에 접근 가능lass A { private: void private_func() {} int private_num; // B 는 A 의 친구! friend class B; // func 은 A 의 친구! friend void func();
}; class B { public: void b() { A a; // 비록 private 함수의 필드들이지만 친구이기 때문에 접근 가능하다. a.private_func(); a.private_num = 2; }
}; void func() { A a; // 비록 private 함수의 필드들이지만 위와 마찬가지로 친구이기 때문에 접근 // 가능하다. a.private_func(); a.private_num = 2;
} int main() {} ]]></description><link>cpp/overloading2.html</link><guid isPermaLink="false">CPP/Overloading2.md</guid><pubDate>Sat, 03 Aug 2024 06:02:20 GMT</pubDate></item><item><title><![CDATA[inc_support]]></title><description><![CDATA[<img src="images/inc_support.png" target="_self">]]></description><link>images/inc_support.html</link><guid isPermaLink="false">images/inc_support.png</guid><pubDate>Thu, 01 Aug 2024 11:20:21 GMT</pubDate><enclosure url="images/inc_support.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/inc_support.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[whoami]]></title><description><![CDATA[<img src="images/whoami.png" target="_self">]]></description><link>images/whoami.html</link><guid isPermaLink="false">images/whoami.png</guid><pubDate>Thu, 01 Aug 2024 11:20:21 GMT</pubDate><enclosure url="images/whoami.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/whoami.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이분탐색 & 파라메트릭 서치]]></title><description><![CDATA[이분 탐색(Binary Search)은 정렬된 배열에서 특정 값을 찾는 효율적인 알고리즘
시간 복잡도는 O(log n)으로, 선형 검색보다 훨씬 빠릅니다.이분 탐색의 기본 원리는 다음과 같습니다:
배열의 중간 원소를 선택
중간 원소와 찾고자 하는 값을 비교
찾고자 하는 값이 중간 원소보다 작으면 왼쪽 부분 배열을 탐색하고, 크면 오른쪽 부분 배열을 탐색
찾고자 하는 값을 찾을 때까지 또는 더 이상 탐색할 수 없을 때까지 이 과정을 반복
#include &lt;iostream&gt;
#include &lt;vector&gt; int binarySearch(const std::vector&lt;int&gt;&amp; arr, int target) { int left = 0; int right = arr.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; // 타겟을 찾았을 때 인덱스 반환 } else if (arr[mid] &lt; target) { left = mid + 1; // 오른쪽 부분 배열 탐색 } else { right = mid - 1; // 왼쪽 부분 배열 탐색 } } return -1; // 타겟을 찾지 못했을 때
} int main() { std::vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11, 13, 15}; int target = 7; int result = binarySearch(arr, target); if (result != -1) { std::cout &lt;&lt; "타겟 " &lt;&lt; target &lt;&lt; "은 인덱스 " &lt;&lt; result &lt;&lt; "에 있습니다." &lt;&lt; std::endl; } else { std::cout &lt;&lt; "타겟 " &lt;&lt; target &lt;&lt; "을 찾을 수 없습니다." &lt;&lt; std::endl; } return 0;
}
파라메트릭 서치(Parametric Search)는 최적화 문제를 해결하는 알고리즘 기법입니다. 주로 이분 탐색(Binary Search)을 응용하여 연속적인 값에 대한 결정 문제를 해결하는 데 사용됩니다.파라메트릭 서치의 주요 특징:
최적화 문제를 결정 문제로 변환: "최댓값을 찾아라" 같은 최적화 문제를 "이 값이 가능한가?" 같은 결정 문제로 바꿉니다.
이분 탐색 활용: 가능한 해의 범위를 이분 탐색으로 좁혀가며 최적해를 찾습니다.
연속적인 값에 적용: 정수뿐만 아니라 실수 값에 대해서도 사용할 수 있습니다.
효율성: O(log N) 시간 복잡도로 최적해를 찾을 수 있습니다.
파라메트릭 서치의 일반적인 절차:
문제의 답이 될 수 있는 범위를 정합니다.
그 범위의 중간값에 대해 결정 문제를 해결합니다.
결과에 따라 탐색 범위를 반으로 줄입니다.
원하는 정확도에 도달할 때까지 2-3 과정을 반복합니다.
파라메트릭 서치는 다양한 최적화 문제에 적용할 수 있습니다. 예를 들어, 특정 조건을 만족하는 최대 또는 최소값을 찾는 문제, 이진 탐색으로 해결할 수 있는 결정 문제 등에 활용됩니다.]]></description><link>algorithm/study/이분탐색-&amp;-파라메트릭-서치.html</link><guid isPermaLink="false">Algorithm/Study/이분탐색 &amp; 파라메트릭 서치.md</guid><pubDate>Mon, 29 Jul 2024 11:50:10 GMT</pubDate></item><item><title><![CDATA[누적합 알고리즘]]></title><description><![CDATA[누적합(prefix sum) 알고리즘은 배열의 부분합을 빠르게 계산하는 데 사용되는 기법
주어진 배열의 각 위치까지의 원소들의 합을 미리 계산해 놓는 방식
원본 배열: A[1], A[2], ..., A[n]
누적합 배열: S[i] = A[1] + A[2] + ... + A[i]
시간 복잡도 전처리: O(n)
구간 합 쿼리: O(1) 특정 구간 [L, R]의 합을 S[R] - S[L-1]로 O(1) 시간에 계산 가능
]]></description><link>algorithm/study/누적합-알고리즘.html</link><guid isPermaLink="false">Algorithm/Study/누적합 알고리즘.md</guid><pubDate>Mon, 29 Jul 2024 11:29:59 GMT</pubDate></item><item><title><![CDATA[파일 입출력 2]]></title><description><![CDATA[
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in("test.txt"); std::string s; if (in.is_open()) { // 위치 지정자를 파일 끝으로 옮긴다. in.seekg(0, std::ios::end); // 그리고 그 위치를 읽는다. (파일의 크기) int size = in.tellg(); // 그 크기의 문자열을 할당한다. s.resize(size); // 위치 지정자를 다시 파일 맨 앞으로 옮긴다. in.seekg(0, std::ios::beg); // 파일 전체 내용을 읽어서 문자열에 저장한다. // read의 파라미터: 저장할 객체, 버퍼 사이즈 in.read(&amp;s[0], size); std::cout &lt;&lt; s &lt;&lt; std::endl; } else { std::cout &lt;&lt; "파일을 찾을 수 없습니다!" &lt;&lt; std::endl; } return 0;
}
// getline 으로 읽어들이기
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in("test.txt"); char buf[100]; if (!in.is_open()) { std::cout &lt;&lt; "파일을 찾을 수 없습니다!" &lt;&lt; std::endl; return 0; } // getline 함수는 개행 문자 (혹은 지정한 문자) 가 나오기 전에 지정한 버퍼의 크기가 다 차게 된다면 `failbit` 를 켜게 됨 while (in) { in.getline(buf, 100); // in.getline(buf, 100, '.')로 하면 .나올 때까지 읽음 // 기본적으로 '\n' std::cout &lt;&lt; buf &lt;&lt; std::endl; } return 0;
}
in.getline: ifstream에 정의된 getline은 buffer를 입력해줘야 함. 버퍼의 크기를 너무 작게 만든다면 정상적으로 데이터를 받을 수 없음.이러한 한계점을 극복하기 위해서 std::string::getline을 이용string::getline은 첫번째 인자를 istream(인풋 파일 스트림만을 의미하는 것 아님. 전체)
두번째 인자는 저장할 스트링 객체#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in("test.txt"); if (!in.is_open()) { std::cout &lt;&lt; "파일을 찾을 수 없습니다!" &lt;&lt; std::endl; return 0; } std::string s; while (in) { getline(in, s); std::cout &lt;&lt; s &lt;&lt; std::endl; } return 0;
}
한 가지 주의할 사항으로&nbsp;`while`&nbsp;문 조건으로&nbsp;절대&nbsp;`in.eof()`&nbsp;를 사용하면 안됩니다. 이러한 코드를 사용했다면 99 퍼센트의 확률로 잘못된 코드 입니다. 왜냐하면&nbsp;[eof]&nbsp;함수는 파일 위치 지시자가 파일에 끝에 도달한&nbsp;이후&nbsp;에&nbsp;`true`&nbsp;를 리턴하기 때문입니다. 예를 들어서&nbsp;`while`&nbsp;문 안에서 파일을 쭈르륵 읽다가 파일 끝(EOF) 바로 직전까지 읽었다고 해봅시다. 그렇다면 아직 EOF 를 읽지 않았으므로&nbsp;`in.eof()`&nbsp;는 참인 상태일 것입니다. 그 상태에서 예컨대&nbsp;`in &gt;&gt; data`&nbsp;를 하게 된다면&nbsp;`data`&nbsp;에는 아무것도 들어가지 않게 됩니다. 즉 초기화가 되지 않은 상태로 남아있는 것입니다! 다시 말해&nbsp;`in.eof()`&nbsp;는&nbsp;`while`&nbsp;문 안에서&nbsp;파일 읽기가 안전하다 라는 것을 보장하지 않습니다. 정확한 사용법은 그냥&nbsp;`while(in)`&nbsp;처럼 스트림 객체 자체를 전달하는 것입니다. 앞에서도 말했듯이&nbsp;[istream]&nbsp;객체는 다음 읽기가 안전할 때만&nbsp;`true`&nbsp;로 캐스팅됩니다.
ofstream을 이용해서 파일을 쓸 수 있음.#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt; int main() { // 파일 쓰기 준비 std::ofstream out("test.txt"); std::string s; if (out.is_open()) { out &lt;&lt; "이걸 쓰자~~"; } return 0;
}
다만 out에 특별한 설정이 없다면 딱 저대로 텍스트 파일이 생성됨 (기존의 파일 내용 없어짐) 만약 덧붙이고 싶다면 std::ios::app 옵션을 사용한다.std::ofstream out("test.txt", std::ios::app);
out 객체를 생성할 때 옵션은 몇가지 더 있음
ios::binary
ios::app
ios::ate - 자동으로 파일 끝에서 부터 읽기와 쓰기를 실시합니다. (즉 파일을 열 때 위치 지정자가 파일 끝을 가리키고 있게 됨
ios::trunc - 파일 스트림을 열면 기존에 있던 내용들이 모두 지워짐. 기본적으로&nbsp;ofstream&nbsp;객체를 생성할 때 이와 같은 설정으로 만들어짐
ios::app 과 ios::ate는 비슷하지만 중요한 차이가 있음.ios::app은 원본 내용 무조건 보장, ios::ate는 기존 파일의 내용을 보존X#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class Human { std::string name; int age; public: Human(const std::string&amp; name, int age) : name(name), age(age) {} std::string get_info() { return "Name :: " + name + " / Age :: " + std::to_string(age); } friend std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; o, Human&amp; h);
}; std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; o, Human&amp; h) { o &lt;&lt; h.get_info(); return o;
}
int main() { // 파일 쓰기 준비 std::ofstream out("test.txt"); Human h("이재범", 60); out &lt;&lt; h &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;sstream&gt; int main() { std::istringstream ss("123"); int x; ss &gt;&gt; x; std::cout &lt;&lt; "입력 받은 데이터 :: " &lt;&lt; x &lt;&lt; std::endl; return 0;
}
sstream에 std::istringstream이 정의되어 있음 -&gt; 마치 문자열을 하나의 스트림이라고 생각하게 하는 가상화 장치std::istringstream ss("123"); // 입력스트림 생성 (입력받은 것같음)
활용 어케하냐#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt; double to_number(std::string s) { std::istringstream ss(s); double x; ss &gt;&gt; x; return x;
} std::string to_str(int x) { std::ostringstream ss; ss &lt;&lt; x; return ss.str();
} int main() { std::cout &lt;&lt; "변환:: 1 + 2 = " &lt;&lt; to_number("1") + to_number("2") &lt;&lt; std::endl; std::cout &lt;&lt; "문자열로 변환:: 1 + 2 = " &lt;&lt; to_str(1 + 2) &lt;&lt; std::endl; return 0;
}
]]></description><link>cpp/파일-입출력-2.html</link><guid isPermaLink="false">CPP/파일 입출력 2.md</guid><pubDate>Sat, 06 Jul 2024 09:11:08 GMT</pubDate></item><item><title><![CDATA[pso_data]]></title><description><![CDATA[<img src="images/pso_data.png" target="_self">]]></description><link>images/pso_data.html</link><guid isPermaLink="false">images/pso_data.png</guid><pubDate>Mon, 01 Jul 2024 12:57:39 GMT</pubDate><enclosure url="images/pso_data.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/pso_data.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[collectpso]]></title><description><![CDATA[<img src="images/collectpso.png" target="_self">]]></description><link>images/collectpso.html</link><guid isPermaLink="false">images/collectpso.png</guid><pubDate>Mon, 01 Jul 2024 12:57:39 GMT</pubDate><enclosure url="images/collectpso.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/collectpso.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS]]></title><description><![CDATA[
너비 우선 탐색
가까운 노드부터 우선적으로 탐색
큐 자료구조
<img alt="BFS_1.png" src="images/bfs_1.png" target="_self"><br><img alt="BFS_2.png" src="images/bfs_2.png" target="_self">
#include &lt;bits/stdc++.h&gt; using namespace std; bool visited[9];
vector&lt;int&gt; graph[9]; // BFS 함수 정의
void bfs(int start) { queue&lt;int&gt; q; q.push(start); // 현재 노드를 방문 처리 visited[start] = true; // 큐가 빌 때까지 반복 while(!q.empty()) { // 큐에서 하나의 원소를 뽑아 출력 int x = q.front(); q.pop(); cout &lt;&lt; x &lt;&lt; ' '; // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입 for(int i = 0; i &lt; graph[x].size(); i++) { int y = graph[x][i]; if(!visited[y]) { q.push(y); visited[y] = true; } } }
} int main(void) { // 노드 1에 연결된 노드 정보 저장 graph[1].push_back(2); graph[1].push_back(3); graph[1].push_back(8); // 노드 2에 연결된 노드 정보 저장 graph[2].push_back(1); graph[2].push_back(7); // 노드 3에 연결된 노드 정보 저장 graph[3].push_back(1); graph[3].push_back(4); graph[3].push_back(5); // 노드 4에 연결된 노드 정보 저장 graph[4].push_back(3); graph[4].push_back(5); // 노드 5에 연결된 노드 정보 저장 graph[5].push_back(3); graph[5].push_back(4); // 노드 6에 연결된 노드 정보 저장 graph[6].push_back(7); // 노드 7에 연결된 노드 정보 저장 graph[7].push_back(2); graph[7].push_back(6); graph[7].push_back(8); // 노드 8에 연결된 노드 정보 저장 graph[8].push_back(1); graph[8].push_back(7); bfs(1);
}
]]></description><link>algorithm/lecture/bfs.html</link><guid isPermaLink="false">Algorithm/Lecture/BFS.md</guid><pubDate>Sun, 30 Jun 2024 16:29:56 GMT</pubDate><enclosure url="images/bfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS_2]]></title><description><![CDATA[<img src="images/bfs_2.png" target="_self">]]></description><link>images/bfs_2.html</link><guid isPermaLink="false">images/BFS_2.png</guid><pubDate>Sun, 30 Jun 2024 16:24:17 GMT</pubDate><enclosure url="images/bfs_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bfs_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS_1]]></title><description><![CDATA[<img src="images/bfs_1.png" target="_self">]]></description><link>images/bfs_1.html</link><guid isPermaLink="false">images/BFS_1.png</guid><pubDate>Sun, 30 Jun 2024 16:22:59 GMT</pubDate><enclosure url="images/bfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DFS]]></title><description><![CDATA[
스택 또는 재귀 이용
<img alt="DFS_1.png" src="images/dfs_1.png" target="_self"><br><img alt="DFS_2.png" src="images/dfs_2.png" target="_self">#include &lt;bits/stdc++.h&gt; using namespace std; bool visited[9];
vector&lt;int&gt; graph[9]; void dfs(int x) { visited[x] = true; cout &lt;&lt; x &lt;&lt; ' '; for(int i = 0; i &lt; graph[x].size(); i++) { int y = graph[x][i]; if (!visited[y] ) dfs(y); }
} int main(void) { graph[1].push_back(2); graph[1].push_back(3); graph[1].push_back(8); // 노드 2에 연결된 노드 정보 저장 graph[2].push_back(1); graph[2].push_back(7); // 노드 3에 연결된 노드 정보 저장 graph[3].push_back(1); graph[3].push_back(4); graph[3].push_back(5); // 노드 4에 연결된 노드 정보 저장 graph[4].push_back(3); graph[4].push_back(5); // 노드 5에 연결된 노드 정보 저장 graph[5].push_back(3); graph[5].push_back(4); // 노드 6에 연결된 노드 정보 저장 graph[6].push_back(7); // 노드 7에 연결된 노드 정보 저장 graph[7].push_back(2); graph[7].push_back(6); graph[7].push_back(8); // 노드 8에 연결된 노드 정보 저장 graph[8].push_back(1); graph[8].push_back(7); // dfs(1); return 0;
} ]]></description><link>algorithm/lecture/dfs.html</link><guid isPermaLink="false">Algorithm/Lecture/DFS.md</guid><pubDate>Sun, 30 Jun 2024 16:19:29 GMT</pubDate><enclosure url="images/dfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/dfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DFS_2]]></title><description><![CDATA[<img src="images/dfs_2.png" target="_self">]]></description><link>images/dfs_2.html</link><guid isPermaLink="false">images/DFS_2.png</guid><pubDate>Sun, 30 Jun 2024 16:08:37 GMT</pubDate><enclosure url="images/dfs_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/dfs_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DFS_1]]></title><description><![CDATA[<img src="images/dfs_1.png" target="_self">]]></description><link>images/dfs_1.html</link><guid isPermaLink="false">images/DFS_1.png</guid><pubDate>Sun, 30 Jun 2024 16:06:32 GMT</pubDate><enclosure url="images/dfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/dfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[iOS에서 백그라운드에서 포그라운드 이동 시 FAsyncLoadingThread 크래쉬]]></title><description><![CDATA[확인해보니깐 백그라운드 이동시에 IOSAppDelegate.cpp -(void)MainAppThread:(NSDictionary*)launchOptions 함수의 FAppEntry::SuspendTick() 에서 Suspend를 걸고 있는데 포그라운드로 다시 이동되서 메인쓰레드가 동작됐을때 FCoreDelegates::ApplicationHasEnteredForegroundDelegate 이벤트 또는 World Tick 동작시에 Suspend 상태가 유지되는 경우가 발생됩니다. FCoreDelegates::ApplicationHasEnteredForegroundDelegate 에서만 문제가 있었으면 그부분을 수정하면 되는데 World Tick까지 발생되서 반드시 수정이 필요한 부분]]></description><link>error/ios에서-백그라운드에서-포그라운드-이동-시-fasyncloadingthread-크래쉬.html</link><guid isPermaLink="false">Error/iOS에서 백그라운드에서 포그라운드 이동 시 FAsyncLoadingThread 크래쉬.md</guid><pubDate>Sat, 29 Jun 2024 12:24:51 GMT</pubDate></item><item><title><![CDATA[상속]]></title><description><![CDATA[
#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("기반") { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
class Derived : public Base { std::string s; public: Derived() : s("파생"), Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Base* p_c = &amp;c; p_c-&gt;what(); return 0;
}
기반 클래스
기반 클래스
파생 클래스
=== 포인터 버전 ===
기반
<img alt="cpp_1.png" src="images/cpp_1.png" target="_self">위처럼 파생클래스에서 기반클래스로 캐스팅 하는 것은 업 캐스팅
#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("기반") { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
class Derived : public Base { std::string s; public: Derived() : s("파생"), Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Derived* p_p = &amp;p; p_p-&gt;what(); return 0;
}
error C2440: 'initializing' : cannot convert from 'Base *' to 'Derived *'
<br><img alt="cpp_2.png" src="images/cpp_2.png" target="_self">위처럼 다운 캐스팅은 컴파일러 에러를 내뱉음 -&gt; 다운 캐스팅은 매우 위험한 행동임.그럼 아래와 같은 경우는 어떨까?#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("기반") { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
class Derived : public Base { std::string s; public: Derived() : s("파생"), Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Base* p_p = &amp;c; Derived* p_c = p_p; p_c-&gt;what(); return 0;
}
위의 다운캐스팅 경우와 똑같이 에러가 발생함. 다만 우리는 실제 p_p가 Derived c를 가리킨다는 것을 알고 있기 때문에 강제로 static_cast를 이용해서 다운캐스팅을 할 수 있다. Derived* p_c = static_cast&lt;Derived*&gt;(p_p);
이를 실행하면 어떻게 될까.clang++ 로 빌드한 결과 실행은 된다. (책에서는 안된다고 적혀있긴 한다.)상속관계에서 캐스팅 하는 것은 dynamic_cast를 사용하면 된다.Derived* p_c = dyanmic_cast&lt;Derived*&gt;(p_p);
그러나 아래와 같은 에러가 발생한다.error: 'Base' is not polymorphic Derived* p_c = dynamic_cast&lt;Derived*&gt;(p_p);
왜 에러가 발생할까?downcasting 을 dynamic_cast 를 통해 시도할때, compile time 에서 에러가 나오는 경우는 Base class 가 "polymorphic" 하지 않을 경우(즉, 가상함수가 없을 경우) 에 한정됩니다. 그 외의 경우는, 컴파일 타임에서 에러를 내지 않고 대신 nullptr 값을 리턴합니다. 또한, 레퍼런스 타입으로 캐스팅하려 할 경우는 bad_cast 를 throw 하게 됩니다. dynamic_cast 를 이용한 다운캐스팅시, 컴파일타임에 에러가 검출#include &lt;iostream&gt; class Base { public: Base() { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } virtual void what() { std::cout &lt;&lt; "기반 클래스의 what()" &lt;&lt; std::endl; }
};
class Derived : public Base { public: Derived() : Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; "파생 클래스의 what()" &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; Base* p_c = &amp;c; Base* p_p = &amp;p; std::cout &lt;&lt; " == 실제 객체는 Base == " &lt;&lt; std::endl; p_p-&gt;what(); std::cout &lt;&lt; " == 실제 객체는 Derived == " &lt;&lt; std::endl; p_c-&gt;what(); return 0;
}
위에서 공부한 것에 의하면,p_c는 업캐스팅, p_p는 그냥 포인터 가르키기이므로 아래와 같이 결과가 출력되어야 함.기반 클래스
기반 클래스
파생 클래스
== 실제 객체는 Base ==
기반 클래스의 what()
== 실제 객체는 Derived == 파생 클래스의 what()
근데 실제 결과는 기반 클래스
기반 클래스
파생 클래스 == 실제 객체는 Base == 기반 클래스의 what() == 실제 객체는 Derived == 파생 클래스의 what()
virtual 키워드 사용 때문에 이런 일이 발생하는 것임 어떻게 이런 일이 발생하는 것이냐면아래 코드 실행시에 p_c-&gt;what();
컴퓨터(런타임) 입장에서"흠, p_c 는 Base 포인터니까 Base 의 what() 을 실행해야지"
"어 근데 what 이 virtual 이네?" "잠깐. 이거 실제 Base 객체 맞어? 아니네 Derived 객체네"
"그럼 Derived 의 what 을 실행해야지"
p_p-&gt;what();
"흠, p_c 는 Base 포인터니까 Base 의 what() 을 실행해야지"
"어 근데 what 이 virtual 이네?" "잠깐. 이거 실제 Base 객체 맞어? 어 맞네."
"Base 의 what 을 실행하자"
이렇게 컴파일 시에 어떤 함수가 실행될 지 정해지지 않고 런타임 시에 정해지는 일을 가리켜서&nbsp;동적 바인딩(dynamic binding)&nbsp;이라고 부름!-&gt; virtual를 붙이면 동적바인딩이겠네 어떤 함수를 실행할 지 모르니까// i 는 사용자로부터 입력받는 변수
if (i == 1) { p_p = &amp;c;
} else { p_p = &amp;p;
}
p_p-&gt;what();
다음과 같은 코드는 정적 바인딩임. 컴파일 타임에서 어떤 함수가 실행될 지 정해지니까 #include &lt;iostream&gt; class Base {
public: void display() { std::cout &lt;&lt; "Display Base" &lt;&lt; std::endl; }
}; class Derived : public Base {
public: void display() { std::cout &lt;&lt; "Display Derived" &lt;&lt; std::endl; }
};
int main() { Base base; Derived derived; base.display(); // 정적 바인딩, Base::display() 호출 derived.display(); // 정적 바인딩, Derived::display() 호출 return 0;
}
C++ 11 에서는 파생 클래스에서 기반 클래스의 가상 함수를 오버라이드 하는 경우,&nbsp;override&nbsp;키워드를 통해서 명시적으로 나타낼 수 있음그렇다면 프로그램 내부적으로&nbsp;virtual&nbsp;함수들은 어떻게 처리될까요? 즉, 이 포인터가 어떠한 객체를 가리키는지 어떻게 알 수 있을까요? (난이도 : 上)Answerc++에서 virtual 함수는 동적 바인딩(dynamic binding) 또는 런타임 바인딩(run-time binding)을 통해 처리됩니다. 이는 실행 시간에 호출될 함수가 결정되는 방식입니다. 이를 위해 C++는 가상 함수 테이블(Virtual Table, vtable)과 가상 함수 포인터(Virtual Table Pointer, vptr)를 사용합니다.가상 함수 테이블(vtable)과 가상 함수 포인터(vptr)1. 가상 함수 테이블(vtable) • 가상 함수 테이블은 클래스마다 존재하는 함수 포인터 테이블입니다.
• 클래스에 가상 함수가 정의되면, 컴파일러는 해당 가상 함수를 가리키는 포인터를 가상 함수 테이블에 저장합니다.
2. 가상 함수 포인터(vptr) • 가상 함수 포인터는 객체마다 존재합니다.
• 이 포인터는 객체가 속한 클래스의 가상 함수 테이블을 가리킵니다.
• 객체가 생성될 때, 이 포인터는 해당 객체의 클래스에 맞는 가상 함수 테이블을 가리키도록 초기화됩니다.
동작 원리
객체 생성 시
• 객체가 생성되면, 객체의 vptr은 해당 클래스의 vtable을 가리키도록 설정됩니다.
가상 함수 호출 시
• 가상 함수가 호출될 때, 객체의 vptr을 통해 vtable에 접근합니다.
• vtable에서 적절한 함수 포인터를 찾아 해당 함수를 호출합니다.
#include &lt;iostream&gt; class Base {
public: virtual void show() { std::cout &lt;&lt; "Base class" &lt;&lt; std::endl; }
}; class Derived : public Base {
public: void show() override { std::cout &lt;&lt; "Derived class" &lt;&lt; std::endl; }
}; void display(Base* obj) { obj-&gt;show(); // 동적 바인딩을 통해 적절한 함수 호출
} int main() { Base base; Derived derived; display(&amp;base); // "Base class" display(&amp;derived); // "Derived class" return 0;
} Base* b = new Derived(); b-&gt;show(); // Derived show b-&gt;display(); // Derived display
vtable 구성
• Base vtable:• Base::show
• Base::display
• Derived vtable:• Derived::show (Base의 show 함수 재정의)
• Derived::display (Base의 display 함수 재정의)
vptr 초기화• Base 포인터가 Derived 객체를 가리킬 때, Derived 객체의 vptr은 Derived 클래스의 vtable을 가리킵니다.
• 따라서 b-&gt;show()와 b-&gt;display() 호출 시 Derived 클래스의 가상 함수 테이블을 참조하여 각각 Derived::show와 Derived::display가 호출됩니다.
상속 시에 Base 클래스 소멸자를 가상함수로 만들어야 됨#include &lt;iostream&gt; class Parent { public: Parent() { std::cout &lt;&lt; "Parent 생성자 호출" &lt;&lt; std::endl; } ~Parent() { std::cout &lt;&lt; "Parent 소멸자 호출" &lt;&lt; std::endl; }
};
class Child : public Parent { public: Child() : Parent() { std::cout &lt;&lt; "Child 생성자 호출" &lt;&lt; std::endl; } ~Child() { std::cout &lt;&lt; "Child 소멸자 호출" &lt;&lt; std::endl; }
};
int main() { std::cout &lt;&lt; "--- 평범한 Child 만들었을 때 ---" &lt;&lt; std::endl; { Child c; } std::cout &lt;&lt; "--- Parent 포인터로 Child 가리켰을 때 ---" &lt;&lt; std::endl; { Parent *p = new Child(); delete p; }
}
--- 평범한 Child 만들었을 때 ---
Parent 생성자 호출
Child 생성자 호출
Child 소멸자 호출
Parent 소멸자 호출
--- Parent 포인터로 Child 가리켰을 때 ---
Parent 생성자 호출
Child 생성자 호출
Parent 소멸자 호출
delete p&nbsp;를 하더라도,&nbsp;p&nbsp;가 가리키는 것은&nbsp;Parent&nbsp;객체가 아닌&nbsp;Child&nbsp;객체 이기 때문에, Child&nbsp;객체가 소멸되는 것과 같은 순서로 생성자와 소멸자들이 호출되어야만 합니다. 그런데 실제로는,&nbsp;Child&nbsp;소멸자가 호출되지 않습니다. 캐스팅한 타입 Parent만을 해제하고 있음.위의 코드에서 Parent 클래스의 소멸자를 가상함수로 만든다면 우리가 원하는대로 동작할것임. Child 소멸자를 호출하게 됨 그렇다며 왜 Parent 소멸자가 호출 되는 것일까?Child&nbsp;소멸자가 '알아서'&nbsp;Parent&nbsp;의 소멸자도 호출함(Child&nbsp;는 자신이&nbsp;Parent&nbsp;를 상속받는다는 것을 알고 있습니다).반면에&nbsp;Parent&nbsp;소멸자를 먼저 호출하게 되면,&nbsp;Parent&nbsp;는&nbsp;Child&nbsp;가 있는지 없는지 모르므로,&nbsp;Child&nbsp;소멸자를 호출해줄 수 없습니다 (Parent 는 자신이 누구에서 상속해주는지 알 수 없지요).이와 같은 연유로,상속될 여지가 있는&nbsp;Base&nbsp;클래스들은 (위 경우&nbsp;Parent) 반드시 소멸자를&nbsp;virtual&nbsp;로 만들어주어야 나중에 문제가 발생할 여지가 없게 됩니다.#include &lt;iostream&gt; class A { public: virtual void show() { std::cout &lt;&lt; "Parent !" &lt;&lt; std::endl; }
};
class B : public A { public: void show() override { std::cout &lt;&lt; "Child!" &lt;&lt; std::endl; }
}; void test(A&amp; a) { a.show(); }
int main() { A a; B b; test(a); test(b); return 0;
}
]]></description><link>cpp/상속.html</link><guid isPermaLink="false">CPP/상속.md</guid><pubDate>Tue, 25 Jun 2024 13:28:42 GMT</pubDate><enclosure url="images/cpp_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[subset_graph]]></title><description><![CDATA[<img src="images/subset_graph.png" target="_self">]]></description><link>images/subset_graph.html</link><guid isPermaLink="false">images/subset_graph.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/subset_graph.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subset_graph.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그리디 알고리즘]]></title><description><![CDATA[
현재 상황에서 지금 당장 좋은 것만 고르는 방법
문제 1.
<img alt="greedy_1.png" src="images/greedy_1.png" target="_self">#include &lt;bits/stdc++.h&gt; using namespace std; int n = 1260;
int cnt; int coinTypes[4] = {500, 100, 50, 10}; int main()
{ for (int i = 0; i &lt; 4; ++i) { cnt += n / coinTypes[i]; n % = coinTypes[i]; } cout &lt;&lt; cnt &lt;&lt; '\n';
} 문제 2. <br><img alt="greedy_2.png" src="images/greedy_2.png" target="_self">2 이상의 수로 나누는 것이 1을 빼는 것보다 수를 더 많이 줄일 수 있음 -&gt; 그리디#include &lt;bits/stdc++.h&gt; using namespace std; int n,k;
int result; int main()
{ cin &gt;&gt; n &gt;&gt; k; while (true) { // n이 k로 나누어 떨어지는 수가 될 때까지 빼기 int target = (n/k) * k; result += (n - target); n = target; // n이 k보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출 if (n &lt; k) break; result++; n /= k; } // 마지막으로 남은 수에 대하여 1씩 빼기 result += (n-1); cout &lt;&lt; result &lt;&lt;'\n';
}
문제 3.<br><img alt="greedy_3.png" src="images/greedy_3.png" target="_self">Mine: 0이나 1을 만났을 때 더하기 나머지 곱하기#include &lt;bits/stdc++.h&gt; using namespace std; string str; int main()
{ cin &gt;&gt; str; long long result = str[0]-'0'; for (int i = 1; i &lt; str.size(); i++) { int num = str[i] - '0'; if (num &lt; = 1 || result &lt;= 1) result += num; else result *= num; } cout &lt;&lt; result &lt;&lt; '\n';
} 문제 4.<br><img alt="greedy_4.png" src="images/greedy_4.png" target="_self">예시: n = 5, 공포도 : 2 3 1 2 2오름차순 정렬하고 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면 그룹 결성 그룹1: 1, 2, 3
그룹2: 2 2#include &lt;bits/stdc++.h&gt; using namespace std; int n;
vector&lt;int&gt; arr; int main()
{ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; arr.push_back(x); } sort(arr.begin(), arr.end()); int result = 0; int cnt = 0; for(int i =0; i &lt; n; i++) { cnt += 1; if( cnt &gt;= arr[i]) { result +=1; cnt = 0; } } cout &lt;&lt; result &lt;&lt; '\n';
} ]]></description><link>algorithm/lecture/그리디-알고리즘.html</link><guid isPermaLink="false">Algorithm/Lecture/그리디 알고리즘.md</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[78. Subsets]]></title><description><![CDATA[Given an integer array&nbsp;nums&nbsp;of&nbsp;unique&nbsp;elements, return&nbsp;all possible&nbsp;subsets&nbsp;(the power set).The solution set&nbsp;must not&nbsp;contain duplicate subsets. Return the solution in&nbsp;any order.Constraints:
1 &lt;= nums.length &lt;= 10
-10 &lt;= nums[i] &lt;= 10
All the numbers of&nbsp;nums&nbsp;are&nbsp;unique.
<img alt="subset_graph.png" src="images/subset_graph.png" target="_self">class Solution {
public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; curr; vector&lt;vector&lt;int&gt;&gt; result; dfs(nums, 0, curr, result); return result; } private: void dfs( vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; curr, vector&lt;vector&lt;int&gt;&gt;&amp; result) { result.push_back(curr); for(int i = start; i &lt; nums.size(); i++) { curr.push_back(nums[i]); dfs(nums, i+1, curr, result); curr.pop_back(); } }
};
]]></description><link>algorithm/leetcode/78.-subsets.html</link><guid isPermaLink="false">Algorithm/LeetCode/78. Subsets.md</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/subset_graph.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subset_graph.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[217. Contains Duplicate]]></title><description><![CDATA[Given an integer array&nbsp;nums, return&nbsp;true&nbsp;if any value appears&nbsp;at least twice&nbsp;in the array, and return&nbsp;false&nbsp;if every element is distinct.Example 1:Input: nums = [1,2,3,1]
Output: trueExample 2:Input: nums = [1,2,3,4]
Output: falseExample 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: trueConstraints:
1 &lt;= nums.length &lt;= 105
-109&nbsp;&lt;= nums[i] &lt;= 109 class Solution {
public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { std::set&lt;int&gt; s(nums.begin(), nums.end()); return s.size() != nums.size(); }
}; ]]></description><link>algorithm/leetcode/217.-contains-duplicate.html</link><guid isPermaLink="false">Algorithm/LeetCode/217. Contains Duplicate.md</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate></item><item><title><![CDATA[greedy_4]]></title><description><![CDATA[<img src="images/greedy_4.png" target="_self">]]></description><link>images/greedy_4.html</link><guid isPermaLink="false">images/greedy_4.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_3]]></title><description><![CDATA[<img src="images/greedy_3.png" target="_self">]]></description><link>images/greedy_3.html</link><guid isPermaLink="false">images/greedy_3.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_2]]></title><description><![CDATA[<img src="images/greedy_2.png" target="_self">]]></description><link>images/greedy_2.html</link><guid isPermaLink="false">images/greedy_2.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_1]]></title><description><![CDATA[<img src="images/greedy_1.png" target="_self">]]></description><link>images/greedy_1.html</link><guid isPermaLink="false">images/greedy_1.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[파일 입출력]]></title><description><![CDATA[<img alt="cpp_5.png" src="images/cpp_5.png" target="_self">ios_base - 스트림의 입출력 형식 관련 데이터 처리ios - 스트림 버퍼 초기화, 입출력 작업 상태 처리
스트림버퍼: 데이터를 내보내거나 받아들이기 전에 임시로 저장하는 곳
사용자가 1byte씩 쓰거나 읽는다고 할 때 실제 프로그램은 1byte씩 읽는게 아님 -&gt; 하드디스크에 쓰거나 읽을 때 시간이 오래걸리기 때문에 한 뭉터기로 쓰거나 읽어옴
istream - 실제로 입력을 수행하는 클래스operator&gt;&gt;는 모든 공백문자(띄어쓰기, 엔터, 탭)을 입력시에 무시함
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { std::string s; while (true) { std::cin &gt;&gt; s; std::cout &lt;&lt; "word : " &lt;&lt; s &lt;&lt; std::endl; }
}
this is a long sentence
word : this
word : is
word : a
word : long
word : sentence
ABCD EFGH IJKL
word : ABCD
word : EFGH
word : IJKL
주의할 점// 주의할 점
#include &lt;iostream&gt;
using namespace std;
int main() { int t; while (true) { std::cin &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (t == 0) break; }
}
3
입력 :: 3
4
입력 :: 4
5
입력 :: 5
6
입력 :: 6
7
입력 :: 7
숫자만 입력시에 잘 동작함. 그러나 문자('c\n')를 입력한다면 기괴환 무한루프 결과가 나옴.<br><img alt="cpp_6.png" src="images/cpp_6.png" target="_self">ios 클래스에서 스트림 상태를 관리하는 플래그가 4개가 정의되어 있음
goodbit: 스트림에 입출력 작업이 가능할 때
badbit: 스트림에 복구 불가능한 오류 발생시
eofbit: 입력 작업시에&nbsp;EOF 도달시
failbit: 스트림에 복구 가능한 오류 발생시
'c\n'을 입력하는 경우 타입에 맞지 않는 값이기 때문에 failbit가 켜짐. 그리고 입력값을 받지 않고 리턴함. 그러나 스트림에 'c\n'이 남아있는데 이를 처리하지 않는다는 것 -&gt; 무한루프// 해결 방안
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { int t; while (std::cin &gt;&gt; t) { std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (t == 0) break; }
}
while(std::cin &gt;&gt; t)로 인해서 무한루프에 빠지지 않고 제대로 처리됨.이게 어떻게 처리되는 지를 이해하기 위해서는 ios에 정의되어 있는 함수 operator void*() const;에 대해 알아야함.operator void*() const;
이 함수는&nbsp;ios 객체를&nbsp;void*&nbsp;로 변환함. 이 떄 Null 포인터가 아닌 값을 반환하기 위해서는 failbit와 badbit가 모두 off인 경우임.즉 정상적으로 입출력 작업을 수행할 수 있는 경우임.코드로 돌아가서 문자 's'를 입력 한다면 failbit가 켜지게 됨
std::cin &gt;&gt; t를 후에 cin이 리턴되는데 null 포인터를 리턴하게 되어서 루프를 돌지 않게 됨.문제를 해결한 상태지만 입력을 계속 진행할 수 없음. cin에 failbit가 켜져있기 때문임. 그래서 플래그를 초기화 해야함#include &lt;iostream&gt;
#include &lt;string&gt; int main() { int t; while (true) { std::cin &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; "제대로 입력해주세요" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 std::cin.ignore(100, '\n'); // 개행문자가 나올 때 까지 무시한다 } if (t == 1) break; }
}
fail()함수는 ios에 정의되어 있고 failbit || badbit가 true인 경우 true를 리턴함.clear()도 ios에 정의되어 있고 인자를 주지 않으면 플래그를 goodbit로 초기화함 따라서 fail 상태 초기화할 수 있음.ignore() istream에 정의되어 있고 최대 첫번째 인자(100)만큼 두번째 인자('\n')이 나올 때까지 버퍼에서 무시함.ios_base 클래스에서 스트림 입출력 형식 바꾸기 가능: 10진수 -&gt; 16진수로 처리#include &lt;string&gt;
#include &lt;iostream&gt; int main() { int t; while (true) { std::cin.setf(std::ios_base::hex, std::ios_base::basefield); std::cin &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; "제대로 입력해주세요" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 // std::cin.ignore(100,'n');//개행문자가 나올 때까지 // 무시한다 } if (t == 0) break; }
}
위의 코드는 16진수로 입력받기 -&gt; 10진수로 출력std::cin.setf(ios_base::hex, ios_base::basefield)setf의 버전은 2가지임.인자를 1개 받는 경우와 위의 경우처럼 2개를 받는 것1개를 받는 경우: 하나의 인자를 받는 setf는 새로운 포맷 플래그를 설정하고, 기존 플래그와 병합합니다.
이 경우, std::ios::hex 플래그를 설정하여 이후의 입력을 16진수로 처리합니다. 이전에 설정된 다른 플래그는 유지되며, 새로운 플래그와 병합됩니다.2개를 받는 경우
두 개의 인자를 받는 setf는 첫 번째 인자로 전달된 플래그를 설정하고, 두 번째 인자로 전달된 마스크에 해당하는 플래그를 클리어(지움)합니다.이 경우, std::ios::hex 플래그를 설정하면서, std::ios::basefield에 해당하는 플래그 (std::ios::dec, std::ios::oct, std::ios::hex)는 모두 클리어합니다. 즉, std::ios::hex만 남게 됩니다.위의 방법말고 16진수로 입력을 조작하는 방법은 조작자를 사용하는 것// 조작자의 사용
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { int t; while (true) { std::cin &gt;&gt; std::hex &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; "제대로 입력해주세요" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 std::cin.ignore(100, 'n'); //개행문자가 나올 때까지 무시한다 } if (t == 0) break; }
}
std::cin &gt;&gt; hex &gt;&gt; t; hex가 cin에서 수를 받는 방식을 바꿈 여기에서 hex는 함수고 조작자라고 부름. 그 전의 경우 hex는 이름은 같지만 형식플래그고 (std::ios_base::hex) 정의되어 있는 상수 '값'임.그러나 조작자 hex는 ios_base객체를 레퍼런스로 받고 다시 그 객체를 리턴하도록 정의된 함수임.std::ios_base&amp; hex(std::ios_base&amp; str);
operator&gt;&gt; 중에서도 위 함수를 인자로 가지도록 오버로딩 되어 있음istream&amp; operator&gt;&gt;(ios_base&amp; (*pf)(ios_base&amp;));
조작자를 사용하면 입력 형식을 쉽게 바꿀 수 있음. endl는 출력을 관장하는 ostream에 정의되어 있는 조작자임. 한줄 개행문자를 출력하는 것말고 버퍼를 flush 역할을 수행함.기본적으로 문자 1개를 내보낸다고 화면에 바로 출력하는 것이 아니라 버퍼에 모은 다음에 버퍼에 어느정도 쌓이면 출력하게 되지만 flush()는 버퍼에 데이터가 얼마나 쌓여있든지 바로 출력을 해줌.c++에 streambuf 클래스가 있음 streambuf 클래스는 스트림에 대한 가장 기본적인 제어를 담당<br><img alt="cpp_7.png" src="images/cpp_7.png" target="_self">
(streambuf 클래스에서 스트림을 어떤 식으로 추상화하고 있는지 나타내는 그림)streambuf 클래스는 스트림의 상태를 나타내기 위해서 세 개의 포인터 정의
버퍼의 시작 부분을 가르키는 시작 포인터
다음으로 읽을 문자를 가르키고 있는 포인터(스트림 위치 지정자)
버퍼의 끝 부분을 가르키는 끝 포인터
streambuf 클래스는 입력 버퍼와 출력 버퍼를 구분해서 get area, put area라 부름. 이를 각각 가르키는 포인터도 g, p를 붙여서 표현입력 객체 cin.rdbuf()를 호출하면 cin 객체가 수행하고 있던 streambuf 객체를 가르키는 포인터를 리턴하게 됨. cin 객체는 istream 객체이므로 오직 입력만을 수행하고 있음. 따라서 streambuf 객체에는 get area만 있음snextc() 함수는 스트림 위치 지정자를 한 칸 전진한 해당 문자를 엿봄.(읽는 것이 아님)peek의 결과가 왜 'w'일까?<br><img alt="cpp_8.png" src="images/cpp_8.png" target="_self"><br><img alt="cpp_9.png" src="images/cpp_9.png" target="_self">streambuf&nbsp;에는&nbsp;snextc&nbsp;함수 말고도 수 많은 함수들이 정의되어있음.
C++ 입출력 라이브러리는 스트림 버퍼도 추상화해서 클래스로 만들었다는 것을 기억하기cin은 스트림버퍼에서 공백을 기준으로 가져옴#include &lt;iostream&gt;
#include &lt;string&gt; int main()
{ std::string s; std::cin &gt;&gt; s; std::cout &lt;&lt; "1: " &lt;&lt; s &lt;&lt; std::endl; // std::cin &gt;&gt; s; std::cout &lt;&lt; "2: " &lt;&lt; s &lt;&lt; std::endl; return 0; }
Q) 입력값으로 hello world 를 입력했을 때 std::cin &gt;&gt; s 를 주석처리한 경우와 아닌 경우 결과는?주석처리 하지 않은 경우 1: hello
2: world 주석처리한 경우 1: hello
2: hello
]]></description><link>cpp/파일-입출력.html</link><guid isPermaLink="false">CPP/파일 입출력.md</guid><pubDate>Sun, 16 Jun 2024 09:05:57 GMT</pubDate><enclosure url="images/cpp_5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_5.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_9]]></title><description><![CDATA[<img src="images/cpp_9.png" target="_self">]]></description><link>images/cpp_9.html</link><guid isPermaLink="false">images/cpp_9.png</guid><pubDate>Sun, 16 Jun 2024 08:56:39 GMT</pubDate><enclosure url="images/cpp_9.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_9.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_8]]></title><description><![CDATA[<img src="images/cpp_8.png" target="_self">]]></description><link>images/cpp_8.html</link><guid isPermaLink="false">images/cpp_8.png</guid><pubDate>Sun, 16 Jun 2024 08:56:32 GMT</pubDate><enclosure url="images/cpp_8.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_8.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_7]]></title><description><![CDATA[<img src="images/cpp_7.png" target="_self">]]></description><link>images/cpp_7.html</link><guid isPermaLink="false">images/cpp_7.png</guid><pubDate>Sun, 16 Jun 2024 08:34:17 GMT</pubDate><enclosure url="images/cpp_7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_7.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_6]]></title><description><![CDATA[<img src="images/cpp_6.png" target="_self">]]></description><link>images/cpp_6.html</link><guid isPermaLink="false">images/cpp_6.png</guid><pubDate>Sun, 16 Jun 2024 07:00:10 GMT</pubDate><enclosure url="images/cpp_6.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_6.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_5]]></title><description><![CDATA[<img src="images/cpp_5.png" target="_self">]]></description><link>images/cpp_5.html</link><guid isPermaLink="false">images/cpp_5.png</guid><pubDate>Sun, 16 Jun 2024 06:44:01 GMT</pubDate><enclosure url="images/cpp_5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_5.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_4]]></title><description><![CDATA[<img src="images/cpp_4.png" target="_self">]]></description><link>images/cpp_4.html</link><guid isPermaLink="false">images/cpp_4.png</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate><enclosure url="images/cpp_4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[상속 2]]></title><description><![CDATA[가상함수는 약간의 오버헤드가 발생class Parent { public: virtual void func1(); virtual void func2();
};
class Child : public Parent { public: virtual void func1(); void func3();
};
<img alt="cpp_3.png" src="images/cpp_3.png" target="_self">Parent* p = Parent();
p-&gt;func1(); p&nbsp;가&nbsp;Parent&nbsp;를 가리키는 포인터 이니까,&nbsp;func1()&nbsp;의 정의를&nbsp;Parent&nbsp;클래스에서 찾아봐야겠다.
func1()&nbsp;이 가상함수네? 그렇다면&nbsp;func1()&nbsp;을 직접 실행하는게 아니라, 가상 함수 테이블에서&nbsp;func1()&nbsp;에 해당하는 함수를 실행해야겠다.
Parent* c = Child();
c-&gt;func1();
p&nbsp;가 실제로는&nbsp;Child&nbsp;객체를 가리키고 있으므로,&nbsp;Child&nbsp;객체의 가상 함수 테이블을 참조하여,&nbsp;Child::func1()&nbsp;을 호출두 단계에 걸쳐서 함수를 호출함 -&gt; 약간의 오버헤드#include &lt;iostream&gt; class Animal { public: Animal() {} virtual ~Animal() {} virtual void speak() = 0; // 순수 가상함수
}; class Dog : public Animal { public: Dog() : Animal() {} void speak() override { std::cout &lt;&lt; "왈왈" &lt;&lt; std::endl; }
}; class Cat : public Animal { public: Cat() : Animal() {} void speak() override { std::cout &lt;&lt; "야옹야옹" &lt;&lt; std::endl; }
}; int main() { Animal* dog = new Dog(); Animal* cat = new Cat(); dog-&gt;speak(); cat-&gt;speak();
}
가상 함수에&nbsp;= 0;&nbsp;을 붙여서, 반드시 오버라이딩 되도록 만든 함수를 완전한 가상 함수라 해서,&nbsp;순수 가상 함수(pure virtual function)라고 부름순수 가상 함수는 본체가 없음 -&gt; 함수 호출 불가 -&gt; 순수 가상함수를 담고 있는 객체는 생성 불가능 (추상클래스를 가르키는 포인터는 생성가능)인스턴스화를 하기 위해서는 상속 받는 클래스를 만들고 순수 가상함수를 모두 오버라이드 해야함순수 가상함수를 하나 이상 포함하고 있는 클래스 -&gt; 추상 클래스Animal a; // 스택할당 - 불가능
a.speak(); Animal* dog = new Dog();
Animal* cat = new Cat(); dog-&gt;speak();
cat-&gt;speak(); #include &lt;iostream&gt; class A { public: int a; A() { std::cout &lt;&lt; "A 생성자 호출" &lt;&lt; std::endl; }
}; class B { public: int b; B() { std::cout &lt;&lt; "B 생성자 호출" &lt;&lt; std::endl; }
}; class C : public B, public A { public: int c; C() : A(), B() { std::cout &lt;&lt; "C 생성자 호출" &lt;&lt; std::endl; }
};
int main() { C c; }
상속 순서에 따라서 생성자 호출B 생성자 호출
A 생성자 호출
C 생성자 호출
다중 상속시 주의할 점base 클래스의 함수나 변수가 동일한 이름인 경우 문제가 발생 (다이아몬드 상속)class A { public: int a;
}; class B { public: int a;
}; class C : public B, public A { public: int c;
}; int main() { C c; c.a = 3;
}
error C2385: ambiguous access of 'a'
1&gt; could be the 'a' in base 'B'
1&gt; or could be the 'a' in base 'A' 다이아몬드 상속class Human { // ...
};
class HandsomeHuman : public Human { // ...
};
class SmartHuman : public Human { // ...
};
class Me : public HandsomeHuman, public SmartHuman { // ...
};
<br><img alt="cpp_4.png" src="images/cpp_4.png" target="_self">만약 Human에 name이라는 변수가 있다면 상속을 받은 HandsomeHuman, SmartHuman에도 name이라는 변수가 있는 것Me는 두 클래스를 상속 받으니 name 변수가 중복되는 문제 발생해결할 수 있는 방법class Human { public: // ...
};
class HandsomeHuman : public virtual Human { // ...
};
class SmartHuman : public virtual Human { // ...
};
class Me : public HandsomeHuman, public SmartHuman { // ...
};
이러한 형태로&nbsp;Human&nbsp;을&nbsp;virtual&nbsp;로 상속 받는다면,&nbsp;Me&nbsp;에서 다중 상속 시에도, 컴파일러가 언제나&nbsp;Human&nbsp;을 한 번만 포함하도록 지정할 수 있게 됩니다. 참고로, 가상 상속 시에,&nbsp;Me&nbsp;의 생성자에서&nbsp;HandsomeHuman&nbsp;과&nbsp;SmartHuman&nbsp;의 생성자를 호출함은 당연하고 Human&nbsp;의 생성자 또한 호출해주어야만 합니다.최상단 base의 생성자를 호출한다는 것이 특이]]></description><link>cpp/상속-2.html</link><guid isPermaLink="false">CPP/상속 2.md</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate><enclosure url="images/cpp_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[상속3 - 다중 상속]]></title><description><![CDATA[예를 들어서 여러분이&nbsp;차량(Vehicle)&nbsp;에 관련한 클래스를 생성한다고 해봅시다. 차량의 종류로는 땅에서 다니는 차, 물에서 다니는 차, 하늘에서 다니는 차, 우주에서 다니는 차들이 있다고 해봅시다. (차 라고 하기 보다는 운송 수단이 좀 더 적절한 표현이겠네요..)또한, 이 차량들은 각기 다른 동력원들을 사용하는데, 휘발유를 사용할 수 도 있고, 풍력으로 갈 수 도 있고 원자력으로 갈 수도 있고, 페달을 밟아서 갈 수 도 있습니다.이러한 차량들을 클래스로 나타내기 위해서, 다중 상속을 활용할 수 있지만 그 전에, 아래와 같은 질문들에 대한 대답을 생각해봅시다.
LandVehicle&nbsp;을 가리키는&nbsp;Vehicle&amp;&nbsp;레퍼런스를 필요로 할까? 다시 말해,&nbsp;Vehicle&nbsp;레퍼런스가 실제로는&nbsp;LandVehicle&nbsp;을 참조하고 있다면,&nbsp;Vehicle&nbsp;의 멤버 함수를 호출하였을 때, LandVehicle 의 멤버 함수가 오버라이드 되서 호출되기를 바라나요? GasPoweredVehicle&nbsp;의 경우도 마찬가지 입니다. 만일&nbsp;Vehicle&nbsp;레퍼런스가 실제로는&nbsp;GasPoweredVehicle&nbsp;을 참조하고 있을 때,&nbsp;Vehicle&nbsp;레퍼런스의 멤버함수를 호출한다면,&nbsp;GasPoweredVehicle&nbsp;의 멤버 함수가 오버라이드 되서 호출되기를 원하나요? 만일 두 개의 질문에 대한 대답이 모두&nbsp;예&nbsp;라면 다중 상속을 사용하는 것이 좋을 것입니다. 하지만 그 전에, 몇 가지 고려할 점이 더 있습니다. 만약에 이 차량이 작동하는 환경이&nbsp;𝑁N&nbsp;개가 있고 (땅, 물, 하늘, 우주 등등), 동력원의 종류가&nbsp;𝑀M&nbsp;개가 있다고 해봅시다.이를 위해서, 크게 3 가지 방법으로 이러한 클래스를 디자인 할 수 있습니다. 바로 브리지 패턴 (bridge pattern), 중첩된 일반화 방식 (nested generalization), 다중 상속 입니다. 각각의 방식에는 모두 장단점이 있습니다. 브리지 패턴의 경우 차량을 나타내는 한 가지 카테고리를 아예 멤버 포인터로 만들어버립니다. 예를 들어서&nbsp;Vehicle&nbsp;클래스의 파생 클래스로&nbsp;LandVehicle,&nbsp;SpaceVehicle&nbsp;클래스들이 있고,&nbsp;Vehicle&nbsp;클래스의 멤버 변수로 어떤 엔진을 사용하는지 가리키는&nbsp;Engine*&nbsp;멤버 변수가 있습니다. 이&nbsp;Engine&nbsp;은&nbsp;GasPowered,&nbsp;NuclearPowered&nbsp;와 같은&nbsp;Engine&nbsp;의 파생 클래스들의 객체들을 가리키게 됩니다. 그리고 런타임 시에 사용자가&nbsp;Engine&nbsp;을 적절히 설정해주면 됩니다. 이 경우 동력원 이나 환경을 하나 추가하더라도 클래스를 1 개만 더 만들면 됩니다. 즉, 총&nbsp;𝑁+𝑀N+M&nbsp;개의 클래스만 생성하면 된다는 뜻입니다. 하지만 오버라이딩 가지수가&nbsp;𝑁+𝑀N+M&nbsp;개 뿐이므로 최대&nbsp;𝑁+𝑀N+M&nbsp;개 알고리즘 밖에 사용할 수 없습니다. 만일 여러분이&nbsp;𝑁×𝑀N×M&nbsp;개의 모든 상황에 대한 섬세한 제어가 필요하다면 브리지 패턴을 사용하지 않는 것이 좋습니다. 또한, 컴파일 타임 타입 체크를 적절히 활용할 수 없다는 문제가 있습니다. 예를 들어서&nbsp;Engine&nbsp;이 페달이고 작동 환경이 우주라면, 애초에 해당 객체를 생성할 수 없어야 하지만 이를 컴파일 타임에서 강제할 방법이 없고 런타임에서나 확인할 수 있게 됩니다. 뿐만 아니라, 우주에서 작동하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 있지만 (SpaceVehicle&nbsp;클래스), 작동 환경에 관계 없이 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 는 없습니다. 중첩된 일반화&nbsp;방식을 사용하게 된다면, 한 가지 계층을 먼저 골라서 파생 클래스들을 생성합니다. 예를 들어서&nbsp;Vehicle&nbsp;클래스의 파생 클래스들로&nbsp;LandVehicle,&nbsp;WaterVehicle, 등등이 있겠지요. 그 후에, 각각의 클래스들의 대해 다른 계층에 해당하는 파생 클래스들을 더 생성합니다. 예컨대&nbsp;LandVehicle&nbsp;의 경우 동력원으로 휘발유를 사용한다면&nbsp;GasPoweredLandVehicle, 원자력을 사용한다면&nbsp;NuclearPoweredLandVehicle&nbsp;클래스를 생성할 수 있겠지요.
따라서 최대&nbsp;𝑁×𝑀N×M&nbsp;가지의 파생 클래스들을 생성할 수 있게 됩니다. 따라서 브릿지 패턴에 비해서 좀 더 섬세한 제어를 할 수 있게 됩니다. 왜냐하면 오버라이딩 가지수가&nbsp;𝑁+𝑀N+M&nbsp;이 아닌&nbsp;𝑁×𝑀N×M&nbsp;이 되기 때문이지요. 하지만 동력원을 하나 더 추가하게 된다면 최대&nbsp;𝑁N&nbsp;개의 파생 클래스를 더 만들어야 합니다. 뿐만 아니라 앞서 브릿지 패턴에서 나왔던 문제 - 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 없다가 여전히 있습니다. 따라서 만약에 휘발유를 사용하는 차량들에서 공통적으로 사용되는 코드가 있다면 매 번 새로 작성해줘야만 합니다. 다중 상속을 이용하게 된다면, 브리지 패턴 처럼 각 카테고리에 해당하는 파생 클래스들을 만들게 되지만, 그 대신&nbsp;Engine*&nbsp;멤버 변수를 없애고 동력원과 환경에 해당하는 클래스를 상속받는 파생 클래스들을 최대&nbsp;𝑁×𝑀N×M&nbsp;개 만들게 됩니다. 예를 들어서 휘발유를 사용하며 지상에서 다니는 차량을 나타내는&nbsp;GasPoweredLandVehicle&nbsp;클래스의 경우&nbsp;GasPoweredEngine&nbsp;과&nbsp;LandVehicle&nbsp;두 개의 클래스를 상속받겠지요.
따라서 이 방식을 통해서 브리지 패턴에서 불가능 하였던 섬세한 제어를 수행할 수 있을 뿐더러, 말도 안되는 조합을 (예컨대&nbsp;PedalPoweredSpaceVehicle) 컴파일 타입에서 확인할 수 있습니다 (애초에 정의 자체를 안하면 되니까요!). 또한 이전에 두 방식에서 발생하였던&nbsp;휘발유를 사용하는 모든 차량을 가리킬 수 없다&nbsp;문제를 해결할 수 있습니다. 왜냐하면 이제&nbsp;GasPoweredEngine&nbsp;을 통해서 휘발유를 사용하는 모든 차량을 가리킬 수 있기 때문이지요. ]]></description><link>cpp/상속3-다중-상속.html</link><guid isPermaLink="false">CPP/상속3 - 다중 상속.md</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate></item><item><title><![CDATA[cpp_3]]></title><description><![CDATA[<img src="images/cpp_3.png" target="_self">]]></description><link>images/cpp_3.html</link><guid isPermaLink="false">images/cpp_3.png</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate><enclosure url="images/cpp_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Overloading]]></title><description><![CDATA[#include &lt;iostream&gt; class Complex { private: double real, img; double get_number(const char* str, int from, int to) const; public: Complex(double real, double** img) : real(real), img(img) { } Complex(const Complex&amp; c) { real = c.real; img = c.img ; } Complex(const char* str); Complex operator+(const Complex&amp; c) const; Complex operator-(const Complex&amp; c) const; Complex operator*(const Complex&amp; c) const; Complex operator/(const Complex&amp; c) const; Complex&amp; operator=(const Complex&amp; c); Complex&amp; operator+=(const Complex&amp; c); Complex&amp; operator-=(const Complex&amp; c); Complex&amp; operator=(const Complex&amp; c); Complex&amp; operator/=(const Complex&amp; c); void println() { std::cout &lt;&lt; "( " &lt;&lt; real &lt;&lt; " , " &lt;&lt; img &lt;&lt; " ) " &lt;&lt; std::endl; } }; Complex Complex::operator+(const Complex&amp; c) const { Complex temp(real + c.real, img + c.img); return temp;
} Complex Complex::operator-(const Complex&amp; c) const { Complex temp(real - c.real, img - c.img); return temp;
} Complex Complex::operator*(const Complex&amp; c) const { Complex temp(real * c.real - img * c.img, real * c.img + img * c.real); return temp;
} Complex Complex::operator/(const Complex&amp; c) const { Complex temp( (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img), (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img)); return temp;
} Complex&amp; Complex::operator=(const Complex&amp; c) { real = c.real; img = c.img; return *this; } Complex&amp; Complex::operator+=(const Complex&amp; c) { (*this) = (*this) + c; return *this; } Complex&amp; Complex::operator-=(const Complex&amp; c) { (*this) = (*this) - c; return *this; } Complex&amp; Complex::operator*=(const Complex&amp; c) { (*this) = (*this) * c; return *this; } Complex&amp; Complex::operator/=(const Complex&amp; c) { (*this) = (*this) / c; return *this; } Complex::Complex(const char* str) { int begin = 0, end = strlen(str); img = 0.0; real = 0.0; // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다. int pos_i = -1; for (int i = 0; i != end; i++) { if (str[i] == 'i') { pos_i = i; break; } } // 만일 'i' 가 없다면 이 수는 실수 뿐이다. if (pos_i == -1) { real = get_number(str, begin, end - 1); return; } // 만일 'i' 가 있다면, 실수부와 허수부를 나누어서 처리하면 된다. real = get_number(str, begin, pos_i - 1); img = get_number(str, pos_i + 1, end - 1); if (pos_i &gt;= 1 &amp;&amp; str[pos_i - 1] == '-') img *= -1.0;
} double Complex::get_number(const char *str, int from, int to) const { bool minus = false; if (from &gt; to) return 0; if (str[from] == '-') minus = true; if (str[from] == '-' || str[from] == '+') from++; double** num = 0.0; double** decimal = 1.0; bool integer_part = true; for (int i = from; i &lt;= to; i++) { if (isdigit(str[i]) &amp;&amp; integer_part) { num *= 10.0; num += (str[i] - '0'); } else if (str[i] == '.') integer_part = false; else if (isdigit(str[i]) &amp;&amp; !integer_part) { decimal /= 10.0; num += ((str[i] - '0') * decimal); } else // 그 이외의 이상한 문자들이 올 경우 break; } if (minus) num *= -1.0; return num;
}
int main() { Complex a(0, 0); a = a + "-1.1 + i3.923"; a.println(); a = a - "1.2 -i1.823"; a.println(); a = a * "2.3+i22"; a.println(); a = a / "-12+i55"; a.println(); } Complex a = b + c + b;를 고려 했을 때 (b.plus(c)).plus(b) 가 되므로 -&gt; (b + c) + (b + c)가 되어버림
그래서 사칙연산에는 주소값을 리턴하지 않는다.전자는 복사생성자, 후자는 생성 후 대입연산자 여기에서는 얕은 복사가 일어난다.Complex operator+(const char* str) const;
Complex operator-(const char* str) const;
Complex operator*(const char* str) const;
Complex operator/(const char* str) const; Complex Complex::operator+(const char* str) const { Complex temp(str); return (*this) + temp;
} Complex Complex::operator-(const char* str) const { Complex temp(str); return (*this) - temp;
} Complex Complex::operator*(const char* str) const { Complex temp(str); return (*this) * temp;
} Complex Complex::operator/(const char* str) const { Complex temp(str); return (*this) - temp;
}
컴파일러는 문자열 리터럴로부터&nbsp;const Complex&nbsp;타입의 객체를 새롭게 생성할 수 있다.a = a + "-1.1 + i3.923"; 를 a = a.operator+("-1.1 + i3.923")로
그리고 이것을 a = a.operator+(Complex("-1.1 + i3.923")); 변환할 수 있다.그러나 a = "-1.1 + i3.923" + a;는 컴파일 실패한다. 변환할 수 없는 형태이기 때문이다.]]></description><link>cpp/overloading.html</link><guid isPermaLink="false">CPP/Overloading.md</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate></item><item><title><![CDATA[생성자]]></title><description><![CDATA[class Employee { std::string name; int age; std::string position; // 직책 (이름) int rank; // 순위 (값이 클 수록 높은 순위) public: Employee(std::string name, int age, std::string position, int rank) : name(name), age(age), position(position), rank(rank) {} // 복사 생성자 Employee(const Employee&amp; employee) { name = employee.name; age = employee.age; position = employee.position; rank = employee.rank; } // 디폴트 생성자 Employee() {} void print_info() { std::cout &lt;&lt; name &lt;&lt; " (" &lt;&lt; position &lt;&lt; " , " &lt;&lt; age &lt;&lt; ") ==&gt; " &lt;&lt; calculate_pay() &lt;&lt; "만원" &lt;&lt; std::endl; } int calculate_pay() { return 200 + rank * 50; }
}; Q1. b와 c의 메모리주소는 a와 비교하면 어떻게 되어있는가?
Employee* a = new Employee(); // 객체 a 생성 (디폴트 생성자 호출) Employee* b = new Employee(*a); // 객체 b 생성 (복사 생성자 호출)
Employee* c = a; b는 복사생성자를 호출했기 때문에 a와 b의 메모리 주소는 다르다. 그러나 c는 a의 주소값을 대입했기 때문에 메모리 주소가 같다.Q2. 두 생성자의 차이점은 무엇인가?Employee(std::string name, int age, std::string position, int rank) : name(name), age(age), position(position), rank(rank) {} // 생성자 본문에서 초기화하는 생성자 Employee(std::string name, int age, std::string position, int rank) { this-&gt;name = name; this-&gt;age = age; this-&gt;position = position; this-&gt;rank = rank; }
첫번째 생성자는 멤버 변수가 생성될 때 해당하는 값으로 초기화 하고 두번째 생성자는 멤버 변수가 기본 생성자로 한 번 초기화된 후 다시 값이 대입된다. 그래서 비효율적이다.]]></description><link>cpp/생성자.html</link><guid isPermaLink="false">CPP/생성자.md</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate></item><item><title><![CDATA[Invalidation Box]]></title><description><![CDATA[Invalidation Box는 언리얼 엔진 4의 UMG(언리얼 모션 그래픽) UI 시스템에서 사용하는 위젯입니다. UI의 렌더링과 성능을 최적화하는 데 사용됩니다. Invalidation Box의 주요 기능은 자식 위젯의 렌더링을 캐시하는 것입니다. Invalidation Box 내부의 자식 위젯이 변경될 때, Invalidation Box는 전체 UI가 아닌 변경된 부분만 다시 렌더링하여 성능을 향상시킵니다.
성능 최적화: 자식 위젯의 렌더링을 캐시함으로써 드로우 콜 및 업데이트 수를 줄여 성능을 향상시킵니다. 특히 복잡한 UI에서 효과적입니다. 효율적인 리드로잉: 변경이 발생할 때 영향을 받은 부분만 다시 그리므로 불필요한 계산과 렌더링 과정을 최소화합니다. CPU 사용량 감소: 드로우 콜이 줄어들고 업데이트 빈도가 낮아져 CPU 사용량이 크게 감소하여 게임이나 애플리케이션이 더 부드럽게 실행됩니다. 복잡한 UI: 많은 요소가 자주 업데이트되는 UI의 경우, Invalidation Box로 감싸면 리렌더링 범위를 제한하여 성능 향상을 얻을 수 있습니다.
정적인 콘텐츠: 자주 변경되지 않는 UI 섹션에 Invalidation Box를 사용하면 초기 렌더링을 캐시하여 중복 렌더링 사이클을 방지할 수 있습니다.
동적인 요소: 동적인 요소에서도 콘텐츠의 작은 부분만 변경되는 경우, Invalidation Box가 필요한 부분만 업데이트하여 성능을 최적화할 수 있습니다. UI에 추가: UMG 위젯 팔레트에서 Invalidation Box를 드래그하여 UI 계층 구조에 추가합니다.
위젯 래핑: 최적화하려는 위젯을 Invalidation Box 내부에 배치합니다.
설정 조정: 필요에 따라 Invalidation Box 설정을 조정합니다. 기본적으로 자식 위젯을 올바르게 무효화하고 캐시하지만, 특정 성능 요구 사항에 따라 세부 조정이 가능합니다.
테스트 및 프로파일링: 언리얼 엔진의 프로파일링 도구를 사용하여 UI에서 성능 향상을 테스트하고 확인합니다. 필요에 따라 조정합니다.
]]></description><link>ue/invalidation-box.html</link><guid isPermaLink="false">UE/Invalidation Box.md</guid><pubDate>Wed, 12 Jun 2024 13:16:00 GMT</pubDate></item><item><title><![CDATA[cpp_2]]></title><description><![CDATA[<img src="images/cpp_2.png" target="_self">]]></description><link>images/cpp_2.html</link><guid isPermaLink="false">images/cpp_2.png</guid><pubDate>Sun, 09 Jun 2024 07:33:07 GMT</pubDate><enclosure url="images/cpp_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_1]]></title><description><![CDATA[<img src="images/cpp_1.png" target="_self">]]></description><link>images/cpp_1.html</link><guid isPermaLink="false">images/cpp_1.png</guid><pubDate>Sun, 09 Jun 2024 07:30:07 GMT</pubDate><enclosure url="images/cpp_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CMake 사용법]]></title><description><![CDATA[CMakeLists.txt를 만들자로그가 의미하는 것?Configuring done - Configure 단계
CMakeListss.txt 분석
CMakeCache.txt 생성
Generating done - Generate 단계
Native Build System 파일 생성
주의점: CMakeCache.txt에 정의된 변수를 사용하기 때문에 갱신되지 않으면 잘못된 Native Build Systme file이 생성될 수 있음.--fresh를 사용하면 CMakeCache.txt를 지우고 빌드함CMake 커맨드cmake_minimum_required(VERSION )project( VERSION LANGUAGES )message(""), message(STATUS "")set( )
message("${variable-name}")
unset()List( ...) 보통 APPEND와 FIND를 주로 사용
예시:
List(APPEND FILES foo.cpp bar.cpp haz.cpp)
List(FIND FILES bar.cpp bar_cpp_index)
List // 알파벳 순서도로 정렬if()
elseif()
else()
endif()foreach(&lt;loop_var&gt; IN [LISTS ] [ ITEMS ]
endforeach()
예시:
foreach(FILE IN LISTS FILES)
message("${FILE} " is in the list)
endforeach()add_subdirectory(&lt;source_directory&gt;)
폴더마다 CMakeLists.txt를 가질 수 있음
CMake 실행할 때 지정된 CMakeLists.txt가 실행됨 (하위폴더는 포함되지 않음)
add_subdirectory를 통해서 하위 폴더 추가 가능 (소스 디렉토리에 CMakeLists.txt 필수)add_compile_options()컴파일 옵션을 전역적으로 추가]]></description><link>cmake/cmake-사용법.html</link><guid isPermaLink="false">CMake/CMake 사용법.md</guid><pubDate>Sun, 05 May 2024 06:50:49 GMT</pubDate></item><item><title><![CDATA[bool vs uint8]]></title><description><![CDATA[Unreal Engine의 리플렉션 시스템에서 bool 대신 uint8을 사용하는 것은 주로 효율성과 일관성을 위한 선택입니다. 여기에는 몇 가지 상세한 이유가 있습니다:
메모리 효율성: C++에서 bool 타입은 일반적으로 1바이트를 차지합니다. 하지만, 이는 표준에 의해 보장되는 것은 아닙니다. 따라서, 다른 컴파일러나 플랫폼에서 bool의 크기가 달라질 수 있습니다. uint8은 명확하게 1바이트 크기를 갖기 때문에 플랫폼 간 일관성을 보장합니다. 이러한 일관성은 특히 크로스-플랫폼 게임 개발에 있어 중요합니다.
리플렉션과 직렬화: Unreal Engine의 리플렉션 시스템은 객체의 프로퍼티를 자동으로 식별하고 처리하는 데 사용됩니다. 이 시스템은 uint8과 같은 명확하게 정의된 크기를 가진 데이터 타입을 더 잘 처리할 수 있습니다. 이는 직렬화(데이터를 네트워크를 통해 전송하거나 디스크에 저장하는 과정)에서 중요합니다. bool이 다른 크기를 가질 수 있다면, 직렬화 과정에서 데이터의 정확한 해석이 어려울 수 있습니다.
비트 필드 사용: Unreal Engine은 종종 비트 필드를 사용하여 메모리 사용을 최적화합니다. uint8은 이러한 목적으로 사용하기에 적합한 타입입니다. 비트 필드에서 각 비트는 별도의 플래그나 설정을 나타낼 수 있으며, 이는 bool보다 메모리를 더 효율적으로 사용하는 방법입니다.
컴파일러 최적화: 일부 컴파일러는 bool 타입을 특별히 최적화하지 않을 수 있습니다. uint8은 보다 일반적인 데이터 타입이므로, 컴파일러에 따라 bool보다 더 효율적으로 처리될 수 있습니다.
확장성: bool은 단순히 참/거짓만을 나타내지만, uint8을 사용하면 추가적인 정보를 동일한 메모리 공간에 저장할 수 있습니다. 예를 들어, 여러 상태나 모드를 나타내는데 uint8이 더 유용할 수 있습니다.
네, C++ 표준에서 bool 타입의 정확한 크기는 명시하지 않고 있습니다. 표준은 단지 bool이 최소 1바이트를 차지해야 한다고 규정할 뿐입니다. 이는 bool이 다른 컴파일러나 아키텍처에서 다른 크기를 가질 수 있음을 의미합니다.예를 들어, 대부분의 현대 컴파일러와 플랫폼에서 bool은 1바이트를 차지합니다. 이는 bool을 효율적으로 처리하기 위한 최소 크기입니다. 그러나 특정 시스템이나 컴파일러 최적화 설정에 따라 bool이 더 큰 메모리 공간을 차지할 수도 있습니다. 예를 들면:
일부 오래된 또는 특수한 시스템: 이러한 시스템에서 bool은 1바이트보다 큰 크기를 가질 수 있습니다. 예를 들어, 일부 구형 컴퓨터 아키텍처에서는 1바이트보다 큰 단위로 메모리를 관리하는 경우가 있었습니다.
최적화 목적: 컴파일러는 때때로 메모리 접근 속도를 개선하기 위해 bool의 크기를 늘릴 수 있습니다. 예를 들어, 특정 프로세서 아키텍처에서는 더 큰 단위의 메모리 접근이 더 효율적일 수 있어, bool을 그 크기에 맞춰 조정할 수 있습니다.
특정 컴파일러 설정: 개발자가 특정 컴파일러 옵션을 사용해 bool의 크기를 조절할 수도 있습니다. 이런 경우는 드물지만, 성능 최적화나 특정 하드웨어 요구 사항에 의해 발생할 수 있습니다.
이러한 상황에서 bool의 크기가 1바이트가 아닐 수 있으므로, 크로스-플랫폼 애플리케이션 개발 시 bool의 크기에 대해 가정하지 않는 것이 중요합니다. 대신, 명시적인 크기를 갖는 타입(예: uint8_t)을 사용하는 것이 더 안전합니다.]]></description><link>ue/bool-vs-uint8.html</link><guid isPermaLink="false">UE/bool vs uint8.md</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate></item><item><title><![CDATA[enum vs enum class]]></title><description><![CDATA[C++에서 enum class와 enum은 둘 다 열거형 타입을 정의하는데 사용되지만, 몇 가지 중요한 차이점이 있습니다. 스코프(Scope) 및 이름 충돌: enum: 전통적인 enum은 스코프가 제한되지 않습니다. 이는 enum의 각 값이 열거형 이름 없이 직접 접근될 수 있다는 것을 의미합니다. 이것은 다른 enum과의 이름 충돌을 야기할 수 있습니다.
enum class: C++11에서 도입된 enum class는 강화된 스코프 규칙을 가집니다. 여기서 각 값은 열거형의 이름을 통해서만 접근할 수 있습니다. 이는 이름 충돌을 방지하고 코드의 명확성을 높입니다. 타입 안정성(Type Safety): enum: 기본적인 enum은 기본 정수 타입으로 암시적으로 변환될 수 있으며, 이는 타입 안전성 문제를 일으킬 수 있습니다.
enum class: enum class는 더 엄격한 타입 안전성을 제공합니다. 이는 enum class 값을 그들의 열거형 타입이 아닌 다른 타입으로 암시적으로 변환하는 것을 방지합니다. 기본 타입 지정: enum: 전통적인 enum은 컴파일러에 의해 결정되는 정수 타입을 사용합니다.
enum class: enum class에서는 개발자가 기본 타입을 명시적으로 지정할 수 있습니다 (예: enum class MyEnum : uint8_t { ... }). 포워딩(Forward Declaration): enum: 전통적인 enum은 크기가 고정되어 있지 않기 때문에, 포워드 선언이 제한적입니다.
enum class: enum class는 포워드 선언이 가능하며, 이는 열거형의 크기가 명시적으로 정의될 때 유용합니다. 결론적으로, enum class는 더 나은 스코프 관리, 타입 안전성 및 명확성을 제공하는 반면, 전통적인 enum은 구버전의 코드와의 호환성과 간결한 문법을 제공합니다.]]></description><link>ue/enum-vs-enum-class.html</link><guid isPermaLink="false">UE/enum vs enum class.md</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate></item><item><title><![CDATA[ble_configuration]]></title><description><![CDATA[<img src="images/ble_configuration.png" target="_self">]]></description><link>images/ble_configuration.html</link><guid isPermaLink="false">images/ble_configuration.png</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate><enclosure url="images/ble_configuration.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_configuration.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Mac에서 UE4 엔진 소스 빌드 시 유의사항]]></title><description><![CDATA[TL ;DR
언리얼 깃헙에서 브랜치 4.27plus를 받아서 빌드하기. 그리고 윈도우에서 remote 빌드 거는 게 더 합리적인 것 같음. 어차피 Objc 자동완성 사용 불가능UE4 4.27.2 버전을 사용해서 tag가 4.27.2 버전을 다운로드 받음<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release" target="_self">https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release</a>
<br>
Install&nbsp;<a data-tooltip-position="top" aria-label="https://mac.github.com/" rel="noopener nofollow" class="external-link is-unresolved" href="https://mac.github.com/" target="_self">GitHub for Mac</a>&nbsp;then&nbsp;<a data-tooltip-position="top" aria-label="https://guides.github.com/activities/forking/" rel="noopener nofollow" class="external-link is-unresolved" href="https://guides.github.com/activities/forking/" target="_self">fork and clone our repository</a>. To use Git from the Terminal, see the&nbsp;<a data-tooltip-position="top" aria-label="https://help.github.com/articles/set-up-git/" rel="noopener nofollow" class="external-link is-unresolved" href="https://help.github.com/articles/set-up-git/" target="_self">Setting up Git</a>&nbsp;and&nbsp;<a data-tooltip-position="top" aria-label="https://help.github.com/articles/fork-a-repo/" rel="noopener nofollow" class="external-link is-unresolved" href="https://help.github.com/articles/fork-a-repo/" target="_self">Fork a Repo</a>&nbsp;articles. If you'd rather not use Git, use the 'Download ZIP' button on the right to get the source directly. <br>
Install the latest version of&nbsp;<a data-tooltip-position="top" aria-label="https://itunes.apple.com/us/app/xcode/id497799835" rel="noopener nofollow" class="external-link is-unresolved" href="https://itunes.apple.com/us/app/xcode/id497799835" target="_self">Xcode</a>. Open your source folder in Finder and double-click on&nbsp;Setup.command&nbsp;to download binary content for the engine. You can close the Terminal window afterwards.
If you downloaded the source as a .zip file, you may see a warning about it being from an unidentified developer (because .zip files on GitHub aren't digitally signed). To work around it, right-click on Setup.command, select Open, then click the Open button. In the same folder, double-click&nbsp;GenerateProjectFiles.command. It should take less than a minute to complete. Load the project into Xcode by double-clicking on the&nbsp;UE4.xcworkspace&nbsp;file. Select the&nbsp;ShaderCompileWorker&nbsp;for&nbsp;My Mac&nbsp;target in the title bar, then select the 'Product &gt; Build' menu item. When Xcode finishes building, do the same for the&nbsp;UE4&nbsp;for&nbsp;My Mac&nbsp;target. Compiling may take anywhere between 15 and 40 minutes, depending on your system specs. After compiling finishes, select the 'Product &gt; Run' menu item to load the editor. MacOS에서 언리얼 엔진 소스 설치시 (4.27.2) 버그Setup.command를 클릭하면 디펜던시 설정을 함 근데remote server error가 발생함.(403)Checking dependencies...
Updating dependencies: 0% (0/63485)...<br>
Failed to download '<a rel="noopener nofollow" class="external-link is-unresolved" href="http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94" target="_self">http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94</a>': The remote server returned an error: (403) Forbidden. (WebException)<br>이 경우에 Engine/Build/Commit.gitdeps.xml을&nbsp;&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/EpicGames/UnrealEngine/tree/4.26/Engine/Build" target="_self">https://github.com/EpicGames/UnrealEngine/tree/4.26/Engine/Build</a>&nbsp;버전의 Engine/Build/Commit.gitdeps.xml으로 교체해주면 Setup.command를 해결할 수 있음.<br>참고:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/carla-simulator/carla/issues/6486" target="_self">https://github.com/carla-simulator/carla/issues/6486</a><br><img alt="GitHub" src="https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">GitHub<br><a data-tooltip-position="top" aria-label="https://github.com/carla-simulator/carla/issues/6486" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/carla-simulator/carla/issues/6486" target="_self">Unreal Setup.bat (failed to download error) · Issue #6486 · carla-simulator/carla</a>&nbsp;(51kB)ShaderCompileWorker 빌드 시에 아래와 같은 버그가 발생<br><img alt="var_error.jpg" src="images/var_error.jpg" target="_self">Xcode가 빌드할 때 컴파일 옵션을 좀 더 타이트하게 잡아서 발생 하는 이슈
컴파일러에게 -Wno-unused-but-set-variable 설정을 하면 해결할 수 있음. UE4는 씨샾 코드를 빌드하기 때문에 { 언리얼 엔진 경로 }/Source/Programs/UnrealBuildTool/Platform/Mac/MacToolChain.cs에서GetCompileArguments_Global 함수를 찾아서 Result가 선언된 다음 라인에 코드를 작성하면 됨	Result += " -Wno-unused-but-set-variable";
여기까지 하면 ShaderCompileWorker 빌드 성공할 수 있음이제 UE4 빌드를 해야 하는데 info.plist가 없어서 빌드 실패하는 이슈가 발생이것은 UE4 Project - Build Setting에서 UE4GENERATE_INFOPLIST_FILE 옵션을 YES로 설정하기Engine/Plugins/Media/BinkMedia/Source/SDK/lib/BinkUnrealMac.a가 없다는 이슈가 발생/Users/choeseung-in/Downloads/UnrealEngine-4.27.2-release/clang:1:1: no such file or directory: '/Users/choeseung-in/Downloads/UnrealEngine-4.27.2-release/Engine/Plugins/Media/BinkMedia/Source/SDK/lib/BinkUnrealMac.a'이건 해당 경로에 static library가 없다는 이슈다.
Setup.command와 GenerateProjectFiles.command 과정은 디펜던시를 설정하고 다운로드 해와서 필요한 경로에 넣는 역할인데 이 부분이 잘못 되어서 그런 것으로 추정된다.
그래서 Issue를 찾아보던 중에 branch에 4.27 plus가 있는 것을 발견하였고 계속 유지보수가 이뤄지고 있어서 다시 엔진 소스를 받아서 실행하니 빌드를 할 수 있었다.]]></description><link>ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html</link><guid isPermaLink="false">UE/Mac에서 UE4 엔진 소스 빌드 시 유의사항.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glew32_install_error]]></title><description><![CDATA[<img src="images/glew32_install_error.png" target="_self">]]></description><link>images/glew32_install_error.html</link><guid isPermaLink="false">images/glew32_install_error.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/glew32_install_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glew32_install_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[serial]]></title><description><![CDATA[<img src="images/serial.png" target="_self">]]></description><link>images/serial.html</link><guid isPermaLink="false">images/serial.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/serial.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/serial.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동기, 비동기]]></title><description><![CDATA[Concurrency allows us to execute different tasks at the same time, or it appears to us at the same time.
CPU는 Time Slicing과 Context Switching으로 Concurrency를 달성
CPU는 각 task가 처리되는 시간을 정확히 예상할 수 없음 그러므로, 하나씩 TimeSlicing과 Context Switching을 통해서 task를 처리함
즉 작업을 분산하자가 목표임iOS에서 Concurrency를 달성하는 법
Manual Thread Creation (직접 쓰레드 생성)
class Thread: NSObject { } // https://developer.apple.com/documentation/foundation/thread GCD ( Grand Central Dispatch) <a data-tooltip-position="top" aria-label="https://developer.apple.com/documentation/DISPATCH" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.apple.com/documentation/DISPATCH" target="_self">GCD</a>&nbsp;is a queue-based API that allows executing closures on worker's pools in the FIFO (First in first out) order.
FIFO Order로 Task를 수행함
추상화 → 쓰레드를 얼마나 사용하고 있는 지 같은 것들을 신경쓰지 않아도 됨 (세부구현요소 배제)
order와 manner로 Data Consistent를 달성할 수 있음. → Data Consistency를 저해하는 요소 - Deadlock, Race Conditon.
그러니까 iOS에서는 Queue에 잘 넣으면 쓰레드에 알아서 넣어줌. 언리얼에도 있을까? TGraph 같은 거 있던데
우리가 해야할 것은 Queue 잘 보내는 것(직접적으로 쓰레드를 관리하지 않음)
Serial Queue - one task at a time
<br><img alt="serial.png" src="images/serial.png" target="_self">
Concurrent Queue - multiple tasks at a time<br>
<img alt="concurrent.png" src="images/concurrent.png" target="_self"> Synchronous 다른 execution이 완료 되기전까지 현재 쓰레드를 Block 함. Asynchronous 현재 스레드를 Block 하지 않고, 다른 some task later, simultaneously하게 execution 함.
asynchronous를 사용하면 program이 즉시 block에서 빠져나감 Main Queue
따로 큐를 지정하지 않으면 Main Queue에서 돌아감
시리얼 큐임
task가 synchronous 하게 실행됨
UI를 update 하는 큐임 Single Serial Queue with Multiple Asynchronous Dispatch. 시리얼 큐안에서 async execution만 존재하면 serial Order를 따른다. Single Serial Queue with Multiple Asynchronous Dispatch &amp; Synchronous codes. 시리얼 큐이기 때문에 line by line으로 코드를 읽음
sync는 block 하고 async는 제어권을 넘겨줌 Single Concurrent Queue with Multiple Asynchronous Dispatch. 런할 때마다 바뀜. Single Concurrent Queue with Multiple Asynchronous and Synchronous Dispatch. 가장 헷갈리는 예임
모두 다 4개의 task를 concurrent 큐에다가 넣고, 두번째는 sync 나머지를 async일 때 3번째랑, 4번째는 무조건 두번째 코드가 다 끝난 이후에 나옴. 왜냐하면 첫번째 큐가 들어가고 탈출하고, 두번째 큐가 들어가는데 여기에서 블락됨 다만, concurrent 큐라서 두번째 task와 첫번째 task가 실행될 수 있음. 두번째 task가 끝나면 세,네번째 task 가능. a Serial Queue alongside a Concurrent Queue with Multiple Asynchronous Dispatch. 랜덤하게 나올 수 있으나 Serial 1, 2, 3의 순서는 지켜져야 한다.(연속은 안해도 됨) SerialQueue에서 sync와 async의 차이점 let queue = DispatchQueue(label: "com.example.serialQueue")
queue.async { print("Async task 1")
}
queue.async { print("Async task 2")
}
print("Outside of queue")
결과Async task 1
Outside of queue
Async task 2
let queue = DispatchQueue(label: "com.example.serialQueue")
queue.sync { print("Async task 1")
}
queue.sync { print("Async task 2")
}
print("Outside of queue")
Async task 1
Async task 2
Outside of queue
동기는 일의 제어권을 꽉 잡고 있음. (흔히 Block 한다고 함)
비동기는 일의 제어권을 넘겨줌동기와 비동기는 제어권을 넘겨주냐, 넘겨주지 않느냐로 판단하는 것
MainQueue에서 sync 사용금지
현재 큐에서 sync로 작업을 보내지 말자 DispatchQueue.global().async { DispatchQueue.global().sync { }
} // 오래 걸리는 함수
public func tiltShift(image: UIImage?) -&gt; UIImage? { guard let image = image else { return nil } sleep(1) let mask = topAndBottomGradient(size: image.size) return image.applyBlur(radius: 6, maskImage: mask) } func asyncTiltShift(_ inputImage: UIImage?, runQueue: DispatchQueue, completionQueue: DispatchQueue, completion: @escaping (UIImage?, Error?) -&gt; ()) { runQueue.async { var error: Error? error = .none let outputImage = tiltShift(image: inputImage) completionQueue.async { completion(outputImage, error) } }
} // 사용 예시 let imageNames = ["dark_road_small", "train_day", "train_dusk", "train_night"]
let images = imageNames.compactMap { UIImage(named: "\($0).jpg") } // 변형한 이미지 저장하기 위한 배열 생성 var tiltShiftedImages = [UIImage]() // 동시큐 만들기 let workerQueue = DispatchQueue(label: "com.inflearn.concurrent", attributes: .concurrent) let appendQueue = DispatchQueue(label: "com.inflearn.append.serial") for image in images { asyncTiltShift(image, runQueue: workerQueue, completionQueue: appendQueue) { image, error in guard let image = image else { return } tiltShiftedImages.append(image) } }
]]></description><link>ios/동기,-비동기.html</link><guid isPermaLink="false">iOS/동기, 비동기.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/serial.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/serial.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[concurrent]]></title><description><![CDATA[<img src="images/concurrent.png" target="_self">]]></description><link>images/concurrent.html</link><guid isPermaLink="false">images/concurrent.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/concurrent.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/concurrent.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Orientation]]></title><description><![CDATA[Project - Target - General - Deployment Info에서 iPhone Orientation을 체크 / 체크해제를 할 수 있다.이것을 체크 하게 되면 동일한 효과를 얻는다.
// AppDelegate.swift func application( _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow? ) -&gt; UIInterfaceOrientationMask { return // 체크한 항목들 } supportedInterfaceOrientations를 지정하면 아이폰에서 '자동 화면 회전'을 설정한 경우 아이폰을 어떻게 잡고 있느냐에 따라서 해당하는 InterfaceOrientation으로 화면이 회전 된다. LandscapeRight로 고정을 했는데 SFSafariViewController에서 애플로그인을 하고 돌아온 다음에 화면이 Portrait이 되는 경우가 있다고 함. AppDelegate에 접근해서 InterfaceOrientation을 LandscapeRight로 다시 변경하면 된다. // AppDelegate.swift
import UIKit
@main class AppDelegate: UIResponder, UIApplicationDelegate { @objc var allList: UIInterfaceOrientationMask = .portrait func application( _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow? ) -&gt; UIInterfaceOrientationMask { return allList } } Swift private func rotate() { let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene (UIApplication.shared.delegate as! AppDelegate).allList = .landscapeRight if #available(iOS 16.0, *) { debugPrint("above 16.0") windowScene?.requestGeometryUpdate(.iOS(interfaceOrientations: .landscapeRight)) self.setNeedsUpdateOfSupportedInterfaceOrientations() } else { debugPrint("below 16.0") let value = UIDeviceOrientation.landscapeRight.rawValue UIDevice.current.setValue(value, forKey: "orientation") } }
Objective-C- (void)rotate:(UIButton *)button { AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate]; UIInterfaceOrientationMask e = UIInterfaceOrientationMaskLandscapeRight; appDelegate.allList = e; NSNumber *value = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeRight]; [[UIDevice currentDevice] setValue:value forKey:@"orientation"]; }
샘플 프로젝트에서 SFSafariViewController에서 돌아올 때 화면 전환이 되는 버그를 재현할 순 없었지만 화면 전환은 위의 코드를 사용 했을 때 쉽게 바꿀 수 있었다. 주의해야할 점은 AppDelegate에 있는 supportedInterfaceOrientationsFor를 먼저 바꿔주고 setValue를 하거나 화면 업데이트를 해줘야 한다는 점이다.그리고 추가적으로 UIInterfaceOrientation과 UIInterfaceOrientationMask 차이점이다.
UIInterfaceOrientation is Constants that specify the orientation of the app's user interface.
UIInterfaceOrientation는 enum value이고 App의 user interface라고 한다.
UIInterfaceOrientationMask is Constants that specify a view controller’s supported interface orientations.
UIInterfaceOrientationMask ViewController의 interface orientation이라고 한다.UIInterfaceOrientation은 처음 앱의 interface orientation이고 최상위 뷰컨트롤러인 UIWindowScene의 interface orientation이다. UIViewController에서 UIInterfaceOrientation인 interfaceOrientation은 deprecated여서 사용할 수 없고 아래처럼 windowScene에서 접근할 수 있다. read-only value라 바꿀 순 없다.let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene windowScene.interfaceOrientation 이러한 interfaceOrientation을 바꾸기 위해서 사용하는게 바로 UIInterfaceOrientationMask다.
UIInterfaceOrientationMask는 바꿀 방향을 표시하는 bitmask다. SDK에게 어떤 방향으로 바꿀거에요. 라고 알려줄 때 사용하는 프로퍼티다. 그리고 화면 전환을 하면 된다.여담으로 이건 버그인 것 같은데, AppDelegate에서 supportedInterfaceOrientationsFor에서 portrait를 제외하면 추후 화면전환을 사용할 수 없다. ]]></description><link>ios/orientation.html</link><guid isPermaLink="false">iOS/Orientation.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[allpublic]]></title><description><![CDATA[<img src="images/allpublic.png" target="_self">]]></description><link>images/allpublic.html</link><guid isPermaLink="false">images/allpublic.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/allpublic.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/allpublic.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[immutable_mutable]]></title><description><![CDATA[<img src="images/immutable_mutable.png" target="_self">]]></description><link>images/immutable_mutable.html</link><guid isPermaLink="false">images/immutable_mutable.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/immutable_mutable.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/immutable_mutable.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[removedinternal]]></title><description><![CDATA[<img src="images/removedinternal.png" target="_self">]]></description><link>images/removedinternal.html</link><guid isPermaLink="false">images/removedinternal.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/removedinternal.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/removedinternal.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Network Timeout UnitTest]]></title><description><![CDATA[서버 통신을 담당하는 NetworkManager에서 Timeout Error를 시뮬레이팅 하는 법은URLProtocol을 Confirm하고, Error를 Response로 넘겨주는 방식으로 처리하는 것이 간편
class TimeoutURLProtocol: URLProtocol { override class func canInit(with request: URLRequest) -&gt; Bool { return true } override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest { return request } override func startLoading() { // Introduce a delay (simulating a timeout) DispatchQueue.global().asyncAfter(deadline: .now() + 3.0) { // Respond with an error self.client?.urlProtocol(self, didFailWithError: NSError(domain: NSURLErrorDomain, code: NSURLErrorTimedOut, userInfo: nil)) self.client?.urlProtocolDidFinishLoading(self) } } override func stopLoading() { // Clean up or additional actions, if needed }
}
그런 다음에 test code 안에서, URLSessionConfiguration이 protocol을 컨펌함func testURLSessionTimeout() { let expectation = XCTestExpectation(description: "Time out expectation") let config = URLSessionConfiguration.ephemeral config.protocolClasses = [TimeoutURLProtocol.self] // Timeout Interval, 단위는 seconds config.timeoutIntervalForRequest = 3 let session = URLSession(configuration: config, delegate: nil, delegateQueue: nil) let task = session.dataTask(with: url) { data, response, error in if let error = error { // Time out error print("Error: \(error)") // Error 발생 기대 충족 expectation.fulfill() return } guard let data = data else { let noDataError = NSError() // No Data Error return } // Success, There is Data. print(data) } task.resume() wait(for: [expectation], timeout: 4) } 그러면 TimeoutURLProtocol, config.timeoutIntervalForRequest과 wait()을 통해서 타임아웃 에러를 시뮬레이팅할 수 있음.]]></description><link>ios/network-timeout-unittest.html</link><guid isPermaLink="false">iOS/Network Timeout UnitTest.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[Objective - C]]></title><description><![CDATA[#import &lt;Foundation/Foundation.h&gt; @interface Vehicle : NSObject { // Declare Member variable int wheels; int seats;
} - (int) wheels;
- (int) seats;
- (void) setWheels:(int) w; - (void) setSeats:(int) s; - (void) print; @end @implementation Vehicle - (int)wheels { return wheels
} - (int)seats { return seats
} - (void)setWheels:(int)w { wheels = w;
} - (void)setSeats:(int)s { seats = s;
} - (void)print { NSLog(@"Vehicle have %i wheels and %i seats.", wheels, seats);
} @end // 대괄호는 메세지를 구분해주는 기호
// [Receiver message] 형식 int main(int argc, const char * argv[]) { @autoreleasepool { // vehicle을 alloc 하고 init 하라 Vehicle* vehicle = [[Vehicle alloc] init]; [vehicle setWheels: 4]; [vehicle setSeats: 2]; [vehicle print]; NSLog(@"wheels: %i, seats: %i", [vehicle wheels], [vehicle seats]); } return 0; }
Objective-C 는 선언과 구현이 분리되어 있음@interface ~ @end는 선언부임
@implementation ~@end는 구현부임[ ] 대괄호는 message를 구분하는 기호로 주로 사용됨. [Receiver Message] 형식임. 그리고 멤버 메서드는 message의 일종임. getter setter를 이용할 때도 초기 버전에는 리시버 메세지 형식을 그대로 따라야 했으나, 지금은 Dot 접근도 가능함 getter 구현시에 관행적으로 get을 붙이지 않는다. getWheels(X) -&gt; wheels(O)
getter, setter를 매번 구현하는 것은 귀찮음. getter setter를 지우고 선언부 member method 영역에 @property로 선언하는 것으로 대체할 수 있음. 그리고 @property로 사용하면 멤버 변수 선언을 생략해도 됨만약, @property 선언만 하고 멤버변수를 선언하지 않았을 때 객체 내부에서 해당 변수를 사용하기 위해서는 _ 을 붙여줘야함. @property를 선언한 변수는 내부적으로 _\name 으로 선언되기 때문내부에서도 같은 이름을 사용하고 싶으면 @synthesize를 사용해야함.
@interface Vehicle : NSObject { // 생략 가능! // int wheels; // int seats; } @property int wheels;
@property int seats; @end @implementation Vehicle
@synthesize seats; - (void)print { NSLog(@"Vehicle have %i wheels and %i seats.", _wheels, seats);
} @end int main(int argc, const char * argv[]) { @autoreleasepool { // vehicle을 alloc 하고 init 하라 Vehicle* vehicle = [[Vehicle alloc] init]; [vehicle setWheels: 4]; [vehicle setSeats: 2]; vehicle.wheels = 4; vehicle.seats = 2; [vehicle print]; NSLog(@"wheels: %i, seats: %i", [vehicle wheels], [vehicle seats]); NSLog(@"wheels: %i, seats: %i", vehicle.wheels, vehicle.seats); } return 0; } 다른 언어와 다르게 함수를 선언할 때 Arguement를 나누는 기준이 콜론(:)이다.// 2개의 인자를 가진 함수
- (void) setWheels:(int)w Seats:(int)s; // 호출할 때 [vehicle setWheels:4 Seats:2]; if, else if, else, switch문 대부분의 언어와 똑같음.
for, while문도 마찬가지NSString과 NSMutableString이 있음. 둘 다 객체 타입NSString과 NSMutableString의 차이점은 자기 자신을 바꿀 수 있냐임.
NSString은 append, insert 같은 함수가 없음. 자신은 변화 불가능이니까String 초기화시 alloc과 init을 이용하고 @""를 이용해 값을 넣을 수 있음
보통 바로 NSString* varname = @""; 로 바로 초기화함.
int main(int argc, const char * argv[]) { @autoreleasepool { NSString* str = [[NSString alloc]init]; str = @"This is NSString"; NSString* str2 = [[NSString alloc]initWithString:@"This is NSString"]; NSLog(@"str: %@", str); NSLog(@"str: %@", str2); // immutable class - 자기 자신은 변화를 못하기 때문에 새로 할당해야함. NSString* result; // substringFromIndex result = [str substringFromIndex:6]; NSLog(@"result: %@", result); // substringToIndex result = [str substringToIndex:6]; NSLog(@"result: %@", result); // method chaining result = [[str substringToIndex:11 ] substringFromIndex:8]; NSLog(@"result: %@", result); //substringWithRange result = [[str substringWithRange:NSMakeRange(8, 3)] lowercaseString]; NSLog(@"result: %@", result); result = [[str substringWithRange:NSMakeRange(8, 3)] uppercaseString]; NSLog(@"result: %@", result); // NSMutableString - 자기 자신 수정 가능, 할당해서 사용해야함 string처럼 =@""로 불가 NSMutableString* mstr = [NSMutableString stringWithString:str]; NSLog(@"mstr: %@", mstr); [mstr appendString:@ " and NSMutableString"]; NSLog(@"mstr: %@", mstr); [mstr insertString:@"Mutable" atIndex:8]; NSLog(@"mstr: %@", mstr); } return 0; }
NSMutableString은 무조건 할당해서 사용해야한다. NSString처럼 =@""로 사용하면 아래처럼 경고를 주고 NSMutableString 메서드를 사용하게 되면 런타임에서 에러가 발생한다.
<img alt="immutable_mutable.png" src="images/immutable_mutable.png" target="_self">]]></description><link>ios/objective-c.html</link><guid isPermaLink="false">iOS/Objective - C.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/immutable_mutable.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/immutable_mutable.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Swift, Objective - C interoperability]]></title><description><![CDATA[Objective - C는 아직도 시장에서 꽤 큰 점유율을 가지고 있음
Swift와 C++의 interoperability 가능 (WWDC23 - Mix Swift and C++) 신기능이라 아직 레퍼가 부족?Swift 코드베이스에 Objc 쓰기 -&gt; Objective-C Bridging Header
Objc 코드베이스에 Swift 쓰기 -&gt; public과 open 키워드가 있는 객체들 자동으로 헤더로 생성framework를 개발할 때 공개해야할 API를 잘 설정해야함.Swift 코드 베이스에서 Objc를 사용할 것. 프레임워크 내부에서 ObjC API를 보고 사용할 수 있지만 이 프레임워크를 사용하는 외부는 Objc 코드를 볼 수 있음엄브렐라 헤더에 Objc 해더를 임포트하고 Build phrase에서 public으로 바꾸기그런 다음에 xcframework로 뽑기
## Framework 아카이브 - iphoneOS
xcodebuild archive -project ObjcIntoSwiftFramework.xcodeproj \
-scheme ObjcIntoSwiftFramework \
-sdk iphoneos \
-destination "generic/platform=iOS" \
-archivePath archives/ObjcIntoSwiftFramework-iOS.xcarchive ## Framework 아카이브 - iphone simulator
xcodebuild archive -project ObjcIntoSwiftFramework.xcodeproj \
-scheme ObjcIntoSwiftFramework \
-sdk iphonesimulator \
-destination "generic/platform=iOS Simulator" \
-archivePath archives/ObjcIntoSwiftFramework-iOS_Simulator.xcarchive ## xcframework 추출
xcodebuild -create-xcframework \
-archive archives/ObjcIntoSwiftFramework-iOS.xcarchive -framework ObjcIntoSwiftFramework.framework \
-archive archives/ObjcIntoSwiftFramework-iOS_Simulator.xcarchive -framework ObjcIntoSwiftFramework.framework \
-output xcframeworks/ObjcIntoSwiftFramework.xcframework
xcframework을 확인 해보면 헤더에 모든 헤더가 노출되어 있음<img alt="allpublic.png" src="images/allpublic.png" target="_self">이제 해야할 것은 xcframework에서 internal objective - c 헤더를 제거하는 것 이를 위해서엄블레라 헤더에서 Internal 주석 이하 모두 삭제xcframework 경로를 파라미터로 받는 스크립트를 실행해서 처리함#! /bin/sh -e # # removeInternalHeaders.sh # ## 1 XCFRAMEWORK_DIR=$1 INTERNAL_MARK="__INTERNAL__" ## 2 function removeInternalHeadersInUmbrellaHeader { local framework_name="$(basename $1 .framework)" local headers_dir="$1/Headers" local umbrella_header_file="$headers_dir/$framework_name.h" local internal_mark_found=false local internal_headers=() ## 2.1 while read -r line; do if $internal_mark_found; then if [[ $line == "#import"* ]]; then local filename=$(sed 's/.*\"\(.*\)\".*/\1/' &lt;&lt;&lt; $line) internal_headers[${#internal_headers[@]}]=$filename fi elif [[ $line == *$INTERNAL_MARK* ]]; then internal_mark_found=true fi done &lt; $umbrella_header_file ## 2.2 echo "${#internal_headers[@]} files will be removed" for filename in ${internal_headers[@]}; do local file="$headers_dir/$filename" if [ -f "$file" ]; then rm $file echo "Removed file: $file" else echo "Tried to remove file but it does not exist: $file" fi done ## 2.3 sed -i "" '/'$INTERNAL_MARK'/,$d' $umbrella_header_file } ## 3 for directory in ${XCFRAMEWORK_DIR}/**/*.framework; do [ -d "$directory" ] || continue removeInternalHeadersInUmbrellaHeader $directory done # $HOME = 내 Users Path
$ ./removeInternalHeaders.sh $HOME/Labs/ObjcIntoSwiftFramework/xcframeworks/ObjcIntoSwiftFramework.xcframework
결과<br><img alt="removedinternal.png" src="images/removedinternal.png" target="_self"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.fleksy.com/blog/developing-an-ios-framework-in-unison-with-swift-objective-c/" target="_self">https://www.fleksy.com/blog/developing-an-ios-framework-in-unison-with-swift-objective-c/</a>]]></description><link>ios/swift,-objective-c-interoperability.html</link><guid isPermaLink="false">iOS/Swift, Objective - C interoperability.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/allpublic.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/allpublic.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[framework_path]]></title><description><![CDATA[<img src="images/framework_path.png" target="_self">]]></description><link>images/framework_path.html</link><guid isPermaLink="false">images/framework_path.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/framework_path.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/framework_path.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hostapp_file]]></title><description><![CDATA[<img src="images/hostapp_file.png" target="_self">]]></description><link>images/hostapp_file.html</link><guid isPermaLink="false">images/hostapp_file.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/hostapp_file.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/hostapp_file.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[sandbox_error]]></title><description><![CDATA[<img src="images/sandbox_error.png" target="_self">]]></description><link>images/sandbox_error.html</link><guid isPermaLink="false">images/sandbox_error.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/sandbox_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/sandbox_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[simulator_device_error]]></title><description><![CDATA[<img src="images/simulator_device_error.png" target="_self">]]></description><link>images/simulator_device_error.html</link><guid isPermaLink="false">images/simulator_device_error.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/simulator_device_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/simulator_device_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fatframework_path]]></title><description><![CDATA[<img src="images/fatframework_path.png" target="_self">]]></description><link>images/fatframework_path.html</link><guid isPermaLink="false">images/fatframework_path.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/fatframework_path.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/fatframework_path.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[aggregate]]></title><description><![CDATA[<img src="images/aggregate.png" target="_self">]]></description><link>images/aggregate.html</link><guid isPermaLink="false">images/aggregate.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/aggregate.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/aggregate.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_4]]></title><description><![CDATA[<img src="images/slate_arcitecture_4.png" target="_self">]]></description><link>images/slate_arcitecture_4.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_4.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_OVERVIEW_1]]></title><description><![CDATA[<img src="images/slate_overview_1.png" target="_self">]]></description><link>images/slate_overview_1.html</link><guid isPermaLink="false">images/SLATE_OVERVIEW_1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_overview_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_overview_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_OVERVIEW_2]]></title><description><![CDATA[<img src="images/slate_overview_2.png" target="_self">]]></description><link>images/slate_overview_2.html</link><guid isPermaLink="false">images/SLATE_OVERVIEW_2.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_overview_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_overview_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_3]]></title><description><![CDATA[<img src="images/slate_arcitecture_3.png" target="_self">]]></description><link>images/slate_arcitecture_3.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_3.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_1]]></title><description><![CDATA[<img src="images/slate_arcitecture_1.png" target="_self">]]></description><link>images/slate_arcitecture_1.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_2]]></title><description><![CDATA[<img src="images/slate_arcitecture_2.png" target="_self">]]></description><link>images/slate_arcitecture_2.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_2.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slate Architecture]]></title><description><![CDATA[ Pros: Programmers like that UI description is "close" to the code; easy to get at the data.
Invalidation is usually a non-issue; just poll data directly.
Easy to procedurally build interfaces. Cons: Adding animation and styling is harder.
UI description is imperative code, so no chance to make it data-driven. Desired Slate Characteristics: Easy access to model's code and data 모델의 코드와 데이터에 쉽게 접근할 수 있습니다.
Support procedural UI generation. 절차적 UI 생성을 지원합니다.
UI description should be hard to screw up.
Must support animation and styling. 애니메이션과 스타일을 지원해야 합니다. 불투명한 캐시와 중복된 상태를 피하세요. 역사적으로 UI는 상태를 캐시하고 명시적인 무효화를 요구 (from preferred to least preferred) Polling
Transparent caches
Opaque caches with low-grain invalidation 노티피케이션보다 알림을 더 선호 When UI structure is changing, prefer polling to notification. (When notification is necessary, prefer low-grain notifications to fine-grain notifications.) 피드백 루프를 피하기. Ex: 모든 레이아웃은 프로그래머 설정에서 계산됩니다. 이전 레이아웃 상태에 의존하지 않기. Only exceptions are when UI state becomes the model; e.g. ScrollBars visualize UI state.
This is done for correctness and programmer sanity rather than performance. 일단 난잡하게 개발 -&gt; 후에 일반화하기. &nbsp;Slate uses delegates as a flexible conduit for widgets that need to read and write the Model's data. Slate widgets read the Model's data when they need to display it.
STextBlock 은 Text 라는 델리게이트를 사용.<img alt="SLATE_ARCITECTURE_1.png" src="images/slate_arcitecture_1.png" target="_self">이 예제에서 Framerate는 float, integer로 저장될 확률이 높습니다. Delegate를 사용하면 값을 읽을 때마다 변환을 수행할 수 있는 유연성이 제공됩니다.<br><img alt="SLATE_ARCITECTURE_2.png" src="images/slate_arcitecture_2.png" target="_self">SEditableText는 입력과 출력을 모두 담당하는 Slate 위젯입니다. STextBlock과 마찬가지로 데이터 시각화를 위해 Text 대리자를 사용합니다. 사용자가 편집 가능한 텍스트 필드에 일부 텍스트를 입력하고 Enter 키를 누르면 SEditableText가 OnTextChanged 대리자를 호출합니다. 프로그래머가 입력의 유효성을 검사하고 모델의 데이터를 OnTextChanged에 변경하는 데 적합한 기능을 연결했다고 가정합니다.다음 프레임 동안 SEditableText는 모델의 데이터에서 읽습니다. 위의 예에서 항목 이름은 OnTextChanged 대리자에 의해 변경되었으며 Text 대리자를 통해 시각화를 위해 읽혀집니다.Using a delegate is not always desirable. Depending on the use case, the arguments to Slate widgets may need to be constant values or functions. We encapsulate this notion via the&nbsp;TAttribute &lt; T &gt;&nbsp;class. An attribute can be set to a constant or to a delegate.<br>After reading the&nbsp;<a data-tooltip-position="top" aria-label="https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine#pollingdataflowanddelegates" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine#pollingdataflowanddelegates" target="_self">Polling Data Flow and Delegates</a>&nbsp;section, one might have serious concerns about performance.Consider the following observations:
UI complexity is bounded by the number of live widgets.
Scrolling content is virtualized whenever possible; this mostly avoids live widgets off-screen. Large numbers of off-screen widgets can easily tank Slate performance. Assumption: users with big screens have beefy machines to drive those screens; they can handle a large number of widgets.
Sometimes polling is either not performant or functionally incorrect. This is often the case with non-trivial values that cannot be expressed as a combination of simpler, trivial values. We usually invalidate in scenarios where the structure of the Model changes drastically. It is then reasonable to scrap an existing UI and recreate it. However, doing so assumes state loss, so we should not do it unless necessary.Invalidation is - as a rule - reserved for infrequent, low-granularity events.Consider the example of the Blueprint Editor, which displays nodes on a graph. When an update is requested, all the&nbsp;Graph&nbsp;Panel widgets are cleared and re-created. This is preferable to fine-grain invalidation because it is simpler and more maintainable.모델 구조가 크게 변경된다면 다 지우고 다시 그리는 게 낫다. (like 그래프)All Slate widgets store children in child slots. (As opposed to storing a plain array of child widgets.) Child slots always store a valid widget; by default they store the&nbsp;SNullWidget, which is a widget with no visualization or interaction. Each type of widget can declare its own type of child slot, which caters to its specific needs. Consider that&nbsp;SVerticalSlot&nbsp;arranges its children completely differently than an&nbsp;SCanvas, which is quite different from SUniformGridPanel. The Slots allow each type of panel to ask for a set of per-child settings that affect the arrangement of the children.모든 Slate 위젯은 하위 슬롯에 하위 항목을 저장합니다. (하위 위젯의 일반 배열을 저장하는 것과 반대입니다.) 하위 슬롯은 항상 유효한 위젯을 저장합니다. 기본적으로 시각화나 상호작용이 없는 위젯인 SNullWidget을 저장합니다. 각 위젯 유형은 특정 요구 사항을 충족하는 자체 하위 슬롯 유형을 선언할 수 있습니다. SVerticalSlot은 SUniformGridPanel과 상당히 다른 SCanvas와 완전히 다르게 자식을 배열한다는 점을 고려하세요. 슬롯을 사용하면 각 유형의 패널에서 하위 배열에 영향을 미치는 하위별 설정 세트를 요청할 수 있습니다.위젯은 세 가지 형태로 제공됩니다 Leaf Widgets&nbsp;- widgets with no child slots. e.g. STextBlock displays a piece of text. It has native knowledge of how to draw text. 하위 슬롯이 없는 위젯. 예를 들어 STextBlock은 텍스트 조각을 표시합니다. 텍스트를 그리는 방법에 대한 기본 지식이 있습니다. Panels&nbsp;- widgets with a dynamic number of child slots. e.g.&nbsp;SVerticalBox&nbsp;arranges any number of children vertically given some layout rules. 동적 개수의 하위 슬롯이 있는 위젯. 예를 들어 SVerticalBox는 일부 레이아웃 규칙에 따라 여러 자식을 수직으로 정렬합니다. Compound Widgets&nbsp;- widgets with a fixed number of explicitly named child slots. e.g.&nbsp;SButton&nbsp;has one slot called Content which contains any widgets inside the button. 동적 개수의 하위 슬롯이 있는 위젯. 예를 들어 SVerticalBox는 일부 레이아웃 규칙에 따라 여러 자식을 수직으로 정렬합니다. Slate layout is accomplished in two passes.
Pass 1:&nbsp;Cache Desired Size&nbsp;- the relevant functions are&nbsp;SWidget::CacheDesiredSize&nbsp;and&nbsp;SWidget::ComputeDesiredSize
Pass 2:&nbsp;ArrangeChildren&nbsp;- the relevant function is&nbsp;SWidget::ArrangeChildren
The goal of this pass is to figure out how much space each widget wants to occupy.&nbsp; Widgets with no children (i.e. leaf widgets) are asked to compute and cache their desired size based on their intrinsic properties.Leaf Widget은 자기 고유의 intrinsic 특성을 기준으로 사이즈가 계산되고 캐싱되도록 요청됨.Widgets that combine other widgets (i.e. compound widgets and panels) use special logic to determine their desired size as a function of the size of their children.
다른 위젯과 결합하는 위젯 (패널과 Compound 위젯)은 special logic을 통해 사이즈가 계산됩니다.Note that each type of widget is only required to implement&nbsp;ComputeDesiredSize();&nbsp;the caching and traversal logic are implemented by Slate.
각 위젯 유형은 ComputeDesiredSize()를 구현하는 데만 필요합니다. 캐싱 및 순회 논리는 Slate에 의해 구현됩니다.Slate guarantees that when ComputeDesiredSize() is called on a widget, its children have already computed and cached their desired size. Thus, this is a bottom-up pass.
Slate는 위젯에서 ComputeDesiredSize()가 호출될 때 해당 하위 항목이 이미 원하는 크기를 계산하고 캐시했음을 보장합니다. 따라서 이것은 상향식 패스입니다.다음의 예를 고려해보자.<br><img alt="SLATE_ARCITECTURE_3.png" src="images/slate_arcitecture_3.png" target="_self">An STextBlock widget would compute its desired size by measuring the string that it is displaying. The SImage widget would determine its size based on the image data it is showing. Assume that the text inside the textblock requires 14 slate units of space, and the image requires 8. The horizontal panel arranges widgets horizontally, and therefore requires 14 + 8 = 22 units of space.STextBlock의 Text를 고려하면 14사이즈 되어야하고, SImage의 Image가 들어가려면 8사이즈가 필요하다. 그래서 Horizontal Box는 14+8 = 22로 결정된다.ArrangeChildren is a top-down pass. Slate begin at the top-level windows and asks each window to arrange its children based on the constraints provided by the programmers. When the space allotted for each child is known, Slate can recur and arrange the children's children. The recursion continues until all the children are arranged.AlignChildren은 하향식 패스입니다. 슬레이트는 최상위 창에서 시작하여 프로그래머가 제공한 제약 조건에 따라 하위 창을 정렬하도록 각 창에 요청합니다. 각 자식에게 할당된 공간이 알려지면 Slate는 자식의 자식을 반복해서 배열할 수 있습니다. 모든 하위 항목이 정렬될 때까지 재귀가 계속됩니다.<br><img alt="SLATE_ARCITECTURE_4.png" src="images/slate_arcitecture_4.png" target="_self">먼저 Horizontal Box에 사이즈를 할당하고 그것에 맞춰 자식 컴포넌트의 사이즈가 결정된다.STextBlock은 Autosize이고 내부 Text는 14 사이즈를 필요로하기 때문에 14로 결정된다 SImage의 내부 이미지는 8의 사이즈를 필요로 하지만 Fill WIdth이기 때문에 11로 결정된다.Note that in the actual SHorizontalBox widget, the alignment of the SImage within its slot would be driven by the&nbsp;HAlign&nbsp;property, which can be Left, Center, Right, or Fill.In practice, Slate never performs a full ArrangeChildren pass. Instead, this functionality is used to implement other functionality. Key examples are hit detection and painting.
실제로 Slate는 전체 AlignChildren 패스를 수행하지 않습니다. 대신 이 기능은 다른 기능을 구현하는 데 사용됩니다. 주요 예로는 히트 감지 및 페인팅이 있습니다.During the paint pass, Slate iterates over all the visible widgets and produces a list of draw elements which will be consumed by the rendering system. This list is produced anew for every frame. 페인트 패스 중에 Slate는 표시되는 모든 위젯을 반복하고 렌더링 시스템에서 사용할 그리기 요소 목록을 생성합니다. 이 목록은 매 프레임마다 새로 생성됩니다.We begin at the top level windows and recur down the hierarchy, appending the draw elements of every widget to the draw list. 최상위 창에서 시작하여 계층 구조를 따라 반복하여 모든 위젯의 그리기 요소를 그리기 목록에 추가합니다.Widgets tend to do two things during paint: they output actual draw elements or figure out where a child widget should exist and ask the child widget to paint itself. 위젯은 페인트하는 동안 두 가지 작업을 수행하는 경향이 있습니다. 즉, 실제 그리기 요소를 출력하거나 하위 위젯이 어디에 있어야 하는지 파악하고 하위 위젯에게 자체적으로 페인트하도록 요청합니다.Thus, we can think of a simplified general-case&nbsp;OnPaint&nbsp;function as being 따라서 단순화된 일반적인 경우의 OnPaint 함수를 다음과 같이 생각할 수 있습니다. // An arranged child is a widget and its allotted geometry
struct ArrangedChild
{ Widget; Geometry;
}; OutputElements OnPaint( AllottedGeometry )
{ // Arrange all the children given our allotted geometry Array&lt;ArrangedChild&gt; ArrangedChildren = ArrangeChildrenGiven( AllottedGeometry ); // Paint the children for each ( Child in ArrangedChildren ) { OutputElements.Append( Child.Widget.OnPaint( Child.Geometry ) ); } // Paint a border OutputElements.Append( DrawBorder() );
}
The key functions that define an SWidget's behavior in Slate are: ComputeDesiredSize() - responsible for desired size. 원하는 사이즈를 책임집니다.| ArrangeChildren() - responsible for arrangement of children within the parent's allotted area. 부모에게 할당된 공간 내에서 자녀를 배치할 책임이 있습니다. OnPaint() - responsible for appearance. Event handlers - these are of the form OnSomething. These are functions that may be invoked on your widget by Slate at various times. 이는 OnSomething 형식입니다. 이는 Slate가 위젯에서 다양한 시간에 호출할 수 있는 함수입니다. Composition is the notion that any slot should be able to contain arbitrary widget content. This affords users of Slate a great deal of flexibility. Composition is used whenever possible in core Slate widgets. 구성은 모든 슬롯이 임의의 위젯 콘텐츠를 포함할 수 있어야 한다는 개념입니다. 이는 Slate 사용자에게 상당한 유연성을 제공합니다. 컴포지션은 핵심 슬레이트 위젯에서 가능할 때마다 사용됩니다.]]></description><link>ue/slate-architecture.html</link><guid isPermaLink="false">UE/Slate Architecture.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slate Overview]]></title><description><![CDATA[Slate&nbsp;is a completely custom and platform agnostic user interface framework that is designed to make building the user interfaces for tools and applications such as Unreal Editor, or in-game user interfaces, fun and efficient. It combines a declarative syntax with the ability to easily design, lay out, and style components that allows for easily creating and iterating on UIs.The Slate UI solution makes it extremely easy to put together graphical user interfaces for tools and applications and iterate on them quickly.Slate의 선언적 구문을 사용하면 프로그래머가 간접 계층을 추가하지 않고도 UI 구축에 액세스할 수 있습니다. 새 위젯을 선언하고 생성하는 프로세스를 단순화하기 위해 완전한 매크로 세트가 제공됩니다.SLATE_BEGIN_ARGS( SSubMenuButton ) : _ShouldAppearHovered( false ) {} /** The label to display on the button */ SLATE_ATTRIBUTE( FString, Label ) /** Called when the button is clicked */ SLATE_EVENT( FOnClicked, OnClicked ) /** Content to put in the button */ SLATE_NAMED_SLOT( FArguments, FSimpleSlot, Content ) /** Whether or not the button should appear in the hovered state */ SLATE_ATTRIBUTE( bool, ShouldAppearHovered )
SLATE_END_ARGS()
// Add a new section for static meshes
ContextualEditingWidget-&gt;AddSlot()
.Padding( 2.0f )
[ SNew( SDetailSection ) .SectionName("StaticMeshSection") .SectionTitle( LOCTEXT("StaticMeshSection", "Static Mesh").ToString() ) .Content() [ SNew( SVerticalBox ) + SVerticalBox::Slot() .Padding( 3.0f, 1.0f ) [ SNew( SHorizontalBox ) + SHorizontalBox::Slot() .Padding( 2.0f ) [ SNew( SComboButton ) .ButtonContent() [ SNew( STextBlock ) .Text( LOCTEXT("BlockingVolumeMenu", "Create Blocking Volume") ) .Font( FontInfo ) ] .MenuContent() [ BlockingVolumeBuilder.MakeWidget() ] ] ] ]
];
위의 코드는 아래 UI를 만든다.<img alt="SLATE_OVERVIEW_1.png" src="images/slate_overview_1.png" target="_self">Styles can be created and applied to the various parts of a widget. This makes it easy to iterate on the look of the components in the UI, as well as share and reuse styles. 스타일을 생성하여 위젯의 다양한 부분에 적용할 수 있습니다. 이를 통해 UI의 구성 요소 모양을 쉽게 반복할 수 있을 뿐만 아니라 스타일을 공유하고 재사용할 수도 있습니다.// Tool bar
{ Set( "ToolBar.Background", FSlateBoxBrush( TEXT("Common/GroupBorder"), FMargin(4.0f/16.0f) ) ); Set( "ToolBarButton.Normal", FSlateNoResource() ); // Note: Intentionally transparent background Set( "ToolBarButton.Pressed", FSlateBoxBrush( TEXT("Old/MenuItemButton_Pressed"), 4.0f/32.0f ) ); Set( "ToolBarButton.Hovered", FSlateBoxBrush( TEXT("Old/MenuItemButton_Hovered"), 4.0f/32.0f ) ); // Tool bar buttons are sometimes toggle buttons, so they need styles for "checked" state Set( "ToolBarButton.Checked", FSlateBoxBrush( TEXT("Old/MenuItemButton_Pressed"), 4.0f/32.0f, FLinearColor( 0.3f, 0.3f, 0.3f ) ) ); Set( "ToolBarButton.Checked_Hovered", FSlateBoxBrush( TEXT("Old/MenuItemButton_Hovered"), 4.0f/32.0f ) ); Set( "ToolBarButton.Checked_Pressed", FSlateBoxBrush( TEXT("Old/MenuItemButton_Pressed"), 4.0f/32.0f, FLinearColor( 0.5f, 0.5f, 0.5f ) ) ); // Tool bar button label font Set( "ToolBarButton.LabelFont", FSlateFontInfo( TEXT("Roboto-Regular"), 8 ) );
}
SNew( SBorder )
.BorderImage( FEditorStyle::GetBrush( "ToolBar.Background" ) )
.Content()
[ SNew(SHorizontalBox) // Compile button (faked to look like a multibox button) +SHorizontalBox::Slot() [ SNew(SButton) .Style(TEXT("ToolBarButton")) .OnClicked( InKismet2.ToSharedRef(), &amp;FKismet::Compile_OnClicked ) .IsEnabled( InKismet2.ToSharedRef(), &amp;FKismet::InEditingMode ) .Content() [ SNew(SVerticalBox) +SVerticalBox::Slot() .Padding( 1.0f ) .HAlign(HAlign_Center) [ SNew(SImage) .Image(this, &amp;SBlueprintEditorToolbar::GetStatusImage) .ToolTipText(this, &amp;SBlueprintEditorToolbar::GetStatusTooltip) ] +SVerticalBox::Slot() .Padding( 1.0f ) .HAlign(HAlign_Center) [ SNew(STextBlock) .Text(LOCTEXT("CompileButton", "Compile")) .Font( FEditorStyle::GetFontStyle( FName( "ToolBarButton.LabelFont" ) ) ) .ToolTipText(LOCTEXT("CompileButton_Tooltip", "Recompile the blueprint")) ] ] ]
]
The Slate Widget Reflector provides a means of debugging and analyzing the UI and associated code. This helps track down bugs and undesirable behavior as well as profile and optimize your user interface. 슬레이트 위젯 리플렉터는 UI 및 관련 코드를 디버깅하고 분석하는 수단을 제공합니다. 이는 버그와 바람직하지 않은 동작을 추적하고 사용자 인터페이스를 프로파일링하고 최적화하는 데 도움이 됩니다.슬레이트를 사용하기 위해서 아래 모듈을 설정해줘야 한다.<br><img alt="SLATE_OVERVIEW_2.png" src="images/slate_overview_2.png" target="_self">]]></description><link>ue/slate-overview.html</link><guid isPermaLink="false">UE/Slate Overview.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_overview_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_overview_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slate Widget Examples]]></title><description><![CDATA[ IsEnabled - This will specify whether or not the widget is able to be interacted with. If it is disabled, it will be greyed out. 위젯이 상호작용할 수 있는지 여부를 지정합니다. 비활성화된 경우 회색으로 표시됩니다. ToolTip - This will specify what kind of custom SToolTip widget will be used for this widget's tool tip. If not specified, it will not appear. 이 위젯의 ​​도구 설명에 사용할 사용자 정의 SToolTip 위젯의 종류를 지정합니다. 지정하지 않으면 나타나지 않습니다. ToolTipText - This will specify what kind of text will show up as a simple tooltip for this widget's tool tip. If not specified, or if the ToolTip attribute was used, it will not appear. 이 위젯의 ​​도구 설명에 대한 간단한 도구 설명으로 표시할 텍스트 종류를 지정합니다. 지정하지 않거나 ToolTip 속성을 사용한 경우에는 표시되지 않습니다. Cursor - This will specify what cursor will appear while the mouse is hovering over this widget. 이는 마우스가 이 위젯 위에 있는 동안 어떤 커서가 나타날지 지정합니다. Visibility 다음 인수는 모든 단일 위젯에 있는 것은 아니지만 대부분의 위젯에 있습니다.
Text - This will specify the text that this widget will have, if applicable.
Content - This will specify what widget should be placed in the content section of the widget, if applicable.
ReadOnly - This will prevent this widget from being editable if&nbsp;true.
Style - This will specify the style of images or text font used by the widget. How this is applicable varies by widget.
Padding - The padding of a widget amount of spacing in slate units around the left, top, right, and bottom parts of the widget within its parent. These can be specified as a single value for all four parts, or as a horizontal and vertical value, or as four separate values.
HAlign - The horizontal alignment of content within the widget.
VAlign - The vertical alignment of content within the widget.
The visibility of a widget determines how the widget will appear, as well as its interactivity.
위젯의 가시성에 따라 위젯이 표시되는 방식과 상호작용성이 결정됩니다. Visible (Default) - The widget will appear normally. 위젯이 정상적으로 나타납니다. Collapsed - The widget will not be visible and will take up no space in the layout. It will not be interactive. 위젯은 표시되지 않으며 레이아웃에서 공간을 차지하지 않습니다. 인터렉션형이 아닙니다. Hidden - The widget will not be visible, but will take up space in the layout. It will not be interactive. 위젯은 표시되지 않지만 레이아웃에서 공간을 차지합니다. 인터렉션형이 아닙니다. HitTestInvisible - Visible to the user, but only as art. It will not be interactive. 사용자에게 표시되지만 아트로만 표시됩니다. 대화형이 아닙니다. SelfHitTestInvisible - Same as HitTestInvisible, but does not apply to child widgets. HitTestInvisible과 동일하지만 하위 위젯에는 적용되지 않습니다. HAlign_Fill/VAlign_Fill HAlign_Left VAlign_Top HAlign_Center/VAlign_Center HAlign_Right VAlign_Bottom ]]></description><link>ue/slate-widget-examples.html</link><guid isPermaLink="false">UE/Slate Widget Examples.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[Navigation System]]></title><description><![CDATA[인공지능이 Path Finding을 해서 레벨을 탐색할 수 있음. 시스템은 레벨의 충돌 지오메트리로부터 내비게이션 메시를 생성하고 메시를 타일로 나눕니다. 그런 다음 이러한 타일은 다각형으로 분할되어 에이전트가 목적지로 이동할 때 사용하는 그래프를 형성합니다. 각 다각형에는 에이전트가 전체 최저 비용으로 최적의 경로를 결정하는 데 사용하는 비용이 할당됩니다.내비게이션 시스템에는 정적, 동적 및 동적 수정자 전용의 세 가지 생성 모드가 포함되어 있습니다. 이 모드는 프로젝트에서 내비게이션 메시가 생성되는 방식을 제어하고 필요에 맞는 다양한 옵션을 제공합니다.시스템은 또한 에이전트를 위한 두 가지 회피 방법, 즉 RVO(Reciprocal Velocity Obstacles)와 Detour Crowd Manager(우회 군중 관리자)를 제공합니다. 이러한 방법을 사용하면 에이전트는 게임 플레이 중에 동적 장애물과 다른 에이전트를 탐색할 수 있습니다.]]></description><link>ue/navigation-system.html</link><guid isPermaLink="false">UE/Navigation System.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[PhysX iOS 빌드]]></title><description><![CDATA[cd {EngineSource 디렉토리}/Engine/Source/ThirdParty/PhysX3/Lib/IOS
nm libPxFoundation.a <img alt="symbol_result.png" src="images/symbol_result.png" target="_self">커스텀한 엔진 심볼 확인 불가 -&gt; 커스텀한 PhysX lib .a overwrite 해야함. PhysX 빌드 CMake Version: 3.28.0 (minimum: 3.0)
XCode: 14.1
MacOS: Ventura 13.3.1(a)
Machine: Apple M1 Ultra Environment - Add EntryName: GW_DEPS_ROOT
Value: {PhysX Path} - 주의사항: PhysX3.4 아님 PxShared도 가지고 있는 Root 폴더<br><img alt="cmake_setting.png" src="images/cmake_setting.png" target="_self">Configure - Generate - Open Project
(Configure 할 때, output 폴더에 CMakeCache 있으면 지울 것 캐싱되어서 안바뀔 수도 있음)Xcode 프로젝트가 열렸으면 타겟 All_BUILD로 변경 Edit 스킴을 눌러서 release, debug 각 config에 맞는 걸로 바꾼 후 실행하면 .a들 뽑힘. (PhysX3.4와 PxShared 라이브러리들)<br><img alt="change_scheme.png" src="images/change_scheme.png" target="_self">해당 폴더로 가서 libPxFoundationDEBUG.a $ nm libPxFoundationDEBUG.a
<br><img alt="symbol_find_result.png" src="images/symbol_find_result.png" target="_self">뽑은 라이브러리들(PhysX3.4, PxShared) 엔진소스/ThirdParty/PhysX3/Lib/IOS로 가서 덮어쓰기]]></description><link>ue/physx-ios-빌드.html</link><guid isPermaLink="false">UE/PhysX iOS 빌드.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/symbol_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/symbol_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unreal Engine만의 기본 타입이 있는 이유와 문자열]]></title><description><![CDATA[ 언리얼 엔진에서 int32와 같은 언리얼 엔진 데이터형이 따로 있는 이유는 다양한 플랫폼에 대응하기 때문이다.
언리얼은 문자 인코딩 방식 UTF-16을 사용하고 있음. 이것도 역시 다양한 플랫폼을 위해서..
윈도우는 CP949를 사용해서 언리얼엔진에서 한글 사용시 깨진다. 소스코드를 UTF-8로 저장하면 한글 제대로 나온다.유니코드를 위한 언리얼 표준 Character 타입은 TCHAR이다.
언리얼 엔진에서 문자열을 사용할 때 TEXT 매크로를 사용해 생성하고 다뤄야한다.
TEXT 매크로로 감싸면 TCHAR 배열로 만들어짐!FString은 단순하게 TCHAR를 가르키고 있는 포인터임. 그래서 FString을 출력하고 싶으면 디레퍼런스 연산자 *를 사용해야함.FString을 자르거나, 찾거나 등 문자열을 다루는 함수들은 내부적으로 FCString으로 타입이 변환한 후 처리된다. 이는 저수준의 C 함수를 사용해야하기 때문이다. 실제로 Atoi나 Atof 같은 함수를 사용하기 위해서는 FCString을 이용한다. #include "MyGameInstance.h"
void UMyGameInstance::Init()
{ Super::Init(); TCHAR LogCharArray[] = TEXT("Hello World"); UE_LOG(LogTemp, Log, TEXT("%s"), LogCharArray); FString LogCharString = LogCharArray; UE_LOG(LogTemp, Log, TEXT("%s"), *LogCharString); const TCHAR* LongCharPtr = *LogCharString; UE_LOG(LogTemp, Log, TEXT("%s"), LongCharPtr); TCHAR* LogCharDataPtr = LogCharString.GetCharArray().GetData(); UE_LOG(LogTemp, Log, TEXT("%s"), LogCharDataPtr); TCHAR LogCharArrayWithSize[100]; FCString::Strcpy(LogCharArrayWithSize, LogCharString.Len(), *LogCharString); UE_LOG(LogTemp, Log, TEXT("%s"), LogCharArrayWithSize); // Find, Slice if (LogCharString.Contains(TEXT("World"), ESearchCase::IgnoreCase)) { int32 Index = LogCharString.Find(TEXT("World"),ESearchCase::IgnoreCase); FString EndString = LogCharString.Mid(Index); UE_LOG(LogTemp, Log, TEXT("Find Test: %s"), *EndString); } FString Left, Right; if (LogCharString.Split(TEXT(" "), &amp;Left, &amp;Right)) { UE_LOG(LogTemp, Log, TEXT("%s and %s"), *Left, *Right); } // Int, Float -&gt; String int IntValue = 32; float FloatValue = 3.141592; // 스트링으로 전환 FString FloatIntString = FString::Printf(TEXT("Int: %d, Float: %f"), IntValue, FloatValue); FString FloatString = FString::SanitizeFloat(FloatValue); FString IntString = FString::FromInt(IntValue); UE_LOG(LogTemp, Log, TEXT("%s"), *FloatIntString); UE_LOG(LogTemp, Log, TEXT("Int:%s, Float:%s"), *IntString, *FloatString); int32 IntValueFromString = FCString::Atoi(*IntString); float FloatValueFromString = FCString::Atof(*FloatString); FString FloatIntFromString = FString::Printf(TEXT("Int: %d, Float: %f"), IntValueFromString, FloatValueFromString); UE_LOG(LogTemp, Log, TEXT("%s"), *FloatIntFromString); // FNAME // 에셋관리를 위한 것 // 대소문자 구분 x // 한번 선언되면 바꿀 수 없음 key로 만들어짐 Key - Vlaue // 팁 // 위의 코드는 overhead 발생 -&gt; 아래코드 staticonyonce를 이용하기 for (int i = 0; i &lt; 10000; ++i) { FName SerachInNamePool = FName(TEXT("pelvis")); const static FName StaticOnlyOnce(TEXT("pelvis")); } ]]></description><link>ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html</link><guid isPermaLink="false">UE/Unreal Engine만의 기본 타입이 있는 이유와 문자열.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[아틀라스]]></title><description><![CDATA[-&gt; 여러개의 작은 이미지나 텍스쳐를 큰 이미지 파일로 만드는 것장점
드로우콜 감소 - 여러개의 텍스쳐를 개별적으로 불러오는 것 대신 한번에 불러오니까 드로우 콜 감소시킬 수 있음
메모리 사용 최적화 - 텍스처를 개별적으로 불러올 때 발생할 수 있는 메모리 낭비를 없애줌
텍스처 스위칭 감소 - 동일한 드로우콜 내에서 다른 텍스처로 스위칭하는데 비용이 드는데 이 과정을 없앰
배치처리 효율화 - 비슷한 유형의 많은 객체가 동일한 텍스처 아틀라스를 사용하는 경우, 이들을 함께 그룹화하여 배치 처리할 수 있습니다. 이는 렌더링 효율성을 높이고, CPU와 GPU 사이의 복잡한 상호작용을 줄일 수 있습니다.
실제로 UMG에 생 이미지를 사용해서 3개의 이미지를 만든다면 Draw Call 3이고 Atlas를 사용하면 Draw Call이 1임.단점
여러개의 텍스처를 하나의 아틀라스로 묶어야 하기 때문에 공격적인 압축이 필요함. 이는 세부 디테일이 흐려질수도 있음(화질 깨질 수도 있음)
모든 텍스처가 동일한 해상도를 공유하기 때문에, 고해상도는 해상도를 낮춰야할 가능성이 있음
사용되지 않는 부분의 아틀라스는 리소스 낭비
큰 텍스처 아틀라스를 메모리에 로드할 때 각각 개별 로드하는 것보다 로드시간이 길 수 있음
텍스처 스트리밍(MipMap) 동적으로 텍스처를 로드하고 언로드할 때 오바헤드가 있을 수 있음 UVMapping의 유연성- 텍스처 아틀라스를 사용하면, 개별 텍스처에 대한 UV 매핑을 조정하여 다양한 텍스처 조각을 사용할 수 있습니다. 이는 다양한 비주얼 효과를 생성하거나, 다양한 객체에 동일한 텍스처 아틀라스를 다르게 적용하여 리소스를 절약할 수 있는 방법을 제공합니다.
아트 워크플로우 개선 - 아티스트들은 텍스처 아틀라스를 사용하여 텍스처 작업을 보다 효율적으로 관리할 수 있습니다. 특히, 게임 내에서 다양한 요소들이 비슷한 텍스처 스타일을 공유할 때, 아틀라스 하나를 업데이트함으로써 여러 개체의 비주얼을 일관되게 유지할 수 있습니다.
텍스처를 Create Sprite -&gt; Sprite 클릭 -&gt; Atlas Group에 넣기밉맵은 동일한 텍스처의 여러 사전 계산된 버전을 작은 해상도로 점차 줄여 가며 저장하는 기법을 말합니다. 이렇게 하면, 3D 환경 내에서 물체가 더 멀리 있을 때, 더 작은 해상도의 텍스처를 사용하여 렌더링할 수 있습니다.
성능 향상: 더 작은 해상도의 텍스처를 사용하면, 그래픽 처리 장치(GPU)의 부담이 줄어들어 렌더링 성능이 향상됩니다. 멀리 있는 객체에 고해상도 텍스처를 사용하는 것은 메모리와 처리 능력을 낭비하기 때문에, 밉맵을 사용하면 이러한 자원을 효율적으로 사용할 수 있습니다.
시각적 품질 향상: 밉맵을 사용하면 텍스처의 해상도가 뷰포트와의 거리에 따라 동적으로 조정되므로, 텍스처 앨리어싱(계단 현상)이나 모아레 패턴 같은 시각적 아티팩트를 줄일 수 있습니다. 멀리 있는 객체에 대해 더 낮은 해상도의 텍스처를 사용함으로써, 더 부드럽고 자연스러운 이미지를 생성할 수 있습니다.
미리 준비된 다양한 해상도 이미지를 준비하는 것객체가 화면에서 멀어질수록 이미지의 해상도를 동적으로 조절하여 사용
가까이 -&gt; 고해상도
멀리 -&gt; 저해상도밉맵은 언리얼엔진4에서는 텍스쳐가 Power of two인 경우에 자동으로 생성된다. 아닌 경우는 자동생성 안해준다. 그런데 5에서는 자동 생성해준다.여담으로 텍스쳐 압축기술인 DXT5는 Power of four인 경우에 적용된다.
따라서 텍스쳐 크기는 안전하게 Power of two를 유지하는 것이 좋다.같은 이미지를 사용하는 UMG가 있을 때 아틀라스를 사용하는 것이 합리적이다. Draw Call을 줄여준다.
Draw Call이 뭐야?
Draw Call을 수동으로 부를 수 있을까?
Draw Call이 적으면 무조건 좋은거야?
UMG를 사용할 때 Draw Call을 줄이기 위해서 어떤 작업들을 해야할까?
아틀라스를 사용하면 그러면 Draw Call이 1 보장되겠네? <a rel="noopener nofollow" class="external-link is-unresolved" href="https://drehzr.tistory.com/666" target="_self">https://drehzr.tistory.com/666</a> - 밉맵
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://coding-hell.tistory.com/78" target="_self">https://coding-hell.tistory.com/78</a> - 언리얼 UI 최적화하기
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.nullbus.net/94" target="_self">https://blog.nullbus.net/94</a> - UMG Draw Call 분석하기
]]></description><link>ue/아틀라스.html</link><guid isPermaLink="false">UE/아틀라스.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[symbol_find_result]]></title><description><![CDATA[<img src="images/symbol_find_result.png" target="_self">]]></description><link>images/symbol_find_result.html</link><guid isPermaLink="false">images/symbol_find_result.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/symbol_find_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/symbol_find_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[symbol_result]]></title><description><![CDATA[<img src="images/symbol_result.png" target="_self">]]></description><link>images/symbol_result.html</link><guid isPermaLink="false">images/symbol_result.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/symbol_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/symbol_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cmake_setting]]></title><description><![CDATA[<img src="images/cmake_setting.png" target="_self">]]></description><link>images/cmake_setting.html</link><guid isPermaLink="false">images/cmake_setting.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/cmake_setting.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cmake_setting.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[change_scheme]]></title><description><![CDATA[<img src="images/change_scheme.png" target="_self">]]></description><link>images/change_scheme.html</link><guid isPermaLink="false">images/change_scheme.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/change_scheme.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/change_scheme.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[NativizedAssets]]></title><description><![CDATA[<img src="images/nativizedassets.png" target="_self">]]></description><link>images/nativizedassets.html</link><guid isPermaLink="false">images/NativizedAssets.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/nativizedassets.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/nativizedassets.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[object_file_header]]></title><description><![CDATA[<img src="images/object_file_header.png" target="_self">]]></description><link>images/object_file_header.html</link><guid isPermaLink="false">images/object_file_header.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/object_file_header.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/object_file_header.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[printf]]></title><description><![CDATA[<img src="images/printf.png" target="_self">]]></description><link>images/printf.html</link><guid isPermaLink="false">images/printf.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/printf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/printf.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Build System]]></title><description><![CDATA[
Source 폴더 -&gt; Unreal Build Tool (C#) -&gt; 각 플랫폼 컴파일러 실행
실제 Build를 하는 것은 C#으로 진행함 그래서 닷넷을 설치하는 것Source 폴더 구조Source
- Module 폴더 (보통 Project 이름)
- 소스코드(.h, .cpp)
- {모듈이름}.Build.cs
- 타겟 설정 파일: 전체 솔루션이 다룰 빌드 대상 지정
&gt; {프로젝트 이름}.Target.cs: 게임 빌드 설정
&gt; {프로젝트 이름}Editor.Target.cs: 에디터 빌드 설정Build.cs는 모듈마다 들어가는 모듈 설정 파일모듈.cpp, 모듈.cpp로 지정매크로를 이용해서 모듈의 뼈대를 제작
IMPLEMENT_MODULE: 일반 모듈
IMPLEMENT_GAME_MODULE: 게임 모듈
IMPLEMENT_PRIMARY_GAME_MODULE: 주 게임 모듈
외부로 공개할 클래스 선언에는 {모듈이름}_DLL 매크로를 붙임
Build.cs에서 참조 관계 설정
서브 모듈을 플러그인으로 분리할 수 있음]]></description><link>ue/build-system.html</link><guid isPermaLink="false">UE/Build System.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[executable_file_structure]]></title><description><![CDATA[<img src="images/executable_file_structure.png" target="_self">]]></description><link>images/executable_file_structure.html</link><guid isPermaLink="false">images/executable_file_structure.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/executable_file_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/executable_file_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[build_process]]></title><description><![CDATA[<img src="images/build_process.png" target="_self">]]></description><link>images/build_process.html</link><guid isPermaLink="false">images/build_process.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/build_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/build_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_inprogress]]></title><description><![CDATA[<img src="images/ebtnode_result_inprogress.png" target="_self">]]></description><link>images/ebtnode_result_inprogress.html</link><guid isPermaLink="false">images/ebtnode_result_inprogress.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_inprogress.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_inprogress.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_type]]></title><description><![CDATA[<img src="images/ebtnode_result_type.png" target="_self">]]></description><link>images/ebtnode_result_type.html</link><guid isPermaLink="false">images/ebtnode_result_type.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_type.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_type.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_failed]]></title><description><![CDATA[<img src="images/ebtnode_result_failed.png" target="_self">]]></description><link>images/ebtnode_result_failed.html</link><guid isPermaLink="false">images/ebtnode_result_failed.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_failed.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_failed.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_aborted]]></title><description><![CDATA[<img src="images/ebtnode_result_aborted.png" target="_self">]]></description><link>images/ebtnode_result_aborted.html</link><guid isPermaLink="false">images/ebtnode_result_aborted.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_aborted.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_aborted.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Navigation]]></title><description><![CDATA[<img src="images/navigation.png" target="_self">]]></description><link>images/navigation.html</link><guid isPermaLink="false">images/Navigation.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/navigation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/navigation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GameFlowChart]]></title><description><![CDATA[<img src="images/gameflowchart.png" target="_self">]]></description><link>images/gameflowchart.html</link><guid isPermaLink="false">images/GameFlowChart.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/gameflowchart.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gameflowchart.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Blendspace]]></title><description><![CDATA[<img src="images/blendspace.png" target="_self">]]></description><link>images/blendspace.html</link><guid isPermaLink="false">images/Blendspace.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/blendspace.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/blendspace.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[참조 vs 포인터]]></title><description><![CDATA[
성능 같음
포인터는 원본 전달을 확실히 알려줌.
참조는 표현적으로 원본을 넘겨주는 지 아닌지 애매함예시: PrintInfo(&amp;info) - 포인터 vs PrintInfo(info) - 참조참조에서 마음대로 고치는 부분은 const를 사용하면 해서 읽기용으로 만들 수 있음.물론 포인터도 const 사용 가능*을 기준으로 앞뒤에 따라 의미가 달라짐. 변경앞인 경우
void (const PrintInfo StatInfo info) {} -&gt; 주소값을 타고 가는 데이터 변경 불가능
info-&gt;hp = 100; // 에러
뒤인 경우:
void (PrintInfo StatInfo* const info) { } -&gt; 주소값 자체 변경 불가능
info = other_info; // 불가능 참조 타입은 참조하는 대상이 없으면 안됨 nullptr 개념 없음, 포인터는 nullptr 가능
]]></description><link>cpp/참조-vs-포인터.html</link><guid isPermaLink="false">CPP/참조 vs 포인터.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[포인터에 const 사용하기]]></title><description><![CDATA[int age = 29;
const int* pt = &amp;age; *pt += 1; // 불가능 age += 1; // age는 const가 아니므로 가능 cout &lt;&lt; age &lt;&lt; endl; // 가능
const float g_earth = 9.80;
const float* pe = &amp;g_earth; // 불가능 - pm을 이용해 g_moon의 값을 변경한다면 const라는 것이 무의미해지기 때문에
// c++은 const 변수의 주소를 const가 아닌 일반 포인터에 대입하는 것을 금지함.
const float g_moon = 1.63;
float* pm = &amp;g_moon; 포인터를 지시하는 포인터를 사용할 때 복잡해짐const가 아닌 포인터를 const 포인터에 대입하는 것은 간접 지시인 경우에만 가능(?)int age = 29;
int* pd = &amp;age;
// 간접지시? 왜 간접지시냐면 pt는 결국 age를 가리키는 거랑 마찬가지이기 뗴문ㅇㅇ
const int* pt = pd; //( 이거 가능?) // age++ 가능
// *pd +=1 가능
// *pt += 1는 불가능!
위의 예에서 보다시피 간접지시에서 const와 const가 아닌 것을 섞어쓰는 것은 매우 non - safe임.const int **pt2;
int* p1;
const int n = 13; pp2 = &amp;p1; // 사실 안됨, 근데 된다고 가정
*pp2 = &amp;n; // const끼리니까 간접지시로 p1이 n을 가리키게 한다. *p1 = 10; // const n을 변경하게 만든다.? const 무효 const가 아닌 포인터를 const 포인터에 대입하는 것은 한다리만 건너는 간접지시인 경우에만 가능. 노트는 무슨 말이야 젠장..Note. 데이터형 자체가 포인터가 아니라면 const 데이터의 주소이든, const가 아닌 데이터의 주소이든 const를 지시하는 포인터(한다리 건너는 간접지시?) 에 모두 대입할 수 있다.
int n = 1; const int* p1 = &amp;n;
int* p2 = &amp;n; const int* p3 = p2; // 이게 안됨.
int* n2 = 2;
const int* p4 = &amp;n2;
int* p5 = p4; // 여기서 안됨 // 이것도 안됨
const int x = 5;
int* ptr = &amp;x; ]]></description><link>cpp/포인터에-const-사용하기.html</link><guid isPermaLink="false">CPP/포인터에 const 사용하기.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[Problem1]]></title><description><![CDATA[아래 코드에서 "복사 생성"은 몇번 호출 되는가
class A { int x; public: A(int c) : x(c) {} A(const A&amp; a) { x = a.x; std::cout &lt;&lt; "복사 생성" &lt;&lt; std::endl; }
}; class B { A a; public: B(int c) : a(c) {} B(const B&amp; b) : a(b.a) {} A get_A() { A temp(a); return temp; }
}; int main() { B b(10); std::cout &lt;&lt; "---------" &lt;&lt; std::endl; A a1 = b.get_A();
}
Copy Elision(복사 생략) 중 Return Optimization왜냐하면 어떤 함수가 함수 내에서 생성한 객체를 리턴 한다면, 굳이 그걸 그냥 사용하면 되지 이를 복사 생성을 또할 필요가 없기 때문]]></description><link>cpp/problem1.html</link><guid isPermaLink="false">CPP/Problem1.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[ble-gatt-structure]]></title><description><![CDATA[<img src="images/ble-gatt-structure.png" target="_self">]]></description><link>images/ble-gatt-structure.html</link><guid isPermaLink="false">images/ble-gatt-structure.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-gatt-structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-gatt-structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-l2cap]]></title><description><![CDATA[<img src="images/ble-l2cap.png" target="_self">]]></description><link>images/ble-l2cap.html</link><guid isPermaLink="false">images/ble-l2cap.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-l2cap.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-l2cap.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-link-layer]]></title><description><![CDATA[<img src="images/ble-link-layer.png" target="_self">]]></description><link>images/ble-link-layer.html</link><guid isPermaLink="false">images/ble-link-layer.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-link-layer.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-link-layer.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-connection]]></title><description><![CDATA[<img src="images/ble-connection.png" target="_self">]]></description><link>images/ble-connection.html</link><guid isPermaLink="false">images/ble-connection.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-connection.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-connection.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-connection 1]]></title><description><![CDATA[<img src="images/ble-connection-1.png" target="_self">]]></description><link>images/ble-connection-1.html</link><guid isPermaLink="false">images/ble-connection 1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-connection-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-connection-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-data-exchange]]></title><description><![CDATA[<img src="images/ble-data-exchange.png" target="_self">]]></description><link>images/ble-data-exchange.html</link><guid isPermaLink="false">images/ble-data-exchange.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-data-exchange.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-data-exchange.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-attribute-table]]></title><description><![CDATA[<img src="images/ble-attribute-table.png" target="_self">]]></description><link>images/ble-attribute-table.html</link><guid isPermaLink="false">images/ble-attribute-table.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-attribute-table.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-attribute-table.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-conn-fig-1]]></title><description><![CDATA[<img src="images/ble-conn-fig-1.png" target="_self">]]></description><link>images/ble-conn-fig-1.html</link><guid isPermaLink="false">images/ble-conn-fig-1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-conn-fig-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-conn-fig-2]]></title><description><![CDATA[<img src="images/ble-conn-fig-2.png" target="_self">]]></description><link>images/ble-conn-fig-2.html</link><guid isPermaLink="false">images/ble-conn-fig-2.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-conn-fig-2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-conn-fig-3]]></title><description><![CDATA[<img src="images/ble-conn-fig-3.png" target="_self">]]></description><link>images/ble-conn-fig-3.html</link><guid isPermaLink="false">images/ble-conn-fig-3.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-conn-fig-3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble_host_controller]]></title><description><![CDATA[<img src="images/ble_host_controller.png" target="_self">]]></description><link>images/ble_host_controller.html</link><guid isPermaLink="false">images/ble_host_controller.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble_host_controller.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_host_controller.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>