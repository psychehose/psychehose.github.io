<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 215 at column 331: Input is not proper UTF-8, indicate encoding !
Bytes: 0x08 0xEC 0x9D 0xB4
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[psychehose.github.io]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>psychehose.github.io</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 19 Jan 2025 11:57:48 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 19 Jan 2025 11:55:19 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[271. Encode and Decode Strings]]></title><description><![CDATA[<a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.Please implement&nbsp;encode&nbsp;and&nbsp;decodeExample 1:Input: ["neet","code","love","you"] Output:["neet","code","love","you"]
Example 2:Input: ["we","say",":","yes"] Output: ["we","say",":","yes"]
Constraints:
0 &lt;= strs.length &lt; 100
0 &lt;= strs[i].length &lt; 200
strs[i]&nbsp;contains only UTF-8 characters.
이 문제는 인코딩과 디코딩을 디자인하는 문제다. 평소에 푸는 PS와 좀 다른 스타일의 문제였다. 특징은 시간 복잡도는 이여야 하고, 공간 복잡도는 이여야 한다. 그래서 저장하는 멤버변수를 사용할 수 없다. #include &lt;vector&gt;
using namespace std; class Solution {
public: string encode(vector&lt;string&gt;&amp; strs) { string res; for (const auto&amp; c : strs) { res += to_string(c.size()) + "#" + c; } return res; } vector&lt;string&gt; decode(string s) { vector&lt;string&gt; res; int i = 0; while(i &lt; s.size()) { int j = i; while(s[j] != '#') { ++j; } int len = stoi(s.substr(i, j-i)); string sub = s.substr(j+1, len); res.push_back(sub); i = j + len + 1; } return res; }
}; stoi(), substr 사용 방법을 숙지할 수 있었다.]]></description><link>algorithm/leetcode/271.-encode-and-decode-strings.html</link><guid isPermaLink="false">Algorithm/LeetCode/271. Encode and Decode Strings.md</guid><pubDate>Sun, 19 Jan 2025 11:54:09 GMT</pubDate></item><item><title><![CDATA[Swarm Teams]]></title><description><![CDATA[Swarm에 있는 모듈을 만들어야함. module.config.php Swarm이 모듈을 인식하도록 하는 설정 파일
PHP 배열 형태로 이벤트 리스너 바인딩, 서비스 등록 등을 설정합니다. Module.php (이름은 꼭 ‘Module’일 필요는 없지만 일반적으로 많이 사용) Swarm에서 제공하는 다양한 Hook(Listener)나 Config 설정을 등록하고, 실제 기능(웹훅 전송 로직 등)을 구현하는 파일입니다. ]]></description><link>infra/swarm-teams.html</link><guid isPermaLink="false">Infra/Swarm Teams.md</guid><pubDate>Sun, 19 Jan 2025 09:32:38 GMT</pubDate></item><item><title><![CDATA[Linux 명령어]]></title><description><![CDATA[읽기, 쓰기 권한을 다른사용자 (others)에게 부여sudo chmod o+x # 쓰기 권한 cd sudo chmod o+r # 읽기 권한 ls
리눅스 전체 삭제 및 파일 내용 지우기$ gg # 첫번째 줄로 이동
$ dG # 현재부터 끝까지 지움
$ dd #한줄삭제
$ 5dd #현재위치부터 5줄 삭제
로그 보는 방법$ tail -n {몇라인 볼 지 = 수} {log_path}
]]></description><link>tip/linux-명령어.html</link><guid isPermaLink="false">Tip/Linux 명령어.md</guid><pubDate>Sun, 19 Jan 2025 09:32:38 GMT</pubDate></item><item><title><![CDATA[Develop]]></title><description><![CDATA[
목표: Clang으로의 포팅 작업을 성공적으로 마치고, 이 과정에서 컴파일러와 빌드 시스템에 대한 심도 있는 이해를 확보.
학습 내용: 컴파일러 작동 원리: Clang의 컴파일 단계(프론트엔드, 미들엔드, 백엔드), LLVM의 역할.
C++ 표준 호환성: MSVC와 Clang 간 차이점 및 비호환 코드 처리 방법.
빌드 시스템: CMake, Ninja 등으로 프로젝트를 관리하고 디버깅하는 방법.
디버깅과 성능 최적화: Clang의 -fsanitize 옵션, clang-tidy, AddressSanitizer 등 툴 활용. 목표: ROS2와 리눅스 환경에 대한 깊은 이해를 통해 실전 로봇 프로젝트에서 문제를 해결할 수 있는 능력 배양.
학습 내용: ROS2 미들웨어 (DDS): 데이터 통신 구조와 QoS 설정 이해.
리눅스 시스템 프로그래밍: 파일 시스템, 프로세스 관리, IPC(파이프, 메시지 큐 등).
네트워킹: ROS2의 분산 네트워크 구조와 리눅스 소켓 프로그래밍.
디버깅 툴: gdb, valgrind, perf 등을 활용한 로깅과 문제 추적. 목표: RISC-V 또는 ARM ISA를 이해하고, 이를 활용한 최적화나 커스텀 하드웨어 프로젝트에서 차별화된 능력 확보.
학습 내용: 어셈블리 언어: 간단한 프로그램 작성, 디스어셈블 분석.
RISC-V/ARM ISA: 기본 명령어 구조와 실행 원리.
임베디드 개발: 로봇 시스템에서 저전력 및 실시간 프로세싱을 위한 코드 작성.
시뮬레이션과 실습: QEMU, RARS, 또는 실제 임베디드 보드 사용. 컴파일러 (Clang, MSVC) 현재 회사 업무와 직접적으로 연결된 부분이므로, 당면 과제 해결에 집중. 리눅스 및 ROS2 통합 C++ 개발자로서 ROS2와 리눅스를 능숙하게 다루는 것은 장기적으로 중요한 자산. ISA와 어셈블리 로봇의 하드웨어와 소프트웨어를 깊이 이해하고 싶다면 필수적이지만, 단기적으로는 필요성이 낮음. 주간 업무 중심의 학습: 컴파일러와 포팅 작업에 대한 심화 학습.
ROS2와 리눅스 주말 학습: 간단한 ROS2 패키지를 리눅스 환경에서 만들어보고 문제를 해결.
장기 계획으로 ISA 학습: 매주 2~3시간 정도 어셈블리나 ISA 기본 개념 학습. 목표: 가상 환경에서 로봇을 제어하고 경로를 탐색.
구현 요소: ROS를 설치하고 Gazebo에서 TurtleBot3 모델 실행.
ROS Navigation Stack으로 자율 경로 계획. ]]></description><link>hose/develop.html</link><guid isPermaLink="false">Hose/Develop.md</guid><pubDate>Thu, 16 Jan 2025 14:18:35 GMT</pubDate></item><item><title><![CDATA[424. Longest Repeating Character Replacement]]></title><description><![CDATA[<a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> You are given a string&nbsp;s&nbsp;and an integer&nbsp;k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most&nbsp;k&nbsp;times.Return&nbsp;the length of the longest substring containing the same letter you can get after performing the above operations.Example 1:Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.Example 2:Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.Constraints:
1 &lt;= s.length &lt;= 105
s&nbsp;consists of only uppercase English letters.
0 &lt;= k &lt;= s.length
못풀었다. 문제를 봤을 때 슬라이딩 윈도우일 것 같긴 했는데 조건을 생각하지 못했다.window size - max_count &gt; k 를 생각했어야 했다. 이걸 떠올리지 못한 이유가 무엇일까라고 생각해봤을 때, 빈도수 관리를 떠올리지 못해서 그런가 싶다.max_count 최적화에 대한 문제가 있는데 이해하면 간단하지만 이해가 쉽지 않았다. 이해를 힘들게 했는데 댓글을 보니 저렇게 생각하면 더 쉽게 이해할 수 있었을 것 같다.For those who are struggling to understand the optimisation with maxf, here is how i understood it: For a substring to be valid, we need window_length - maxf &lt;= k. Here, maxf is the frequency of the most common character in the current window. The difference window_length - maxf tells us how many characters we'd need to change to make the whole window the same character. The biggest valid substring we can get is of size maxf + k. So, the larger maxf is, the better. If maxf doesn't change or goes down, our potential best answer doesn't change. We don't need to update maxf in this case. On the other hand, if maxf goes up, it means we've found a character in the current window that appears more often than in previous windows. This means we might be able to get a longer valid substring, so we update maxf. Hope this helps! And thank you neetcode for the wonderful video as always.
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std; class Solution {
public: int characterReplacement(string s, int k) { unordered_map&lt;char, int&gt; countmap; int res = 0; int l = 0; for (int r = 0; r &lt; s.size(); ++r) { countmap[s[r]] = 1 + countmap[s[r]]; while((r - l + 1) - most_frequent(countmap) &gt; k) { countmap[s[l]] = countmap[s[l]] - 1; l += 1; } res = max(res, r - l + 1); } } int characterReplacement_opt(string s, int k) { unordered_map&lt;char, int&gt; countmap; int l = 0; int max_len = 0; int max_count = 0; for (int r = 0; r &lt; s.size(); ++r) { countmap[s[r]] = countmap[s[r]] + 1; max_count = max(max_count, countmap[s[r]]); while((r - l + 1) - max_count &gt; k) { countmap[s[l]] = countmap[s[l]] - 1; l += 1; } max_len = max(max_len, r-l+1); } return max_len; } int most_frequent(unordered_map&lt;char, int&gt;&amp; m) { int frequent = 0; for (auto&amp; [k, v] : m) { frequent = max(frequent, v); } }
};
]]></description><link>algorithm/leetcode/424.-longest-repeating-character-replacement.html</link><guid isPermaLink="false">Algorithm/LeetCode/424. Longest Repeating Character Replacement.md</guid><pubDate>Wed, 15 Jan 2025 14:54:13 GMT</pubDate></item><item><title><![CDATA[Jenkins 설치 및 구성]]></title><description><![CDATA[자동화 시스템 구축
젠킨스에서 Java 11은 2024.07.31까지 지원 Deprecated 될 예정
OpenJDK 17로 구성 완료 sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:148) at java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:129) at java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297) at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:383)
Caused: sun.security.validator.ValidatorException: PKIX path building failed at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:388) at java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:271) at java.base/sun.security.validator.Validator.validate(Validator.java:256) at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:230) at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:132) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1302)
Caused: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:130) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:378) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:321) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:316) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1318) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.onConsumeCertificate(CertificateMessage.java:1195) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.consume(CertificateMessage.java:1138) at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:393) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:476) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:447) at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:201) at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:172) at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1506) at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1421) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:455) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:426) at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:586) at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:187) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect0(HttpURLConnection.java:2909) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect(HttpURLConnection.java:2818) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1929) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1599) at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:223) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1321)
Caused: java.io.IOException: Failed to load https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi to C:\ProgramData\Jenkins\.jenkins\plugins\mailer.jpi.tmp at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1332)
Caused: java.io.IOException: Failed to download from https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi (redirected to: https://get.jenkins.io/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1366) at hudson.model.UpdateCenter$DownloadJob._run(UpdateCenter.java:1923) at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:2235) at hudson.model.UpdateCenter$DownloadJob.run(UpdateCenter.java:1897) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) at hudson.remoting.AtmostOneThreadExecutor$Worker.run(AtmostOneThreadExecutor.java:121) at java.base/java.lang.Thread.run(Thread.java:1583)
suncertpathbuilderexception unable to find valid certification path to requested target를 인터넷에 검색했을 때 -Https를 사용하는 웹사이트에 연결을 시도할 때 Java에서 신뢰하는 인증서 목록에 해당 웹사이트의 인증서가 존재하지 않아서 발생하는 문제라고 한다.그래서 예전에 전달받은 인증서를 jdk(jre)/lib/securites/cacert에 keytool 명령어를 이용해 현재 사용하는 자바인증서에 인증서를 넣었음.keytool -importcert -alias {alias name} -keystore "C:\Program Files\Java\jdk-21.0.2\lib\security\cacerts" -storepass changeit -file C:\Users\psyche95\Desktop\CERT\{.cer}
suncertpathbuilderexception unable to find valid certification path to requested target는 해결 되었으나 아래의 문제가 발생java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
검색하니, openjdk에서 발생할 수 있다고 함 -&gt; oracle jdk의 cacert로 교체하면 된다고 해서 교체 -&gt; 같은 에러 반복 cacert 문제가 아님을 확인환경변수 JAVA_HOME 확인-&gt; java8 사용하고 있었음.
JAVA_HOME java21로 변경이로써 플러그인 업데이트 가능하게 됨. + 배치파일 작성 후 빌드 가능그래도 계속 안된다면, java cacert에서 회사 사내 인증서 없애고 JAVA_HOME 설정 다시 할 것java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty at java.base/java.security.cert.PKIXParameters.setTrustAnchors(PKIXParameters.java:200) at java.base/java.security.cert.PKIXParameters.&lt;init&gt;(PKIXParameters.java:120) at java.base/java.security.cert.PKIXBuilderParameters.&lt;init&gt;(PKIXBuilderParameters.java:104) at java.base/sun.security.validator.PKIXValidator.&lt;init&gt;(PKIXValidator.java:94) Caused: java.lang.RuntimeException: Unexpected error
해결한 줄 알았는데, 다시 발생해서 재설치 진행함.jdk 21은 젠킨스에 도입된 지 얼마 되지 않아서 jdk 17로 교체.sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target그냥 check certificate 하지 않는 게 정신건강에 이로울 거 같아서 skip-certificate-check 플러그인을 hpi로 받음. 그러고나서 C:\ProgramData\Jenkins.jenkins\plugins에 직접 hpi를 넣고 설치 젠킨스 재시작이로써 해결 완료되었고 현재까지는 잘 작동함.Unreal Engine4로 작업을 하고 있는데, ugs를 사용하지 않아 개발자가 주기적으로 binary를 depot에 올려줘야 하는 상황 (perforce helix core 사용)아래 batch 파일을 통해 일정 시간에 컴파일하고 만들어진 binary를 submit 함.@echo off
setlocal enabledelayedexpansion set ENGINE_PATH=C:\Users\owner\Perforce\psyche95_GZ-PSYCHE9503_8014\GolfzonMEngine
set PROJECT_PATH=C:\Users\owner\Perforce\psyche95_GZ-PSYCHE9503_8014\WaveM\U2Client_Wave :: 접근 권한 설정
icacls "%ENGINE_PATH%" /grant Everyone:(F)
icacls "%PROJECT_PATH%" /grant Everyone:(F) :: 필요한 폴더와 파일 삭제
echo Deleting unnecessary files and folders...
if exist "%PROJECT_PATH%\.vs" rmdir /s /q "%PROJECT_PATH%\.vs"
if exist "%PROJECT_PATH%\DerivedDataCache" rmdir /s /q "%PROJECT_PATH%\DerivedDataCache"
if exist "%PROJECT_PATH%\Intermediate" rmdir /s /q "%PROJECT_PATH%\Intermediate"
if exist "%PROJECT_PATH%\Saved" rmdir /s /q "%PROJECT_PATH%\Saved"
if exist "%PROJECT_PATH%\U2Client.sln" del /f /q "%PROJECT_PATH%\U2Client.sln" :: Unreal Engine을 이용해 비주얼 스튜디오 프로젝트 파일 생성
echo Generating Visual Studio project files...
"%ENGINE_PATH%\Engine\Binaries\DotNET\UnrealBuildTool.exe" -projectfiles -project="%PROJECT_PATH%\U2Client.uproject" -game -progress
if %errorlevel% neq 0 ( echo Failed to generate Visual Studio project files. curl -X POST -H "Content-type: application/json" --data "{\"text\":\"Failed to generate Visual Studio project files\", \"channel\":\"#dev_build\"}" "https://hooks.slack.com/services/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" exit /b %errorlevel%
) :: 비주얼 스튜디오를 이용해 U2Client.sln 빌드
echo Building the U2Client.sln...
"C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\Common7\IDE\devenv.com" "%PROJECT_PATH%\U2Client.sln" /Build "Development Editor|Win64" /Project "U2Client"
echo Errorlevel after build: %errorlevel%
if %errorlevel% neq 0 ( echo Build process failed, checking log... curl -X POST -H "Content-type: application/json" --data "{\"text\":\"Build process failed\", \"channel\":\"#dev_build\"}" "https://hooks.slack.com/services/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" exit /b %errorlevel%
) :: 변경된 PDB 및 DLL 파일 검사 및 Perforce로 체크아웃
pushd "%PROJECT_PATH%\Binaries\Win64"
set CHANGES_EXIST=
for %%f in (*.pdb *.dll) do ( :: 파일 접미사 체크 및 변경 검사 echo %%f | findstr /R /C:".*-[0-9][0-9][0-9][0-9]\." &gt; nul if errorlevel 1 ( :: 파일이 마지막으로 변경된 시간 가져오기 for /f "tokens=2 delims==" %%t in ('wmic datafile where name^="%%f" get lastmodified /value') do set LASTMOD=%%t :: Perforce에 저장된 파일의 수정 시간 비교 p4 -u psyche95 fstat -T headTime %%f | findstr /C:"headTime" set HEADTIME=!headTime! if "!LASTMOD:~0,14!" neq "!HEADTIME!" ( set CHANGES_EXIST=true p4 -u psyche95 edit %%f ) )
)
popd :: 변경점이 있으면 제출하고, 없으면 되돌리기
if defined CHANGES_EXIST ( echo Changes detected. Submitting to Perforce... p4 -u psyche95 submit -d "automate submit"
) else ( echo No changes detected. Reverting changes... pushd "%PROJECT_PATH%\Binaries\Win64" for %%f in (*.pdb *.dll) do ( p4 -u psyche95 revert %%f ) popd
) echo Finished: SUCCESS ]]></description><link>infra/jenkins-설치-및-구성.html</link><guid isPermaLink="false">Infra/Jenkins 설치 및 구성.md</guid><pubDate>Wed, 15 Jan 2025 12:54:31 GMT</pubDate></item><item><title><![CDATA[Jenkins 안드로이드 패키징]]></title><description><![CDATA[
Jenkins는 JAVA 11 지원 X -&gt; JDK 17
@echo off
setlocal enabledelayedexpansion :: Java 11 Setting -
set JAVA_HOME=C:\Program Files\Android\Android Studio\jre
set PATH=%JAVA_HOME%\bin;%PATH%
set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
:: Gradle 설정
set GRADLE_USER_HOME=%USERPROFILE%\.gradle_java11
:: Java 옵션 설정
set _JAVA_OPTIONS=-Djava.specification.version=11 :: 기본 경로 설정
set ENGINE_PATH=D:\Develop\GolfzonMEngine
set PROJECT_PATH=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client
set PROJECT_NAME=U2Client
set OUTPUT_DIR=C:\Users\psyche95\Desktop\Golfzon\M_Packaging :: Android SDK 및 NDK 설정
set ANDROID_HOME=C:\Users\psyche95\AppData\Local\Android\Sdk
set ANDROID_NDK_PATH=%ANDROID_HOME%\ndk\25.2.9519653
set NDKROOT=%ANDROID_NDK_PATH% :: 출력 폴더 설정
for /f "tokens=2 delims==" %%I in ('wmic os get localdatetime /value') do set TIMESTAMP=%%I
set NEW_OUTPUT_DIR=%OUTPUT_DIR%\Build_Android_%TIMESTAMP:~0,8%_%TIMESTAMP:~8,6% :: 필요한 디렉토리 생성
if not exist "%NEW_OUTPUT_DIR%" mkdir "%NEW_OUTPUT_DIR%" :: 프로젝트 파일 확인
if not exist "%PROJECT_PATH%\%PROJECT_NAME%.uproject" ( echo Error: Project file not found! exit /b 1
) echo Starting Android packaging for %PROJECT_NAME%... :: Project Build
call "%ENGINE_PATH%\Engine\Build\BatchFiles\RunUAT.bat" ^
BuildCookRun ^
-nocompileeditor ^
-installed -nop4 ^
-project=%PROJECT_PATH%\%PROJECT_NAME%.uproject ^
-cook -stage -archive -archivedirectory="%NEW_OUTPUT_DIR%" ^
-package ^
-ue4exe="%ENGINE_PATH%\Engine\Binaries\Win64\UE4Editor-Cmd.exe" ^
-compressed ^
-ddc=InstalledDerivedDataBackendGraph ^
-pak ^
-prereqs ^
-targetplatform=Android -cookflavor=ASTC ^
-build ^
-CrashReporter ^
-target=%PROJECT_NAME% ^
-clientconfig=Development ^
-utf8output ^
-AndroidSDK="%ANDROID_HOME%" ^
-AndroidNDK="%NDKROOT%" if %ERRORLEVEL% neq 0 ( echo Error: Build failed with exit code %ERRORLEVEL% exit /b %ERRORLEVEL%
) echo Android packaging completed successfully.
echo Output directory: %NEW_OUTPUT_DIR%
exit /b 0 -nocompileeditor: 에디터 컴파일을 건너뜀 -installed: 엔진 바이너리로 빌드 -nop4: Perforce 연동을 비활성화 -project: 프로젝트 파일의 경로를 지정 -cook: 콘텐츠 쿠킹을 수행 -stage: 패키징된 게임을 스테이징 디렉토리로 복사 -archive: 패키지된 게임을 아카이브 -archivedirectory: 아카이브 디렉토리를 지정 -package: 게임을 패키징 -ue4exe: 사용할 UE4 Editor 실행 파일의 경로를 지정 -compressed: 패키지를 압축 -ddc: 사용할 파생 데이터 캐시(DDC) 설정을 지정 DDC는 파생 데이터 캐시를 의미합니다. 이는 에셋 처리 결과를 저장하는 캐시 시스템입니다. 예를 들어, 텍스처의 압축 버전이나 머티리얼의 컴파일된 버전 등이 여기에 저장됩니다. DDC를 사용하면 에셋 처리 시간을 줄이고, 여러 사용자 간에 처리된 데이터를 공유할 수 있습니다. -pak: 콘텐츠를 PAK 파일로 패키징 -prereqs: 필요한 선행 요구사항을 포함 -targetplatform: 대상 플랫폼을 Android로 설정 -cookflavor: 쿠킹 설정을 ASTC(텍스처 압축 형식)로 지정 -build: 코드를 빌드 -CrashReporter: 크래시 리포터를 포함 -target: 빌드할 프로젝트 이름을 지정 -clientconfig: 클라이언트 구성을 Development or Shipping -utf8output: 출력을 UTF-8로 인코딩 -AndroidSDK: Android SDK 경로를 지정 -AndroidNDK: Android NDK 경로를 지정 Execution of commandlet took: 123.49 seconds LogShaderCompilers: Display: === FShaderJobCache stats === LogShaderCompilers: Display: Total job queries 0, among them cache hits 0 (0.00%) LogShaderCompilers: Display: Tracking 0 distinct input hashes that result in 0 distinct outputs (0.00%) LogShaderCompilers: Display: RAM used: 0.00 MB (0.00 GB) of 1638.40 MB (1.60 GB) budget. Usage: 0.00% LogShaderCompilers: Display: ================================================ LogShaderCompilers: Display: Shaders left to compile 0 LogShaderCompilers: Display: Shaders left to compile 0 OptickLog: Display: OptickPlugin UnLoaded! LogHttp: Display: cleaning up 0 outstanding Http requests. LogContentStreaming: Display: There are 1 unreleased StreamingManagers
Took 140.1294547s to run UE4Editor-Cmd.exe, ExitCode=0
********** COOK COMMAND COMPLETED **********
********** BUILD COMMAND STARTED **********
Running: D:\Develop\GolfzonMEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe U2Client Android Development -Project=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject -Manifest=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Manifest.xml -nobuilduht -NoHotReload -xgeexport C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject -NoUBTMakefiles -remoteini="C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client" -skipdeploy -log="C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UBT-U2Client-Android-Development.txt" Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client Adjust SDK found in C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Plugins\Adjust\Source\Adjust\../ThirdParty/Android Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client D:\Develop\GolfzonMEngine\Engine\Source\Runtime\Engine\Engine.Build.cs: warning: Referenced directory 'D:\Develop\GolfzonMEngine\Engine\Source\Launch\Public' does not exist. PLATFORM_ANDROID_NDK_VERSION = 250300 NDK toolchain: r25c, NDK version: 33, GccVersion: 4.9, ClangVersion: 14.0.7 Parsing headers for U2Client Running UnrealHeaderTool "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject" "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Android\U2Client\Development\U2Client.uhtmanifest" -LogCmds="loginit warning, logexit warning, logdatabase error" -Unattended -WarningsAsErrors -abslog="C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UHT-U2Client-Android-Development.txt" -installed LogInit: Display: Loading text-based GConfig.... Reflection code generated for U2Client in 3.4027725 seconds Compiling Native 64-bit code with NDK API 'android-33' Writing manifest to C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Manifest.xml XGEEXPORT: Exported 'D:\Develop\GolfzonMEngine\Engine\Intermediate\Build\UBTExport.000.xge.xml' Total execution time: 6.14 seconds
Took 6.2589684s to run UnrealBuildTool.exe, ExitCode=0
Running: C:\Program Files (x86)\Incredibuild\xgConsole.exe "C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread Fatal Error: File not found: C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml
Took 0.0520074s to run xgConsole.exe, ExitCode=3
BUILD FAILED: Command failed (Result:3): C:\Program Files (x86)\Incredibuild\xgConsole.exe "C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread. See logfile for details: 'xgConsole-2024.07.31-10.14.49.txt'
AutomationTool exiting with ExitCode=1 (Error_Unknown)
Error: AutomationTool execution failed. Check log: C:\Windows\system32\config\systemprofile\UnrealEngine\BuildTemp\UAT_Log.txt
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE
인크레디빌드 사용시에 패키징 에러가 발생함.
로그에서 실패한 이유가 File Not found인데 실제 경로에 가보니 해당 파일이 있었다.
그래서 권한을 주는 등 다양한 방법을 적용해봤으나 계속해서 같은 이유로 실패했다.인크레디빌드 Agent를 끄고 패키징을 하면 Incredibuild 관련 부분을 통과할 수 있었다. 또는 RunUAT 실행 인자에 -noxge를 추가해도 Incredibuild가 꺼져서 관련 부분을 통과할 수 있었다. 이를 통해, Incredibuild 관련 이슈라 판단하고 incredibuild support에 질문함.<img alt="inc_support.png" src="images/inc_support.png" target="_self">윈도우 젠킨스 설치시에 Windows Service에 등록된다.젠킨스를 이용해서 빌드를 할 때 Window Service에 등록된 사용자로 빌드를 하는데 기본 값이 SYSTEM 사용자다. 그래서 이를 바꿔줘야한다.WIN + R를 누르고 services.msc를 입력해서 서비스를 연다.Jenkins Service를 돌릴 윈도우 계정이 필요한데 회사 도메인을 이용한 사내아이디를 사용 해야했다.Jenkins - 속성 - 로그온 - 찾아보기
아이디 검색 - 비밀번호 입력하고 젠킨스 중지C:\Program Files\Jenkins 로 이동해서 jenkins.xml을 수정한다. xml을 열어서 &lt;arguments&gt; 있는 곳에 다음 값을 추가한다. (젠킨스 서비스가 시작할 때 domain 아이디로 로그인 하겠다고 알려줘야함)&lt;arguments&gt;-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar "C:\Program Files\Jenkins\jenkins.war" --httpPort=12000 --webroot="%ProgramData%\Jenkins\war --serviceLogonAccount={yourdomain\yourid} --serviceLogonPassword={your_passward}"&lt;/arguments&gt;
domain과 id를 하는 법은 cmd를 열고 whoami 입력<br><img alt="whoami.png" src="images/whoami.png" target="_self">젠킨스 다시 시작하고 젠킨스 빌드시에 Incredibuild에서 에러나는 부분을 넘어갈 수 있다. ====2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so.
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png.
[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)
Making .apk with Gradle...
To honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).
Daemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:
Build file 'Z:\build.gradle' line: 14 * What went wrong:
A problem occurred evaluating root project 'app'.
&gt; Could not open dsl generic class cache for script 'Z:\buildscriptAdditions.gradle' (C:\Users\psyche95\.gradle\caches\7.5\scripts\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:
&gt; Run with --stacktrace option to get the stack trace.
&gt; Run with --info or --debug option to get more log output.
&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)
* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s
ERROR: cmd.exe failed with args /c "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\rungradle.bat" :app:assembleDebug (see C:\Users\psyche95\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\Log.txt for full exception trace)
AutomationTool exiting with ExitCode=1 (Error_Unknown)
BUILD FAILED
Error: Build failed with exit code 1
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE
Dataview (inline field '===2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so.
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png.
[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)
Making .apk with Gradle...
To honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).
Daemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:
Build file 'Z:\build.gradle' line: 14 * What went wrong:
A problem occurred evaluating root project 'app'.
&gt; Could not open dsl generic class cache for script 'Z:\buildscriptAdditions.gradle' (C:\Users\psyche95\.gradle\caches\7.5\scripts\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:
&gt; Run with --stacktrace option to get the stack trace.
&gt; Run with --info or --debug option to get more log output.
&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)
* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s
ERROR: cmd.exe failed with args /c "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\rungradle.bat" :app:assembleDebug (see C:\Users\psyche95\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\Log.txt for full exception trace)
AutomationTool exiting with ExitCode=1 (Error_Unknown)
BUILD FAILED
Error: Build failed with exit code 1
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE'): Error: -- PARSING FAILED -------------------------------------------------- &gt; 1 | ===2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64=========================================== | ^ 2 | Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so. 3 | Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png. Expected one of the following: '(', 'null', boolean, date, duration, file link, list ('[1, 2, 3]'), negated field, number, object ('{ a: 1, b: 2 }'), string, variable
젠킨스 설정시에 java 버전을 21로 올렸기 때문에 발생하는 에러다. 현재 gradle 7.5를 사용하고 있는데 gradle 7.5가 지원하는 상방은 java 18이다. 그래서 패키징시에 명시적으로 java 11 path를 넣고 패키징을 했다.
:: batch 파일 상단 :: Java 11 Setting -
set JAVA_HOME=C:\Program Files\Android\Android Studio\jre
set PATH=%JAVA_HOME%\bin;%PATH%
set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
:: Gradle 설정
set GRADLE_USER_HOME=%USERPROFILE%\.gradle_java11
:: Java 옵션 설정
set _JAVA_OPTIONS=-Djava.specification.version=11 ]]></description><link>infra/jenkins-안드로이드-패키징.html</link><guid isPermaLink="false">Infra/Jenkins 안드로이드 패키징.md</guid><pubDate>Wed, 15 Jan 2025 12:54:13 GMT</pubDate><enclosure url="images/inc_support.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/inc_support.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. Longest Substring Without Repeating Characters]]></title><description><![CDATA[<a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a>Given a string&nbsp;s, find the length of the&nbsp;longest&nbsp;substring&nbsp;without repeating characters.Example 1:Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.Example 2:Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.Example 3:Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.Constraints:
0 &lt;= s.length &lt;= 5 * 104
s&nbsp;consists of English letters, digits, symbols and spaces.
내 답시간복잡도 - find, erase = 공간복잡도 class Solution {
public: int lengthOfLongestSubstring(string s) { size_t result = 0; string sub_s; for (size_t i = 0; i &lt; s.size(); ++i) { if (auto p = sub_s.find(s[i]); p != string::npos) { // find result = max(result, sub_s.size()); sub_s.erase(0,p + 1); } sub_s += s[i]; } return max(result, sub_s.size()); }
};
neetcode 답Sliding window using set시간복잡도 공간복잡도 class Solution {
public: int lengthOfLongestSubstring(string s) { unordered_set&lt;char&gt; charSet; int l = 0; int res = 0; for (int r = 0; r &lt; s.size(); r++) { while (charSet.find(s[r]) != charSet.end()) { charSet.erase(s[l]); l++; } charSet.insert(s[r]); res = max(res, r - l + 1); } return res; }
};
]]></description><link>algorithm/leetcode/3.-longest-substring-without-repeating-characters.html</link><guid isPermaLink="false">Algorithm/LeetCode/3. Longest Substring Without Repeating Characters.md</guid><pubDate>Tue, 14 Jan 2025 13:54:54 GMT</pubDate></item><item><title><![CDATA[55. Jump Game]]></title><description/></item><item><title><![CDATA[62. Unique Paths]]></title><description><![CDATA[There is a robot on an&nbsp;m x n&nbsp;grid. The robot is initially located at the&nbsp;top-left corner&nbsp;(i.e.,&nbsp;grid[0][0]). The robot tries to move to the&nbsp;bottom-right corner&nbsp;(i.e.,&nbsp;grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers&nbsp;m&nbsp;and&nbsp;n, return&nbsp;the number of possible unique paths that the robot can take to reach the bottom-right corner.The test cases are generated so that the answer will be less than or equal to&nbsp;2 * 109.Example 1:<img alt="robot_maze.png" src="images/robot_maze.png" target="_self">Input: m = 3, n = 7
Output: 28Example 2:Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner 1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down#include &lt;vector&gt; class Solution {
public: int uniquePaths(int m, int n) { // dp 초기화 std::vector&lt;std::vector&lt;int&gt;&gt; dp(m, std::vector&lt;int&gt;(n,1)); for (std::vector&lt;std::vector&lt;int&gt;&gt;::size_type r = 1; r &lt; dp.size(); ++r) { for (std::vector&lt;int&gt;::size_type c = 1; c &lt; dp[r].size(); ++c) { dp[r][c] = dp[r-1][c] + dp[r][c-1]; } } return dp[m-1][n-1]; }
};
]]></description><link>algorithm/blind75/62.-unique-paths.html</link><guid isPermaLink="false">Algorithm/blind75/62. Unique Paths.md</guid><pubDate>Sun, 05 Jan 2025 10:22:11 GMT</pubDate><enclosure url="images/robot_maze.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/robot_maze.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[robot_maze]]></title><description><![CDATA[<img src="images/robot_maze.png" target="_self">]]></description><link>images/robot_maze.html</link><guid isPermaLink="false">images/robot_maze.png</guid><pubDate>Sun, 05 Jan 2025 08:12:34 GMT</pubDate><enclosure url="images/robot_maze.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/robot_maze.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[70. Climbing Stair]]></title><description><![CDATA[You are climbing a staircase. It takes&nbsp;n&nbsp;steps to reach the top.Each time you can either climb&nbsp;1&nbsp;or&nbsp;2&nbsp;steps. In how many distinct ways can you climb to the top?Example 1:Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1 step + 1 step
2 steps
Example 2:Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1 step + 1 step + 1 step
1 step + 2 steps
2 steps + 1 step
Constraints:
1 &lt;= n &lt;= 45
점화식으로 해결class Solution {
public: int climbStairs(int n) { if (n == 1) return 1; std::vector&lt;int&gt; dp { 1, 2 }; dp.reserve(n); for (int i = 2; i &lt; n; ++i) { dp.push_back(dp[i-1] + dp[i-2]); } return *(dp.end() - 1); }
};
]]></description><link>algorithm/blind75/70.-climbing-stair.html</link><guid isPermaLink="false">Algorithm/blind75/70. Climbing Stair.md</guid><pubDate>Fri, 03 Jan 2025 16:39:39 GMT</pubDate></item><item><title><![CDATA[Visitor Pattern]]></title><description><![CDATA[기존의 SFML에서는 멤버 변수 sf::Event::EventType을 확인해서 각 이벤트를 처리 했었다. 내가 사용하는 3.0 버전에서는 이벤트를 visitor를 이용해서 처리 한다. Visitor 패턴은 객체 구조와 처리를 분리하는 디자인 패턴. 즉 '다른 클래스에 있는 알고리즘을 가져와서 실행할 수 있게 해주는 패턴'임 // 기존 방식 (이제 지원하지 않음)
if (event.type == sf::Event::Closed) { window.close();
} // Visitor 패턴 사용 (새로운 방식)
event.visit([&amp;window](const sf::Event::Closed&amp;) { window.close();
}); 컴파일 타임 검사: 잘못된 이벤트 타임에 접근하는 것을 방지하고 타입 불일치 오류를 컴파일 단계에서 발견할 수 있다. 기존의 방식을 사용하면 아래처럼 런타임에서 에러를 잡을 수 있다.
// 기존
if (event.type == sf::Event::MouseMoved) { // 실수로 KeyPressed의 데이터를 사용하려고 하면... bool isShiftPressed = event.key.shift; // 잘못된 메모리 접근
} // visitor
event.visit([](const sf::Event::MouseMoved&amp; mouse) { // mouse.position만 사용할 수 있음 // 다른 이벤트의 멤버는 접근 불가능
}); 코드 가독성: 중첩 if문, switch문 없음. 각 이벤트 타입별 처리가 원활
유지보수 좋음: 기존 코드 수정하지 않고 새로운 핸들러 추가가 쉬움
sf:Event 클래스를 확인하면 클래스 내에 struct으로 각 이벤트가 정의 되어 있다. 그리고 내부 변수에 private로 m_data를 가지고 있다.
이 m_data의 타입은 std::variant&lt;Closed, Resized, FocusLost, /*...*/ &gt; 이다.std::variant는 여러 타입 중 하나를 저장할 수 있는 type-safe union이다. 그렇다면 어떻게 SFML에서 m_data와 visit을 통해서 이벤트를 처리할까?이를 이해하기 위해 먼저 std::variant와 std::visit의 관계와 사용법에 대해 알아야만 한다.// 기본구조 // Variant: 여러 타입 중 하나를 저장할 수 있는 컨테이너
std::variant&lt;A, B, C&gt; data;
// Visitor: variant에 저장된 데이터를 처리하는 방법
auto visitor = [](const auto&amp; value) { /* 처리 로직 */ }; // 동작 방식
// 1. variant가 데이터 저장
std::variant&lt;int, std::string&gt; data = 42;
// 2. visitor가 데이터 처리
std::visit([](const auto&amp; value) { using T = std::decay_t&lt;decltype(value)&gt;; if constexpr (std::is_same_v&lt;T, int&gt;) { std::cout &lt;&lt; "정수 처리: " &lt;&lt; value &lt;&lt; std::endl; } else if constexpr (std::is_same_v&lt;T, std::string&gt;) { std::cout &lt;&lt; "문자열 처리: " &lt;&lt; value &lt;&lt; std::endl; }
}, data);
using T = std::decay_t&lt;decltype(value)&gt; 에서 decltype(value)는 value의 정확한 타입을 추론하고 std::decay_t는 참조와 const를 제거한 순수한 타입을 얻는다. 위 코드에서 const int&amp;는 int로 변환된다.이렇게 얻은 타입 T로 컴파일 타임에 타입 체크를 수행한다.if constexpr (std::is_same_v&lt;T, int&gt;) { // int 타입일 때의 처리
}
else if constexpr (std::is_same_v&lt;T, std::string&gt;) { // string 타입일 때의 처리
}
위의 예시와 같이std::variant 과 std::visit를 이용하면 컴파일 타임에서 안전하게 타입을 추론할 수 있고 각 타입마다 처리를 하기 용이 해진다는 장점을 알 수 있다.Window::pollEvnet() 를 호출하면 m_data가 변경된다.//SFML Event 내부 구현
template &lt;typename TEventSubtype&gt; Event::Event(const TEventSubtype&amp; eventSubtype)
{ static_assert(isEventSubtype&lt;TEventSubtype&gt;, "TEventSubtype must be a subtype of sf::Event"); if constexpr (isEventSubtype&lt;TEventSubtype&gt;) m_data = eventSubtype;
}
// SFML Event 내부 구현
class Event {
public: // visitor 패턴을 이용한 이벤트 처리 template &lt;typename T&gt; auto visit(T&amp;&amp; visitor) const { // visitor는 람다함수 or 함수 객체 return std::visit(std::forward&lt;T&gt;(visitor), m_data); }
};
여기에서 Visitor 패턴의 핵심 동작이 일어난다. Event::visit 함수는 std::visit의 단순 래퍼다.
std::forward&lt;T&gt;를 통해 visitor (람다나 함수 객체) 를 perfect 전달한다. 따라서 m_data와 visitor를 통해서 각 이벤트에 대해서 처리를 할 수 있게 된다.void Simulator::handleEvents() {
if (auto event = window.pollEvent()) { event-&gt;visit([this](const auto&amp; e) { using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }); }
}
이 코드가 실행될 때 내부적으로 아래와 같은 과정이 일어난다.
람다 함수가 Event::visit에 전달
Event::visit은 람다 함수를 std::visit으로 전달
std::visit은 m_data에 저장된 실제 타입을 확인하고 람다를 호출 한다.
이걸 좀 풀어서 설명하면 아래처럼 코드가 실행되는 것이다.std::visit( [this](const auto&amp; e) { // 여기서 e는 variant에 저장된 실제 타입의 참조 using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }, m_data // variant 객체 전달
);
struct EventVisitor { Simulator&amp; simulator; // 참조를 저장 // 특정 이벤트용 처리기 void operator()(const sf::Event::Closed&amp; event) { simulator.window.close(); } void operator()(const sf::Event::KeyPressed&amp; event) { ... } // 다른 모든 이벤트를 처리하는 템플릿 template&lt;typename T&gt; void operator()(const T&amp; event) {}
};
void Simulator::handleEvents() { if (auto event = window.pollEvent()) { event-&gt;visit(EventVisitor{*this}); }
} 객체를 만들고 operator()를 구현하면 객체를 함수처럼 사용할 수 있다.EventVisitor visitor; visitor(something);
내부적으로는 위의 람다 함수의 경우와 사실 거의 같다. 람다 함수 대신에 함수 객체를 넘겨주는 것이 차이점이다. 그리고 기본적으로 std::visit은 variant에 저장된 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다
event-&gt;visit(EventVisitor{*this}); 호출 한다.
Event::visit은 std::visit에 함수 객체와, m_data를 전달한다.
std::visit은 m_data(variant)를 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다.
]]></description><link>golf-simulator/visitor-pattern.html</link><guid isPermaLink="false">Golf Simulator/Visitor Pattern.md</guid><pubDate>Fri, 03 Jan 2025 15:33:44 GMT</pubDate></item><item><title><![CDATA[Resume]]></title><description><![CDATA[Not Yet..]]></description><link>hose/resume/resume.html</link><guid isPermaLink="false">Hose/Resume/Resume.canvas</guid><pubDate>Tue, 31 Dec 2024 09:30:05 GMT</pubDate></item><item><title><![CDATA[ Home]]></title><description><![CDATA[개발을 진행하면서 공부하는 내용을 포스팅 합니다.
Clang++
Vision
Robotics
Game Engine
Graphics C++, Swift, Objective-C, RxSwift Git, Perforce, Jenkins
Unreal Engine CMake Email: <a data-tooltip-position="top" aria-label="mailto:psychehose@gmail.com" rel="noopener nofollow" class="external-link" href=".html" target="_self">psychehose@gmail.com</a>
<br>GitHub: <a data-tooltip-position="top" aria-label="https://github.com/psychehose" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose" target="_self">psychehose</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 31 Dec 2024 09:29:18 GMT</pubDate></item><item><title><![CDATA[Modeling]]></title><description><![CDATA[수학을 배운 경험이 있다면 x^2&nbsp; + y^2 = 1 형태의 식을 본 적이 있을 것이다. 이러한 형태를 음함수라고 하는데 GPU는 음함수를 잘 처리하지 못한다. 그러면 어떻게 하느냐? 평면의 점을 샘플링해서 Polygon Mesh로 만든다. (샘플링을 한다는 것은 정점과, 법선 벡터를 잘 뽑는 것을 의미한다.)어떤 물체가 있고 이를 잘 샘플링해서 폴리곤 메쉬로 만들었다. 이렇게 만들어진 메쉬를 컴퓨터(?)는 어떻게 저장을 하는 지 알아보자.<img src="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">t1, t2, t3라는 삼각형 메쉬가 존재한다. 이를 메모리에 저장을 하는 방법은 간단하다. 좌표를 그냥 배열에 때려넣으면 된다. 때려 넣고 나니 문제점이 있는 것 같다.&nbsp; vertex array를 보면 중복되는 것이 많다는 것을 알 수 있다. 낭비가 심하다. 그래서 위와 같이 저장하지 않는다. 문제를 해결하기 위해 인덱스를 추가해 보자.<br><img src="https://blog.kakaocdn.net/dn/bB6wFv/btstk41D2xI/WHrJSexTiosKNTGHhMQe40/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">각 정점들에 index를 줘서 해결하면 더 빠르게 처리할 수 있다.3ds Max와 같은 모델링 프로그램을 이용해서 export를 하면 .obj 파일을 얻을 수 있다. 간단한 구를 모델링해서 export를 해서 열면 어떤 데이터가 들어 있을까?구는 26개의 정점과 48개의 삼각형으로 이뤄져 있다.<br><img src="https://blog.kakaocdn.net/dn/d3DpsC/btstkTy9Ufk/3TFup6zSfeHakZy5345wc1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">v는 Vertex를 의미하고, 숫자는 순서대로 x, y, z이다.vn는 Vertex Noraml을 의미하고 숫자는 순서대로 x, y, z이다.f는 face를 의미하고 v // vn 을 의미한다. (구는 v와 vn이 1:1로 대응하지만, 직육면체와 같은 입체에서는 vn이 중복될 수 있다.)<br><img src="https://blog.kakaocdn.net/dn/1Vyde/btsth6yLCPq/GbVkDxpfn73pFLdUo44HZ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">.obj를 Import 하게 되면 메모리는 위와 같이 저장된다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.kocw.net/home/search/kemView.do?kemId=1349173" target="_self">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>]]></description><link>graphics/modeling.html</link><guid isPermaLink="false">graphics/Modeling.md</guid><pubDate>Tue, 31 Dec 2024 06:02:33 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[컴퓨터 그래픽스 기초와 수학]]></title><description><![CDATA[컴퓨터 그래픽스는 3D 인풋을 받아 2D 공간에 표현하는 것에 대한 학문이다.컴퓨터 그래픽스의 Production는 5단계로 나눌 수 있다.<img src="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Modeling은 Polygon Mesh로 형태를 만드는 작업과 질감 처리 같은 Texture를 만드는 작업을 말한다.Rigging은 뼈대를 만들고 Polygon Mesh와 관계를 만드는 작업을 말한다.Animation은 Rigging를 통해 만들어진 관계들을 시퀀스로 만들어 실제로 움직이는 것처럼 보이게 만드는 작업이다.Rendering은 3차원에 있는 Scene을 2차원 Scene으로 나타내는 과정이다. 여기에서 중요한 이슈는 텍스쳐와 빛을 처리하는 것이다.Post-Processing는 후처리를 해서 좀 더 사실적으로 보이게 하는 작업이다. 필수 작업은 아니다.1번 ~ 3번의 작업은 그래픽 아티스트가 작업하고 4번 ~ 5번은 컴퓨터 프로그램이 처리한다.<br><img src="https://blog.kakaocdn.net/dn/mFeAO/btstpF7SkJM/2hgcK3ZnsHKFQ7ORXIcLN1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">일반적으로 게임의 하단에 Unity와 Unreal과 같은 게임엔진이 있고 게임 엔진에서 Graphics API를 사용한다. Graphics API에는 DirectX, Vulkan, OpenGL, Metal 등이 있다. Graphics API는 GPU를 구동하기 위한 추상화 되어 있는 인터페이스다.그래픽스 분야에서는 기본적으로 선형대 수학을 정말 많이 사용하는 것 같다.&nbsp;Line, Ray, and Linear Interpolation<br><img src="https://blog.kakaocdn.net/dn/QVQu5/btstqsArCYv/IB9YYR1LMmXpo37iJ5BsY0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">t의 범위에 따라서 p(t)를 부르는 이름이 달라진다.t의 범위가 -inf &lt; t &lt; inf 인 경우 Infinite linet의 범위가 0 &lt;= t &lt; inf 인 경우 Rayt의 범위가 0 &lt;= t &lt;= 1 인 경우 Line segmentp(t)에 대한 식을 풀어쓰면 Line segment는 p0과 p1의 Line interpolation과 대응한다는 것을 알 수 있다.<br><img src="https://blog.kakaocdn.net/dn/bTDV50/btstpCQPsfu/XuWI7yGFk88ChA1GK782NK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이것이 의미하는 바는 p0와 p1 사이에 위치하는 값을 양 끝점의 값으로 추정할 수 있다는 것이다.(선형보간법)<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.kocw.net/home/search/kemView.do?kemId=1349173" target="_self">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>]]></description><link>graphics/컴퓨터-그래픽스-기초와-수학.html</link><guid isPermaLink="false">graphics/컴퓨터 그래픽스 기초와 수학.md</guid><pubDate>Tue, 31 Dec 2024 06:01:51 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LINQ]]></title><description><![CDATA[Swift에서&nbsp; map(), filter() 같은&nbsp;고차함수를 많이 사용했었어요. C#으로 처음 PS를 풀 때 map을 사용하고 싶어서 c# map function으로 구글링 했을 때&nbsp; LINQ의 Select() 메서드를 사용하라고 하더군요. 'Select이 뭐지?' 했는데 데이터베이스 시간에 SQL로 열심히 실습할 때 나오는 그 select가 동일합니다. 그럼 LINQ가 뭘까요?LINQ는 Language-Integrated Query의 준말로 C#에서 직접 쿼리 기능을 통합하는 방식을 기반으로 하는 기술 이름이에요. 일반적으로 쿼리는 특수화된 쿼리 언어로 표현되어요. 예를 들면 관계형 데이터베이스에서는 SQL, XML에서는 XQuery가 사용됩니다. 그래서 하나의 형식을 사용할 때마다 하나의 쿼리 언어를 학습할 필요가 생기는 거죠. 그래서 LINQ가 등장하게 되었어요. LINQ는 다양한 데이터 소스 및 다양한 형식에 사용할 수 있는 일관된 모델을 제공합니다. 모든 형식에서 같은 방식으로 데이터를 쿼리하고 변환할 수 있게 됩니다.&nbsp;LINQ는 쿼리군요.&nbsp; 그럼 쿼리는 무엇일까요?&nbsp;
쿼리는 데이터 소스에서 검색할 데이터 및 반환된 데이터에 필요한 모양과 구성을 설명하는 지침 집합이다.
쉽게 풀면 쿼리는 데이터 소스에서 데이터를 검색(추출)하는 식입니다. (쿼리를 통해 검색된 결과가 아님을 주의)C#에서 쿼리(LINQ)를 어떻게 이용할 수 있을까요?&nbsp; LINQ는 세가지 작업으로 구성됩니다!1.&nbsp; 데이터 소스 가져오기 쿼리 만들기 쿼리 실행 데이터 소스는 말 그대로 우리가 쿼리하고 싶은 데이터 모음입니다. 단 쿼리 변수의 타입이&nbsp;IEumerable 또는 IQueryable이므로 이것을 두 타입 중 하나를 컨펌해야만 합니다.&nbsp;List와 Array와 같은 컬렉션 타입은 IEnumerable을 컨펌하고 있기 때문에 데이터 소스로 사용할 수 있어요. 또 관계형 데이터 베이스나, XML과 같은 것들을 IEumerable 또는 IQueryable로 로드를 하거나 맵핑을 해서 데이터 소스로 사용할 수 있습니다.// Array int[] numbers = new int[7] { 0,1,2,3,4,5,6 }; IEumerable&lt;int&gt; numQuery = from number in numbers where (number % 2) == 0 select number;
// LINQ to XML
// Create a data source from an XML document.
// using System.Xml.Linq;
XElement contacts = XElement.Load(@"c:\myContactList.xml"); IQueryable&lt;Contract&gt; contractQuery = from contract in contracts where ... select ...
// LINQ to SQL Mapping Northwnd db = new Northwnd(@"c:\northwnd.mdf"); // Query for customers in London.
IQueryable&lt;Customer&gt; custQuery = from cust in db.Customers where cust.City == "London" select cust;
이제 쿼리 변수를 만들겠습니다.쿼리 변수를 만드는 방법은 두가지가 있습니다. 쿼리 구문을 이용해서! 메서드 구문을 이용해서! 그럼 1번 2번을 두개 다 연습을 해볼게요. 연습을 하기 전에 데이터 소스를 먼저 만들어줍시다.// Teacher.cs public class Teacher
{ public string Name { get; set; } public int ID { get; set; } public decimal Salary { get; set; } public Teacher(string name, int id, decimal salary) { Name = name; ID = id; Salary = salary; }
} // Student.cs public class Student
{ public string Name { get; set; } public int ID { get; set; } public List&lt;int&gt; scroes { get; set; } public Student(string name, int id, List&lt;int&gt; scroes) { Name = name; ID = id; this.scroes = scroes; }
} // Program.cs namespace TestLINQ
{ class Program { static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); } public static void SeedData(List&lt;Student&gt; students, List&lt;Teacher&gt; teachers) { List&lt;Student&gt; _students = new List&lt;Student&gt;() { new Student("김수로", 0, new() { 90, 95,70,50, 87}), new Student("박혁거세", 1, new() { 80, 45,95,80, 75}), new Student("이은혜", 2, new() { 83, 63,89,93, 63}), new Student("이근왕", 3, new() { 55, 77,77,31, 90}), new Student("선우현", 4, new() { 100, 15,25,36, 57}), }; foreach (var s in _students) { students.Add(s); } List&lt;Teacher&gt; _teachers = new List&lt;Teacher&gt;() { new Teacher("김철수", 5, 10000), new Teacher("이진혜", 6, 20000), new Teacher("김왕심", 7, 30000), new Teacher("박수빈", 8, 40000), new Teacher("손을왕", 9, 50000), }; foreach (var t in _teachers) { teachers.Add(t); } } }
}
혹시 SQL을 사용한 경험이 있으신가요?SQL처럼 select where from을 이용해서 쿼리 하는 방식이 쿼리 구문을 이용하는 방법입니다. SQL과 차이점이라면 순서가 반대라는 것!쿼리 구문은 아래와 같은 형식을 가집니다.
쿼리 구문은 반드시 from절로 시작해야 함
쿼리 구문은 반드시 select절 또는 group절로 끝나야 함.
첫 번째 from절과 마지막 select절 또는 group절 사이에 where, orderby, join, let절과 추가 from절들이 하나 이상 들어갈 수 있음.
첫 번째 예시는 첫번째 시험에서 90점 이상을 맞은 학생들을 검색하는 쿼리 변수를 만들게요. static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); IEnumerable&lt;Student&gt; notLessThan90 = from student in students where (student.scroes[0] &gt;= 90) select student; Console.WriteLine("첫번째 시험에서 90점 이상 맞은 학생들"); foreach (Student student in notLessThan90) { Console.WriteLine("{0}, {1}", student.Name, student.scroes[0]); }
쿼리 구문을 이용하면 상당히 직관적으로 데이터를 추출할 수 있네요. 기본적인 구조는 이해하는데 문제가 없을 것 같아요.추가로 정렬을 의미하는 orderby도 한번 사용해 볼게요. Student에서 성이 이씨인 사람들을 뽑을건데 ID를 내림차순으로 정렬해보도록 하겠습니다. IEnumerable&lt;Student&gt; descendingByID = from student in students where (student.Name[0].ToString() == "이") orderby student.ID descending select student; Console.WriteLine("학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬"); foreach (Student student in descendingByID) { Console.WriteLine("{0}, {1}", student.Name, student.ID); }
되게 간단하네요.&nbsp; 마지막으로 select 대신에 group을 한번 사용해볼게요.Student 리스트에서 성으로 그룹핑을 하겠습니다. Console.WriteLine("학생들의 성으로 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstName= from student in students group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstName) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } Console.WriteLine("학생들의 성으로 내림차순으로 정렬 및 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescending= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescending) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } }
보시다시피 group을 사용하면 IGrouping을 반환해서 네스트 타입이 되네요. 일일이 타입을 적어주는 게 불편한 경우도 있죠. 그런 경우에는 암묵적 형식인 var 키워드를 사용해도 됩니다. var groupByFirstNameDescending2= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (var group in groupByFirstNameDescending2) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } }
위에서 쿼리를 쿼리 구문을 이용해서 작성해 봤어요.&nbsp;쿼리 구문은 코드를 컴파일할 때 .NET CLR(공용 언어 런타임)에 대한 메서드 호출로 변환해야 합니다. 이러한 메서드 호출은&nbsp;Where,&nbsp;Select,&nbsp;GroupBy,&nbsp;Join,&nbsp;Max,&nbsp;Average&nbsp;등과 같은 표준 쿼리 연산자를 호출한다고 하네요. 따라서 우리는 쿼리 구문 대신 메서드 구문을 사용하여 연산자를 직접 호출할 수도 있어요.쿼리 구문과 메서드 구문은 의미상 동일하지만, 쿼리 구문이 더 간단하고 읽기 쉽다고 생각하는 사람이 많다고 합니다. 저도 쿼리 구문이 더 읽기가 쉬웠어요. 그러나 일부 쿼리는 메서드 호출로 표현해야 합니다. 예를 들어 필터를 하는 쿼리에서 요소 개수 또는 최댓값등을 얻으려면 메서드 호출을 사용해야 해요. 따라서 LINQ 쿼리를 작성하기 시작한 경우에도 쿼리 및 쿼리 식 자체에서 메서드 구문을 사용하는 방법을 잘 알고 있으면 유용합니다.위에서 쿼리 구문으로 작성한 쿼리를 메서드 문법으로 작성해 볼게요. // 메서드 구문 이용 Console.WriteLine("메서드 구문 이용해서"); IEnumerable&lt;Student&gt; notLessThan90Method = students.Where(student =&gt; student.scroes[0] &gt;= 90); Console.WriteLine("첫번째 시험에서 90점 이상 맞은 학생들"); foreach (Student student in notLessThan90Method) { Console.WriteLine("{0}, {1}", student.Name, student.scroes[0]); } IEnumerable&lt;Student&gt; descendingByIDMethod = students.Where(student =&gt; student.Name[0].ToString() == "이").OrderByDescending(student =&gt; student.ID); // from student in students // where (student.Name[0].ToString() == "이") // orderby student.ID descending // select student; Console.WriteLine("학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬"); foreach (Student student in descendingByIDMethod) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } Console.WriteLine("학생들의 성으로 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameMethod = students.GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } Console.WriteLine("학생들의 성으로 내림차순으로 정렬 및 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescendingMethod = students.OrderByDescending(student =&gt; student.Name[0].ToString()) .GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescendingMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } }
마지막으로 Concat() 메서드를 이용해서 학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID를 추출하겠습니다. Console.WriteLine("학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID"); var oddIDInTeacherAndStudent = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)); foreach (var id in oddIDInTeacherAndStudent) { Console.WriteLine(id); }
위에서 쿼리 변수를 열심히 만들어서 출력해 봤는데요. 항상 맨 밑에 foreach가 존재합니다. 쿼리 변수는 사실 결과 데이터를 가지고 있지 않아요. 그저 명령만을 가지고 있습니다.&nbsp; 실제로 데이터를 얻기 위해서는 쿼리 실행을 해줘야 합니다. 쿼리 실행 하는 법은 foreach를 사용해서 루프를 돌게 하면 되겠습니다.즉시 실행을 하기 위해서는 Count(), Average(), Max() 등 결과를 얻기 위해 foreach를 암묵적으로 사용하는 메서드 문법을 사용하거나, ToList, ToArray 같은 것을 사용해서 결과를 바로 캐시 하는 방법을 사용하면 됩니다. var oddIDCount = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).Count(); Console.WriteLine(oddIDCount); var oddIDList = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).ToList(); Console.WriteLine(String.Join(" ", oddIDList));
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/LINQ_Practice" target="_self">https://github.com/psychehose/LINQ_Practice</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/" target="_self">https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/</a>]]></description><link>csharp/linq.html</link><guid isPermaLink="false">csharp/LINQ.md</guid><pubDate>Tue, 31 Dec 2024 06:01:06 GMT</pubDate></item><item><title><![CDATA[28. Plate Pick up Objects]]></title><description><![CDATA[Player가 그릇에 KitchenObject를 두는 로직을 구현하도록 하겠습니다.제약사항은 다음과 같습니다.
같은 KitchenObject가 들어가면 안됨
Valid한 KitchenObject만 들어가야함
가능한 경우는 두 가지입니다. 첫 번째는 ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직입니다. 두 번째는 ClearCounter에 KitchenObject(그릇 제외)가 놓여져 있고, Player가 들고 있는 그릇에 놓는 로직입니다.ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직부터 구현 하겠습니다.PlateKitchenObject 스크립트를 생성합니다. 이는 KitchenObject를 상속합니다. Plate Prefab에 스크립트를 넣고 레퍼런스로 Scriptable Object를 넣습니다.<img src="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// ClearCouter.cs public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject() is PlateKitchenObject) { // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter plateKitchenObject.AddIngredient(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
여기에서 제약조건을 추가해야 합니다. - 이미 가지고 있는 타입인 경우에 어떠한 액션도 일어나지 않게 하겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlateKitchenObject : KitchenObject
{ private List&lt;KitchenObjectSO&gt; kitchenObjectSOArray; private void Awake() { kitchenObjectSOArray = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (kitchenObjectSOArray.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOArray.Add(kitchenObjectSO); return true; } } }
ClearCounter에 있는 함수 AddIngredienet를 TryAddIngredent로 리팩토링 하겠습니당// ClearCouter.cs if (player.GetKitchenObject() is PlateKitchenObject)
{ // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter if(plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); }
}
제약조건 추가하기 - 유효한 KitchenObject만 넣을 수 있게 할게요
토마토슬라이스
치즈슬라이스
빵
양배추 슬라이스
익힌 고기패티
탄 고기패티
public class PlateKitchenObject : KitchenObject { [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOList; }
<br><img src="https://blog.kakaocdn.net/dn/cj2Xuj/btssACqprSj/ONuQLp1IF5IhnmfiTsAgDk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlateKitchenObject : KitchenObject
{ [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOListy; private List&lt;KitchenObjectSO&gt; kitchenObjectSOList; private void Awake() { kitchenObjectSOList = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (!validKitchenObjectSOListy.Contains(kitchenObjectSO)) { return false; } if (kitchenObjectSOList.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOList.Add(kitchenObjectSO); return true; } } }
코드 리팩토링을 진행할게요. KitchenObject에&nbsp; TryGetPlate 메서드를 만들어서 이것을 사용하도록 할게요. plateKitchenObject를 얻기 위해서 GetKitchenObject를 호출하고 as를 이용해서 타입캐스팅을 하는데 이것을 더 안전하게 하기 위해서 out parameter를 이용하도록 하겠습니다.// KitchenObject.cs
public bool TryGetPlate(out PlateKitchenObject plateKitchenObject) { if (this is PlateKitchenObject) { plateKitchenObject = this as PlateKitchenObject; return true; } else { plateKitchenObject = null; return false; } }
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
ClearCounter에서 열심히 만든 부분을 StoveCounter, CuttingCounter에도 똑같이 적용하도록 하겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter, IHasProgress
{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } // State Machine 초기화 state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter, IHasProgress
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler OnCut; private int cuttingProgress; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgress = 0; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgress++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnCut?.Invoke(this, EventArgs.Empty); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgress) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }
}
이제는 ClearCounter에 그릇이 놓여져 있고 그릇에 KitchenObject를 위치시키는 로직을 짜도록 하겠습니다.ClearCounter가 HasKitchenObject가 true인 경우에서 Player가 KitchenObject를 가지고 있지만 그릇이 아닌 경우에서 ClearCounter가 그릇을 가지고 있는 경우를 생각하면 됩니다. 말로 전달하니 조금 복잡한 것 같네요.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } else { // Player is not holding plate but something else if (GetKitchenObject().TryGetPlate(out plateKitchenObject)) { // There is Plate in Clear Counter if (plateKitchenObject.TryAddIngredient(player.GetKitchenObject().GetKitchenObjectSO())) { player.GetKitchenObject().DestroySelf(); } } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
&nbsp;끝!]]></description><link>unity/28.-plate-pick-up-objects.html</link><guid isPermaLink="false">Unity/28. Plate Pick up Objects.md</guid><pubDate>Tue, 31 Dec 2024 06:00:03 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[27. Plates Counter]]></title><description><![CDATA[접시가 생성되는 PlatesCounter를 만들어봅시다. Prefab을 만들어줍시다.스크립트를 생성합니다. PlatesCounter는 일정 시간이 흐르면 접시가 하나씩 생성되고 이미 존재한다면 그 위에 쌓아야 합니다.Plates Scriptable Object (기존에 만든 KitchenObjectSO로), Plate Object를 생성합니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; } } }
}
Visual을 담당하는 스크립트도 만듭시다. 왜냐하면 그릇을 쌓아야 하기 때문입니다. 따라서, Visual에는 TopPoint와 그릇 Visual Prefab을 알고 있어야겠죠?using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab;
}
<img src="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 PlatesCounter에서 이벤트 핸들러를 만들고 Invoke를 해줍시다. 그런 다음에 Visual에서 리슨 해주면 되겠네요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); }
}
근데 뭔가 잘못된 거 같아요. 그릇들을 쌓으려면 그릇 List를 가지고 있어야하고 Vector를 높이는 코드가 없어요. 처리 ㄱㄱusing System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }
}
여기까지 하면 그릇을 추가하면 슉슉하고 올라갑니다. 이제 플레이어가 그릇을 가져가는 코드를 작성합시다. PlatesCounter에서 Remove 이벤트 핸들러를 만들어주고&nbsp;Interact가 발생하면&nbsp;&nbsp;이를 Invoke하면 되겠죠?using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; public event EventHandler OnPlateRemoved; private float spawnPlateTimer; private float spawnPlateTimerMax = 4f; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } } public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player is empty Handed if (platesSpawnedAmount &gt; 0) { // There is at least one plate here platesSpawnedAmount--; KitchenObject.SpawnKitchenObject(plateKitchenObjectSO, player); // Update Visual OnPlateRemoved?.Invoke(this, EventArgs.Empty); } } }
}
비쥬얼에서 그릇 가져가는 이벤트를 리스닝 합시다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; platesCounter.OnPlateRemoved += PlatesCounter_OnPlateRemoved; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }
}
]]></description><link>unity/27.-plates-counter.html</link><guid isPermaLink="false">Unity/27. Plates Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:59:01 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[26. Stove Counter]]></title><description><![CDATA[고기를 굽는 StoveCounter를 만들어봅시다. 역시 Prefab을 먼저 만들어야 합니다. StoveCounter는 익히기 전 익힌 후의 오브젝트 input, output이 있기 때문에 Scriptable Object Script를 만들겠습니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class FryingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public float fryingTimerMax;
}
이제 고기 상태에 따라 Meet Uncooked, Cooked, Burned의 Scriptable Object와 Prefab을 만듭시다.<img src="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bagZDK/btssAHL3PhM/rXjdwUtJkw8eAJT6pyGOr0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cx1MPZ/btssk1SBRSJ/VBwrujauNrjjP9KSciFCPk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cSdtLN/btssBZyGhGf/JruIsm7eW6zkIP6BxFqlzK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">StoveCounter 스크립트를 만들고 SerializedField를 만들어줍시다. 그런 다음에 유니티로 돌아가서 레퍼런스를 넣어줍시다.public class StoveCounter : BaseCounter
{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray;
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; private float fryingTimer; private FryingRecipeSO fryingRecipeSO; private void Update() { if (HasKitchenObject()) { fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { Debug.Log("Fried"); fryingTimer = 0f; GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); } Debug.Log(fryingTimer); } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; }
}
위 코드는 문제가 발생 합니다. 시간은 계속 흐르기 때문에 오브젝트(고기)가 사라지고 output 오브젝트가 계속 새로 생깁니다. 이 문제를 해결하기 위해서 State Machine 개념을 도입해야 합니다. 처리하기 쉽게 Enum을 사용하도록 합시다. 그리고 State에 Burned도 있기 때문에 유사하게 Burning SO도 만듭시다.[CreateAssetMenu()]
public class BurningRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public float burningTimerMax;
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ private enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
StoveCounter에 Animation을 넣읍시다. StoveCounterVisual 스크립트를 생성할게요using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounterVisual : MonoBehaviour
{ [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; [SerializeField] private StoveCounter stoveCounter;
}
StoveCounter에서 EventHandler를 만들고 Invoke 할게요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
StoveCounterVisual에서 이벤트를 리슨 하는 코드를 작성!using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounterVisual : MonoBehaviour
{ [SerializeField] private StoveCounter stoveCounter; [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; private void Start() { stoveCounter.OnStateChanged += StoveCounter_OnOnStateChanged; } private void StoveCounter_OnOnStateChanged(object sender, StoveCounter.OnStateChangedEventArgs e) { bool showVisual = e.state == StoveCounter.State.Frying || e.state == StoveCounter.State.Fried; stoveOnGameObject.SetActive(showVisual); particlesGameObject.SetActive(showVisual); }
}
ProgressBar를 만듭시다. 전에 CuttingCounter에서 만든 거와 동일해요 그래서 재사용 가능using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public interface IHasProgress
{ public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged; public class OnProgressChangedEventArgs: EventArgs { public float progressNormalized; }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private GameObject hasProgressGameObject; [SerializeField] private Image barImage; private IHasProgress hasProgress; private void Start() { hasProgress = hasProgressGameObject.GetComponent&lt;IHasProgress&gt;(); if (hasProgress == null) { Debug.LogError("GameObject " + hasProgressGameObject + " does not have a component that implements IHasProgress"); } hasProgress.OnProgressChanged += HasProgress_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void HasProgress_OnProgressChanged(object sender, IHasProgress.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }
}
StoveCounter에서 Confirm 합시다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter, IHasProgress
{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
끝!]]></description><link>unity/26.-stove-counter.html</link><guid isPermaLink="false">Unity/26. Stove Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:58:13 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[25. Trash Counter]]></title><description><![CDATA[어떤 오브젝트도 버릴 수 있는 TrashCounter를 만듭시다.TrashCounter Prefab을 먼저 만들기_BaseCounter -&gt; Create Prefab Variant -&gt; TrashCounter로 네이밍프리팹에 들어가서 TrashCounter_Visual 넣고 복사해서 Selected로 네이밍 합니다.&nbsp; 그런 다음에 Selected에 SelectedCounter 스크립트를 넣어주기 그리고 Mesh 설정, Scale 1.01배 설정 등 귀찮은 작업들을 해줍시다.<img src="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Script를 생성합니다. 로직은 매우 단순해요. 인터렉트가 발생하면 플레이어가 가지고 있는 오브젝트를 없애면 되겠습니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class TrashCounter : BaseCounter { public override void Interact(Player player) { if (player.HasKitchenObject()) { player.GetKitchenObject().DestroySelf(); } }
}
<br><img src="https://blog.kakaocdn.net/dn/cwFk56/btsshrj0wKp/CjAEbaE6rG0AbuggrFQKGk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/25.-trash-counter.html</link><guid isPermaLink="false">Unity/25. Trash Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:57:18 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[24. Look At Camera]]></title><description><![CDATA[오브젝트마다 사용자에게 어떻게 보여줘야 할지 다른 경우가 있습니다. 이것을 일일이 설정하면 코드가 복잡해질 거예요. 이를 스크립트로 만들어서 필요한 경우 스크립트를 넣어서 핸들링하는 방법을 알아볼게요.LookAtCamera 스크립트를 생성할게요.using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine; public class LookAtCamera : MonoBehaviour
{ [SerializeField] private Mode mode; private enum Mode { LookAt, LookAtInverted, CameraForward, CameraForwardInverted } private void LateUpdate() { switch (mode) { case Mode.LookAt: // 예전에는 Camera.main이 캐시되지 않아서 배드 퍼포먼스여서 사용하지 않았으나 지금은 디폴트로 캐시되어서 사용 transform.LookAt(Camera.main.transform); break; case Mode.LookAtInverted: Vector3 dirFromCamera = transform.position - Camera.main.transform.position; transform.LookAt(transform.position + dirFromCamera); break; case Mode.CameraForward: transform.forward = Camera.main.transform.forward; break; case Mode.CameraForwardInverted: transform.forward = -Camera.main.transform.forward; break; } }
}
위처럼 enum으로 상태를 관리해줄게요. LookAt은 오브젝트가 카메라를 바라봅니다. (메인 카메라가 중앙에 있다면, 중앙을 향해서)LookAtInverted는 카메라를 바라보는 것은 같은데 좌우가 뒤집힙니다. CamerarForward는 메인 카메라 방향을 바라보지만, 기울어지지 않습니다. 역시 CameraForwardInverted는 좌우가 반전됩니다.유니티에서 오브젝트에 스크립트를 추가한 후에 설정해서 사용하면 됩니다.<img src="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/24.-look-at-camera.html</link><guid isPermaLink="false">Unity/24. Look At Camera.md</guid><pubDate>Tue, 31 Dec 2024 05:56:59 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[23. Cutting Progress, World Canvas]]></title><description><![CDATA[이번에는 재료들을 컷할 때 몇 번 액션을 줘야 하는지 정하고 Cutting Counter 위에 프로그레스바를 넣을 거예요.토마토는 3번, 치즈는 3번, 양배추는 5번 F키를 눌러서 잘라줘야 합니다.원재료가 있고 이를 컷팅했을 때 Sliced 재료가 되어야 하니까 Scriptable Object를 만들어서 관리하는 게 좋아요.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class CuttingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public int cuttingProgressMax;
}
<img src="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Cutting Counter에 가서 로직을 작성해 볼까요? cuttingProgress라는 이름으로 int인 프로퍼티를 만들고 Player가 CuttingCounter에 원재료를 올려놓으면 0으로 초기화해줍니다. 그리고 F키를 눌러 InteractAlternate를 하게 되면 cuttingProgress를 높이면 되겠습니다.그 외 코드들은, CuttingRecipeSO의 input인 토마토, 치즈, 양배추만 컷팅 카운터에 올릴 수 있게 하는 코드입니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; private int cuttingProgess; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgess = 0; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgess++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgess) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }
}
그리고 [SerializedField]로 설정했기 때문에 유니티에서 꼭 레퍼런스를 지정해 주세요.<br><img src="https://blog.kakaocdn.net/dn/EHheN/btsrNBG5Htz/5kSMlkvN7e2r0aa6DSXp41/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CuttingCounter 하위에 Empty Object를 만들고, Render Mode를 World Space로 바꿔줍시다. Rect Transform에서 Position과 width, height를 다 0으로 설정합시다. 그리고 프로그레스 바를 어디에다가 띄울지 위치를 대충 결정해 주면 됩니다. 그런 다음에 하위에 Image를 만들게요.Image를 눌러서 Color를 정해주고 Source 이미지에 White 1x1을 넣어주세요.<br><img src="https://blog.kakaocdn.net/dn/u82GH/btsrSKXRW5u/LN0bud5Z4lOEzRdYJkIYFK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Image type을 정해줍시다.Image Type에는 아래 4종류가 있습니다.
Simple
Tiled
Sliced
Filled
저는 Filled를 선택할게요. Fill Amount를 조정하면 아까 위에서 설정한 Source Image(하얀색)에서 우리가 설정한 색깔(노란색)로 변합니다. 1이면 전체가 노란색으로 채워집니다. 노란색으로 채우는 방법도 여러 가지입니다. Fill Method에서 Horizontal로 설정하면 왼쪽에서부터 가로로 채워집니다.<br><img src="https://blog.kakaocdn.net/dn/sqVRe/btsrSM2rv0c/rM2KN55cTnmJ1whSzup6Lk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/GCYaK/btsrYVRyRXh/qsaIsO3P6wNKrV18kv5Atk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위처럼 백그라운드 설정하기 위해서 먼저 Bar를 복사하고 이름을 Background로 짓습니다. 그런 다음에 Simple로 바꾸고 색깔을 검은색으로 하면 됩니다. 여기에서 중요한 것이 Bar보다 위에 위치시켜야 한다는 점입니다. 순서대로 그리기 때문입니다.Background에 아웃라인을 좀 더 주고 명확하게 하고 싶어서 컴포넌트를 추가하겠습니다.<br><img src="https://blog.kakaocdn.net/dn/AIGG7/btsrIb9Pm3Z/4S8qXoMIqZOHhTziVLSPQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CuttingCounter에서 ProgressUI를 분리하는 것이 더 깔끔하기 때문에 스크립트를 생성하고 ProgressBarUI로 이름 짓겠습니다. 스크립트를 ProgressBarUI에 어태치 해주세요.SerializedField로 CuttingCounter, Image를 선언하고 유니티에서 레퍼런스를 지정해 줍시다.public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image image;
}
CuttingCounter에서 이벤트로 ProgressBarUI에 이벤트를 넘겨줘야 하기 때문에 CuttingCounter에서 EventHandler를 만들고, 명확하게 몇 번 컷팅했는 지를 보내야 하기 때문에, EventArgus도 만들어줘야 합니다. 그런 다음에 InteractAlternate에서 Invoke 해주면 되겠죠?CuttingCounter.cs
// ...
public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged;
public class OnProgressChangedEventArgs: EventArgs
{ public float progressNormalized;
} //... // CuttingCounter.cs (InteractAlternate 메서드 안) CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new OnProgressChangedEventArgs
{ progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax
});
이벤트를 Invoke 하는 코드를 만들었으니, ProgressBarUI에서 이벤트를 리스닝하는 코드를 작성하면 되겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image barImage; private void Start() { cuttingCounter.OnProgressChanged += CuttingCounter_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void CuttingCounter_OnProgressChanged(object sender, CuttingCounter.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }
}
이제 마지막으로 Cutting 애니메이션을 넣도록 하겠습니다.CuttingCounter에서 OnCut이라는 이벤트 핸들러를 만들고 역시 InteracteAlternate()에서 Invoke 해줍시다.public event EventHandler OnCut; OnCut?.Invoke(this, EventArgs.Empty);
CuttingCounterVisual 스크립트를 만들어줄게요.public class CuttingCounterVisual : MonoBehaviour { [SerializeField] private CuttingCounter cuttingCounter; private Animator animator; private const string CUT = "Cut"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { cuttingCounter.OnCut += CuttingCounter_OnCut; } private void CuttingCounter_OnCut(object sedner, System.EventArgs e) { animator.SetTrigger(CUT); } }
SerializedField를 선언했으면? 당연히 레퍼런스를 넣어줘야겠죠? 끝!<br><img src="https://blog.kakaocdn.net/dn/lpEMX/btsrSNNNpx1/JXtASI1Rj7lKfM41TlNWJK/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/23.-cutting-progress,-world-canvas.html</link><guid isPermaLink="false">Unity/23. Cutting Progress, World Canvas.md</guid><pubDate>Tue, 31 Dec 2024 05:56:38 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[22. Cutting Recipe SO]]></title><description><![CDATA[지난번에 언급했던 문제점!하드코딩 되어있기 때문에 어떤 재료든 컷팅하며 슬라이스 토마토가 되어있는 이슈를 해결하도록 하겠습니다.각각 종류에 맞는 슬라이스로 만드는 것이 목표입니다.Scriptable Object를 이용해서 해결해봅시다. 고고대력 흐름은 CuttingRecipeSO를 만들어서 Input과 outpt으로 원재료 -&gt; 슬라이스로 다루는 것입니다.Input - 토마토, 치즈, 양배추Output - 토마토 슬라이스, 치즈 슬라이스, 양배추 슬라이스제약조건도 추가해줘야 합니다. 이미 잘린 것은 또 자를 수 없기 때문에요먼저 CuttingRecipeSO 스크립트를 만듭시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class CuttingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output;
}
유니티에서 노가다를 통해서 프리팹과 SO를 만듭시다. 처음엔 드래그 앤 드랍 싫고 그랬는데 익숙해지면 소소한 재미가 있더라고요.KitchenObjectSO - 치즈슬라이스랑, 캐비지 슬라이스 만들기KitchenObject - 치즈 슬라이스, 캐비지 슬라이스 만들기CuttingRecipeSO - 토마토,치즈,캐비지 만들기<img src="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 CuttingCounter에서 로직 구현을 할 차례예요.시리얼라이즈드 필드로 CuttingRecipeSO를 배열로 들고 있어야하고, KitchenObjectSO를 리턴하는 메서드가 필요하겠네요.그리고 이미 잘린 것은 또 못자르게 로직을 구현합시다.&nbsp;간단하게 CuttingCounter가 가지고 있는 KitchenObject가 루프를 돌아서 이게 Recipe의 Input과 같으면, 잘라주면 됩니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(kitchenObject.GetKitchenObjectSO()); kitchenObject.DestroySelf(); // Cutting KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return true; } } return false; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO.output; } } return null; }
}
마지막으로 유니티로 돌아가서 시리얼라이즈드 필드에 아래처럼 SOArray 레퍼런스를 잘 넣어주면 끝!<br><img src="https://blog.kakaocdn.net/dn/MeJop/btsqYqfsKQm/cI5DI71dFiLKeLt6TObc11/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/22.-cutting-recipe-so.html</link><guid isPermaLink="false">Unity/22. Cutting Recipe SO.md</guid><pubDate>Tue, 31 Dec 2024 05:55:48 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[21. Cutting Counter, Interact Alternate]]></title><description><![CDATA[이번에는 CuttingCounter를 만들게요!플레이어는 Cutting Counter에서 치즈, 토마토, 양배추를 놓고 자를 수 있어요. 그래서 놓고 드는 인터렉트 말고 다른 인터렉트가 필요할 거예요!프리팹을 먼저 만들게요. _BaseCounter를 선택하고 Prefab Variant를 클릭해서 만들어줍시다. 그리고 비주얼 넣고, 선택되었을 때 처리를 하면 되겠죠? 스크립트도 만들어서 어태치 하고 BaseCounter를 상속하게 합니다.그리고 유니티로 돌아와서 레퍼런스를 넣어줍시다. 처음에 할 때 이 과정이 복잡했는데, 이제는 조금 익숙해져서 다행이네요. 역시 반복이 답이제 자르는 인터렉트 키를 만들어봅시다.Input System에서 열고 InteractAlternate 추가하고 F로 설정! Save Asset 누르는 거 잊지 말기<img src="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input System에서 액션을 만들어줬기 때문에 이것을 등록하고 구현해야겠죠? 이미 구현한 Interact처럼 하면 됩니다.
GameInput.cs에 등록
Player가 Interact를 하기 때문에 Player.cs에서 등록 및 구현
BaseCounter에서 구현
코드를 작성해 봅시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.InputSystem; public class GameInput : MonoBehaviour { public EventHandler OnInteractAction; // 새로 구현한 곳 public EventHandler OnInteractAlternateAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Subscribe 코드 playerInputActions.Player.Interact.performed += Interact_performed; playerInputActions.Player.InteractAlternate.performed += InteractAlternateOnperformed; }
// 새로 구현한 곳 private void InteractAlternateOnperformed(InputAction.CallbackContext obj) { OnInteractAlternateAction?.Invoke(this, EventArgs.Empty); } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }
}
Player.cs에 추가합시다.private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction;
// 새로 추가됨 gameInput.OnInteractAlternateAction += OnInteractAlternateAction; }
// 새로 추가됨 private void OnInteractAlternateAction(object sender, EventArgs e) { if (selectedCounter != null) { selectedCounter.InteractAlternate(this); } }
BaseCounter에 구현을 하러 갑시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void InteractAlternate(Player player) { Debug.LogError("InteractAlternate.Interact();"); } public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
이제 CuttingCounter에서 overriding을 구현해야 해요. 그전에 Cutting을 했을 때 원래 있던 KitchenObject가 새로운 KitchenObject(Ex: 토마토 -&gt; 잘린 토마토)로 변해야므로 새로운 KitchenObjectSO와 KitchenObject를 만들겠습니다.일단 바로 추가할 수 있는 Destory()를 먼저 구현할게요(토마토 -&gt; 잘린 토마토인 경우 토마토 객체를 먼저 없애줘야 하므로)using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError("IKitchenObjectParent already has kitchen object"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; } // 새로 추가된 부분 public void DestroySelf() { kitchenObjectParent.ClearKitchenObject(); Destroy(gameObject); }
}
잘린 토마토 슬라이스 Scriptable Object와 프리팹을 유니티에서 만듭시다.<br><img src="https://blog.kakaocdn.net/dn/0QIKK/btsqYZ9QisQ/e0ETQgs7TAA2kRdfLderD0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">다 만든 다음에, CuttingCounter 코드를 작성 ㄱㄱusing System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO cuttingKitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Player is carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject()) { // There is Kitchen Object here kitchenObject.DestroySelf(); // Cutting Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); } }
}
코드에서, 다음 두 라인이 CuttingCounter.cs와 ContainerCounter.cs에서 공통적으로 사용됩니다. 따라서 리펙토링 대상이겠죠? 고고Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab);
kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player);
KitchenObject.cs에서 static 메서드로 만들어줍시다.public static KitchenObject SpawnKitchenObject(KitchenObjectSO kitchenObjectSO, IKitchenObjectParent kitchenObjectParent) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); KitchenObject kitchenObject = kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;(); kitchenObject.SetKitchenObjectParent(kitchenObjectParent); return kitchenObject; }
// ContainerCounter.cs
public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 KitchenObject.SpawnKitchenObject(kitchenObjectSO, player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }
마지막으로 Cutting Counter에 시리얼라이즈드 필드를 사용했으니 유니티에서 레퍼런스(만들어 놓은 Tomato Slice SO)를 넣어주면 끝!여기까지 하면, 토마토를 자르면 잘린 토마토가 되는 걸 확인할 수 있어요. 근데 치즈를 잘라도 잘린 토마토가 나오기 때문에 다음에 이 문제를 해결하도록 하겠습니다!]]></description><link>unity/21.-cutting-counter,-interact-alternate.html</link><guid isPermaLink="false">Unity/21. Cutting Counter, Interact Alternate.md</guid><pubDate>Tue, 31 Dec 2024 05:55:05 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20. Player Pick Up & Drop Object]]></title><description><![CDATA[이번에는 Player가 ContainerCounter에서 Object를 꺼내서 ClearCounter에 놓았다 들었다 하는 것을 구현할게요.public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { if (player.HasKitchenObject()) { // Player가 가지고 있으면 아무것도 해선 안됨 } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } }
}
컨터이너에서 오브젝트를 꺼내고, 바로 컨테이너에서 인터렉트를 할 시에 에러가 발생해야 해요. 왜냐하면 플레이어가 오브젝트를 들고 있지 않을 때만 인터렉트를 해야 하기 하기 때문이에요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }
}
현재는 KitchenObject가 Tomato, CheeseBlock만 존재합니다. Bread와, Cabbage를 추가하고 이것들을 담는 Prefab들을 유니티에만 들게요.각각 KitchenObjectSO와, KitchenObject, ContainerPrefab을 만들고 씬에 배치하면 끝!<img src="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/20.-player-pick-up-&amp;-drop-object.html</link><guid isPermaLink="false">Unity/20. Player Pick Up &amp; Drop Object.md</guid><pubDate>Tue, 31 Dec 2024 05:54:14 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[19. Container Counter와 상속]]></title><description><![CDATA[이번에는 물건을 꺼내오는 Container Counter를 구현할 거예요.이 게임에는 다양한 종류의 Counter가 존재합니다. 그래서 BaseCounter를 만들고 구체적인 카운터가 Base를 상속받게 하는 것이 좋습니다.프리팹도 베이스를 만들어 놓으면 프리팹을 정말 빠르게 만들 수 있습니다. 그래서 프리팹부터 만들어보도록 하겠습니다._BaseCounter로 이름 짓고 프리팹을 열어 CounterTopPoint를 넣어줍니다.<img src="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">_BaseCounter을 이용해서 ClearCounter 프리팹을 만들어볼게요.우클릭하고 Prefab Variant를 클릭합시다.<br><img src="https://blog.kakaocdn.net/dn/bjcUyF/btsqZvNH1vT/kKOpjwB2mkbPMhWrqC1pUK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러고나서 기존의 ClearCounter에 들어있는 Selected, ClearCounter_Visual을 복붙하고 스크립트를 잘 넣으면 됩니다.기존의 ClearCounter는 지워주면 되겠죠?<br><img src="https://blog.kakaocdn.net/dn/bMMeIK/btsqYP0df5o/et5dTWLLgxjIwzdMF1F2Bk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 _BaseCounter를 이용해서 ContainerCounter 프리팹을 만들게요.프리팹을 만들 때 설정해줘야 하는 건 다음과 같아요.
Visual Prefab(Asset) 끌당하기
복사해서 Selected 만들기
선택되었을 때, 하위 MeshRender 설정하기
Rendering 버그가 안 나게 선택되었을 때, Scale 전체 1.01로 수정하기
SelectedCounter에 스크립트 넣어주기
다 적용하면 아래처럼 사진처럼 됩니다.<br><img src="https://blog.kakaocdn.net/dn/dfUG6B/btsqXSQNHDr/d8M2SSux89DATZXuCm9KZK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 ContainerCounter 스크립트를 만든 다음 어태치 하고 코드를 작성할게요.public class ContainerCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool hasKitchenObject() { return kitchenObject != null; }
}
시리얼라이즈드필드 변수를 썼으니 어떻게 해야 된다? 유니티에서 레퍼런스를 추가해야 한다!&nbsp;추가 ㄱㄱ<br><img src="https://blog.kakaocdn.net/dn/biz7BP/btsqYZolSGD/qL5RsQqPyqQej5xaKm1AKK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 BaseCounter 스크립트를 만들어서 구체적인 Counter들의 부모로 사용할 거예요.public class BaseCounter : MonoBehaviour { public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); }
} 그런 다음에 Player.cs에서 ClearCounter를 BaseCounter로 변경
Container의 SelectedCounter를 설정해 볼까요. 현재는 SelectedCounterVisual이 시리얼라이즈 필드로 ClearCounter를 가지고 있는데 BaseCounter로 변경하고 그리고 GameObject는 Array로 바꿉시다.public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private BaseCounter baseCounter; [SerializeField] private GameObject[] visualGameObjectArray; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == baseCounter) { Show(); } else { Hide(); } } private void Show() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(true); } } private void Hide() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(false); } }
}
시리얼라이즈드 필드를 바꿨으니 각각 프리팹의 Selected로 가서 레퍼런스를 다시 넣어줍시다.<br><img src="https://blog.kakaocdn.net/dn/bDYQ2I/btsqZgwz8EM/N0rgbcuxLhfrPAlFeWOu61/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/dWVoRR/btsqYpOi57P/vrQg3yTGe27xekzOSR59bK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드 겹치는 부분인 IKitchenObjectParent도 Base로 뺄게요.public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
public class ContainerCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); }
}
public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { }
}
상속을 하니까 코드 라인이 눈에 띄게 줄어들었네요.이제 ContainerCounter에 Animation을 넣어볼게요. Animator를 이용하면 되겠죠?먼저 ContainerCounter에서 인터렉트가 발생했을 때 ContainerCounterVisual에 이벤트를 넘겨주게 코드를 작성합시다.public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); }
}
CountainerCounterVisual 스크립트를 생성하고 이벤트를 리스닝하는 코드를 작성하면 됩니다.public class CountainerCounterVisual : MonoBehaviour { [SerializeField] private ContainerCounter containerCounter; private Animator animator; private const string OPEN_CLOSE = "OpenClose"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { containerCounter.OnPlayerGrabbedObject += ContainerCounter_OnPlayerGrabbedObject; } private void ContainerCounter_OnPlayerGrabbedObject(object sedner, System.EventArgs e) { animator.SetTrigger(OPEN_CLOSE); } }
시리얼라이즈드 필드를 사용했으니 아래처럼 CotainerCounter_Visual에 레퍼런스를 넣고 구현을 마무리하면 되겠습니다! 끝<br><img src="https://blog.kakaocdn.net/dn/xiUU3/btsqYUHgX9Z/AKB4OKNI7LX6LecrI2CqgK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/19.-container-counter와-상속.html</link><guid isPermaLink="false">Unity/19. Container Counter와 상속.md</guid><pubDate>Tue, 31 Dec 2024 05:53:57 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[18. Player Pick up, CSharp Interfaces]]></title><description><![CDATA[카운터들이 키친 오브젝트를 가지고 있는 경우도 있지만, 플레이어가 키친 오브젝트를 가지고 있는 경우도 있겠죠? 이를 Interface를 이용해서 리팩토링 하면 됩니다!인터페이스 스크립트를 만들게요.public interface IKitchenObjectParent { public Transform GetKitchenObjectFollowTransform(); public KitchenObject GetKitchenObject(); public void SetKitchenObject(KitchenObject kitchenObject); public void ClearKitchenObject(); public bool HasKitchenObject(); }
이렇게 만들면, KitchenObject가 ClearCounter를 가지고 있는 것 아니라 IKitchenObjectParent를 프로퍼티로 가지게 합니다. 수정을 해볼까요?public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError("IKitchenObjectParent already has kitchen object"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }
}
부모가 될 수 있는 ClearCounter로 가서 IKitchenObjectParent를 컨펌할게요. 그리고 인터렉트를 할 때, Clear Counter가 들고 있는 Kitchen Object의 부모를 Player로 바꿔줘야 하기 때문에 Interact의 파라미터에 Player가 필요해요.&nbsp;public class ClearCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
Player도 IKitchenObjectParent를 컨펌합시다! 아직 플레이어는 ClearCounter가 가지고 있는 counterTopPoint (물건을 놓는 위치) 같은 것이 없어요. 이것을 SerializedField로 Transform kitchenObjectHoldPoint로 이름 짓고 Player 하위에 빈 객체를 하나 만들고 아래처럼 위치를 잡아줄게요. 그리고 Player Scirpt의 kitchenObjectHoldPoint에 레퍼런스로 넣어주면 되겠죠?<img src="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public class Player : MonoBehaviour, IKitchenObjectParent { public static Player Instance { get; set; } public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } private bool isWalking; private Vector3 lastInteractDir; private ClearCounter selectedCounter; private KitchenObject kitchenObject; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; [SerializeField] private LayerMask counterLayerMask; [SerializeField] private Transform kitchenObjectHoldPoint; private void Awake() { if (Instance != null) { Debug.LogError("Player가 한명보다 많습니다."); } Instance = this; } private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { if (selectedCounter != null) { selectedCounter.Interact(this); } } private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; // 회전을 부드럽게 하는 lerp, slerp transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return kitchenObjectHoldPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; } }
Interface를 이용한 리팩토링을 완료했어요. 이제 플레이어가 카운터에 있는 키친 오브젝트를 들 수 있게 되었습니다.]]></description><link>unity/18.-player-pick-up,-csharp-interfaces.html</link><guid isPermaLink="false">Unity/18. Player Pick up, CSharp Interfaces.md</guid><pubDate>Tue, 31 Dec 2024 05:53:02 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[13. Clear Counter - RayCast로 객체와 인터렉트하기]]></title><description><![CDATA[Empty Object(ClearCounter)를 생성하고 Prefab Asset(ClearCounter_Visual)을 만든 오브젝트에 끌어당겨 넣습니다.비주얼과 로직을 분리해야 하기 때문에 ClearCounter에 로직을 넣고 _Visual에는 UI 관련된 것을 넣습니다.따라서 ClearCounter에 ClearCounter.cs를 추가하고 Box Colider를 설정하고 크기는 Visual과 맞춥니다.그런 다음에 Player.cs를 작성할 것입니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class Player : MonoBehaviour { private bool isWalking; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float interactDistance = 2f; if (Physics.Raycast(transform.position, moveDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log("-"); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); }
}
Parameter에 out이 들어가는 경우는 일종의 콜백으로 생각하면 될 것 같습니다.위의 코드를 실행하면, 멈춰있을 때 이벤트가 발생하지 않아 인터렉션을 할 수가 없는 이슈가 있습니다. 그 이유는 HandleInteractions()에서 멈춰있을 때 moveDir이 0이기 때문입니다. 이것을 클래스 프로퍼티로 가지고 있으면 이슈를 해결할 수 있습니다.
// Player.cs // 클래스 프로퍼티로 가지고 있기
private Vector3 lastInteractDir; // ... /// private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log("-"); } }
그리고 만든 Object Instance를 다음에 다른 인스턴스를 빠르게 생성하기 위해서 파일창으로 드래그 앤 드롭을 해서 Object Prefab으로 만듭니다.<img src="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Interact를 하기 위해서는 플레이어가 객체를 Identifying 할 수 있어야 합니다. 이때 유니티에서 제공하는 tag를 사용할 수 있으나, 코드에서 컴포넌트를 얻어서 처리하는 것이 더욱 효과적인 방법인 것 같습니다. Try-를 이용하면 null 체크까지 진행할 수 있습니다. 이제 HandleInteractions()을 수정하겠습니다.// Player.cs // ... // private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }
RayCast를 사용할 때 매개변수에 layerMask를 쓸 수 있습니다. 이것을 설정하면 Player의 rayCast가 반응하는 Layer들을 설정할 수 있게 됩니다.&nbsp; Counter layer를 Counters라고 만들고 Counter의 Layer를 Counters로 설정하겠습니다.<br><img src="https://blog.kakaocdn.net/dn/XC2Hp/btso8z4Fejb/nHJTV998t8IKb312TzGJQ0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/ct99it/btso09muO2Z/GdpNRfT1HIXmhhynng9EUk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그런 다음에 Player.cs에서 SerializeField를 설정합시다.// Player.cs [SerializeField] private LayerMask counterLayerMask;
그러고나서 유니티로 돌아와 Player 인스턴스를 클릭하고 Inspector에서 SerializeField를 설정하면 끝입니다.<br><img src="https://blog.kakaocdn.net/dn/RaakV/btso12gk3LK/UQmJClmkttamek63c4N8F0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 Player는 아래처럼 Layer가 Counters로 설정된 오브젝트에만 인터렉트를 하게 됩니다!<br><img src="https://blog.kakaocdn.net/dn/D96LV/btso7R5xiII/WZahA3bPsoVxmdF6R2L0K1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html</link><guid isPermaLink="false">Unity/13. Clear Counter - RayCast로 객체와 인터렉트하기.md</guid><pubDate>Tue, 31 Dec 2024 05:52:25 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[14. Interact Action Events]]></title><description><![CDATA[Player가 Object에 갔을 때 Interact를 하는 것을 개발하겠습니다.&nbsp;Input System 열어서 Actions에 Interact를 생성하고 'E'를 바인딩합시다.<img src="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이벤트의 흐름은 아래와 같아요.
GameInput -&gt; Player -&gt; ClearCounter
먼저 GameInput.cs를 열어 코드를 작성해 볼까요? 어떻게 구현하면 될까요?Input System에서 Interact가 발생했을 때 알아채기 위해서 우리는 이 이벤트를 리스닝하고 있어야 합니다. 그러고 나서 이 이벤트가 발생했다는 사실을&nbsp; Player에게 보내야 해요. 따라서 EventHandler를 프로퍼티로 가지고 있어야 하고, Input System에서 오는 Interact를 리스닝하고 액션이 들어왔을 때 EventHandler를 통해 이벤트를 보내주는 함수를 구현하면 됩니다.&nbsp;public class GameInput : MonoBehaviour { // Event를 넘겨주는 객체 public EventHandler OnInteractAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Listening playerInputActions.Player.Interact.performed += Interact_performed; } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { //OnInteractAction이 Null일 수 있기 때문에 Invoke를 사용한다. OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }
}
Player.cs에서 OnInteractAction을 리스닝하면 됩니다.// Player.cs // GameInput.cs에서 발생하는 OnInteractAction을 리스닝 하기 private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }
유니티에서 이런 비동기 처리는 Event라는 것을 처리하는 것 같습니다. Swift는 클로저를 통해 제어권을 넘겨주는 방식이랑 상당히 유사한 것 같네요. 끝!]]></description><link>unity/14.-interact-action-events.html</link><guid isPermaLink="false">Unity/14. Interact Action Events.md</guid><pubDate>Tue, 31 Dec 2024 05:52:16 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[15. Selected Counter Visual & Singleton Pattern]]></title><description><![CDATA[이번에는 오브젝트에 다가갈 때 UI를 업데이트하는 것을 구현했어요. UI 로직과 게임 로직은 분리하는 게 좋아요.SelectedCounterVisual 스크립트를 생성하고 공통적으로 적용해야 하기 때문에 ClearCounter Prefab을 열어줍니다. 그리고 ClearCounter_Visual을 복사해서 Selected로 이름을 바꿉시다. 그런 다음 Inspector에서 세 가지 과정을 완료하면 되어요.
CounterSelected로 Meterial 변경 (Selected 하위에 있는 컴포넌트들)
사이즈 변경 (사이즈가 같으면 발생하는 렌더링 버그가 있음)
SelectedCounterVisual 넣기
<img src="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/dNulJo/btspE3SQKsU/H3PrGoAKCMIhBuYF9d6Tgk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/XdXso/btspNP0efBe/UfjgVYsPfcUiLcY4MY1QCK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 코드를 작성하고, SerializeField를 만들어서 레퍼런스를 넣어줍시다!흐름은 Player가 Object에 다가간다. -&gt; Selected Counter Visual을 업데이트해준다. 그러면 Player.cs에 다음과 같은 코드를 작성하면 되어요. 그리고 아직은 1인용 게임이기 때문에 Player는 인스턴스는 무조건 하나일 수밖에 없어서 싱글톤으로 만들면 됩니다.// Player.cs
public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } // Single 톤으로 만들어야하니까 public static Player Instance { get; private set; } private void Awake() { if (Instance != null) { Debug.LogError("Player가 한명보다 많습니다."); } Instance = this; } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // 수정
private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } }
이제 Visual을 업데이트를 하는 코드를 작성합시다!// SelectedCounterVisual.cs public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private ClearCounter clearCounter; [SerializeField] private GameObject visualGameObject; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == clearCounter) { Show(); } else { Hide(); } } private void Show() { gameObject.SetActive(true); } private void Hide() { gameObject.SetActive(false); }
}
이때 좀 주의할 점이 있는데 이벤트 등록을 Start()에서 하는 것입니다. Awake()에서 등록을 하게 되면 에러가 발생할 수 있습니다.왜냐하면 Player.cs에서 Instance를 Awake()에서 만들기 때문에 순서가 보장되지 않을 수 있기 때문입니다.따라서! 반드시 Start()에서 이벤트 등록을 해줍시다.이제 다시 유니티로 돌아가 [SerializeField]에 알맞는 레퍼런스를 넣어줄까요?<br><img src="https://blog.kakaocdn.net/dn/cveG34/btspOyYfvgw/91xl8AZvUZ4XgWtzWGXch0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bfZ78Q/btspCnqqB3Z/sYY06RxUirfT2CRaSdoMQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/d2OVRZ/btspGLxv4Oz/1AVqaYIqCEan1owh9eTlt1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bUh0Ao/btspRinhPFO/4mvrstPKOfYh7zouWBcz10/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/lF40S/btspFM4lwGY/uYgrQlWSSg8EzynxPNt201/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/15.-selected-counter-visual-&amp;-singleton-pattern.html</link><guid isPermaLink="false">Unity/15. Selected Counter Visual &amp; Singleton Pattern.md</guid><pubDate>Tue, 31 Dec 2024 05:52:04 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[16. Kitchen Object, Scriptable Object]]></title><description><![CDATA[Clear Counter에는 음식을 올려놓을 수 있어요. Clear Counter에 객체를 올려놓는 것을 개발하겠습니다.먼저 올려놓을 객체들을 Prefab으로 만듭니다. KitchenObjects 폴더에 만들어줄게요. 그런 다음에, ClearCounter 스크립트를 열고다음 코드를 작성합니다.public class ClearCounter : MonoBehaviour { [SerializeField] private Transform tomatoPrefab; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform tomatoTransform = Instantiate(tomatoPrefab, counterTopPoint); tomatoTransform.localPosition = Vector3.zero; }
}
Interact()가 호출되면 Log를 띄우고 토마토를 Clear Counter 위에 올려놓을 거예요. 이제 유니티로 돌아가서 설정한 SerializeField에 레퍼런스를 넣겠습니다.<img src="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 인터렉트를 하게 되면 토마토가 슉하고 올라갈 거예요. 근데 Clear Counter 위에는 토마토도 올라갈 수 있지만 다양한 것들도 올라갈 수 있어요. 그래서 이것을 Scriptable Object로 감싸고, 안에 멤버 변수로 Prefab을 가지고 있다면 코드를 공통화할 수 있어요.Scriptable Object를 만듭시다.[CreateAssetMenu()]
public class KitchenObjectSO : ScriptableObject { public Transform prefab; public Sprite sprite; public string objectName;
}
유니티로 돌아가서 확인해 보면 Create Kitchen Object SO라는 것이 생겼을 거예요. Tomato와, CheeseBlock을 만듭니다.<br><img src="https://blog.kakaocdn.net/dn/Bgna7/btspCllNj6o/lrnpl70tqht3IeX3Ev4Ptk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">ClearCounter.cs를 수정해 볼까요?public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; }
}
이렇게 하면 끝입니다.근데 kitchenObjectTransform에서 해당하는 KitchenObjectSO를 얻을 수 있을까요? 바로 얻을 수 없습니다. 이것 역시 스크립트를 이용해야 하는데 Scriptable Object에는 Script를 드래그 앤 드롭할 수 없습니다. 그래서 KitchenObject 스크립트를 만들어서 Prefab에 넣어야 합니다. 뭔가 쓰고 보니 말이 좀 헷갈리네요.<br><img src="https://blog.kakaocdn.net/dn/pp8fj/btspRh2ZVw7/OflwT6hlZfzIauDyiRsKDK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; }
}
즉 여러 KitchenObject&nbsp;(Tomato, Cheese etc..)를&nbsp;사용하는 곳 일종의 Type Erasing을 하는 곳에서는 Scriptable Object를 사용해서 관리하고 유니티에서 프리팹으로 KitchenObject에 Scriptable Object 레퍼런스를 넣어주면 되겠습니다.public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; // KitchenObject로 Scriptable Object를 얻을 수 있음! Debug.Log(kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().GetKitchenObjectSO().objectName); }
}
]]></description><link>unity/16.-kitchen-object,-scriptable-object.html</link><guid isPermaLink="false">Unity/16. Kitchen Object, Scriptable Object.md</guid><pubDate>Tue, 31 Dec 2024 05:51:53 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[17. Kitchen Object Parent]]></title><description><![CDATA[플레이어나 Counter들은 Kitchen Object를 가지고 있을 수 있어요.(플레이어는 Kitchen Object를 들 수 있고, Counter는 위에 Kitchen Object를 올릴 수 있습니다.) 이것을 Parent라고 할게요. 나중에 Interface를 이용해서 바꾸겠지만 지금은 Kitchen Object의 부모는 Clear Counter라고 가정하고 코드를 작성할게요.플레이어가 키친 오브젝트를 들고 있고 ClearCounter에 가서 ClearCounter의 Interact() 코드를 호출할 거예요. 이때 Clear Counter가 자식을 가지고 있으면 (즉 키친 오브젝트가 올려져 있으면) 아무것도 처리하지 않고, 자식을 가지고 있지 않으면 Kitchen Object를 자식으로 만들면 되겠네요.그리고 KitchenObject에서 부모를&nbsp; SetClearCounter로 설정하면 되어요. 그리고 키친오브젝트의 부모를 Set할 때 부모의 UI를 업데이트를 하면 됩니다. 비주얼 업데이틀 어떻게 하면 될까요? 부모의 Top인 CounterTopPoint에 올려놓으면 됩니다. 그리고 여기에서 부모의 메서드인 SetKitchenObject를 해주면 될 거예요. (부모의 자식은 나다.)public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; private void Update() { } public void Interact() { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetClearCounter(this); } else { Debug.Log(kitchenObject.GetClearCounter()); } } public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
이제 KitchenObject로 가서 SetClearCounter()를 구현합시다.public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private ClearCounter clearCounter; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public ClearCounter GetClearCounter() { return clearCounter; } public void SetClearCounter(ClearCounter clearCounter) { if (this.clearCounter != null) { this.clearCounter.ClearKitchenObject(); } this.clearCounter = clearCounter; if (clearCounter.hasKitchenObject()) { Debug.LogError("clear counter already has kitchen object"); } clearCounter.SetKitchenObject(this); transform.parent = clearCounter.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }
}
]]></description><link>unity/17.-kitchen-object-parent.html</link><guid isPermaLink="false">Unity/17. Kitchen Object Parent.md</guid><pubDate>Tue, 31 Dec 2024 05:51:36 GMT</pubDate></item><item><title><![CDATA[캐릭터 움직임과 Time.deltaTime]]></title><description><![CDATA[이번에는 유니티를 이용해 WASD로 움직이는 캐릭터를 만들어봅시다.Unity Project 3D URP로 생성해요.<img src="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">공허한 화면을 뒤로한 채 Hierarchy에서 오른쪽 클릭 후 3D Object -&gt; Plane을 눌러서 생성합시다. 이름을 Floor로 해줄게요그런 다음에, Inspector 창에서, Scale을 5, 5, 5로 Position과 Rotation을 0, 0, 0으로 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/bgttrZ/btsn6GSp3Nd/jRc4YxJMqApLlhmuq8I6O0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하이어러키 창에서 메인 카메라를 클릭한 다음 인스펙터창에서 Position, Rotation, Scale을 아래처럼 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/AjHWa/btsn9Tizkle/7XvsKtRoy95S7IjBmF8cd1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하이어러키 창에서 Create Empty를 만들고 이름을 Player로 합시다. 그리고 만든 Player 하위에 3D Object - Capsule을 생성합니다. 이렇게 하는 이유는 뷰 로직과 동작 로직을 분리하기 위해서예요.Player 오브젝트의 Position과 Rotation은 0,0,0 Scale은 1,1,1으로 설정하고 PlayerVisual(하위에 만든 캡슐)은 Postion (0,1,0) Rotation은 0,0,0, Scale은 1,1,1로 설정해 주세요.<br><img src="https://blog.kakaocdn.net/dn/RqMrq/btsn8pI3tFB/SnaoJYXV9i7IINUlK9jrO1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/cBgb5p/btsn7trHo5k/ibnoMMkaaZStsV2b9Jpaek/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Project 창에서 Asset 폴더 아래에 Script 폴더를 만들고 그곳에 C# Script를 만들고 파일을 Player 오브젝트에 드래그 앤 드롭합니다.그런 다음에 Asset - Open C# Project를 클릭합니다.<br><img src="https://blog.kakaocdn.net/dn/TaZwr/btsn8pI31yr/M7jSrnckR44FD7Tkg4yU70/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class Player : MonoBehaviour { [SerializeField] private float moveSpeed = 7f; private void Update() { Vector2 inputVector = new Vector2(0, 0); if (Input.GetKey(KeyCode.W)) { inputVector.y += 1; } if (Input.GetKey(KeyCode.A)) { inputVector.x -= 1; } if (Input.GetKey(KeyCode.S)) { inputVector.y -= 1; } if (Input.GetKey(KeyCode.D)) { inputVector.x += 1; } inputVector = inputVector.normalized; Vector3 moveDir = new Vector3(inputVector.x, 0, inputVector.y); transform.position += moveDir * moveSpeed * Time.deltaTime; }
}
좌표 시스템이 평소 학교에서 배웠던 거랑 일치하지 않을 수 있어요. 그리고 게임 엔진마다 축이 조금씩 상이하더라고요.&nbsp; 제가 공부할 때는 Right Handed를 많이 사용했는데, 유니티는 Left Handed라고 합니다. 아래 그림 참고 하시면 될 것 같아요.<br><img src="https://blog.kakaocdn.net/dn/TIRvR/btsn8lfDOKD/RL0AI3d1kyNgGDFcfsrZSk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드 자체는 별 게 없는 것 같아요. 조금 특징적인 것에 대해서만 알면 될 것 같습니다.inputVector = inputVector.normalized;
왜 inputVector를 정규화를 할까요? 왜냐하면, Vector는 속력이 아닌 속도를 나타내기 때문입니다. 만약 정규화를 하지 않았을 때, 대각선으로 이동한다면 inputVector의 값은 (1,1)이 될 거예요. 그러면 벡터의 길이 (스칼라) 값은 1.414...이 되기 때문에 대각선으로 이동할 때 더 빠른 속도로 이동하게 됩니다. 즉 동일한 속도가 보장이 되지 않게 됩니다. 이러한 이유로 정규화를 통해서 방향만을 얻고, 이동 속도는 변수로 곱해서 처리하는 것이 일반적인 것 같습니다.transform.position += moveDir * moveSpeed * Time.deltaTime;
위 코드에서 속력과 방향에 Time.deltaTime를 곱하고 있습니다. 왜 그럴까요? 이것을 알기 위해서는 Frame(프레임)과 FPS에 대해 먼저 알아야 합니다.동영상은 정지된 여러 장의 사진으로 구성되어 있고, 우리는 이 사진이 빠르게 변하는 것을 움직이는 것으로 보게 됩니다. 여기에서 이 정지된 사진을 프레임이라고 합니다. FPS는 Frame Per seconds의 준말로 1초당 몇 장의 사진이 변하는가입니다. 60 FPS면 1초당 연속하는 60장의 사진을 보는 것이라고 이해하면 될 것 같아요. 그래서 FPS는 성능에 비례합니다. (고사양 컴퓨터면 더 높고, 더 낮은 사양이면 더 낮습니다.)유니티에서 Update() 메서드는 1 프레임을 주기로 호출됩니다. 만약 위의 코드에서 Time.deltaTime이 없다면, 어떻게 될까요? 고사양의 컴퓨터를 가진 사람은 더 빨리 이동할 것입니다. 저사양의 컴퓨터를 가진 사람은 더 느리게 이동할 테고요. 이러한 차이를 보정하기 위해서 바로 Time.deltaTime을 곱하는 것입니다.&nbsp;유니티에서 Time.deltaTime의 정의는&nbsp;The interval in seconds from the last frame to the current one입니다.&nbsp;즉 현재 프레임과 이전 프레임의 시간 간격을 의미하게 되는 거예요. 따라서 고사양의 컴퓨터는 deltaTime의 값은 작을 테고, 저사양의 컴퓨터의 값은 더 높게 됩니다.&nbsp;고사양 컴퓨터는 60 fps가 나오고, 저사양의 게임은 30fps가 나온다고 가정하면, 아래와 같이 1 프레임당 시간 간격, 즉 deltaTime을 구할 수 있습니다.30fps = 1 / 30 = 0.03333333360fps = 1 / 60 = 0.01666666이때 Update 코드를 생각해봅시다. Update 코드는 1 프레임에 한번 호출된다고 했으니까,&nbsp;저사양 컴퓨터: (moveDir moveSpeed 0.3333333) * 30 만큼 이동 (30프레임)고사양 컴퓨터: (moveDir moveSpeed 0.016666666) * 60 만큼 이동 (60프레임)의 값은 같게 됩니다.그래서, Time.deltaTime로 컴퓨터 사양에 따른 이동을 보정할 수 있게 됩니다.캐릭터 이동을 구현할 때, GetKey를 이용해 구현하는 것보다, Input System이라는 package를 이용해서 구현하는 것이 확장하기 더 좋아요. 절대 Input System Package를 이용하세요!<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/Ex_Collision_Detection" target="_self">https://github.com/psychehose/Ex_Collision_Detection</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/destiny9720/221411002215?view=img_1" target="_self">https://m.blog.naver.com/destiny9720/221411002215?view=img_1</a>&nbsp;<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization" target="_self">https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://windeva.tistory.com/840" target="_self">https://windeva.tistory.com/840</a>]]></description><link>unity/캐릭터-움직임과-time.deltatime.html</link><guid isPermaLink="false">Unity/캐릭터 움직임과 Time.deltaTime.md</guid><pubDate>Tue, 31 Dec 2024 05:49:28 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Glow Effect 만들기]]></title><description><![CDATA[게임을 만들어보고 싶어서, 요즘 유니티를 공부하고 있어요.게임을 하다 보면 반짝거리는 물체들이 많이 있는데, 이 반짝거리는 효과를 어떻게 만드는지 공부해 보고 정리해 봤습니다.&nbsp;Glow Effect를 만들기 위해서 4가지가 성립해야 합니다.
Shader - Emission에서 Color가 검은색이 아니고, Intensity &gt; 0 이어야 합니다.
Post Processing Bloom (Intensity와 Threshold 세팅)
Render Pipeline Asset에서 HDR 체크
Camera에서 Rendering - Post Processing 체크
먼저 3D Object 구를 만든 다음에 이 구에 적용한 Material을 만듭시다.<img src="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/digjIe/btsnTEeToHv/SEV8Xa8MbugddHdz7EcIT0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">만든 Material을 구에 드래그 앤 드랍 해줍시다. 구 오브젝트를 선택하고 오른쪽 Inspector에서 Surface Inputs - Emission을 체크하고 색깔(검은색 X)을 지정하고 intensity를 0보다 높게 설정하면 1번 과정은 끝입니다. 그러면 구에 색깔이 있을 거예요.intensity를 엄청 높여도 Render Pipeline Asset이 HDR 옵션이 해제되어 있다면 Glow Effect는 나타나지 않을 거예요. 만약 나타난다면 HDR 옵션이 체크되어 있는 겁니다.<br><img src="https://blog.kakaocdn.net/dn/rYlDe/btsnTDfYB5N/KTQwg2cdfH6vEaKk9GTnR0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 Post Processing 옵션을 가지고 있는 Object를 만들 거예요. Create Empty 하고 이름을 변경합시다. 그런 다음에 아래처럼 Add Componet를 눌러서 Volume을 추가합시다.<br><img src="https://blog.kakaocdn.net/dn/cAcJUG/btsnSXFAZ5U/Uirq8dXFSglHSBkO8vArnK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/ME19w/btsnFK8UrKr/uTAOWh6GYcHtVmySaBjv61/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/EykhQ/btsnEXAV6i8/qMLIiOvafOxKXXFoe67ye1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Volume에서 Profile 칸이 아마 비워져 있을 텐데, New를 클릭해서 새로 생성한 뒤에, Add Override를 눌러서 Post Processing - Bloom을 클릭합니다. 그리고 Threshold를 설정하고 Intensity를 설정하면 됩니다. 이때 Threshold는 최솟값이에요. Intensity보다 작아야 작동합니다. Intensity는 Glow Effect의 강함입니다. 저는 Intensity를 1로 설정하겠습니다. 아직도 역시 효과가 없을 거예요!이제 URP에서 HDR 옵션을 체크해 주면 Glow Effect가 적용됩니다.<br><img src="https://blog.kakaocdn.net/dn/yWAiA/btsnF6Ya6uR/KmEDRHvcznviMUYwbWb2fK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">근데 한 가지 문제점이 있는데 씬 뷰에서는 적용되는데 게임 뷰에서 적용이 안될 수도 있습니다. (아래사진 왼쪽). Camera를 클릭해서 Rendering - Post Processing을 체크하면 게임 뷰에서도 적용(아래사진 오른쪽)됩니다.<br><img src="https://blog.kakaocdn.net/dn/bFAcJS/btsnLvJE7ic/KLNSIRJlE4hBxymlgALJVK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/bg7pfi/btsnHRsEeVi/k0CzMQSMCyd2nV873aYKqK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">단순 Glow Effect 뿐만 아니라 더 다양한 Effect를 적용하고 싶을 때 (예를 들면 캐릭터를 클릭했을 때 외곽선 하이라이팅 하고 싶은 경우)는 Unity에서 제공하는 Shader Graph를 사용하면 된다고 하네요. 다음에 기회가 되면 다뤄보도록 하겠습니다~<br>&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=bkPe1hxOmbI" target="_self">https://www.youtube.com/watch?v=bkPe1hxOmbI</a>]]></description><link>unity/glow-effect-만들기.html</link><guid isPermaLink="false">Unity/Glow Effect 만들기.md</guid><pubDate>Tue, 31 Dec 2024 05:48:39 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵)]]></title><description><![CDATA[컬렉션은 내장된 배열과 튜플 타입과는 다르게 힙에 저장됩니다. 이것은 데이터량이 런타임에서 변경될 수 있다는 뜻입니다. 러스트 표준 라이브러리가 제공하는 컬렉션은 다음과 같습니다.
sequence 타입: Vec, VecDeque, LinkedList
map 타입: HashMap, BTreeMap
Sets 타입: HashSet, BTreeSet
Misc 타입: BinaryHeap
그중에서 자주 사용되는 세 가지 컬렉션을 알아보겠습니다.
Vec는 여러 개의 값을 서로 붙어 있게 저장합니다.
String은 문자의 모음입니다.
HashMap은 키-값으로 저장합니다.
let v: Vec&lt;i32&gt; = Vec::new();
벡터는 제네릭을 이용해서 구현되어있습니다. 그래서 어떠한 종류의 값도 저장할 수 있습니다.let v = vec![1,2,3];
let v = Vec::from([1,2,3,4]);
let v = vec![0; 5]; // [0,0,0,0,0]
초기값이 있는 벡터를 생성하는 것은 흔한 일이기 때문에 러스트에서는 vec! 매크로를 제공하고 있습니다. Vec의 static method인 from을 이용해서도 배열을 생성할 수 있습니다. 길이가 n인 배열을 생성하고 0으로 초기화할 수 있습니다.let mut v = Vec:new();
v.push(5);
v.push(6);
v.push(7);
v.pop();
v.pop(); // insert(index, value)
// remove(index)
v.insert(1,4)
v.remove(1) // let mut vec = vec![1, 2, 3];
let mut vec2 = vec![4, 5, 6];
vec.append(&amp;mut vec2);
assert_eq!(vec, [1, 2, 3, 4, 5, 6]);
assert_eq!(vec2, []);
컬렉션 변수에 대해서 그 변수가 담고 있는 값이 변경되게 하려면 mut 키워드를 사용합니다. push &amp; pop을 사용해서 벡터 값을 자료구조 스택처럼 사용할 수 있습니다.특정한 인덱스에 값을 넣고 빼기 위해서는 insert &amp; remove를 사용하면 됩니다. Insert &amp; remove는 인덱스를 직접 사용하기 때문에 인덱스 범위를 넘어가면 패닉을 일으키게 됩니다.배열과 배열의 연산에는 append를 이용합니다. 특이한 점이 append를 하게 되면 추가 하는 항목들이 있는 배열에서 요소들이 사라집니다.let v = vec![1, 2, 3, 4, 5]; let third: i32 = v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
벡터 요소를 읽기 위해서는 []과 get 함수를 이용하는 방법입니다. []를 이용하는 경우 존재하지 않는 요소를 참조하게 되면 패닉을 일으키게 되겠죠?get 함수를 사용하면 벡터 범위를 벗어난 인덱스를 사용하면 퍄닉 없이 None이 반환됩니다.let v = vec![100, 32, 57];
for i in &amp;v { println!("{}", i);
} /// let mut v = vec![100, 32, 57];
for i in &amp;mut v { *i += 50;
}
인덱스를 명시하지 않아도, Swift나 Python처럼 반복문을 돌면서 요소에 접근할 수 있습니다. 요소들을 변경시키길 원한다면 역참조연산자(*)를 사용하면 됩니다.String은 문자들의 모음입니다. 러스트에서 스트링은 세 가지 특징적인 개념을 가집니다.
에러를 꼭 명시해줘야 합니다.
복잡한 데이터 구조를 가지고 있습니다.&nbsp;
UTF-8이라는 점입니다.
let mut s = String::new();
// let data = "initial contents";
let s = data.to_string(); // the method also works on a literal directly:
let s = "initial contents".to_string(); let s = String::from("initial contents");
스트링 생성은 String 타입의 new() 정적 메소드를 이용해서 할 수 있습니다. 그리고 스트링 리터럴(&amp;str)을 생성하고. to_string() 메서드를 이용해서 생성할 수도 있습니다.let mut s = String::from("foo");
s.push_str("bar"); let mut s1 = String::from("foo");
let s2 = "bar"; // 참조자를 사용하기 때문에 소유권을 넘기지 않음.
s1.push_str(&amp;s2);
println!("s2 is {}", s2);
스트링에 스트링을 추가하기 위해서 push_str 메소드를 사용할 수 있습니다.&nbsp; 문자 한 개를 추가하길 원하면 push() 메서드를 사용할 수 있습니다.&nbsp;let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &amp;s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요 연산자를 이용해서 문자열끼리 접합할 수 있습니다. 위의 코드를 보면 let s3 = s1 + &amp;s2; 입니다. s1에는 참조자가 붙지 않고 s2에 참조자가 붙어 있는 것을 볼 수 있는데요. 이것은 스트링에서 + 연산자는 add 메서드를 이용하기 때문입니다.
fn add(self, s: &amp;str) -&gt; String {
add()를 자세하게 보고 s3의 코드를 보면 조금 당황할 수도 있습니다. 왜냐하면, add의 파라미터는 &amp;str 타입인데 &amp;s2의 타입은 &amp;String이기 때문입니다. 하지만 컴파일러는 이를 컴파일 할 수 있습니다. 왜 그럴까요? &amp;String인자는 &amp;str로 강제될 수 있기 때문입니다. 이를 러스트에서는 역참조 강제(deref coercion)라고 합니다.위에서 보듯 +의 동작은 다루기가 불편한 것처럼 보입니다. 어떤 것은 String이고, 붙여지는 건 &amp;str인 것처럼요. 왜냐하면 이는 소유권에 대해서 더 신경을 써야한다는 것을 의미하니까요. 그래서 러스트는 format! 매크로를 제공합니다. 이를 이용하면 어떠한 파라미터의 소유권도 가져오지 않고 보기 쉽게 스트링을 합칠 수 있습니다.&nbsp;let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe"); let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
// let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe"); let s = format!("{}-{}-{}", s1, s2, s3);
let s1 = String::from("hello");
let h = s1[0];
다른 언어처럼 스트링에 인덱스로 접근하고 싶습니다. 위의코드는 컴파일이 될까요? 접근하면 어떻게 될까요? 러스트에서 스트링 인덱스 접근은 지원하지 않습니다. 이것을 이해하기 위해서 스트링이 어떻게 메모리에 저장되는지 확인해봐야 합니다.String은 Vec을 감싼 것입니다.&nbsp;let len = String::from("Hola").len(); // 1 let len = String::from("Здравствуйте").len(); len은 4입니다. 이건 4byte 길이라는 뜻입니다.
len은 24입니다. 글자는 12개지만, 이 문자 각각의 유니코드 스칼라 값이 2입니다. 12* 2 = 24
이 말은 스트링의 바이트들 안의 인덱스는 유니코드 스칼라 값과 항상 대응되지 않는다는 것을 의미합니다.그리고 인덱스 연산은 언제나 상수 시간에 실행될 것으로 기대를 받는데, String으로 그러한 성능을 보장하는 것은 불가능입니다. 왜냐하면 스트링 내에 얼마나 많은 문자가 있는지 알아내기 위해 시작지점부터 인덱스로 지정된 곳까지 살펴봐야 하기 때문입니다.만약 스트링 슬라이스를 만들기 위하고 인덱스를 사용하길 원한다면 구체적으로 지정해야 합니다.let hello = "Здравствуйте"; let s = &amp;hello[0..4]; // Зд
// let s = &amp;hello[0..1]; // 패닉 발생!
반복문을 돌면서 바이트에 관계 없이 유니코드 스칼라 값(글자)에 대한 연산을 하길 원하면 chars를 사용하면 됩니다.for c in "नमस्ते".chars() { println!("{}", c);
} for b in "नमस्ते".bytes() { println!("{}", b);
}
즉 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 확실히 기억해야만 합니다.''use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); // let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50]; let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
추가적으로 튜플의 벡터에 대해 collect 메서드를 사용해서 생성할 수 있습니다collect 메소드는 데이터를 모아서 컬렉션 타입으로 만들어줍니다.let field_name = String::from("Favorite color");
let field_value = String::from("Blue"); let mut map = HashMap::new();
map.insert(field_name, field_value);
insert 할 때, field_name과 field_value의 소유권은 map으로 이동합니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); let team_name = String::from("Blue");
let score = scores.get(&amp;team_name);
..use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); for (key, value) in &amp;scores { println!("{}: {}", key, value);
}
반목문 접근은 다른 컬렉션과 마찬가지로 &amp;를 이용해서 접근할 수 있습니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25); println!("{:?}", scores);
위의 코드는 키에 대한 값이 있어도 덮었어 집니다.&nbsp;만약 키에 할당된 값이 없을 경우에만 삽입하고 싶으면 다음 entry API를 이용하면 됩니다.entry의 리턴 값은 Enum 타입 Entry인데 있는지 없는 지를 반환합니다.Entry의 or_insert 메소드는 해당 키가 존재하는 경우는 Entry 키에 대한 값을 반환하고 아닌 경우에는 새 값을 삽입하고 수정된 Entry에 대한 값을 반환합니다.se std::collections::HashMap; let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10); scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50); println!("{:?}", scores);
이걸로 러스트의 콜렉션 타입 중 가장 자주 쓰이는 Vec, String, HashMap에 대해 알아보았습니다.]]></description><link>rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html</link><guid isPermaLink="false">rust/Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵).md</guid><pubDate>Tue, 31 Dec 2024 05:47:06 GMT</pubDate></item></channel></rss>