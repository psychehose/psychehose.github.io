<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[psychehose.github.io]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>psychehose.github.io</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 18 Jun 2025 12:47:47 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 18 Jun 2025 12:45:14 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[3405. Count the Number of Arrays with K Matching Adjacent Elements]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:hard" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#hard">#hard</a>2단계로 접근해야 문제를 쉽게(?) 풀 수 있음. 한번에 하려고 하면 무슨 말인지 이해가 안가서 2단계로 나눠야함.조건 Exactly k indices i (where 1 &lt;= i &lt; n) satisfy the condition arr[i-1] == arr[i]
를 만족하려면 경계가 있어야함. 사이즈가 n이라면 공간은 n-1개가 있고 이 n-1개의 공간에 막대기를 놓는걸로 생각할 수 있음.k가 작아지면 그룹 개수는 커진다. (연속된 수가 없이 잘려야 하므로) k가 커지면 그룹 개수는 작아진다. (연속된 수 그룹이 있으니)만약 n = 6, k = 3 이라면 공간은 n-1 = 5개가 있고, 막대기는 n-k-1 (6-3-1) 즉 공간이 3개가 됨.
xx | yy | xx
xxx | y | x 등등
만약 n = 6이고, k = 2라면 막대기를 n-k-1 (6-2-1)개 즉 공간은 4개
xx | yy | x | y 등등
막대기의 개수는 n-k-1핵심 원리는 그룹 길이와 매치 개수의 관계를 생각하면 된다.길이 1: [a] → 0개 매치 길이 2: [a,a] → 1개 매치 길이 3: [a,a,a] → 2개 매치 길이 4: [a,a,a,a] → 3개 매치
전체 매치 개수(k) = n - 그룹 개수그룹 개수 = n - k
막대기 개수는 n-k-1그러면 총 n-1개의 공간에서 n-k-1개의 막대기를 놓는 경우의 수를 구하는 것이기 때문에 조합!조합식 C(n-1, n-k-1)인데 조합의 대칭성을 이용해 C(n-1, k)를 구할 수 있음 (C(n,r) = C(n, n-r)과 같음)
xx에는 1 ~ m 까지의 숫자 선택 가능 (m option)
yy에는 앞에 들어간 수(xx) 제외하고 선택 가능 (m-1 option)
xx에는 앞에 들어간 수(yy) 제외하고 선택 가능 (m-1 option)
그럼 답은? C(n-1, k) m (m - 1) * (m-1)일반화 하면 답은 C(n-1, k) m (m-1)^(n-k-1)하지만 C(n-1, k) m (m-1)^(n-k-1)는 매우 큼. 그래서 나머지 연산을 통해서 리턴을 해야함.{C(n-1, k) m (m-1)^(n-k-1) } % MOD는 분배법칙에 의하여{C(n-1, k) m (m-1)^(n-k-1) } % MOD = { (C(n-1,k) % MOD) × (m % MOD) × (pow((m-1), n-k-1) % MOD) } % MOD가 성립함.나머지 연산은 곱셈에 대한 분배 법칙이 성립하기 때문이다.따라서 일단 값을 구해보자 C(n-1, k) * MOD
m * MOD
pow(m-1, n-k-1) % MOD
2번은 그냥 값이 나오고, 3번은 pow(m-1, n-k-1)을 구해야 하는데 그냥 무턱대고 pow를 하면 값을 초과해버린다.double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);
그래서 만들어줘야한다. 비트 연산을 해서 계속 MOD를 통해서 overflow를 방지해야한다. long long power(long long base, long long exp) { long long result = 1; base %= MOD; while (exp &gt; 0) { if (exp &amp; 1) result = (result * base) % MOD; base = (base * base) % MOD; exp &gt;&gt;= 1; } return result; }
그러면 2번과 3번은 해결한거고 문제는 조합에 모듈러 연산을 적용 하는것이다.모듈러 연산은 나눗셈에 대해서 분배법칙이 성립하지 않는다. 따라서 나눗셈을 곱셈으로 바꿔줘야한다. Modular Inverse (모듈러 역원)을 이용해서 변형할 수 있다.Modular Inverse란? b⁻¹는 (b × b⁻¹) % MOD = 1이 되는 수다.MOD = 7일 때, 3의 역원은?
3 × ? ≡ 1 (mod 7)
3 × 5 = 15 ≡ 1 (mod 7)
따라서 3⁻¹ = 5
이 모듈러 역원을 구하는 방법이 페르마 소정리다.p가 소수일 때: a⁻¹ ≡ a^(p-2) (mod p)
조합을 구하는 방법 C(n ,r) = n! / (r! * (n-r)!)이다.분모와 분자를 따로 구한 후에 분모에 Modular 역원을 구해주면 된다.그러면 1번 식도 구할 수 있게 된다.최종적으로 1번 * 2번 * 3번 * MOD 를 해주면 된다. 그리고 값이 초과할 것 같은 곳에서도 MOD 처리를 한다.class Solution {
public: static const long long MOD = 1e9 + 7; long long factorial(int n) { long long result = 1; for (int i = 2; i &lt;= n; i++) { result *= i; } return result; } long long combination(int n, int r) { if (r &gt; n || r &lt; 0) return 0; return factorial(n) / (factorial(r) * factorial(n - r)); } // pow는 long long을 초과함. 그래서 long long을 리턴하는 pow를 제작해야함. long long power(long long base, long long exp) { long long result = 1; while (exp &gt; 0) { if (exp &amp; 1) result = (result * base) % MOD; base = (base * base) % MOD; exp &gt;&gt;= 1; } return result; } long long modInverse(long long a) { return power(a, MOD - 2); } long long combination2(long long n, long long r) { if (r &gt; n || r &lt; 0) return 0; if (r == 0 || r == n) return 1; long long numerator = 1; long long denominator = 1; for (long long i = 0; i &lt; r; i++) { numerator = (numerator * (n - i)) % MOD; denominator = (denominator * (i + 1)) % MOD; } return (numerator * modInverse(denominator)) % MOD; } int countGoodArrays(int n, int m, int k) { /* Exactly k indices i (where 1 &lt;= i &lt; n) satisfy the condition arr[i - 1] == arr[i] 를 만족하려면 경계가 있어야함. 사이즈가 n이라면 공간은 n-1개가 있고, 이 n-1개의 공간에 막대기를 놓는걸로 생각할 수 있음. 1. 그룹 나누기 k가 작아지면 그룹 개수는 커진다. (연속된 수가 없이 잘려야 하므로) k가 커지면 그룹 개수는 작아진다. (연속된 수 그룹이 있으니) if n = 6, k = 3 이라면 공간은 n-1 = 5개가 있고, 막대기는 n-k-1 (6-3-1) 즉 공간이 3개가 됨. xx | yy | xx xxx | y | x 등등 if n = 6이고, k = 2라면 막대기를 n-k-1 (6-2-1)개 즉 공간은 4개 xx | yy | x | y 막대기의 개수는 n-k-1 즉 조합식 C(n-1, n-k-1)인데 조합의 대칭성을 이용해 C(n-1, k)를 구할 수 있음 그럼 xx | yy | xx가 있다고 생각할 때 2. 값을 할당하기 xx에는 1 ~ m 까지의 숫자 선택 가능 (m option) yy에는 앞에 들어간 수(xx) 제외하고 선택 가능 (m-1 option) xx에는 앞에 들어간 수(yy) 제외하고 선택 가능 (m-1 option) 그럼 답은? C(n-1, k) * m * (m - 1) * (m-1) 일반화 한다면? n-k-1 개의 막대기는 n-k개의 그룹 n-k개의 그룹 -&gt; 처음은 m개 그 이후는 m-1개 이게 총 갯수 C(n-1, k) * m * (m-1)^(n-k-1) {C(n-1, k) * m * (m-1)^(n-k-1) } % MOD 분배법칙에 의하여 { (C(n-1,k) % MOD) × (m % MOD) × (pow((m-1), n-k-1) % MOD) } % MOD */ long long comb = combination2(n-1, k) % MOD; long long m_mod = m % MOD; long long power_mod = power(m-1, n-k-1) % MOD; return (comb * m_mod % MOD) * power_mod % MOD; }
};
]]></description><link>algorithm/leetcode/3405.-count-the-number-of-arrays-with-k-matching-adjacent-elements.html</link><guid isPermaLink="false">Algorithm/LeetCode/3405. Count the Number of Arrays with K Matching Adjacent Elements.md</guid><pubDate>Tue, 17 Jun 2025 14:38:28 GMT</pubDate></item><item><title><![CDATA[ Home]]></title><description><![CDATA[ 금융공학과 소프트웨어공학을 전공하며 쌓은 수학적, 논리적 사고를 바탕으로 iOS 개발을 시작했습니다. 저는 시스템 설계와 구현에 강점이 있으며, 새로운 기술 도입에 적극적입니다. iOS 개발과 Android / iOS SDK - 언리얼엔진 플러그인 개발을 해왔습니다. 현재는 크로스플랫폼 (Windows, Android, iOS)을 타겟으로 하는 골프공 물리 시뮬레이터 개발과 스윙 모션 영상 처리를 개발 하고 있습니다.
C++ CMake - ⭐⭐⭐
OpenCV - ⭐⭐⭐ Swift Objective C RxSwift - ⭐⭐⭐⭐
Java Android - ⭐⭐
Unreal Engine - ⭐⭐
Git Perforce Helix Core -⭐⭐⭐
⭐⭐⭐⭐: 전문적 활용 - 심화 문제 해결 및 최적화 가능
⭐⭐⭐ : 실무 활용 - 일상적 개발 업무 수행 가능
⭐⭐: 기본 활용 - 이해 및 참고 자료를 통한 구현 가능
Graphics
Robotics
Computer Vision C++ 물리 라이브러리 리팩토링 (Only Windows -&gt; 크로스 플랫폼) C++ 골프공 물리 Simulator 개발 (C++, Qt, OpenGL, Metal) 크로스플랫폼 비디오 캡쳐 라이브러리 개발중 (OpenCV) 안드로이드 / iOS 네이티브 라이브러리 개발 및 언리얼엔진 통합
+ 언리얼엔진 클라이언트 개발 및 언리얼 인사이트를 활용한 게임 최적화 경험
+ 브랜치 머지 전략 수립과 코드 리뷰 문화 도입 등을 통해 개발 문화를 정착 핀테크 기업에서 iOS 개발자로 근무하며 블록딜 및 비상장주식 플랫폼 개발을 주도 펀드고 앱 : 기획/디자인 단계부터 참여하며 모든 피쳐 개발을 담당 제이스톡 앱 : Modular Architecture를 바탕으로 비상장주식 거래 플랫폼을 개발 + 회사 내 프로젝트를 위한 인앱결제, 네트워크, 유저 정보, OAuth 모듈을 개발 및 CI/CD 배포 환경을 구축 Role - iOS Developer lead
20th SOPT 앱잼(3주 장기 해커톤) Project Init ~ AppStore 배포 종료 (22.11 ~ 24.07)
MVVM, RxSwift, ReactorKit, xcframework, fastlane
SPM을 이용한 일부 부분 모듈화
iOS 4명 - 기획 1명 - 디자인 1명 - 서버 2명 - 안드로이드 4명 Role - iOS Developer
무중력지대 씨앗프로젝트
Project Init ~ AppStore 배포 종료(20.09 ~ 22.08)
MVVM, RxSwift, Moya, `Socket' iOS 3명 - 기획 2명 - 디자인 1명 - 서버 2명 16th SOPT 앱잼 (3주 장기 해커톤) Project Init ~ AppStore 배포 종료 (20.08 ~ 23.04)
MVC , YPImagePicker …
iOS 5명 - 기획 2명 - 디자인 1명 - 서버 1명 - 안드로이드 3명
MAU: 225명
전체 유저: 1,295명 / 고양이: 1,523마리 / 리뷰: 11,169개
아주대학교 금융공학과 전공, 소프트웨어학과 복수전공
딥러닝 컴퓨터 비전 완벽 가이드 - 인프런
Qt 프로그래밍 1편 - 인프런
SOPT 창업동아리 26th iOS 파트 수료2023 let us: Go! Summer 찍먹톤 최우수상 (2023.06)
SOPT 창업동아리 20th 앱잼 대상 (2022.08)
SOPT 창업동아리 16th 앱잼 최우수상 (2020.08)Glitch Hackathon - Near Rust SDK 사용 Project (2023.05)
Email: <a data-tooltip-position="top" aria-label="mailto:psychehose@gmail.com" rel="noopener nofollow" class="external-link" href=".html" target="_self">psychehose@gmail.com</a>
<br>GitHub: <a data-tooltip-position="top" aria-label="https://github.com/psychehose" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose" target="_self">psychehose</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 03 Jun 2025 05:53:57 GMT</pubDate></item><item><title><![CDATA[Develop]]></title><link>hose/develop.html</link><guid isPermaLink="false">Hose/Develop.md</guid><pubDate>Sat, 31 May 2025 10:51:08 GMT</pubDate></item><item><title><![CDATA[ROS 2 핵심 통신 개념]]></title><description><![CDATA[ROS 2(Robot Operating System 2)는 로봇 소프트웨어 개발을 위한 프레임워크로, 분산 시스템을 효율적으로 구축할 수 있게 해준다. ROS 2 Humble의 핵심 통신 개념과 관련 명령어를 정리한다.노드는 ROS의 기본 실행 단위이다. 각 노드는 특정 기능을 수행하는 독립적인 프로세스로, 다른 노드들과 통신하며 전체 시스템을 구성한다.
독립적으로 실행되는 프로세스임
단일 목적을 가지는 모듈화된 코드임
다른 노드와 토픽, 서비스, 액션을 통해 통신함
rclcpp(C++) 또는 rclpy(Python) 라이브러리로 구현함
# 실행 중인 모든 노드 목록 표시
ros2 node list # 특정 노드에 대한 정보 표시
ros2 node info /노드_이름 # 노드 실행
ros2 run 패키지_이름 실행_파일
토픽은 노드 간 비동기식 단방향 통신을 위한 메커니즘이다. 발행자(Publisher)와 구독자(Subscriber) 모델을 사용한다.
지속적인 데이터 스트림에 적합함
일대다(one-to-many) 통신 지원함
비동기적으로 작동하여 발행자는 구독자의 존재 여부에 관계없이 메시지를 보낼 수 있음
센서 데이터, 로봇 상태 등 지속적인 정보 공유에 주로 사용함
# 모든 토픽 목록 표시
ros2 topic list # 토픽과 그 메시지 타입 함께 표시
ros2 topic list -t # 특정 토픽에 대한 정보 표시
ros2 topic info /토픽_이름 # 토픽에 발행되는 메시지 실시간 출력
ros2 topic echo /토픽_이름 # 토픽에 메시지 발행
ros2 topic pub /토픽_이름 메시지_타입 메시지_내용 # 토픽의 발행 주기 측정
ros2 topic hz /토픽_이름
서비스는 동기식 요청-응답 통신 방식이다. 클라이언트-서버 모델을 사용하며, 클라이언트가 요청하면 서버가 응답한다.
일회성 작업에 적합함
요청이 완료될 때까지 클라이언트는 대기함
동기적으로 작동하여 응답을 받을 때까지 블로킹됨
상태 쿼리, 파라미터 설정, 간단한 계산 등에 사용함
# 사용 가능한 모든 서비스 목록 표시
ros2 service list # 서비스와 타입 함께 표시
ros2 service list -t # 서비스의 타입 표시
ros2 service type /서비스_이름 # 특정 타입의 서비스 찾기
ros2 service find 서비스_타입 # 서비스 호출
ros2 service call /서비스_이름 서비스_타입 요청_내용
액션은 장기 실행 작업을 위한 고수준 통신 방식이다. 목표(Goal), 피드백(Feedback), 결과(Result)의 세 가지 통신 채널을 사용한다.
취소 가능한 장기 실행 작업에 적합함
실행 중 상태 피드백을 제공할 수 있음
비동기적으로 작동하여 클라이언트가 다른 작업을 계속할 수 있음
로봇 내비게이션, 물체 조작 등 복잡한 작업에 사용함
# 모든 액션 목록 표시
ros2 action list # 액션과 타입 함께 표시
ros2 action list -t # 특정 액션에 대한 정보 표시
ros2 action info /액션_이름 # 액션 목표 전송
ros2 action send_goal /액션_이름 액션_타입 목표_내용
ROS 2의 통신 메커니즘은 각기 다른 용도에 최적화되어 있다.
노드: 모듈화된 기능 단위
토픽: 지속적인 데이터 스트림에 적합한 비동기 통신
서비스: 일회성 요청-응답에 적합한 동기 통신
액션: 피드백이 필요한 장기 실행 작업에 적합한 비동기 통신
]]></description><link>robotics/ros-2-핵심-통신-개념.html</link><guid isPermaLink="false">robotics/ROS 2 핵심 통신 개념.md</guid><pubDate>Thu, 29 May 2025 14:56:18 GMT</pubDate></item><item><title><![CDATA[1. 기본]]></title><description><![CDATA[ 초기화 Device 생성
CommandQueue 생성 자원 생성 Vertex Buffer 생성
Texture Descriptor 생성 파이프라인 상태 객체 생성 셰이더 함수 로드
렌더 파이프라인 상태 생성 (RenderPipelineState) 명령 인코딩 CommandBuffer 생성
RednerPassDescriptor 생성
렌더 인코더 생성
파이프라인 상태 설정
자원 설정
그리기 명령
인코딩 종료 실행 및 표시 명령 버퍼 커밋 앱 초기화 (단 한번 수행) MTLDevice 생성
MTLCommandQueue 생성
셰이더 컴파일 및 MTLRenderPipelineState 생성
정적 자원 (버퍼, 텍스쳐) 생성 프레임 마다 수행 MTLCommandBuffer 생성
MTLRenderPassDescriptor 설정
MTLRenderCommandEncoder 생성
렌더링 상태 및 자원 설정
그리기 명령 인코딩
인코딩 종료
명령 버퍼 커밋 및 실행 ]]></description><link>graphics/metal/1.-기본.html</link><guid isPermaLink="false">graphics/metal/1. 기본.md</guid><pubDate>Thu, 29 May 2025 14:56:18 GMT</pubDate></item><item><title><![CDATA[자주 사용하는 단축키]]></title><link>qt/자주-사용하는-단축키.html</link><guid isPermaLink="false">Qt/자주 사용하는 단축키.md</guid><pubDate>Thu, 29 May 2025 14:56:18 GMT</pubDate></item><item><title><![CDATA[리소스 임베딩 by compile]]></title><description><![CDATA[크로스플랫폼을 타겟으로 하는 C++ 라이브러리를 개발하면서 리소스를 포함해야 하는 경우가 있다.PC 기반의 환경 (macOS, Windows, Linux 등등)에서 파일 경로를 이용해서 fopen() 으로 리소스에 접근할 수 있다. 그러나 샌드박스 환경 (Android, iOS 등)에서는 파일 시스템 접근이 제한된다. 그래서 각 플랫폼 API를 이용하는 방법으로 리소스에 접근하거나 이미지, 오디오, 텍스트 파일등의 바이너리 리소스를 C / C++ 소스코드 배열로 변환하는 리소스 임베딩 방식을 사용한다.
리소스 파일을 바이트 배열로 변환한다.
바이트 배열을 C++ 소스 코드 파일에 포함시킨다.
컴파일을 할 때 이 배열이 프로그램의 바이너리에 포함된다.
런타임에 이 배열에 접근해서 리소스를 사용한다.
리소스 파일을 바이트 배열로 변환할 때 Python 스크립트나 bin2c, CMake의 configure_file을 사용한다.]]></description><link>cpp/etc/리소스-임베딩-by-compile.html</link><guid isPermaLink="false">CPP/etc/리소스 임베딩 by compile.md</guid><pubDate>Thu, 29 May 2025 14:56:18 GMT</pubDate></item><item><title><![CDATA[09. GLSL 디버그 함수들]]></title><description><![CDATA[
GLSL 디버그 함수들
OpenGL 함수의 디버깅
OpenGL debug output
#version 330 core in vec3 vColor; // LINK ERROR: type mismatch ! out vec4 FragColor; // fragment color: framebuffer void main(void) { FragColor = vColor; // ERROR: type mismatch!
}
위의 코드는 error 가 있는 frag 파일임. 이를 컴파일 했을 때 문제가 생김. 그러나 프로그램은 실행이 됨. - 회색 화면이 출력됨.디버그를 하기 위해서는 아래의 GLSL 함수를 이용 해야함.void glGetShaderiv(GLuint shader, GLenum pname, GLint* params); pname: 어떤 값을 전달 받을 것인가에 대한 정의임. GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH ... params: pname에 대한 결과 GL_COMPILE_STATUS을 지정했다면, 성공: true(1) 실패: false(0) void glGetShaderInfoLog(GLuint shader, GLsizei maxLen, GLsizei* length, GLchar* infoLog); maxLen: infoLog array의 최대 길이
length: infoLog array의 길이
infoLog: 로그 정보 (버퍼에 담겨서 옴)
prog에서 디버깅 하기 (링킹, 실행)<img alt="prog_debugging.png" src="images/prog_debugging.png" target="_self">실제 사용 vert, frag에서<br>
<img alt="glsl_debugging_1.png" src="images/glsl_debugging_1.png" target="_self"> prog에서<br>
<img alt="glsl_debugging2.png" src="images/glsl_debugging2.png" target="_self"> 디버깅 결과 정상<br>
<img alt="debugging_success.png" src="images/debugging_success.png" target="_self"> 에러 발생<br>
<img alt="debugging_failure.png" src="images/debugging_failure.png" target="_self"> OpenGL 드라이버 내부에 error flag 변수를 이용
GLenum glGetError(); 함수를 이용.
GLenum glGetError(); returns: errorFlag
리턴 되고나면 error flag 변수를 GL_NO_ERROR로 초기화
<br><img alt="gl_error_flag.png" src="images/gl_error_flag.png" target="_self">
OpenGL debug extension - 크로노스 그룹에서 만들었음.
OpenGL 4.3에서 core feature가 되었음.
new 이벤트 드라이븐 모델임 OpenGL Error는 event임.
event handler는 callback function임 debug event 원인: API, WINDOW_SYSTEM, SHADER_COMPILER, …
종류: ERROR, UNDEFINED_BEHAVIOR, PERFORMANCE, MARKER (사용자가 표시한것), …
심각성의 정도: severe levels, HIGH, MEDIUM, LOW, NOTIFICATION 그 중 DONT_CARE는 everything임 glEnable(GL_DEBUG_OUTPUT); // 디버그 사용 활성화
glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); // 결과 즉시 출력
glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0 ,NULL, GL_TRUE); // -&gt; 모든 디버그 메세지 받음
glDebugMessageCallback(DebugLog, NULL); // DebugLog라는 함수를 콜백으로 등록함.
void glEnable(GLenum cap);
void glDisable(Glenum cap);
OpenGL 내부의 특정 기능을 on/off함void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled); debug 이벤트 설정 - source, type, severity
enabled: 기능을 끌 것인지 켤 것인지.
ids: 에러 id 넘버에 따라서 기능을 끌 것인지 켤 것인지 - ids다보니까 배열임
count: ids는 포인터 타입이라 길이가 없음. 길이를 여기에 넣으면 됨
콜백함수 등록에 관하여.typedef void (*DEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam); userParam: 사용자가 특정한 파라미터를 넣을 수 있음 -&gt; 추가적인 컨텍스트나 데이터 전달 가능
void APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam) { MyLogger* logger = (MyLogger*)userParam; logger-&gt;log(message);
} // 콜백 설정 시
MyLogger myLogger;
glDebugMessageCallback(debugCallback, &amp;myLogger); MyLogger 객체의 포인터가 userParam으로 전달되어, 콜백 함수 내에서 로깅에 사용
userParam은 const void* 타입이므로, 사용 시 적절한 타입으로 캐스팅해야 함
전달된 객체나 데이터의 생명주기 관리해야함
]]></description><link>graphics/opengl/02.응용/09.-glsl-디버그-함수들.html</link><guid isPermaLink="false">graphics/opengl/02.응용/09. GLSL 디버그 함수들.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/prog_debugging.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/prog_debugging.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[10. OpenGL 깊이 버퍼와 렌더링 순서]]></title><description><![CDATA[깊이 버퍼는 3D 그래픽스에서 어떤 물체가 다른 물체를 가리는지 결정하는 핵심 메커니즘이다.
작동 원리: 각 픽셀마다 카메라로부터의 거리(Z값)를 저장
범위: 일반적으로 [0.0, 1.0] (0.0은 near plane, 1.0은 far plane)
정밀도: 일반적으로 16비트, 24비트 또는 32비트 (24비트가 가장 일반적)
분포: 비선형적 분포 - 가까운 거리에서 정밀도가 높고, 먼 거리에서는 정밀도가 낮음
// 깊이 테스트 활성화
glEnable(GL_DEPTH_TEST); // 깊이 테스트 비교 함수 설정 (기본값은 GL_LESS)
glDepthFunc(GL_LESS); // 새 픽셀의 깊이 값이 작을 때(더 가까울 때) 통과
// 렌더링 루프에서 매 프레임마다 색상 버퍼와 깊이 버퍼를 함께 초기화
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
// 깊이 버퍼 쓰기 활성화 (기본값)
glDepthMask(GL_TRUE); // 깊이 버퍼 쓰기 비활성화 (투명 오브젝트 그릴 때 유용)
glDepthMask(GL_FALSE); GL_LESS: 새 값이 작을 때 통과 (기본값)
GL_LEQUAL: 새 값이 작거나 같을 때 통과
GL_GREATER: 새 값이 클 때 통과
GL_GEQUAL: 새 값이 크거나 같을 때 통과
GL_EQUAL: 새 값이 같을 때만 통과
GL_NOTEQUAL: 새 값이 다를 때 통과
GL_ALWAYS: 항상 통과
GL_NEVER: 절대 통과하지 않음
Z-fighting은 두 물체가 거의 같은 깊이에 있을 때 깜빡이는 현상입니다.
깊이 버퍼의 제한된 정밀도
near plane과 far plane 사이의 거리가 너무 큰 경우
특히 먼 거리에서 정밀도가 낮아지는 비선형 분포로 인해 발생 near/far plane 비율 줄이기: 시야 범위를 필요한 만큼만 설정
glm::mat4 projection = glm::perspective(glm::radians(45.0f), aspect_ratio, 0.1f, 100.0f); 높은 정밀도의 깊이 버퍼 사용: 24비트 또는 32비트 깊이 버퍼 사용
물체 배치 조정: 서로 다른 물체가 완전히 같은 깊이에 있지 않도록 약간 간격 두기
]]></description><link>graphics/opengl/02.응용/10.-opengl-깊이-버퍼와-렌더링-순서.html</link><guid isPermaLink="false">graphics/opengl/02.응용/10. OpenGL 깊이 버퍼와 렌더링 순서.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[03. GPU 내부 구조]]></title><description><![CDATA[<img alt="gpu_structure.png" src="images/gpu_structure.png" target="_self">기본 구조는 인풋 레지스터가 있고, 프로세서가 처리한 후 아웃풋 레지스터로 넘겨주는 형식.
vertext shader와 fragment shader는 GPU Core임
버텍스 쉐이더와 프래그먼트 쉐이더는 독립적이며 그 사이에 fixed hardware가 있음.
각각 쉐이더 프로세서는 임시 변수를 저장할 레지스터를 가지고 있음. (tempory variable)
글로벌 변수가 필요할 수도 있기 때문에 글로벌 레지스터도 있음 (uniform register)
버텍스 쉐이더 프로세서 처리 값인 varying 레지스터의 값과 rasterization을 거친 varying 레지스터의 값은 다름.
레지스터는 하나는 내부적으로 4차원 좌표 (x,y,z,w)로 처리하고 타입은 float.
primitive assembly 단계에서 적용 가능
꼭지점이 2개가 주어지면, 나머지 좌표가 결정됨 (보간법)
컬러도 보간할 수 있음
<br><img alt="linear_interpolation.png" src="images/linear_interpolation.png" target="_self"><br><img alt="bi_linear_interpolation.png" src="images/bi_linear_interpolation.png" target="_self">
rasterization의 핵심 기능
처음에 선분으로 연결하고 보간함
선분끼리 보간함
두번 보간해서 이중 선형 보간
<br><img alt="vertex_shader.png" src="images/vertex_shader.png" target="_self">
vertex processor가 a vertex data -&gt; normalized vertex data로 변환함
각각의 버텍스에 적용
gl_Position, gl_PointSize 같은 pre - defined 되어 있는 레지스터에 값을 넣으면 후처리 단계에서 바로 사용 가능
<br><img alt="primitive_assembly_rasterization.png" src="images/primitive_assembly_rasterization.png" target="_self">
3개의 버텍스 정보가 병렬처리를 거쳐서 3개의 버텍스 위치를 gl_Position 레지스터에 동시에 넣어줌
primitive assembly로 오면서 3개의 정보가 결합해 삼각형인지 판단
3개의 버텍스로 시작했지만, 수천개 수만개의 프래그먼트가 생성됨
이 삼각형 내부에 있는 픽셀을 선택하고 각 픽셀마다 프레그먼트 쉐이더를 진행함.
<br> <img alt="fragment_shader.png" src="images/fragment_shader.png" target="_self">이중선형보간을 통해 삼각형 내부에 속한 픽셀 하나하나 대응되는 데이터를 가지고 있음.
이 프래그먼트마다 Fragment Shader를 돌리면 픽셀의 최종값을 결정함. output이 나오고 이는 곧 framebuffer에 업데이트 되는 값임.]]></description><link>graphics/opengl/02.응용/03.-gpu-내부-구조.html</link><guid isPermaLink="false">graphics/opengl/02.응용/03. GPU 내부 구조.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/gpu_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gpu_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04. GLSL]]></title><description><![CDATA[
C style
새로운 자료형 도입, 연산 추가 vector, matrix
벡터, 행렬 연산
샘플러 for 텍스쳐 맵핑
GL Master Library GLM으로 발전
C++ style <img alt="opengl_shader_program_process.png" src="images/opengl_shader_program_process.png" target="_self">
OpenGL 소스코드를 컴파일 .exe 프로그램을 실행 (OpenGL 프로그램)
OpenGL 프로그램 내에서 vertext shader, fragment shader를 위한 소스코드를 내부에서 컴파일함.
GPU는 shader 프로그램 동시 실행
OpenGL 프로그램에서 user data를 vertex input으로 보냄
그래픽스 파이프라인 통과 -&gt; 화면 출력
<br><img alt="shader_program_structure.png" src="images/shader_program_structure.png" target="_self">
OpenGL은 내부적으로 컴파일러와 실행환경을 가지고 있음
Vertext Shader Object, Fragment Shader
glCreateShader -&gt; Shader object를 만듦
glShaderSource -&gt; 소스코드 내보내기
glCompileShader -&gt; vertex shader 를 위한 소스코드가 컴파일
내부적으로 obj 파일을 저장하게 됨
Shader 프로그램이 두 obj 파일을 묶어서 다운로드 함 (glAttachProgram)
glLinkProgram: GPU 쉐이더 Processor에서 실행 가능한 형태로 결합
glUseProgram: 최종적으로 그래픽 카드에서 실행 #version // 3.3 버전 코어 피쳐 사용
in vec4 vertexPos; // in은 input 레지스터 사용, x,y,z,w 사용 void main(void)
{ gl_Polsition = vertexPos
} <br><img alt="vertext_shader_parallel.png" src="images/vertext_shader_parallel.png" target="_self"><br><img alt="rasterization_mean.png" src="images/rasterization_mean.png" target="_self">#version 330 core out vec4 FragColor; // 프레임버퍼 업데이트. void main()
{ FragColor = vec4(1.0, 0.0, 0.0, 1.0); // red color
} <br><img alt="fragment_shader_execute.png" src="images/fragment_shader_execute.png" target="_self">]]></description><link>graphics/opengl/02.응용/04.-glsl.html</link><guid isPermaLink="false">graphics/opengl/02.응용/04. GLSL.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/opengl_shader_program_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/opengl_shader_program_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. Shader Programming 코드 분석]]></title><description><![CDATA[
shader program 컴파일 방법
const char* vertSource = "#version 330 core \n\
in vec4 vertexPos; \n\
void main(void) { \n\ gl_Position = vertexPos; \n\
}"; const char* fragSource = "#version 330 core \n\
out vec4 FragColor; \n\
void main(void) { \n\ FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n\
}"; GLuint vert = 0; // vertex shader ID number
GLuint frag = 0; // fragment shader ID number
GLuint prog = 0; // shader program ID number
C 프로그램 내에 gl 소스코드를 작성해야해서 스트링 형태로 저장void initFunc(void) { // vert: vertex shader vert = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vert, 1, &amp;vertSource, NULL); glCompileShader(vert); // compile to get .OBJ // frag: fragment shader frag = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(frag, 1, &amp;fragSource, NULL); glCompileShader(frag); // compile to get .OBJ // prog: program prog = glCreateProgram(); glAttachShader(prog, vert); glAttachShader(prog, frag); glLinkProgram(prog); // link to get .EXE // execute it! glUseProgram(prog); // 그래픽 카드에 exe 파일을 실행시키라는 명령어
} 컴파일 해서 최종적으로 executable 형태로 만들어서 그래픽 카드에 전송하는 것 GLunit glCreateShader(GLenum shaderType); shaderType: GL_VERTEX_SHADER, GL_FRAGMENT_SHADER 버텍스 쉐이더인지, 프래그먼트 쉐이더인지 shaderID를 return 함 void glShaderSource(GLunit shaderID, Glsizei count, const GLChar* string, const GLint length); 소스 전달 함수
GLSizei - 문자열 개수가 몇개냐
GLChar** string - 각 문자열 시작주소
GLint* 각 문자열의 길이 void glCompileShader(GLuint shaderID); 소스를 컴파일 하고 obj 파일을 생성 GLuint glCreateProgram(); shader program을 생성
programID을 리턴함 void glAttachShader(GLuint programID, GLuint shaderID); 쉐이더를 프로그램에 어태치함
두번 불려야함 (vertex shader, fragment shader) void glLinkProgram(GLuint programID); 쉐이더 obj를 링크하고 executable을 만듦 void glUseProgram(GLuint programID); 프로그램을 GPU에 설치함 void drawFunc(void) { // clear in gray color glClear(GL_COLOR_BUFFER_BIT); // provide the vertex attributes GLuint loc = glGetAttribLocation(prog, "vertexPos"); glEnableVertexAttribArray(loc); glVertexAttribPointer(loc, 4, GL_FLOAT, GL_FALSE, 0, vertPos); // draw a triangle glDrawArrays(GL_TRIANGLES, 0, 3); // done glFinish();
} <img alt="use_vertex_attirbute_arrays.png" src="images/use_vertex_attirbute_arrays.png" target="_self"> GLint glGetAttribLocation(GLuint programID, const GLchar* name); 입력값: 프로그램 ID와, 대응되는 인풋 레지스터 이름
인풋 레지스터 인덱스가 리턴됨 void glEnableVertexAttribArray(GLuint index); 인풋 레지스터를 enable void glDisableVertexAttribArray(GLuint index); 인풋 레지스터를 Disable void glFinish(void); OpenGL 명령어 큐에 있는 모든 명령을 Finish 시키는 함수 void glVertexAttribPointer(GLuint index, GLint size, gLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer); <br><img alt="glVertexAttribPointer.png" src="images/glvertexattribpointer.png" target="_self">
void glDrawArrays(GLenum mode, GLint first, Glsizei count); Vertex 데이터를 Primitive Assembly 단계에서 어떻게 해석할 지를 결정
mode: 하나씩 사용할건지, 2개식 사용할건지, 3개씩 묶어서 사용할건지
first: 어디서부터 사용할건지 보통 0
count: 갯수 ]]></description><link>graphics/opengl/02.응용/05.-shader-programming-코드-분석.html</link><guid isPermaLink="false">graphics/opengl/02.응용/05. Shader Programming 코드 분석.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/use_vertex_attirbute_arrays.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/use_vertex_attirbute_arrays.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[06. 재사용가능한 코드]]></title><description><![CDATA[const char* vertSource = "#version 330 core \n\
in vec4 vertexPos; \n\
void main(void) { \n\ gl_Position = vertexPos; \n\
}"; const char* fragSource = "#version 330 core \n\
out vec4 FragColor; \n\
void main(void) { \n\ FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n\
}"; vertex / fragment shader source code는 const char* 임
별도의 파일로 저장하고, 읽어오는 함수를 사용하는 것이 편함.
const char* loadFile( const char* filename ) { FILE* fp = fopen( filename, "r" ); if (fp == NULL) { fprintf(stderr, "Error: cannot open \"%s\"\n", filename); return NULL; } // get file size to allocate a buffer fseek(fp, 0, SEEK_END); size_t len = ftell(fp); rewind(fp); char* buf = (char*)malloc(sizeof(char) * (len + 4)); // read in the whole contents: (ASSUMPTION: small file size) size_t size = fread(buf, sizeof(char), len, fp); fclose(fp); buf[size] = '\0'; // done return (const char*)buf;
}
<img alt="export_shader_code.png" src="images/export_shader_code.png" target="_self">loadFile에서 malloc을 사용 했기 때문에 free 꼭 해줘야함 (InitFunc에서 free 시키기)const char* vertSource = loadFile( vertFileName );
const char* fragSource = loadFile( fragFileName );
free( (void*)vertSource );
free( (void*)fragSource ); 현재 = Old
input attribute = attribute
output varying register = varying
FragColor = gl_FragColor GLSL 변수-&gt; Register 사용 어느 Register를 사용할것인가? GLSL 컴파일러가 할당
프로그래머가 강제로 할당 가능 -&gt; layout 키워드 n번째 register 할당<br>
<img alt="layout_qualifier.png" src="images/layout_qualifier.png" target="_self"> GLuint loc = glGetAttribLocation(prog, "vertexPos");
vertexPos가 저장된 레지스터 번호 가져 오는 방법 prog는 뭐지? - glProgram같은 layout에 할당할 시 컴파일러가 화냄 (에러 발생)OpenGL은 오래되어서 컴파일 안되는 레거시 코드가 많음.Example.
glBegin / glEnd
glVertex3f, 4f, 3fv, 4fv
glColor3f, 4f, 3fv, 4fv
glNormal3f, 3fv
GLUT function 사용 -&gt; 현재 GLUT 사용자 없음.
]]></description><link>graphics/opengl/02.응용/06.-재사용가능한-코드.html</link><guid isPermaLink="false">graphics/opengl/02.응용/06. 재사용가능한 코드.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/export_shader_code.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/export_shader_code.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[07. GLSL 자료형]]></title><description><![CDATA[
GLSL 자료형 Vector GLSL Matrix GLSL 언어적 특징
GLSL Qualifiers varying colors 프로그램
<img alt="type_structure.png" src="images/type_structure.png" target="_self">
basic type int, uint, float, double, bool 주로 float을 사용함<br>
<img alt="register_vec.png" src="images/register_vec.png" target="_self"> vectors float형: vec2, vec3, vec4
int형: ivecn
boolean형: bvecn Matrices float형: mat2, mat3, mat4
주의: 열 우선임<br>
<img alt="matrix_row_prior.png" src="images/matrix_row_prior.png" target="_self"> 기본적으로 attribute는 4개의 float을 담음.vec4를 주로 이용하는데 attribute의 멤버에 따라 어떻게 해석할 지 달라짐.
단순 value
배열로 나타내기
xyzw -&gt; 좌표
stpq -&gt; 텍스처 좌표
rgba -&gt; rgba 색상 a.xyzw = v.xyzw; // default
a = v.wzyx; // shuffled
단! 서로 다른 도메인끼리는 불가
xyzw, rgba, stpq 혼용불가 -&gt; .xgt 불가능
2차원 배열
float 형만 있음
열 우선임 -&gt; mat (n x m)일 때 n이 열, m이 행
레지스터에서 Matrix -&gt; mat4인 경우 -&gt; 4개의 register 포인터 자료형 없음
vector, matrix가 기본 자료형
c++스타일 구조체 사용가능
<br><img alt="func_1.png" src="images/func_1.png" target="_self">
파라미터에 in, out, inout을 넣을 수 있음기본적으로 안붙이면 in (call by value)고
out을 붙이면 y에 대한 call by ref임<br><img alt="math_func.png" src="images/math_func.png" target="_self">]]></description><link>graphics/opengl/02.응용/07.-glsl-자료형.html</link><guid isPermaLink="false">graphics/opengl/02.응용/07. GLSL 자료형.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/type_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/type_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[08. Uniform Variable]]></title><description><![CDATA[N개의 삼각형을 그린다고 가정하면, 각 삼각형은 각각의 3개의 Vertex Pos를 가질 거임.GLfloat vertPosFirst[] = { -0.5F, -0.5F, 0.0F, 1.0F, +0.0F, -0.5F, 0.0F, 1.0F, -0.5F, +0.0F, 0.0F, 1.0F,
}; GLfloat vertPosSecond[] = { 0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 0.0F, 0.0F, 1.0F, 0.0F, 0.5F, 0.0F, 1.0F,
}; ... n개가 필요함. 이렇게 n개의 삼각형 vertPos를 가지기 보다는 잘 정의된 vertex pos를 가지고 값을 더해서 새로운 삼각형을 표현할 수가 있음. -&gt; uniform variable을 사용하자.Uniform Variable은 일종의 전역변수임<img alt="using_uniform.png" src="images/using_uniform.png" target="_self">uniform variable은 uniform vec4로 선언함.#version 330 core in vec4 aPos; // vertex position: attribute
in vec4 aColor; // vertex color: attribute
out vec4 vColor; // varying color: varying
uniform vec4 uMove; // movement vector: uniform void main(void) { gl_Position = aPos + uMove; vColor = aColor;
} void drawFunc(void) { // clear in gray color glClear(GL_COLOR_BUFFER_BIT); // provide the vertex attributes GLuint locPos = glGetAttribLocation(prog, "aPos"); glEnableVertexAttribArray(locPos); glVertexAttribPointer(locPos, 4, GL_FLOAT, GL_FALSE, 0, vertPos); // provide the color attributes GLuint locColor = glGetAttribLocation(prog, "aColor"); glEnableVertexAttribArray(locColor); glVertexAttribPointer(locColor, 4, GL_FLOAT, GL_FALSE, 0, vertColor); // draw the first triangle GLuint locMove = glGetUniformLocation(prog, "uMove"); glUniform4f(locMove, -0.5F, -0.5F, 0.0F, 0.0F); glDrawArrays(GL_TRIANGLES, 0, 3); // draw the second triangle glUniform4f(locMove, 0.0F, 0.0F, 0.0F, 0.0F); glDrawArrays(GL_TRIANGLES, 0, 3); // done glFinish();
} // prog: Program
// name: string for uniform variable name
// return: location index of the specified uniform variable GLint glGetUniformLocation(GLuint prog, const GLchar* name); // 아래 함수는 값을 넣을 수 있음
void glUniform1f(GLint loc, Glfloat v0);
void glUniform2f(GLint loc, Glfloat v0 ...v1);
void glUniform3f(GLint loc, Glfloat v0 ... v1 ... v2);
void glUniform4f(GLint loc, Glfloat v0 ... v1 ... v2 ... v3); // 벡터도 넣을 수 있음. 예시 const GLfloat uMoveValue[] = {0.5f, 0.5f 0.5f, 0.5f }; void glUniform1fv(GLint loc, GLsizei count, const GLfloat* value);
void glUniform2fv(GLint loc, GLsizei count, const GLfloat* value);
void glUniform3fv(GLint loc, GLsizei count, const GLfloat* value);
void glUniform4fv(GLint loc, GLsizei count, const GLfloat* value); // transpose 전치 되어 있는 지?
void glUniformMatrix4fv(GLint loc, GLsizei count, GLbooleadn transpose,const GLfloat* value); count는 몇개를 보낼건지에 대한 거임. 예시를 보면 이해감// 단일 float 값 설정
GLfloat brightness = 0.8f;
glUniform1fv(brightnessLocation, 1, &amp;brightness); // 3D 벡터 (색상) 설정
GLfloat color[] = {1.0f, 0.0f, 0.0f}; // 빨간색
glUniform3fv(colorLocation, 1, color); // 여러 개의 2D 벡터 설정
GLfloat positions[] = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f}; // 3개의 2D 위치
glUniform2fv(positionsLocation, 3, positions);
]]></description><link>graphics/opengl/02.응용/08.-uniform-variable.html</link><guid isPermaLink="false">graphics/opengl/02.응용/08. Uniform Variable.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/using_uniform.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/using_uniform.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01. 그래픽스 파이프라인]]></title><description><![CDATA[vertex input -&gt; vertex processing -&gt; primitive assembly -&gt; rasterization -&gt; fragment processing -&gt; blend -&gt; framebuffer<img alt="graphic_pipeline.png" src="images/graphic_pipeline.png" target="_self">
Vertex: 꼭지점
fragment = pixel + 색상, 깊이 ... 사용자의 vertex data -&gt; 좌표 변환
카메라 효과 vertex 결합 -&gt; graphics primitive
1 vertex -&gt; 점
2 vertices -&gt; 선분
3 vertices -&gt; 삼각형 primitive에 포함되는 pixel 선정
프레임 버퍼에서 출력될 pixel들이 선택됨 각 픽셀이 어떤 색을 가져야할 지 계산됨. fragment 단위 처리로 다양한 효과
후처리 단계 프레임 버퍼에 하나의 primitive로 저장됨
그래픽 파이프라인이란 vertex input이 각 단계를 거쳐 프레임버퍼에 하나의 primitive로 저장되는 과정이다.]]></description><link>graphics/opengl/02.응용/01.-그래픽스-파이프라인.html</link><guid isPermaLink="false">graphics/opengl/02.응용/01. 그래픽스 파이프라인.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/graphic_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/graphic_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02. 프로그래머블 그래픽스 파이프라인]]></title><description><![CDATA[<img alt="paralle_processing.png" src="images/paralle_processing.png" target="_self">그래픽스 파이프라인이 병렬화되면서, 병렬 처리를 고려한 small size 프로그램이 필요해짐.
-&gt; Shader의 등장shader = small, special - purpose program
small size
병렬 처리
<br><img alt="programmable_pipeline.png" src="images/programmable_pipeline.png" target="_self"> 그래픽스가 fixed VLSI 칩으로 구현 -&gt; fixed pipeline 병렬처리 도입, 일부는 shader로 구현 -&gt; programmable pipeline vertex shader: vertex processing을 대체
fragment shader: fragment processing을 대체 shader 용어는 모호할 때가 많음 -&gt; 문맥으로 파악하자 vertex processing에 대응되는 프로세싱에 사용되는 코어를 의미하는 경우
실제 GPU에서 수행되고 있는 프로그램을 의미하는 경우 DirectX HLSL(high-level shader language)
OpenGL SL(OpenGL shader language)
]]></description><link>graphics/opengl/02.응용/02.-프로그래머블-그래픽스-파이프라인.html</link><guid isPermaLink="false">graphics/opengl/02.응용/02. 프로그래머블 그래픽스 파이프라인.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/paralle_processing.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/paralle_processing.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OpenGL 인덱스 순서와 면 컬링 관계]]></title><description><![CDATA[그라운드를 생성했는데, 렌더링이 되지 않아서 볼 수 없는 문제가 발생했었다. 삼각형의 인덱스 순서를 변경하니 해결되었는데 그 이유를 자세히 알아보도록 한다.삼각형의 Winding Order이란 삼각형의 정점들이 어떤 순서로 연결되는지를 의미한다. 3D 그래픽스에서는 이 순서를 통해 삼각형의 앞면과 뒷면을 구분합니다.
반시계 방향(Counter-Clockwise, CCW): 삼각형의 정점들이 반시계 방향으로 연결될 때
시계 방향(Clockwise, CW): 삼각형의 정점들이 시계 방향으로 연결될 때
OpenGL의 기본 설정에서는 반시계 방향으로 정의된 삼각형을 앞면으로 간주한다.그라운드(바닥 평면)는 보통 사각형으로 구현되며, 두 개의 삼각형으로 나뉘어 렌더링된다. 이 과정에서 인덱스 순서가 중요하다.// 원래 인덱스 (시계 방향)
const GLuint indices[] = { 0, 1, 2, // 첫 번째 삼각형 0, 2, 3 // 두 번째 삼각형
};
0 --- 1
| / |
| / |
3 --- 2
이 인덱스 배열은 두 개의 삼각형을 시계 방향(CW)으로 정의합니다:
첫 번째 삼각형: 정점 0 → 1 → 2 (시계 방향)
두 번째 삼각형: 정점 0 → 2 → 3 (시계 방향)
OpenGL의 기본 설정에서는 시계 방향으로 정의된 삼각형은 뒷면으로 간주되고,glEnable(GL_CULL_FACE)를 사용하면 뒷면은 렌더링되지 않는다. 따라서 보이지 않는다.// 수정된 인덱스 (반시계 방향)
const GLuint indices[] = { 0, 2, 1, // 첫 번째 삼각형 (방향 변경) 0, 3, 2 // 두 번째 삼각형 (방향 변경)
};
0 --- 1
| / |
| / |
3 --- 2
이렇게 변경된 인덱스 배열은:
첫 번째 삼각형: 정점 0 → 2 → 1 (반시계 방향)
두 번째 삼각형: 정점 0 → 3 → 2 (반시계 방향)
반시계 방향으로 정의된 삼각형들은 OpenGL에 의해 앞면으로 간주되어 면 컬링이 활성화되어도 정상적으로 렌더링된다.법선 벡터가 관찰자를 향하면 삼각형은 반시계 방향, 반대 방향이면 시계 방향이다.인덱스 순서를 변경하는 것 외에도 다음 방법으로 문제를 해결할 수 있음.
앞면 정의 변경
glFrontFace(GL_CW); // 시계 방향을 앞면으로 정의 컬링 모드 변경
glCullFace(GL_FRONT); // 앞면을 컬링하고 뒷면을 렌더링 면 컬링 비활성화 (최적화 포기):
glDisable(GL_CULL_FACE);
하지만 인덱스 순서를 변경하는 것이 가장 표준적인 방법이며, OpenGL의 기본 설정(반시계 방향)을 준수하는 것이 좋음.면 컬링은 중요한 성능 최적화 기법이다. 면 컬링 활성화는 보이지 않는 면을 렌더링을 건너 뛰어서 렌더링 시간을 줄일 수 있고 프래그먼트 쉐이더 연산과 래스터화를 더 효율적으로 수행할 수 있다.]]></description><link>qt/opengl/opengl-인덱스-순서와-면-컬링-관계.html</link><guid isPermaLink="false">Qt/opengl/OpenGL 인덱스 순서와 면 컬링 관계.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[Qt OpenGL in macOS]]></title><description><![CDATA[Qt에서 OpenGL을 사용할 때 QSurfaceFormat을 통해 버전을 설정 해야 한다.// main.cpp
QSurfaceFormat format;
format.setVersion(3, 3); // OpenGL 3.3 사용
format.setProfile(QSurfaceFormat::CoreProfile); // Core 프로파일 사용
format.setDepthBufferSize(24);
format.setStencilBufferSize(8);
format.setSamples(4); // 멀티샘플링 설정
QSurfaceFormat::setDefaultFormat(format); // 중요: 전역 설정으로 지정 기본 지원: macOS는 기본적으로 OpenGL 2.1(레거시 프로파일)을 지원함.
확장 지원: macOS 10.9 (Mavericks) 이상에서는 OpenGL 3.3 Core 프로파일 및 최대 4.1까지 지원
QOpenGLContext context;
if (context.create()) { qDebug() &lt;&lt; "OpenGL Version:" &lt;&lt; context.format().majorVersion() &lt;&lt; "." &lt;&lt; context.format().minorVersion(); qDebug() &lt;&lt; "Profile:" &lt;&lt; (context.format().profile() == QSurfaceFormat::CoreProfile ? "Core" : "Compatibility");
}
macOS에서 OpenGL 3.3으로 설정했는데 실제로는 4.1이 표시되는 현상이 있을 수 있다. 왜냐하면 OpenGL은 하위 호환성이 있는 API로, 요청한 버전보다 높은 버전이 지원된다면 드라이버는 보통 지원되는 가장 높은 버전을 선택한다. 하위 호환성을 거의 보장하므로 3.3 코드는 4.1에서도 문제없이 작동한다.]]></description><link>qt/opengl/qt-opengl-in-macos.html</link><guid isPermaLink="false">Qt/opengl/Qt OpenGL in macOS.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[Qt OpenGL 코드]]></title><description><![CDATA[Qt 프레임워크와 OpenGL을 사용하여 기본 그라운드를 렌더링하는 코드에 대한 설명이다.OpenGL 그래픽 파이프라인은 3D 객체를 2D 화면에 표시하기 위한 일련의 단계를 말함
정점 데이터 준비: 3D 공간에서의 점(정점)들을 정의
정점 쉐이더(Vertex Shader): 각 정점의 위치 변환 처리
프리미티브 조립(Primitive Assembly): 정점들을 삼각형 등의 기본 도형으로 조립
래스터화(Rasterization): 3D 기본 도형을 2D 픽셀로 변환
프래그먼트 쉐이더(Fragment Shader): 각 픽셀의 최종 색상 계산
프레임 버퍼에 출력: 계산된 픽셀을 화면에 표시
바닥(그라운드)을 표현하기 위한 데이터를 준비한다.void GLWidget::createGeometry()
{ // 그라운드 크기 설정 constexpr float size = 10.0f; // 기본 색상 설정 (그린) const QVector3D green(0.0f, 0.5f, 0.1f); // 정점 데이터 (위치와 색상 정보) const float vertices[] = { // 위치(x, y, z) // 색상(r, g, b) -size, 0.0f, -size, green.x(), green.y(), green.z(), // 좌상단 size, 0.0f, -size, green.x(), green.y(), green.z(), // 우상단 size, 0.0f, size, green.x(), green.y(), green.z(), // 우하단 -size, 0.0f, size, green.x(), green.y(), green.z() // 좌하단 }; 정점 데이터 정의 4개의 정점으로 이루어진 평면(사각형)을 생성한다.
각 정점은 위치(x,y,z)와 색상(r,g,b) 정보를 가진다. // 인덱스 데이터 (삼각형 정의) const unsigned int indices[] = { 0, 1, 2, // 첫 번째 삼각형 0, 3, 2 // 두 번째 삼각형 - 면 컬링 고려 }; 인덱스 데이터 정의 사각형을 2개의 삼각형으로 나누어 표현한다.
첫 번째 삼각형: 정점 0, 1, 2를 연결
두 번째 삼각형: 정점 0, 3, 2을 연결 // VAO 생성 및 바인딩 m_groundVAO.create(); m_groundVAO.bind(); // VBO(정점 버퍼) 생성 및 데이터 할당 m_groundVBO.create(); m_groundVBO.bind(); m_groundVBO.allocate(vertices, sizeof(vertices)); // EBO(인덱스 버퍼) 생성 및 데이터 할당 m_groundEBO.create(); m_groundEBO.bind(); m_groundEBO.allocate(indices, sizeof(indices)); OpenGL 버퍼 생성 VAO(Vertex Array Object): 정점 데이터의 구성 방식을 저장하는 객체
VBO(Vertex Buffer Object): 실제 정점 데이터를 GPU 메모리에 저장
EBO(Element Buffer Object): 인덱스 데이터를 GPU 메모리에 저장 // 위치 속성 설정 (attribute 0) m_program-&gt;enableAttributeArray(0); // aPos 속성 활성화 m_program-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 3, 6 * sizeof(float)); // 색상 속성 설정 (attribute 1) m_program-&gt;enableAttributeArray(1); // aColor 속성 활성화 m_program-&gt;setAttributeBuffer(1, GL_FLOAT, 3 * sizeof(float), 3, 6 * sizeof(float)); 속성 포인터 설정 쉐이더 프로그램에 정점 데이터의 구조를 알려줍니다
첫 번째 속성(0): 위치 데이터 (x,y,z - 3개 float)
두 번째 속성(1): 색상 데이터 (r,g,b - 3개 float)
매개변수 설명: 첫 번째: 속성 인덱스
두 번째: 데이터 타입 (GL_FLOAT)
세 번째: 데이터 시작 오프셋 (바이트 단위)
네 번째: 구성요소 개수 (위치: 3, 색상: 3)
다섯 번째: 다음 정점까지의 간격 (stride) (6개 float) 이 함수는 실제로 그라운드를 화면에 그려주는 역할을 합니다:void GLWidget::drawGround()
{ // 그라운드 VAO 바인딩 m_groundVAO.bind(); // 모델 행렬 설정 (단위 행렬 - 원점에 위치) QMatrix4x4 model; m_program-&gt;setUniformValue("model", model); // 그라운드 그리기 (EBO 사용) glDrawElements(GL_TRIANGLES, m_groundIndices, GL_UNSIGNED_INT, nullptr); // VAO 해제 m_groundVAO.release();
} VAO 바인딩: 이전에 설정한 정점 데이터 구성을 활성
모델 행렬 설정: 객체의 위치, 회전, 크기를 정의
그리기 명령 실행: 인덱스를 이용해 삼각형을 그림 GL_TRIANGLES: 삼각형 모드로 그리기
m_groundIndices: 인덱스 개수 (6개)
GL_UNSIGNED_INT: 인덱스 데이터 타입
nullptr: 인덱스 데이터가 이미 바인딩된 EBO에 있음 이 함수는 Qt의 QOpenGLWidget 클래스의 가상 함수로, 화면을 그리는 메인 렌더링 함수입니다:void GLWidget::paintGL()
{ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 쉐이더 프로그램 활성화 m_program-&gt;bind(); // 카메라 뷰 설정 QMatrix4x4 view; view.lookAt( QVector3D(0.0f, 5.0f, 5.0f), // 카메라 위치 QVector3D(0.0f, 0.0f, 0.0f), // 바라보는 지점 QVector3D(0.0f, 1.0f, 0.0f) // 상향 벡터 ); 화면 초기화: 색상 버퍼와 깊이 버퍼를 지움
쉐이더 프로그램 활성화: 그리기에 사용할 쉐이더를 활성화
카메라 뷰 설정 // 투영 행렬 설정 QMatrix4x4 projection; float aspectRatio = width() / static_cast&lt;float&gt;(height()); projection.perspective(45.0f, aspectRatio, 0.1f, 100.0f); // 쉐이더에 행렬 전달 m_program-&gt;setUniformValue("view", view); m_program-&gt;setUniformValue("projection", projection); // 그라운드 그리기 drawGround(); // 쉐이더 프로그램 비활성화 m_program-&gt;release();
} 투영 행렬 설정: 3D 장면을 2D 화면에 투영하는 방법을 정의 45도 시야각(FOV)
화면 비율(aspect ratio)에 맞게 조정
근거리 절단면(near plane): 0.1
원거리 절단면(far plane): 100.0 행렬 전달: 뷰 행렬과 투영 행렬을 쉐이더에 전달 그라운드 그리기: 앞서 정의한 drawGround() 함수 호출 쉐이더 해제: 사용 완료 후 쉐이더를 비활성화 코드에서 사용된 세 가지 주요 변환 행렬 모델 행렬(Model Matrix) 객체의 로컬 공간에서 월드 공간으로 변환
객체의 위치, 회전, 크기를 정의
코드에서는 기본 단위 행렬 사용(원점에 위치) 뷰 행렬(View Matrix) 월드 공간에서 카메라 공간으로 변환
카메라의 위치와 방향을 정의
lookAt 함수로 생성 투영 행렬(Projection Matrix) 카메라 공간에서 클립 공간으로 변환
원근감 적용 (멀리 있는 물체는 작게 보임)
perspective 함수로 생성 ]]></description><link>qt/opengl/qt-opengl-코드.html</link><guid isPermaLink="false">Qt/opengl/Qt OpenGL 코드.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[MCP Setting]]></title><description><![CDATA[
Filesystem MCP Server Node.js server implementing Model Context Protocol (MCP) for filesystem operations
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem" target="_self">https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem</a> Memory A basic implementation of persistent memory using a local knowledge graph. This lets Claude remember information about the user across chats.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/modelcontextprotocol/servers/tree/main/src/memory" target="_self">https://github.com/modelcontextprotocol/servers/tree/main/src/memory</a> obsidian-mcp An&nbsp;MCP server that enables AI assistants to interact with Obsidian vaults, providing tools for reading, creating, editing and managing notes and tags.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/modelcontextprotocol/servers?tab=readme-ov-file" target="_self">https://github.com/modelcontextprotocol/servers?tab=readme-ov-file</a> sequential-thinking An MCP server implementation that provides a tool for dynamic and reflective problem-solving through a structured thinking process.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/modelcontextprotocol/servers/tree/main/src/sequentialthinking" target="_self">https://github.com/modelcontextprotocol/servers/tree/main/src/sequentialthinking</a> brave-search An MCP server implementation that integrates the Brave Search API, providing both web and local search capabilities.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search" target="_self">https://github.com/modelcontextprotocol/servers/tree/main/src/brave-search</a> { "mcpServers": { "filesystem": { "command": "npx", "args": [ "-y", "@modelcontextprotocol/server-filesystem", "{path1}", "{path2}" ] }, "memory": { "command": "npx", "args": [ "-y", "@modelcontextprotocol/server-memory" ] }, "obsidian-mcp": { "command": "npx", "args": [ "-y", "obsidian-mcp", "{path}" ] }, "sequential-thinking": { "command": "npx", "args": [ "-y", "@modelcontextprotocol/server-sequential-thinking" ] }, "brave-search": { "command": "npx", "args": [ "-y", "@smithery/cli@latest", "run", "@smithery-ai/brave-search", "--key", "{key}" ] } }
}
]]></description><link>tip/mcp-setting.html</link><guid isPermaLink="false">Tip/MCP Setting.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[OpenGL Sphere 그리기]]></title><description><![CDATA[3D 공간에서 골프공을 표현하기 위한 구(sphere) 지오메트리를 생성하는 방법
구의 파라미터 설정 (반지름, 분할 수)
정점(vertex) 데이터 생성
인덱스(index) 데이터 생성
OpenGL 버퍼 객체 설정 (VAO, VBO, EBO)
3D 공간에서 구는 다음과 같은 매개변수 방정식으로 표현됩니다: x = r × cos(theta) × cos(phi) y = r × cos(theta) × sin(phi) z = r × sin(theta) r은 반지름 theta는 수직각(latitude): -π/2(하단) ~ π/2(상단) phi는 수평각(longitude): 0 ~ 2π float stackAngle = PI / 2 - i * stackStep; // theta 계산
float xy = radius * cosf(stackAngle); // r × cos(theta) 계산
float z = radius * sinf(stackAngle); // r × sin(theta) 계산 float sectorAngle = j * sectorStep; // θ 계산
float x = xy * cosf(sectorAngle); // r × cos(theta) × cos(phi)
float y = xy * sinf(sectorAngle); // r × cos(theta) × sin(phi)
구는 두 가지 방향으로 분할
stackCount: 위에서 아래로 분할 (위도 분할)
sectorCount: 수평 방향 분할 (경도 분할)
const float radius = 0.3f; // 골프공 반지름
const int sectorCount = 36; // 수평 분할 수 (경도)
const int stackCount = 18; // 수직 분할 수 (위도)
const QVector3D ballColor(1.0f, 1.0f, 1.0f); // 흰색 설정
const float PI = M_PI;
const float sectorStep = 2.0f * PI / sectorCount; // 각 섹터(경도) 사이의 각도
const float stackStep = PI / stackCount; // 각 스택(위도) 사이의 각도 for (int i = 0; i &lt;= stackCount; ++i) { float stackAngle = PI / 2 - i * stackStep; // 시작: π/2(상단), 끝: -π/2(하단) // ... for (int j = 0; j &lt;= sectorCount; ++j) { // ... }
}
이 중첩 루프는 구의 모든 정점을 생성
i 는 위에서 아래로 각 스택(위도)을 순회
j 는 각 스택에서 수평 방향(경도)으로 순회
각 정점에 대해:
위치(x, y, z) 계산
색상(r, g, b) 설정 (모든 정점은 흰색)
for (int i = 0; i &lt; stackCount; ++i) { int k1 = i * (sectorCount + 1); // 현재 스택의 시작 인덱스 int k2 = k1 + sectorCount + 1; // 다음 스택의 시작 인덱스 for (int j = 0; j &lt; sectorCount; ++j, ++k1, ++k2) { // 각 섹터에 2개의 삼각형 추가 if (i != 0) { // 첫 번째 스택이 아닐 경우 indices.append(k1); indices.append(k2); indices.append(k1 + 1); } if (i != (stackCount - 1)) { // 마지막 스택이 아닐 경우 indices.append(k1 + 1); indices.append(k2); indices.append(k2 + 1); } }
}
인덱스 생성은 구를 삼각형 메쉬로 변환하는 과정
각 스택과 섹터의 교차점마다 사각형 영역이 생성됨
각 사각형은 두 개의 삼각형으로 분할됨
특별 케이스 처리: 첫 번째 스택(i=0): 상단 극점만 처리
마지막 스택(i=stackCount-1): 하단 극점만 처리 각 삼각형은 세 개의 인덱스로 구성되며, 이 인덱스는 먼저 정의된 정점 배열을 참조한다.// VAO(Vertex Array Object) 생성 및 바인딩
m_ballVAO.create();
m_ballVAO.bind(); // VBO(Vertex Buffer Object) 생성 및 데이터 할당
m_ballVBO.create();
m_ballVBO.bind();
m_ballVBO.allocate(vertices.constData(), vertices.size() * sizeof(float)); // EBO(Element Buffer Object) 생성 및 데이터 할당
m_ballEBO.create();
m_ballEBO.bind();
m_ballEBO.allocate(indices.constData(), indices.size() * sizeof(GLuint));
이 부분은 OpenGL의 핵심 개념인 버퍼 객체를 설정
VAO(Vertex Array Object): 정점 속성 포인터의 상태를 저장하는 컨테이너
VBO(Vertex Buffer Object): 정점 데이터(위치, 색상 등)를 저장하는 버퍼
EBO(Element Buffer Object): 인덱스 데이터를 저장하는 버퍼
// 속성 설정 - 셰이더의 aPos 및 aColor 속성과 연결
int posAttr = m_program-&gt;attributeLocation("aPos");
int colorAttr = m_program-&gt;attributeLocation("aColor"); // 위치 속성 설정
m_program-&gt;enableAttributeArray(posAttr);
m_program-&gt;setAttributeBuffer(posAttr, GL_FLOAT, 0, 3, 6 * sizeof(float)); // 색상 속성 설정
m_program-&gt;enableAttributeArray(colorAttr);
m_program-&gt;setAttributeBuffer(colorAttr, GL_FLOAT, 3 * sizeof(float), 3, 6 * sizeof(float));
이 부분은 셰이더 프로그램에 전달할 정점 속성을 설정 위치 속성(aPos): 시작 오프셋: 0 (정점 데이터의 시작)
요소 개수: 3 (x, y, z)
스트라이드: 6 * sizeof(float) (한 정점의 전체 크기) 색상 속성(aColor): 시작 오프셋: 3 * sizeof(float) (위치 다음)
요소 개수: 3 (r, g, b)
스트라이드: 6 * sizeof(float) (한 정점의 전체 크기) 각 정점은 다음과 같은 형식으로 저장됩니다:[x, y, z, r, g, b] 처음 3개 값(x, y, z)은 정점의 위치
다음 3개 값(r, g, b)은 정점의 색상
인덱스를 사용하는 이유:
메모리 효율성: 같은 정점을 여러 삼각형에서 재사용할 수 있어 메모리 사용량 감소
성능 향상: 중복된 정점 처리를 줄여 GPU 효율 증가
<img alt="구(Sphere)의 인덱스 생성 시각화" src="images/sphere-indexing-screenshot.png" target="_self">for (int i = 0; i &lt; stackCount; ++i) { int k1 = i * (sectorCount + 1); // 현재 스택의 시작 인덱스 int k2 = k1 + sectorCount + 1; // 다음 스택의 시작 인덱스 for (int j = 0; j &lt; sectorCount; ++j, ++k1, ++k2) { // 각 섹터에 2개의 삼각형 추가 if (i != 0) { // 첫 번째 스택이 아닐 경우 indices.append(k1); indices.append(k2); indices.append(k1 + 1); } if (i != (stackCount - 1)) { // 마지막 스택이 아닐 경우 indices.append(k1 + 1); indices.append(k2); indices.append(k2 + 1); } }
} k1: 현재 스택(i)의 시작 인덱스
k2: 다음 스택(i+1)의 시작 인덱스
이 값들은 다음과 같이 계산됩니다:k1 = i * (sectorCount + 1);
k2 = k1 + sectorCount + 1;
예를 들어, sectorCount가 36인 경우:
i=0일 때: k1=0, k2=37
i=1일 때: k1=37, k2=74
i=2일 때: k1=74, k2=111
각 스택과 섹터 사이의 사각형 영역을 두 개의 삼각형으로 분할한다. 상단 삼각형 (i != 0일 때만):
indices.append(k1); // 현재 스택, 현재 섹터
indices.append(k2); // 다음 스택, 현재 섹터
indices.append(k1 + 1); // 현재 스택, 다음 섹터 하단 삼각형 (i != stackCount-1일 때만):
indices.append(k1 + 1); // 현재 스택, 다음 섹터
indices.append(k2); // 다음 스택, 현재 섹터
indices.append(k2 + 1); // 다음 스택, 다음 섹터 첫 번째 스택 (i=0): 상단 극점에 해당
여기서는 하단 삼각형만 생성 (상단 삼각형 생략)
if (i != 0) 조건으로 처리 마지막 스택 (i=stackCount-1): 하단 극점에 해당
여기서는 상단 삼각형만 생성 (하단 삼각형 생략)
if (i != (stackCount - 1)) 조건으로 처리 구의 수학적 방정식을 사용하여 정점 위치 계산
정점 간 관계를 정의하는 인덱스 데이터 생성
OpenGL 버퍼 객체 설정(VAO, VBO, EBO)
셰이더 프로그램에 정점 속성 전달
]]></description><link>qt/opengl/opengl-sphere-그리기.html</link><guid isPermaLink="false">Qt/opengl/OpenGL Sphere 그리기.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate><enclosure url="images/sphere-indexing-screenshot.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/sphere-indexing-screenshot.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Qt Quick 3D - 기본 개념 정리]]></title><description><![CDATA[View3D는 Qt Quick 애플리케이션에서 3D 콘텐츠를 표시하는 핵심 컴포넌트입니다.View3D { id: view3D anchors.fill: parent environment: SceneEnvironment { clearColor: "skyblue" antialiasingMode: SceneEnvironment.MSAA antialiasingQuality: SceneEnvironment.Medium } // 여기에 카메라, 조명, 모델 등이 배치
} environment: 3D 장면의 환경 설정 (배경색, 안티얼라이징 등)
renderMode: 렌더링 방식 설정
camera: 활성 카메라 지정 clearColor: 배경색 설정
antialiasingMode: 계단 현상 방지 모드 (MSAA, SSAA 등)
antialiasingQuality: 안티얼라이징 품질 (Low, Medium, High, VeryHigh)
backgroundMode: 배경 모드 (단색, 스카이박스 등)
카메라는 3D 공간을 어떤 시점에서 볼지 결정합니다.PerspectiveCamera { id: camera position: Qt.vector3d(0, 10, 12) // (x, y, z) 위치 eulerRotation: Qt.vector3d(-20, 0, 0) // (x, y, z) 회전 각도 // 또는 lookAt 함수 사용 function lookAt(targetPosition, upVector) { // 카메라가 특정 지점을 바라보도록 설정 }
} x: 좌/우 위치 (양수: 오른쪽, 음수: 왼쪽)
y: 높이 (양수: 위쪽, 음수: 아래쪽)
z: 앞/뒤 위치 (양수: 뒤쪽, 음수: 앞쪽) x축 회전: 위/아래 시선 조절 (고개 끄덕이기, '-'값은 아래 보기) - pitch
y축 회전: 좌/우 시선 조절 (고개 좌우로 돌리기)- yaw
z축 회전: 카메라 기울기 (머리 기울이기) - roll targetPosition: 바라볼 대상의 위치
upVector: 카메라의 "위쪽" 방향 (보통 Qt.vector3d(0, 1, 0)), 법선벡터 PerspectiveCamera: 원근감 있는 일반적인 3D 시점
OrthographicCamera: 원근감 없는 도면 같은 시점
조명은 3D 객체를 비추어 보이게 하는 광원입니다.DirectionalLight { eulerRotation: Qt.vector3d(-30, 30, 0) // 빛의 방향 brightness: 0.7 // 밝기 (0.0 ~ 1.0) ambientColor: Qt.rgba(0.3, 0.3, 0.3, 1.0) // 주변광
} 역할: 태양광처럼 평행한 빛을 제공 (무한히 먼 곳에서 오는 빛)
eulerRotation: 빛이 오는 방향 설정
brightness: 빛의 강도 (0.0 ~ 1.0)
ambientColor: 주변광의 색상과 강도
PointLight { position: Qt.vector3d(0, 100, 0) // 광원 위치 brightness: 1.0 color: "white" constantFade: 1.0 linearFade: 0.0 quadraticFade: 0.0
} 역할: 전구처럼 모든 방향으로 빛을 발산
position: 광원의 위치
색상 및 감쇠: 거리에 따른 빛의 감소 설정
SpotLight { position: Qt.vector3d(0, 100, 0) eulerRotation: Qt.vector3d(-90, 0, 0) brightness: 1.0 coneAngle: 30.0 // 빛 원뿔의 각도
} 역할: 원뿔 형태로 특정 방향을 비추는 빛
coneAngle: 빛 원뿔의 각도
Qt Quick 3D는 오른손 좌표계를 사용합니다. y (위) | | +----&gt; x (오른쪽) / / z (화면 안쪽) 오른손 좌표계: 오른손 엄지(x), 검지(y), 중지(z)가 서로 수직인 방향
원점: (0, 0, 0) 좌표
양수 방향: x: 오른쪽
y: 위쪽
z: 화면 안쪽(깊이) 엄지를 회전축 방향으로 향하면 나머지 손가락이 회전 방향
x축 회전: 화면을 기준으로 상하 회전
y축 회전: 화면을 기준으로 좌우 회전
z축 회전: 화면을 기준으로 시계/반시계 회전
View3D { // 1. 환경 설정 environment: SceneEnvironment { clearColor: "skyblue" // 하늘색 배경 antialiasingQuality: SceneEnvironment.Medium // 품질 설정 } // 2. 카메라 설정 PerspectiveCamera { id: camera position: Qt.vector3d(0, 10, 12) // 지면보다 위쪽, 약간 뒤쪽에서 바라봄 } // 3. 조명 설정 DirectionalLight { eulerRotation: Qt.vector3d(0, 0, 0) // 정면에서 비추는 빛 brightness: 0.7 // 밝기 70% ambientColor: Qt.rgba(0.3, 0.3, 0.3, 1.0) // 주변광 } // 4. 지면 모델 Model { id: ground position: Qt.vector3d(0, 0, 0) // 원점에 위치 scale: Qt.vector3d(500, 0.1, 500) // 넓고 얇은 판 source: "#Cube" // 내장 큐브 모델 사용 materials: DefaultMaterial { diffuseColor: "green" // 녹색 지면 } } // 5. 구 Model { id: ball source: "#Sphere" // 내장 구체 모델 scale: Qt.vector3d(0.3, 0.3, 0.3) // 크기 조정 position: Qt.vector3d(0, 5.0, 0) // 초기 위치 materials: DefaultMaterial { diffuseColor: "white" // 흰색 specularAmount: 0.9 // 반사도 } }
}
]]></description><link>qt/qt-quick-3d-기본-개념-정리.html</link><guid isPermaLink="false">Qt/Qt Quick 3D - 기본 개념 정리.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[C++ static const 초기화]]></title><description><![CDATA[C++17에서는 다음과 같은 방법으로 헤더 파일에서 static const 변수를 초기화할 수 있다.// header.h
#ifndef HEADER_H
#define HEADER_H // C++17에서는 inline 키워드를 사용하여 헤더에서 정의 가능
inline static const int MAX_SIZE = 100;
inline static const double PI = 3.14159; class MyClass {
public: // 클래스 내부의 static const static const int CLASS_CONSTANT = 200; // C++17에서는 inline을 사용하여 복잡한 타입도 가능 inline static const std::string NAME = "MyClass";
};
#endif
// header.h
#ifndef HEADER_H
#define HEADER_H // constexpr을 사용하면 컴파일 타임에 값이 결정됨
constexpr int MAX_SIZE = 100;
constexpr double PI = 3.14159; class MyClass {
public: // 클래스 내부에서도 constexpr 사용 가능 static constexpr int CLASS_CONSTANT = 200; // C++17에서는 문자열 리터럴도 가능 static constexpr const char* NAME = "MyClass";
};
#endif
// header.h
#ifndef HEADER_H
#define HEADER_H #include &lt;vector&gt;
#include &lt;string&gt; // 복잡한 객체도 inline을 사용하면 헤더에서 초기화 가능
inline static const std::vector&lt;int&gt; DEFAULT_VALUES = {1, 2, 3, 4, 5};
inline static const std::string APP_NAME = "My Application"; #endif
C++에서 클래스 내에서 static const 변수의 초기화는 타입에 따라 규칙이 다름
정수형 상수 (int, char, bool, enum 등) 클래스 선언 내에서 직접 초기화 가능 class MyClass { static const int a = 3; // 가능
}; 부동 소수점형 상수 (float, double) 클래스 선언 내에서 직접 초기화 불가능 class MyClass { static const float a = 3.0f; // 컴파일 에러
}; C++17 이상에서는 inline 키워드 사용:
class MyClass { inline static const float a = 3.0f; // C++17 이상에서 가능
}; 별도의 소스 파일(.cpp)에서 정의:
// MyClass.h
class MyClass { static const float a; // 선언만
}; // MyClass.cpp
const float MyClass::a = 3.0f; // 정의와 초기화 constexpr 사용 (권장):
class MyClass { static constexpr float a = 3.0f; // 모든 타입에 가능
}; static const는 정수형이 아닌 타입은 별도의 소스 파일에서 정의하는 것이 필요
단 C++17 이상에서는 inline static const 또는 static constexpr을 사용하면 헤더에서 선언 정의 동시에 가능
]]></description><link>cpp/etc/c++-static-const-초기화.html</link><guid isPermaLink="false">CPP/etc/C++ static const 초기화.md</guid><pubDate>Thu, 03 Apr 2025 14:40:06 GMT</pubDate></item><item><title><![CDATA[sphere-indexing-screenshot]]></title><description><![CDATA[<img src="images/sphere-indexing-screenshot.png" target="_self">]]></description><link>images/sphere-indexing-screenshot.html</link><guid isPermaLink="false">images/sphere-indexing-screenshot.png</guid><pubDate>Wed, 02 Apr 2025 14:36:44 GMT</pubDate><enclosure url="images/sphere-indexing-screenshot.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/sphere-indexing-screenshot.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Floating Point]]></title><description><![CDATA[float는 4byte = 32bit다. 32개의 비트는 아래처럼 구성되어 있다.
1 비트: 부호비트
8 비트: 지수부
23 비트: 가수부 (fraction)
실제 값은 (-1)^(부호) 1.가수부 2^(지수부 -127)로 계산할 수 있다.실제 값을 구할 때는 지수부를 저장할 때 127 편향값을 더하는 과정이 있어서 -127를 빼는 것임2.5 변환 과정을 보자.
2.5를 이진법으로 나타내면 10.1
정규화하면 1.01 * 2^1 : 여기에서 실제 지수는 1이지만 편향값 127을 더해서 128을 얻음
32bit 표현
1비트: 0 (양수)
8비트: 지수부 - 128의 이진수(10000000)
23비트: 가수부 - 01000000000000000000000 ( 01 + 빈자리 0 21개)
결과: 0 10000000 01000000000000000000000 소수점 이하 손실
float이 int의 범위를 초과할 수 있음 (clang 17 기준으로 int max로 초기화 됨)
#include &lt;iostream&gt;
#include &lt;limits&gt;
int main() { float float_a = std::numeric_limits&lt;float&gt;::max(); int int_a = 0; std::cout &lt;&lt; float_a &lt;&lt; std::endl; // 3.40282e+38 std::cout &lt;&lt; int_a &lt;&lt; std::endl; // 0 int_a = float_a; // 2147483647 std::cout &lt;&lt; int_a &lt;&lt; std::endl; return 0;
}
아래 코드는 애매하다. c의 값에 따라 true false가 변하니 프로그램을 예측 할 수가 없다. 이런 부작용을 줄이기 위해서는 엡실론을 사용하자.#include &lt;iostream&gt;
#include &lt;limits&gt; int main() { float b = 0.2345; float c = 0.2345001; if (b == c) { std::cout &lt;&lt; "b == c" &lt;&lt; std::endl; // c가 0.23450001인 경우 } else { std::cout &lt;&lt; "b != c" &lt;&lt; std::endl; // c가 0.2345001인 경우 } return 0;
}
엡실론은 개발자가 정의 해도 되고 limits에 정의된 엡실론을 사용해도 된다. limits에 정의된 엡실론은 시스템에 맞는 적절한 엡실론 값이다. 일반적으로는 32비트 float의 경우 약 1.19209e-7 값을 가진다고 한다.#include &lt;iostream&gt;
#include &lt;limits&gt; const float epsilon = 0.0000001; int main() { float b = 0.2345; float c = 0.234501; if (std::fabs(b - c) &lt; epsilon) { std::cout &lt;&lt; "b == c" &lt;&lt; std::endl; } else { std::cout &lt;&lt; "b != c" &lt;&lt; std::endl; } if (std::fabs(b - c) &lt; std::numeric_limits&lt;float&gt;::epsilon()) { std::cout &lt;&lt; "b == c" &lt;&lt; std::endl; } else { std::cout &lt;&lt; "b != c" &lt;&lt; std::endl; } return 0;
}
]]></description><link>cs/floating-point.html</link><guid isPermaLink="false">CS/Floating Point.md</guid><pubDate>Sun, 23 Mar 2025 17:44:39 GMT</pubDate></item><item><title><![CDATA[Context Switching]]></title><description><![CDATA[컨텍스트 스위칭은 CPU가 하나의 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 제어를 전환하는 과정이다.이 과정에서 현재 실행 중인 프로세스의 상태(컨텍스트)를 저장하고 다음에 실행할 프로세스의 상태를 불러온다.
시분할(Time Sharing): 여러 프로세스가 CPU 시간을 공유하기 위해 운영체제가 주기적으로 스위칭
인터럽트(Interrupt) 발생: 하드웨어 인터럽트, 소프트웨어 인터럽트 등이 발생했을 때
I/O 요청: 프로세스가 입출력 작업을 요청했을 때(디스크 읽기/쓰기 등)
동기화 이벤트: 세마포어 획득 대기, 뮤텍스 락 대기 등 현재 실행 중인 프로세스의 상태를 PCB에 저장
해당 프로세스의 PCB를 프로세스 테이블에 업데이트
다음 실행할 프로세스의 PCB를 프로세스 테이블에서 로드
해당 PCB의 정보를 기반으로 CPU 레지스터, 메모리 맵 등을 복원 컨텍스트 스위칭을 하면 오버헤드가 발생할 수 밖에 없다. 프로세스가 전환되면 기존의 컨텍스트를 PCB에 저장하고 프로세스를 업데이트 하고 전환된 PCB를 로드해야하기 때문이다. (CPU 시간 소비)
프로세스는 자신만의 메모리 공간을 사용하는데 이전 프로세스가 사용했던 CPU 캐시는 새 프로세스에게 유용하지 않다. 즉 캐시 미스가 증가한다.
오버헤드를 줄이기 위해서 컨텍스트 스위칭을 최적화 하는 방법이 여러가지가 있는데 스레드 사용과 배치 처리가 있다.스레드를 사용하면 프로세스를 전환하는 것보다 오버헤드가 적다.
스레드는 프로세스보다 적은 상태 정보를 저장한다.
같은 프로세스 내 스레드들은 메모리 공간을 공유하므로 전체 주소 공간(코 데 힙) 전환 이 필요 없다. (스택 영역은 독립적이라 변경 필요)
스레드간 전환 시 캐시 재사용 가능성 높아짐
배치 처리는 요청을 묶어서 한번에 처리해 컨텍스트 스위칭 횟수 자체를 줄이는 방법이다.
시스템 콜: 여러 개의 시스템 호출을 하나로 묶어 커널 모드로의 전환 횟수 감소
I/O 작업 최적화: 여러 I/O 작업을 한 번에 수행하여 블로킹으로 인한 컨텍스트 스위칭 감소
자원 할당: 자원 할당/해제 과정에서 발생하는 컨텍스트 스위칭 최소화
]]></description><link>cs/context-switching.html</link><guid isPermaLink="false">CS/Context Switching.md</guid><pubDate>Sun, 23 Mar 2025 17:44:26 GMT</pubDate></item><item><title><![CDATA[Deadlock]]></title><description><![CDATA[Deadlock (교착상태)의 4가지 필수 조건 자원은 한 번에 하나의 프로세스만 사용 해야한다. 자원이 공유되지 않고 독점적으로 사용할 수 있어야 한다. 프로세스가 이미 일부 자원을 점유한 상태라면 다른 프로세스가 사용 중인 자원을 요청하고 대기하는 상태다. 프로세스가 자원을 스스로 반납하기 전까지 다른 프로세스가 강제로 빼앗을 수 없다. 프로세스들이 순환적으로 다른 프로세스가 요구하는 자원을 가지고 있는 상황이다. 예를 들면 A는 B의 자원을 기다리고, B는 C의 자원을 기다리고, C는 A의 자원을 기다리는 경우다.데드록을 예방하려면 네가지 조건 중 최소한 하나를 제거 해야한다.]]></description><link>cs/deadlock.html</link><guid isPermaLink="false">CS/Deadlock.md</guid><pubDate>Sun, 23 Mar 2025 17:09:27 GMT</pubDate></item><item><title><![CDATA[전역변수와 정적변수의 공통점과 차이점]]></title><description><![CDATA[
둘 다 프로그램이 시작될 때 생성되어 프로그램이 종료될 때까지 존재한다.
스택이 아닌 정적 메모리 영역(데이터 영역)에 저장됨
멀티쓰레드 환경에서 접근이 가능해서 동기화가 메커니즘이 필요하다. (race condition 발생 가능성 있음)
C++11 이전에는 전역 변수, 정적 변수를 초기화 할 때 쓰레드 안전성이 없었으나 C++11 이후에는 초기화할 때 안전성이 있음. Scope가 가장 큰 차이점임. 전역변수는 프로그램 전체에서 접근 가능하지만, 정적 변수는 선언된 범위내에서만 접근 가능하다. (함수, 클래스, 파일)
전역변수는 함수 외부에 선언하고 정적 변수는 static 키워드로 선언한다.
int globalVar = 10; // 전역 변수 static int fileStaticVar = 20; // 파일 범위 정적 변수 void func() { static int localStaticVar = 30; // 함수 내 정적 변수
} class MyClass {
public: static int classStaticVar; // 클래스 정적 변수
};
]]></description><link>cpp/etc/전역변수와-정적변수의-공통점과-차이점.html</link><guid isPermaLink="false">CPP/etc/전역변수와 정적변수의 공통점과 차이점.md</guid><pubDate>Sun, 23 Mar 2025 17:02:53 GMT</pubDate></item><item><title><![CDATA[const 위치 헷갈리는 점 정리]]></title><description><![CDATA[C++에서 포인터와 const를 같이 사용할 때 자주 헷갈린다. 그래서 복습을 계속 한다. 목표는 const 위치에 따라 포인터 자체와 가리키는 값 중 무엇이 변경 불가능한지 암기하는 것이다.'const를 기준으로 왼쪽에 있는 것이 상수고 아무것도 없다면 오른쪽에 있는 것이 상수'
const int* p int const* p
const int* p와 int const* p는 같다. 원리만 기억하면 같다는 사실을 도출할 수 있다.
포인터가 가르키는 값이 상수임. 포인터 자체는 변경 가능하니까 다른 주소를 가르키면 됨#include &lt;iostream&gt;
int main() { int v = 10; int v2 = 30; const int *p = &amp;v; int const *p2 = &amp;v; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; *p2 &lt;&lt; std::endl; *p = 20; // 컴파일 실패 *p2 = 20; // 컴파일 실패 p = &amp;v2; p2 = &amp;v2; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; *p2 &lt;&lt; std::endl; return 0;
} int* const p
const의 왼쪽은 *이므로 포인터 자체가 상수라는 뜻이다. 이 경우 p의 가르키는 값은 변경 가능하지만 p 자체를 변경할 수 없음.
#include &lt;iostream&gt;
int main() { int value1 = 10; int value2 = 20; int *const p3 = &amp;value1; *p3 = 30; // 가능: p가 가리키는 값은 변경 가능 p3 = &amp;value2; // 컴파일 에러: p 자체를 변경할 수 없음 return 0;
} const int* const p
int main() { int value1 = 10; int value2 = 20 const int* const p = &amp;value1; *p = 30; // 컴파일 에러: p가 가리키는 값을 변경할 수 없음 p = &amp;value2; // 컴파일 에러: p 자체를 변경할 수 없음
} const 멤버 함수는 클래스의 상태를 변경하지 않는다는 뜻이다.즉 const 멤버 함수 내에서
멤버 변수 값 수정 불가
non-const 멤버 함수 호출 불가
this 포인터는 const MyClass* 타입이다.
class MyClass {
public: int getValue() const { value = 10; // 컴파일 실패 return value; } private: int value; }
const 참조 반환은 함수가 객체의 내부 데이터에 대한 읽기 전용 접근을 제공하는 방법이다.
아래 코드에서 const가 있는 경우에는 레퍼런스 타입으로 getText()를 하면 컴파일 에러가 발생해서 수정 할 수 있는 여지가 없다.const가 없는 경우에는 getText()에서 컴파일 에러 발생 안하고 text를 수정 가능 하므로 Hello world를 출력하게 된다.class StringContainer {
public: StringContainer() : text("Hello") {} const std::string &amp;getText() { return text; } // 수정 가능한 참조 반환 // std::string &amp;getText() { return text; } private: std::string text;
}; int main() { StringContainer container; std::cout &lt;&lt; container.getText() &lt;&lt; std::endl; std::string &amp;text = container.getText(); // 컴파일 에러 발생 text += " world"; std::cout &lt;&lt; container.getText() &lt;&lt; std::endl; return 0;
}
]]></description><link>cpp/etc/const-위치-헷갈리는-점-정리.html</link><guid isPermaLink="false">CPP/etc/const 위치 헷갈리는 점 정리.md</guid><pubDate>Sun, 23 Mar 2025 16:49:11 GMT</pubDate></item><item><title><![CDATA[상속 생성자, 소멸자 헷갈리는 점]]></title><description><![CDATA[파생 클래스는 기본적으로 기반 클래스의 생성자를 호출한다.
기반클래스 생성자 -&gt; 파생클래스 생성자 -&gt; 파생클래스 소멸자 -&gt; 파생클래스 소멸자 순서다.각 클래스 타입에 맞게 생성을 하면 문제가 없으나, 다형성을 사용하기 위해서 파생클래스를 생성하고 기반클래스 포인터로 가르킬 때 파악을 잘해야한다.#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("Base") { std::cout &lt;&lt; "Base class" &lt;&lt; std::endl; } ~Base() { std::cout &lt;&lt; "Base class 소멸" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; } };
class Derived : public Base { std::string s; public: Derived() : Base(), s("Derived") { std::cout &lt;&lt; "Derived Class" &lt;&lt; std::endl; } ~Derived() { std::cout &lt;&lt; "Derived class 소멸" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { std::cout &lt;&lt; " === Generate base class 생성 ===" &lt;&lt; std::endl; Base p; std::cout &lt;&lt; " === Generate Derived Class ===" &lt;&lt; std::endl; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Base *p_c = &amp;c; Base *p_p = &amp;p; std::cout &lt;&lt; "== 실제 객체는 Base == " &lt;&lt; std::endl; p_p-&gt;what(); // Base 출력 std::cout &lt;&lt; "== 실제 객체는 Derived == " &lt;&lt; std::endl; p_c-&gt;what(); // Base 출력 std::cout &lt;&lt; "================= " &lt;&lt; std::endl; { Derived c; } { Base *p_c = new Derived(); delete p_c; } std::cout &lt;&lt; "================= 소멸자 호출 시작 =======" &lt;&lt; std::endl; return 0;
}
실제 객체는 파생 클래스인데 기반 클래스 포인터로 가르키면 위처럼 Base를 출력할 것이다. 만약 다형성을 이유로 기반 클래스 포인터로 가르키고 파생 클래스의 Derived를 출력하길 원한다면 기반 클래스에 virtual 키워드를 사용하면 된다. 즉 virtual 키워드를 이용하면 기반 클래스 포인터로 가르켜도 실제 객체 (파생클래스)의 멤버 함수 실행할 수 있게 된다.그리고 또 주의할 점은 소멸자다. 객체는 파생 클래스지만 기반 클래스 포인터로 가르키고 있을 때 소멸자가 호출되면 기반 클래스의 소멸자는 호출 되지만 파생 클래스의 소멸자는 호출되지 않는다. 이 지점에서 메모리 누수가 발생한다. 이를 방지 하기 위해서는 기반 클래스의 소멸자에 virtual 키워드를 사용한다. 그러면 기반 클래스 소멸자가 호출될 때 virtual 키워드를 보고 파생 클래스의 소멸자도 호출한다.]]></description><link>cpp/etc/상속-생성자,-소멸자-헷갈리는-점.html</link><guid isPermaLink="false">CPP/etc/상속 생성자, 소멸자 헷갈리는 점.md</guid><pubDate>Sun, 23 Mar 2025 16:13:21 GMT</pubDate></item><item><title><![CDATA[Pseudo random (의사 난수)]]></title><description><![CDATA[왜 의사 난수라고 하는가? 어떻게 하면 진짜 난수를 추출할 수 있는가?의사 난수라고 하는 이유는 컴퓨터 알고리즘으로 생성되는 난수는 수학적 공식에 따라 결정적으로 생성되기 때문이다. 이러한 난수 수열은 시드를 기반으로 해서 생성된다. 만약 같은 시드라면 동일한 수열이 생성된다.의사 난수의 문제점은 시드와 알고리즘을 안다면 난수 시퀀스를 예측할 수 있고 알고리즘이기 때문에 값의 bias (편향성)이 있을 수 있다.C++에서 난수를 생성하는 방법은 주로 random의 std::random_device를 사용하는 것이다. 이것은 수학적 알고리즘을 통해 생성되는 가짜 난수가 아니라 정말로 컴퓨터가 실행 되면서 마주치는 무작위적인 요소들 (예를 들어 장치 드라이버들의 noise) 을 기반으로한 진짜 난수를 제공한다.다만 이 방식은 의사난수 생성보다 느리다. 그래서 보통 시드만 '진짜 난수'로 생성하고 의사 난수 생성기를 통해 난수를 생성한다. 보통 C++ 표준 라이브러리에 포함된 메르센 트위스터(Mersenne Twister) 의사난수 생성기 std::mt19937를 사용함. #include &lt;iostream&gt;
#include &lt;random&gt; int main(int argc, char *argv[]) { std::random_device rd; std::cout &lt;&lt; "Entropy: " &lt;&lt; rd.entropy() &lt;&lt; std::endl; std::mt19937 gen(rd()); std::uniform_int_distribution&lt;&gt; distrib(1, 6); for (int i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; distrib(gen); } return 0;
}
]]></description><link>cs/pseudo-random-(의사-난수).html</link><guid isPermaLink="false">CS/Pseudo random (의사 난수).md</guid><pubDate>Sun, 23 Mar 2025 15:51:44 GMT</pubDate></item><item><title><![CDATA[유리수 클래스 구현]]></title><description><![CDATA[기약분수로 나타내기 위해 최대공약수 (GCD)를 구하는 함수가 필요하다.클래스에서 연산자를 구현해서 반환할 때 약분하고 반환한다.#include &lt;iostream&gt;
#include &lt;stdexcept&gt; class Ratio { private: static int gcd(int a, int b) { a = std::abs(a); b = std::abs(b); while (b != 0) { int temp = b; b = a % b; a = temp; } return a; } // 기약분수 void simplify() { if (num == 0) { den = 1; return; } int divisor = gcd(num, den); num /= divisor; den /= divisor; if (den &lt; 0) { num = -num; den = -den; } } public: int num; int den; explicit Ratio(int num, int den = 1) : num(num), den(den) { if (den == 0) { throw std::invalid_argument("Denominator cannot be zero"); } simplify(); } bool operator==(const Ratio &amp;other) const { return num * other.den == den * other.num; } bool operator!=(const Ratio &amp;other) const { return num * other.den != den * other.num; } bool operator&lt;(const Ratio &amp;other) const { return num * other.den &lt; den * other.num; } bool operator&gt;(const Ratio &amp;other) const { return num * other.den &gt; den * other.num; } bool operator&lt;=(const Ratio &amp;other) const { return num * other.den &lt;= den * other.num; } bool operator&gt;=(const Ratio &amp;other) const { return num * other.den &gt;= den * other.num; } Ratio operator+(const Ratio &amp;other) const { int new_num = num * other.den + den * other.num; int new_den = den * other.den; return Ratio(new_num, new_den); } Ratio operator-(const Ratio &amp;other) const { int new_num = num * other.den - den * other.num; int new_den = den * other.den; return Ratio(new_num, new_den); } Ratio operator*(const Ratio &amp;other) const { int new_num = num * other.den; int new_den = den * other.num; return Ratio(new_num, new_den); } Ratio operator/(const Ratio &amp;other) { int new_num = num * other.den; int new_den = den * other.num; if (new_num == 0) { return Ratio(0); } return Ratio(new_num, new_den); } friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Ratio &amp;r) { os &lt;&lt; r.num &lt;&lt; "/" &lt;&lt; r.den; return os; }
}; int main(int argc, char *argv[]) { Ratio r1(1, 2); std::cout &lt;&lt; "r1 = " &lt;&lt; r1 &lt;&lt; std::endl; Ratio r2(2, 4); // 1/2로 약분됨 std::cout &lt;&lt; "r2 = " &lt;&lt; r2 &lt;&lt; std::endl; Ratio r3 = r1 + r2; std::cout &lt;&lt; "r1 + r2 = " &lt;&lt; r3 &lt;&lt; std::endl; Ratio r4(3, 6); // 1/2로 약분됨 std::cout &lt;&lt; "r4 = " &lt;&lt; r4 &lt;&lt; std::endl; Ratio r5 = r1 * r4; std::cout &lt;&lt; "r1 * r4 = " &lt;&lt; r5 &lt;&lt; std::endl; Ratio r6(-2, 4); // -1/2로 약분됨 std::cout &lt;&lt; "r6 = " &lt;&lt; r6 &lt;&lt; std::endl; Ratio r7(4, -8); // -1/2로 약분됨 std::cout &lt;&lt; "r7 = " &lt;&lt; r7 &lt;&lt; std::endl; std::cout &lt;&lt; "r1 == r2: " &lt;&lt; (r1 == r2 ? "true" : "false") &lt;&lt; std::endl; std::cout &lt;&lt; "r1 == r3: " &lt;&lt; (r1 == r3 ? "true" : "false") &lt;&lt; std::endl; std::cout &lt;&lt; "r1 != r2: " &lt;&lt; (r1 != r2 ? "true" : "false") &lt;&lt; std::endl; std::cout &lt;&lt; "r1 != r3: " &lt;&lt; (r1 != r3 ? "true" : "false") &lt;&lt; std::endl; std::cout &lt;&lt; "r1 &lt; r3: " &lt;&lt; (r1 &lt; r3 ? "true" : "false") &lt;&lt; std::endl; return 0;
}
]]></description><link>cpp/etc/유리수-클래스-구현.html</link><guid isPermaLink="false">CPP/etc/유리수 클래스 구현.md</guid><pubDate>Sun, 23 Mar 2025 15:42:24 GMT</pubDate></item><item><title><![CDATA[문제유형]]></title><description><![CDATA[
<a data-tooltip-position="top" aria-label="https://leetcode.com/problems/two-sum/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/two-sum/" target="_self">LeetCode #1: Two Sum</a> (Easy) 핵심 개념: 해시맵 활용
목표 시간: 15분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_self">LeetCode #121: Best Time to Buy and Sell Stock</a> (Easy) 핵심 개념: 한 번 순회, 최소값 갱신
목표 시간: 15분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/3sum/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/3sum/" target="_self">LeetCode #15: 3Sum</a> (Medium) 핵심 개념: 투 포인터 기법
목표 시간: 25분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/contains-duplicate/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/contains-duplicate/" target="_self">LeetCode #217: Contains Duplicate</a> (Easy) 핵심 개념: 해시셋 활용
목표 시간: 10분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/valid-anagram/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/valid-anagram/" target="_self">LeetCode #242: Valid Anagram</a> (Easy) 핵심 개념: 빈도수 세기
목표 시간: 15분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/group-anagrams/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/group-anagrams/" target="_self">LeetCode #49: Group Anagrams</a> (Medium) 핵심 개념: 해시맵으로 그룹화
목표 시간: 20분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/flood-fill/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/flood-fill/" target="_self">LeetCode #733: Flood Fill</a> (Easy) 핵심 개념: DFS 기본
목표 시간: 20분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/number-of-islands/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/number-of-islands/" target="_self">LeetCode #200: Number of Islands</a> (Medium) 핵심 개념: DFS/BFS 응용
목표 시간: 25분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/rotting-oranges/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/rotting-oranges/" target="_self">LeetCode #994: Rotting Oranges</a> (Medium) 핵심 개념: BFS 응용, 레벨 순회
목표 시간: 30분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/binary-search/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/binary-search/" target="_self">LeetCode #704: Binary Search</a> (Easy) 핵심 개념: 기본 이진 탐색
목표 시간: 10분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/search-insert-position/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/search-insert-position/" target="_self">LeetCode #35: Search Insert Position</a> (Easy) 핵심 개념: 이진 탐색 변형
목표 시간: 15분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/search-in-rotated-sorted-array/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_self">LeetCode #33: Search in Rotated Sorted Array</a> (Medium) 핵심 개념: 이진 탐색 응용
목표 시간: 25분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/climbing-stairs/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/climbing-stairs/" target="_self">LeetCode #70: Climbing Stairs</a> (Easy) 핵심 개념: 기본 DP, 피보나치 수열
목표 시간: 15분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/maximum-subarray/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/maximum-subarray/" target="_self">LeetCode #53: Maximum Subarray</a> (Easy) 핵심 개념: 카데인 알고리즘, 1D DP
목표 시간: 20분 <br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/coin-change/" rel="noopener nofollow" class="external-link is-unresolved" href="https://leetcode.com/problems/coin-change/" target="_self">LeetCode #322: Coin Change</a> (Medium) 핵심 개념: 1D DP 응용
목표 시간: 25분 // 그래프 탐색 (DFS) - 재귀
void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int rows, int cols) { if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || grid[i][j] == 0) { return; } grid[i][j] = 0; // 방문 표시 // 4방향 탐색 dfs(grid, i+1, j, rows, cols); dfs(grid, i-1, j, rows, cols); dfs(grid, i, j+1, rows, cols); dfs(grid, i, j-1, rows, cols);
} // 그래프 탐색 (BFS)
void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, int rows, int cols) { queue&lt;pair&lt;int, int&gt;&gt; q; q.push({i, j}); grid[i][j] = 0; // 방문 표시 vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; while (!q.empty()) { auto [r, c] = q.front(); q.pop(); for (auto [dr, dc] : dirs) { int nr = r + dr, nc = c + dc; if (nr &gt;= 0 &amp;&amp; nr &lt; rows &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; cols &amp;&amp; grid[nr][nc] == 1) { q.push({nr, nc}); grid[nr][nc] = 0; // 방문 표시 } } }
} // 이진 탐색
int binarySearch(vector&lt;int&gt;&amp; nums, int target) { int left = 0, right = nums.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; // 찾지 못함
} // 투 포인터
vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; map; for (int i = 0; i &lt; nums.size(); i++) { int complement = target - nums[i]; if (map.count(complement)) { return {map[complement], i}; } map[nums[i]] = i; } return {};
}
]]></description><link>algorithm/study/문제유형.html</link><guid isPermaLink="false">Algorithm/Study/문제유형.md</guid><pubDate>Sat, 22 Mar 2025 04:24:47 GMT</pubDate></item><item><title><![CDATA[코딩테스트를 위한 암기]]></title><description><![CDATA[코딩테스트 때 cpp reference를 제공해주는 몰라서 헷갈리는 거 간단하게 메모sort(A.begin(), A.end(), [](int a, int b) { return a &lt; b;}); //오름차순
sort(B.begin(), B.end(), [](int a, int b) { return a &gt; b;}); // 내림차순 std::partial_sort(start, middle, end) // 일부 정렬
// 전체에서 가장 작은 애들만 순서대로 저장하고 나머지 위치는 상관없이 저장
std::partial_sort(vec.begin(), vec.begin() + 3, vec.end()); //제거 // first부터 last 사이에 있는 원소 지움
Iterator erase(Iterator first, Iterator last);
// 3인 걸 지워라
vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());
// 조건인걸 지워라 - std::remove_if(vec.begin(), vec.end(), 람다) find, find_if도 erase 같음 // 0 을 10 개 가지는 벡터 생성
std::vector&lt;int&gt; vec(10, 0); // Ten zeros로 외우자!!
std::stack&lt;type&gt; stk; // stack은 그냥 이렇게 초기화 컨테이너로 초기화 하는 방법은 굳이? stk.push();
stk.pop(); // return void;
stk.top();
stk.empty();
stk.size(); // 길이 return size_t
]]></description><link>algorithm/study/코딩테스트를-위한-암기.html</link><guid isPermaLink="false">Algorithm/Study/코딩테스트를 위한 암기.md</guid><pubDate>Tue, 18 Mar 2025 14:06:51 GMT</pubDate></item><item><title><![CDATA[CMake]]></title><description><![CDATA[CMake는 빌드파일을 생성하는 프로그램이다. CMake를 통해 빌드 파일을 생성하고 빌드 프로그램 (Make, Visual Studio, Xcode etc..)을 이용해 프로젝트를 빌드할 수 있다.그리고 CMake 명령은 타겟을 정의하는 것과 타겟의 속성을 지정하는 명령어로 구성된다.
add_executable (&lt;실행 파일 이름&gt; &lt;소스1&gt; &lt;소스2&gt; ... &lt;소스들&gt;)
target_compile_options(&lt;실행 파일 이름&gt; PUBLIC &lt;컴파일 옵션1&gt; &lt;컴파일 옵션2&gt; ...) Ex: `target_compile_options(program PUBLIC -Wall -Werror)
PUBLIC: PRIVATE: target_include_directories(program {PUBLIC or PRIVATE or INTERFACE} ${CMAKE_SOURCE_DIR}/includes) 헤더 파일 탐색 경로 추가 add_library (&lt;라이브러리 이름&gt; [STATIC | SHARED | MODULE ] &lt;소스 1&gt; &lt;소스 2&gt; ...) STATIC: 정적
SHARED: 동적
MODULE: 동적링크 X, dlopen 같은 함수로 런타임에 불러올 수 있는 라이브러리 $ mkdir build &amp;&amp; cd build
$ cmake .. # root CMakeList.txt 경로를 지정해야함
$ brew install ninja
$ cmake .. -G Ninja
$ cmake --build .
.vscode/settings.json{ // 이거는 직접 라이브러리 include path 추가 //"clangd.fallbackFlags": [ //"-I/opt/homebrew/Cellar/opencv/4.11.0_1/include/opencv4", //"-I/opt/homebrew/Cellar/opencv/4.11.0_1/include" //], "clangd.arguments": [ "--compile-commands-dir=${workspaceFolder}", "--background-index", "--clang-tidy" ]
}
]]></description><link>cpp/build-system/cmake.html</link><guid isPermaLink="false">CPP/Build System/CMake.md</guid><pubDate>Sun, 16 Mar 2025 13:40:50 GMT</pubDate></item><item><title><![CDATA[Video Capture]]></title><description><![CDATA[cv::VideoCapture 클래스는 OpenCV에서 카메라 장치나 비디오 파일을 처리하기 위한 클래스다.생성자는 다양한 비디오 소스에 연결하는 기능을 제공VideoCapture(); // Camera 연결
explicit VideoCapture(int index, int apiPreference = CAP_ANY); // 파일
explicit VideoCapture(const String&amp; filename, int apiPreference = CAP_ANY); VideoCapture(const Ptr&lt;IStreamReader&gt;&amp; source, int apiPreference, const std::vector&lt;int&gt;&amp; params); apiPreference - API 백엔드 용도: 비디오 캡처에 사용할 특정 백엔드 API를 지정합니다.
주요 옵션: cv::CAP_ANY: 자동 선택 (기본값)
cv::CAP_DSHOW: Windows DirectShow
cv::CAP_AVFOUNDATION: macOS AVFoundation
cv::CAP_V4L2: Linux Video4Linux2
cv::CAP_GSTREAMER: GStreamer 프레임워크
cv::CAP_FFMPEG: FFmpeg 라이브러리 const Ptr&lt;IStreamReader&gt;&amp; source Ptr&lt;&gt;: OpenCV에서 사용하는 스마트 포인터 클래스입니다. 자동 메모리 관리를 제공
IStreamReader: 데이터 스트림을 읽기 위한 인터페이스 클래스
용도: 사용자 정의 데이터 소스에서 비디오 프레임을 읽을 수 있게 합니다 OpenCV에서 비디오 파일을 생성하고 인코딩하기 위한 클래스CV_WRAP VideoWriter(const String&amp; filename, int fourcc, double fps, Size frameSize, bool isColor = true); CV_WRAP VideoWriter(const String&amp; filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor = true); CV_WRAP VideoWriter(const String&amp; filename, int fourcc, double fps, const Size&amp; frameSize, const std::vector&lt;int&gt;&amp; params); CV_WRAP VideoWriter(const String&amp; filename, int apiPreference, int fourcc, double fps, const Size&amp; frameSize, const std::vector&lt;int&gt;&amp; params); int fourcc Four Character Code - 비디오 코덱을 4개의 문자로 식별하는 방법
a','v','c','1' : H.264 코덱
'M','J','P','G': Motion JPEG 'X','V','I','D': XVID MPEG-4
'm','p','4','v': MPEG-4
'D','I','V','X': DIVX MPEG-4 double fps: Frame rate Size&amp; frameSize: 해상도
예시cv::VideoWriter writer(videoFilename, cv::VideoWriter::fourcc('a', 'v', 'c', '1'), FPS, frame.size());
for (const auto&amp; f : allFrames) { writer.write(f); // 쓰기
} writer.release(); // 닫기
// 창 미리 생성
cv::namedWindow("카메라", cv::WINDOW_NORMAL); while (true) { // 카메라에서 새 프레임 읽기 camera.read(frame); // "카메라" 창에 새 프레임 표시/업데이트 cv::imshow("카메라", frame); // GUI 이벤트 처리 및 키 입력 대기 int key = cv::waitKey(1); if (key == 'q') break; // q키 누르면 종료
} #include &lt;deque&gt;
#include &lt;mutex&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt; class VideoBuffer { private: std::deque&lt;cv::Mat&gt; frames; const int maxFrames; std::mutex mtx; public: VideoBuffer(int capacity) : maxFrames(capacity) {} void addFrame(const cv::Mat&amp; frame) { std::lock_guard&lt;std::mutex&gt; lock(mtx); frames.push_back(frame.clone()); if (frames.size() &gt; maxFrames) { frames.pop_front(); } } std::vector&lt;cv::Mat&gt; getAllFrames() { std::lock_guard&lt;std::mutex&gt; lock(mtx); return std::vector&lt;cv::Mat&gt;(frames.begin(), frames.end()); } size_t size() { std::lock_guard&lt;std::mutex&gt; lock(mtx); return frames.size(); }
};
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt; #include "VideoBuffer.h" int main() { // 설정값 const int FPS = 30; const int PRE_SECONDS = 3; const int POST_SECONDS = 3; const int BUFFER_SIZE = FPS * PRE_SECONDS; // OpenCV 카메라 초기화 (메인 스레드에서) cv::VideoCapture camera(0); if (!camera.isOpened()) { std::cerr &lt;&lt; "카메라를 열 수 없습니다." &lt;&lt; std::endl; return -1; } // 윈도우 생성 (메인 스레드에서) cv::namedWindow("카메라", cv::WINDOW_NORMAL); // 링 버퍼 초기화 VideoBuffer preBuffer(BUFFER_SIZE); std::vector&lt;cv::Mat&gt; postBuffer; // 상태 변수 std::atomic&lt;bool&gt; isRecording(false); std::atomic&lt;bool&gt; shouldQuit(false); std::atomic&lt;int&gt; postFrameCount(0); bool videoSaved = false; std::string videoFilename = "captured_video.mp4"; std::cout &lt;&lt; "시작되었습니다. 's'를 눌러 캡처, 'q'를 눌러 종료, 'p'를 눌러 재생" &lt;&lt; std::endl; // 메인 루프 (UI 작업을 포함) cv::Mat frame; while (!shouldQuit) { // 카메라에서 프레임 읽기 if (!camera.read(frame)) { std::cerr &lt;&lt; "프레임을 읽을 수 없습니다." &lt;&lt; std::endl; break; } // 현재 프레임을 미리 버퍼에 추가 preBuffer.addFrame(frame); // 녹화 중이면 사후 버퍼에 추가 if (isRecording) { postBuffer.push_back(frame.clone()); postFrameCount++; // 사후 녹화 완료 확인 if (postFrameCount &gt;= FPS * POST_SECONDS) { isRecording = false; // 비디오 저장 std::vector&lt;cv::Mat&gt; preFrames = preBuffer.getAllFrames(); std::vector&lt;cv::Mat&gt; allFrames; allFrames.insert(allFrames.end(), preFrames.begin(), preFrames.end()); allFrames.insert(allFrames.end(), postBuffer.begin(), postBuffer.end()); cv::VideoWriter writer(videoFilename, cv::VideoWriter::fourcc('a', 'v', 'c', '1'), FPS, frame.size()); if (!writer.isOpened()) { std::cerr &lt;&lt; "비디오 파일을 저장할 수 없습니다." &lt;&lt; std::endl; } else { for (const auto&amp; f : allFrames) { writer.write(f); } writer.release(); std::cout &lt;&lt; "비디오가 저장되었습니다: " &lt;&lt; videoFilename &lt;&lt; std::endl; videoSaved = true; } postBuffer.clear(); postFrameCount = 0; } } // 프레임 표시 (메인 스레드에서) cv::imshow("카메라", frame); // 키 입력 처리 int key = cv::waitKey(1); if (key == 'q' || key == 'Q') { shouldQuit = true; } else if (key == 's' || key == 'S') { if (!isRecording) { std::cout &lt;&lt; "캡처 시작됨..." &lt;&lt; std::endl; isRecording = true; postBuffer.clear(); postFrameCount = 0; } } else if (key == 'p' || key == 'P' &amp;&amp; videoSaved) { std::cout &lt;&lt; "녹화된 비디오 재생 중..." &lt;&lt; std::endl; cv::VideoCapture player(videoFilename); if (!player.isOpened()) { std::cerr &lt;&lt; "비디오 파일을 재생할 수 없습니다." &lt;&lt; std::endl; } else { cv::namedWindow("재생", cv::WINDOW_NORMAL); cv::Mat playFrame; while (player.read(playFrame)) { cv::imshow("재생", playFrame); if (cv::waitKey(1000 / FPS) &gt;= 0) { break; } } cv::destroyWindow("재생"); player.release(); } } } // 정리 camera.release(); cv::destroyAllWindows(); return 0;
}
]]></description><link>opencv/video-capture.html</link><guid isPermaLink="false">opencv/Video Capture.md</guid><pubDate>Sun, 16 Mar 2025 13:40:50 GMT</pubDate></item><item><title><![CDATA[21. Merge Two Sorted Lists]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a> class Solution {
public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* curr = new ListNode(); ListNode* res = curr; while (list1 != nullptr || list2 != nullptr) { if (list1 == nullptr) { curr-&gt;next = list2; break; } if (list2 == nullptr) { curr-&gt;next = list1; break; } int val1 = list1-&gt;val; int val2 = list2-&gt;val; if (val1 &gt;= val2) { ListNode* temp = new ListNode(val2); curr-&gt;next = temp; list2 = list2-&gt;next; } else { ListNode* temp = new ListNode(val1); curr-&gt;next = temp; list1 = list1-&gt;next; } curr = curr-&gt;next; } return res-&gt;next; }
};
]]></description><link>algorithm/leetcode/21.-merge-two-sorted-lists.html</link><guid isPermaLink="false">Algorithm/LeetCode/21. Merge Two Sorted Lists.md</guid><pubDate>Wed, 05 Mar 2025 15:48:21 GMT</pubDate></item><item><title><![CDATA[206. Reverse Linked List]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */
class Solution {
public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; while(curr != nullptr) { ListNode* next = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = next; } return prev; }
};
]]></description><link>algorithm/leetcode/206.-reverse-linked-list.html</link><guid isPermaLink="false">Algorithm/LeetCode/206. Reverse Linked List.md</guid><pubDate>Wed, 05 Mar 2025 15:48:21 GMT</pubDate></item><item><title><![CDATA[141. Linked List Cycle]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a> class Solution {
public: bool hasCycle(ListNode *head) { ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) { return true; } } return false; }
};
]]></description><link>algorithm/leetcode/141.-linked-list-cycle.html</link><guid isPermaLink="false">Algorithm/LeetCode/141. Linked List Cycle.md</guid><pubDate>Wed, 05 Mar 2025 15:48:21 GMT</pubDate></item><item><title><![CDATA[143. Reorder List]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> class Solution {
public: void reorderList(ListNode* head) { if (!head || !head-&gt;next || !head-&gt;next-&gt;next) { return; } ListNode* slow = head; ListNode* fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } ListNode* mid = slow-&gt;next; slow-&gt;next = nullptr; ListNode* prev = nullptr; ListNode* curr = mid; while(curr != nullptr) { ListNode* next = curr-&gt;next; curr-&gt;next = prev; prev = curr; curr = next; } ListNode* secondHalf = prev; ListNode* first = head; ListNode* second = secondHalf; while(second) { ListNode* firstNext = first-&gt;next; ListNode* secondNext = second-&gt;next; first-&gt;next = second; second-&gt;next = firstNext; first = firstNext; second = secondNext; } }
};
]]></description><link>algorithm/leetcode/143.-reorder-list.html</link><guid isPermaLink="false">Algorithm/LeetCode/143. Reorder List.md</guid><pubDate>Wed, 05 Mar 2025 15:48:21 GMT</pubDate></item><item><title><![CDATA[ros2 명령어]]></title><description><![CDATA[ros2 run [패키지_이름] [노드_이름]ros2 run rqt_grqph rqt_graph$ ros2 node list # 현재 실행중인 노드
$ ros2 node info {/turtlesim} # 노드 정보 확인
]]></description><link>robotics/ros2-명령어.html</link><guid isPermaLink="false">robotics/ros2 명령어.md</guid><pubDate>Wed, 05 Mar 2025 15:48:21 GMT</pubDate></item><item><title><![CDATA[PIC]]></title><description><![CDATA[PIC는 Position Independent Code의 준말로 실행파일이 메모리의 어느 위치에 상관 없이 올바르게 실행될 수 있도록 컴파일된 코드다.리눅스에서 C++을 컴파일 했을 때 아래와 유사한 에러가 발생했다.relocation R_X86_64_PC32 against symbol ... can not be used when making a shared object
CMAKE_POSITION_INDEPENDENT_CODE ON 를 이용해서 해결했다. 왜 이게 해결법일까?공유 라이브러리가 프로그램에 로드될 때 운영체제는 이 라이브러리를 메모리의 어느 위치에 로드할 지 실행 시점에 결정한다. 그래서 메모리 위치는 랜덤이다. 그리고 현대적인 운영체제는 보안 강화를 위해 ASLR(Address Space Layout Randomization)이라는 기술을 사용한다. 이 기술은 프로그램과 라이브러리의 메모리 로드 위치를 의도적으로 무작위화 한다.PIC 옵션 켜지 않으면 위치 종속적 코드(Position Dependent Code)가 되어버려서 아래 유사하게 동작할 것이다. 만약 아래 코드가 메모리의 다른 위치 로드하게 되면 크래쉬가 발생할 것이다.// 위치 종속적 코드의 예시 (가상의 어셈블리와 유사한 형태)
function_a: // 이 함수가 메모리 주소 0x10000에 있다고 가정 ... CALL 0x10500 // function_b의 절대 주소를 하드코딩 ... function_b: // 이 함수는 항상 메모리 주소 0x10500에 있어야 함 ...
PIC 옵션을 켜면// 위치 독립적 코드의 예시
function_a: // 이 함수가 어디에 위치하든 상관없음 ... CALL PC+500 // 현재 프로그램 카운터(PC)로부터의 상대적 오프셋 ... function_b: // function_a로부터 항상 500바이트 떨어진 위치에 있음 ...
함수 호출을 상대적인 거리 (offset)으로 하기 때문에 코드가 메모리 위치에 상관 없이 제대로 동작할 수 있다.즉 PIC 옵션은 메모리 매핑의 불확실성 속에서 코드가 올바르게 동작할 수 있게 된다. 운영체제가 라이브러리를 메모리의 어디에 배치하든 상관없이 코드는 자신의 위치와 다른 코드 조각들의 상대적 위치 관계를 이용하여 올바르게 실행된다.Linux에서는 공유 라이브러리 (so)를 빌드할 때 명시적으로 PIC 설정이 필요하다.
Mac에서는 기본적으로 공유 라이브러리(dylib)를 빌드할 때 -fPIC 옵션이 기본 적용된다.크로스플랫폼 타겟으로 하는 CMake 프로젝트에서는 Root CMakeLists.txt에서 PIC 설정을 하는 것이 좋다.]]></description><link>cpp/build-system/pic.html</link><guid isPermaLink="false">CPP/Build System/PIC.md</guid><pubDate>Sun, 02 Mar 2025 16:00:13 GMT</pubDate></item><item><title><![CDATA[1. basic]]></title><description><![CDATA[brew install --cask docker
docker -v # docker 설치 확인
docker search ubuntu # ubuntu 이미지 검색
docker pull ubuntu:22.04 #specific version
docker run -it ubuntu:22.04 /bin/bash # 도커 컨테이너 생성 및 시작
# 패키지 목록 업데이트
apt update # zsh 및 git, curl 등등 필요한 도구 설치
apt install -y zsh curl git build-essential vim # Oh My Zsh 설치 (선택사항)
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
docker ps
docker ps -a # 꺼져있는 컨테이너도 조회됨.
docker commit [컨테이너ID] my-ubuntu:1.0 # {name}:{version}
docker는 exit를 입력하면 종료됨. 삭제 되는게 아닌 컨테이너가 종료됨. run: 만들면서 실행
start: 종료된 컨테이너 실행
$ docker start -i {name} # 이름으로
$ docker start -i {container_id} #id로
처음 run할 때 --name 지정 안하면 랜덤으로 지정됨 그래서 바꿔야함docker rename {old} {new}
docker rm {docker_container_name}
docker exec -it {컨테이너_이름} bash -c "{command}"
# docker exec -it {컨테이너_이름} bash -c "cd /workspace &amp;&amp; ./build.sh -c -g Ninja" 도커 컨테이너 종료: exit
도커 컨테이너 유지 &amp; 터미널 세션은 종료: Ctrl + P + Ctrl + Q
터미널 세션 다시 실행: docker exec -it {container_name} bash
]]></description><link>docker/1.-basic.html</link><guid isPermaLink="false">docker/1. basic.md</guid><pubDate>Sun, 02 Mar 2025 16:00:13 GMT</pubDate></item><item><title><![CDATA[2. 도커 컨테이너 환경 구축]]></title><description><![CDATA[C++ 크로스 플랫폼 프로젝트를 컴파일 하기 위한 구축
os: ubuntu 22.04 LTS
language: Clang++
build generator: cmake
DockerFile을 작성해서 이미지 설정을 한다.#base 22.04 LTS
FROM ubuntu:22.04 # package install RUN apt-get update &amp;&amp; apt-get install -y \ build-essential \ clang \ clang-format \ clang-tidy \ cmake \ curl \ git \ lldb \ ninja-build \ pkg-config \ tar \ unzip \ wget \ libssl-dev \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* # apt-get clean, rm -rf /var/lib/apt/lists/* 를 하면 패키지 파일을 설치 과정에서 다운로드된 `.deb` 패키지 파일을 제거 # 작업 디렉토리 설정 == mkdir workspace &amp;&amp; cd /workspace랑 같음
WORKDIR /workspace # 환경 변수 설정
ENV CC=clang
ENV CXX=clang++ # Host 프로젝트 소스코드가 이 경로에 들어갈 거임. shared 폴더로 지정한다는것
# docker run할 때 외부 폴더 (호스트의 소스코드 디렉토리)랑 연결할 수 있음
VOLUME ["/workspace"] # 기본 실행 명령어 설정
CMD ["/bin/bash"]
Dockerfile을 이용해서 이미지를 빌드한다.$ docker build -t {도커이미지_이름} {도커파일 경로} # t는 tag의 약자임.
# cd {docker file path}
# docker build -t my-docker .
빌드된 도커이미지로 도커 컨테이너 생성docker run -it --name {container_name} -v {host_path}:/workspace {image_name} #docker run -it --name maxflight-container -v ~/Labs/MaxFlight:/workspace maxflight-dev -it: 대화형 터미널 사용
--name maxflight-container: 컨테이너에 이름 부여 안할시에 랜덤 지정됨
-v ~/Labs/MaxFlight:/workspace: 공유 폴더 연결 호스트의 프로젝트 디렉토리를 컨테이너의 /workspace에 마운트함. 호스트랑 폴더 sync 됨 maxflight-dev: 빌드한 도커 이미지 이름
]]></description><link>docker/2.-도커-컨테이너-환경-구축.html</link><guid isPermaLink="false">docker/2. 도커 컨테이너 환경 구축.md</guid><pubDate>Sun, 02 Mar 2025 16:00:13 GMT</pubDate></item><item><title><![CDATA[setup]]></title><description><![CDATA[vscode를 이용해서 설치
플러터 익스텐션 설치
command + shift + p
flutter 검색
Flutter: New Project 선택
Download SDK 선택 후 위치는 ~/Develop으로 지정
$ flutter doctor -v
찾을 수 없는 명령어면 환경변수에 지정$ echo 'export PATH=$PATH:~/Develop/flutter/bin' &gt;&gt; ~/.zshrc
그런 다음에 flutter doctor -v를 하면 플러터 개발시 필요한 도구들을 알려줌.그에 맞게 업데이트 하거나 설치를 하면 됨.나 같은 경우는 CocoaPods의 버전을 업데이트 (1.12.1 -&gt; 1.16.2)로 해줘야하고, 안드로이드 툴체인을 설치 해야한다.나는 예전에 cocoapods을 설치했을 때 homebrew를 이용해서 설치했기 때문에 homebrew를 통해서 업그레이드 했다.$ brew upgrade cocoapods
안드로이드 툴체인은 안드로이드 스튜디오를 다운로드 하고 아래 구성요소를 설치하면 됨
Android SDK Platform, API 35.0.2
Android SDK Command-line Tools
Android SDK Build-Tools
Android SDK Platform-Tools
Android Emulator
]]></description><link>flutter/setup.html</link><guid isPermaLink="false">flutter/setup.md</guid><pubDate>Sat, 22 Feb 2025 12:24:31 GMT</pubDate></item><item><title><![CDATA[1. 명시적 템플릿 인스터스화]]></title><description><![CDATA[템플릿은 lazy instantiation 방식을 사용한다. 즉 실제로 사용되는 시점에 컴파일러가 해당 타입에 대한 코드를 생성함.// header.hpp
template&lt;typename T&gt;
class Container {
public: void add(T value); T get() const;
private: T data_;
}; // source.cpp
template&lt;typename T&gt;
void Container&lt;T&gt;::add(T value) { data_ = value;
} template&lt;typename T&gt;
T Container&lt;T&gt;::get() const { return data_;
}
일반적인 템플릿 사용시에는 다음과 같은 과정이 발생함 각각의 소스 파일에서 템플릿이 사용될 때마다 컴파일러는 해당 타입에 대한 코드를 생성함 이로 인해 여러 소스 파일에서 동일한 템플릿 인스턴스가 중복 생성될 수 있습니다. Q.여러소스 파일이라는게 이 파일마다 동일한 템플릿 인스턴스가 중복 생성될 수 있다는 뜻일까? 여러 소스 파일에서 동일한 템플릿 인스턴스가 중복 생성"된다는 것은 정확히 각각의 cpp 파일마다 동일한 템플릿 코드가 생성된다는 의미
컴파일 시점에서는 A.cpp와 B.cpp가 각각 독립적으로 컴파일되기 때문에, 각 파일에서 Container&lt;int&gt;에 대한 코드가 따로 생성됩니다. 즉, set()과 get() 함수의 코드가 두 번 생성되는 것 링커가 중복된 인스턴스들 중 하나를 선택하여 최종 실행 파일에 포함시킵니다. Q. 만약 A.cpp에서 Container&lt;int&gt;, Container&lt;double&gt; 사용하고 B.cpp에서 Container&lt;int&gt;, Container&lt;double&gt; 을 똑같이 사용함. 그렇게 어떻게 될까? 링커가 중복된 인스턴스들 중 하나를 선택한다는건 하나의 cpp object 파일에서 그 인스턴스를 지운다는걸까? // A.obj 파일에 생성되는 것:
- Container&lt;int&gt;::set()
- Container&lt;int&gt;::get()
- Container&lt;double&gt;::set()
- Container&lt;double&gt;::get() // B.obj 파일에 생성되는 것:
- Container&lt;int&gt;::set()
- Container&lt;int&gt;::get()
- Container&lt;double&gt;::set()
- Container&lt;double&gt;::get()
링킹 단계:
- 링커는 COMDAT(COMmon DATA) 섹션이라는 특별한 메커니즘을 사용함
- 각 템플릿 인스턴스는 COMDAT 섹션에 들어감.
- 링커는 동일한 COMDAT 섹션을 발견하면, 그 중 하나만 최종 실행 파일에 포함시킴
- 나머지는 자동으로 무시중요한 점은, 링커가 obj 파일에서 인스턴스를 지우는 것이 아닌 최종 실행 파일을 만들 때 중복된 코드 중 하나만 선택한다는 것입니다. obj 파일들은 그대로 유지됨.명시적 템플릿 인스턴스화가 제공하는 이점template class Container&lt;int&gt;; // 명시적 인스턴스화 컴파일 시간 단축 이렇게 선언하면 컴파일러는 해당 타입에 대한 모든 멤버 함수의 코드를 이 시점에 생성한다. 다른 translation unit에서는 이미 생성된 코드를 재사용할 수 있어 전체 컴파일 시간이 단축된다. 코드 크기 최적화 여러 translation unit에서 동일한 템플릿 코드가 중복 생성되는 것을 방지할 수 있다. 특히 크기가 큰 템플릿 클래스의 경우 실행 파일 크기를 상당히 줄일 수 있다. 컴파일 오류 조기 발견 // 컴파일 시점에 오류 발견 가능
template class Container&lt;incomplete_type&gt;; // 컴파일 오류 발생 헤더에서 명시적 인스턴스화하는 경우template class MyTemplate&lt;int&gt;; // 여기서 코드 생성 장점: 간단하고 직관적
단점: 헤더 변경시 이를 포함하는 모든 파일 재컴파일 필요
extern + cpp에서 명시적 인스턴스화// mytemplate.hpp
extern template class MyTemplate&lt;int&gt;; // extern -&gt; 구현 안찾음
// mytemplate.cpp
template class MyTemplate&lt;int&gt;; // 컴파일러는 이곳에서 찾음 장점: 구현 변경시 cpp 파일만 재컴파일
단점: 파일을 분리해야 하는 약간의 수고가 필요
즉 extern은 기능적인 차이를 만들지는 않지만, 컴파일 성능 최적화를 위한 도구다.결론: 명시적 템플릿 인스턴스화를 사용하려면 헤더에 구현까지 하던가, 구현을 분리하려면 extern 키워드를 써라.참고: 템플릿 특수화와 명시적 템플릿 인스턴스화는 같이 사용할 수 없다.]]></description><link>cpp/template/1.-명시적-템플릿-인스터스화.html</link><guid isPermaLink="false">CPP/Template/1. 명시적 템플릿 인스터스화.md</guid><pubDate>Sat, 22 Feb 2025 11:40:18 GMT</pubDate></item><item><title><![CDATA[Bresenham 알고리즘]]></title><description><![CDATA[Bresenham 알고리즘은 컴퓨터 그래픽스에서 직선을 그리는 알고리즘
정수 연산만 사용 (부동소수점 연산 없음)
증분 오차를 사용하여 빠른 계산
래스터 디스플레이에 최적화
]]></description><link>cs/bresenham-알고리즘.html</link><guid isPermaLink="false">CS/Bresenham 알고리즘.md</guid><pubDate>Fri, 21 Feb 2025 09:19:11 GMT</pubDate></item><item><title><![CDATA[Linux 명령어]]></title><description><![CDATA[sudo chmod o+x # 쓰기 권한 cd sudo chmod o+r # 읽기 권한 ls
$ gg # 첫번째 줄로 이동
$ dG # 현재부터 끝까지 지움
$ dd #한줄삭제
$ 5dd #현재위치부터 5줄 삭제 v 눌러서 visual mode 진입
주석할 라인 선택
norm i# (normal mode에서 i -&gt; edit 모드 -&gt; # 삽입) 입력 v 눌러서 visual mode 진입
주석 해제할 라인 선택
norm 1x (맨 앞에서 한글자 지우기) 입력
$ tail -n {몇라인 볼 지 = 수} {log_path}
$ ps -ef f | grep p4d
$ ps aux | grep p4d ps -ef: 전체 형식(FULL format)으로 표시, 프로세스 간의 부모-자식 관계를 트리 구조(f 옵션)로 보여줌
ps aux: BSD 스타일 출력, CPU/메모리 사용량 등 더 자세한 리소스 정보 표시 kill -1 (SIGHUP): 프로세스 재시작
kill -2 (SIGINT): Ctrl+C와 동일, 정상 종료 요청
kill -9 (SIGKILL): 강제 종료, 즉시 종료
kill -15 (SIGTERM): 기본값, 정상 종료 요청
kill -18 (SIGCONT): 중지된 프로세스 재개
kill -19 (SIGSTOP): 프로세스 일시 중지
kill -20 (SIGTSTP): Ctrl+Z와 동일, 일시 중지
권장 사용 순서:
4. kill -15 (SIGTERM) 시도
5. kill -2 (SIGINT) 시도
6. 마지막 수단으로 kill -9 (SIGKILL) 사용 sed 's/^... test'//' 시작부터 ... test" 문자열을 찾음 -&gt; 빈문자열로 치환(//)
^ = 라인의 시작 sed "s|$|@$changelist_number|" s|pattern|replacement|: 여기서는 구분자로&nbsp;/&nbsp;대신&nbsp;|&nbsp;사용 (경로에&nbsp;/가 있어서)
$: 라인의 끝을 의미
@$changelist_number: 라인 끝에 "@"와 changelist 번호를 추가 sed 's/.$//' .: 아무 문자 하나를 의미
$: 문자열의 끝을 의미
따라서&nbsp;.$는 문자열의 마지막 문자 하나를 의미
s/pattern//: pattern과 매칭되는 부분을 빈 문자열로 치환 (= 삭제) sed 's/..$//' 맨 마지막 문자 2개를 삭제 터미널과 출력과 파일에 입력을 동시에 할 수 있는 명령어.$ echo test | tee tee-test-file.txt
test
$ cat tee-test-file.txt
test
]]></description><link>tip/linux-명령어.html</link><guid isPermaLink="false">Tip/Linux 명령어.md</guid><pubDate>Fri, 14 Feb 2025 13:24:19 GMT</pubDate></item><item><title><![CDATA[Tip]]></title><description><![CDATA[UnrealPak.exe {추출할 pak 파일 경로} -Extract {추출 되는 경로}
현재 디렉토리와 하위 디렉토리들에서 읽기 전용이 아닌 파일을 찾는 방법Get-ChildItem -Recurse | Where-Object { !$_.PSIsContainer -and !$_.Attributes.HasFlag([System.IO.FileAttributes]::ReadOnly) } | Select-Object FullName
]]></description><link>tip/tip.html</link><guid isPermaLink="false">Tip/Tip.md</guid><pubDate>Fri, 14 Feb 2025 13:24:19 GMT</pubDate></item><item><title><![CDATA[Wifi Util Class]]></title><description><![CDATA[
Android 10부터 도입된 WifiNetworkSpecifier를 이용한 Wifi는 보통 Ephemeral임.
안드로이드 OS는 네트워크로 인터넷이 안될 것 같다고 판단하면 우선순위 낮춤 -&gt; 이 네트워크를 기본 라우트로 삼지 않게 됨 기본 라우트가 아니면 OS는 패킷을 LTE나 기존 Wi-fi 쪽으로 보내려고 시도
즉 에페메럴 Wifi로는 도달 불가능 -&gt; TCP 연결 실패
bindProcessToNetwork(network)를 통해서 앱 전체 프로세스가 내보내는 트래픽은 네트워크로 보내도록 설정 -&gt; TCP 연결 성공소켓 단위 바인딩 (bindSocket)을 이용하면 다른 통신은 기존 네트워크를 그대로 쓰면서, 특정 소켓은에페메럴 Wi-fi를 이용할 수 있음]]></description><link>android/wifi-util-class.html</link><guid isPermaLink="false">Android/Wifi Util Class.md</guid><pubDate>Tue, 11 Feb 2025 13:41:33 GMT</pubDate></item><item><title><![CDATA[Scalable Application 설계부터 구현까지 - (1) Tuist]]></title><description><![CDATA[확장 가능한 어플리케이션은 모듈을 빠르게 붙이고 뗄 수 있어야 합니다. 이것을 용이하게 해주는 것이 바로 Xcode Project 관리 도구인 Tuist입니다.
Tuist is a command line tool (CLI) that aims to facilitate the generation, maintenance, and interaction with Xcode projects. It's distributed as a binary, which you can easily install and use without having to depend on other tools to manage dependencies (like you would do if the tool was written in other programming languages such as Ruby, or Java) Tuist는 Xcode 프로젝트의 생성, 유지보수 및 상호 작용을 용이하게 하는 것을 목표로 하는 CLI(명령줄 도구)입니다. 종속성을 관리하기 위해 다른 도구에 의존하지 않고 쉽게 설치하고 사용할 수 있는 이진 파일로 배포됩니다(Ruby 또는 Java와 같은 다른 프로그래밍 언어로 작성된 경우처럼).
.
설치 방법과 간단한 사용 방법은 Tuist 공식 홈페이지를 참고해 주세요.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://tuist.io/" target="_self">https://tuist.io/</a>Tuist is a tool that helps developers manage large Xcode projects by leveraging project generation. Moreover, it provides some tools to automate most common tasks, allowing developers to focus on building apps.<br>tuist.io](<a rel="noopener nofollow" class="external-link is-unresolved" href="https://tuist.io/" target="_self">https://tuist.io/</a>)&nbsp;Tuist는 Xcode 프로젝트를 빠르게 구성하는 걸 도와주는 아주 유용한 툴입니다. 높은 러닝 커브라는 단점이 존재하지만 그것을 무색하게 할 만큼 많은 장점들이 있습니다. 제가 직접 체감한 건 다음과 같아요.
Git Conflict이 적습니다. iOS 개발할 때 .xcodeproj에서 생각보다 많이 충돌이 일어나는데 Tuist를 사용하면 이를 현저히 줄여줍니다. 정신 건강에 좋아요. 모듈화를 하는데 용이합니다.(Xcode Project에서 SPM을 추가해서 모듈화를 해본 적이 있는데 확실히 Tuist를 이용해서 Project 단위로 모듈화를 하는 게 더 간단한 것 같아요.) Swift로 프로젝트 설정이 가능합니다. 비슷한 툴인 XcodeGen은 yaml로 파일을 작성한다고 합니다. yaml을 당연히 학습해야겠죠? 구조를 확장할 때 용이합니다. 어플리케이션이 커질수록 설정들도 많아지긴 마련인데 이를 플러그인을 이용해서 가독성 있게 프로젝트를 관리할 수 있습니다. 모듈 간의 관계를 나타내는 그래프 기능 덕분에 구조 파악이 용이합니다.
그리고 시간을 들여 Tuist Template를 만들어 놓으면 다음부터 빠르게 어플리케이션 개발을 세팅된 상태에서 할 수 있습니다.아래 명령어를 이용해서, Tuist를 설치합니다.&nbsp;curl -Ls https://install.tuist.io | bash
프로젝트를 생성할 폴더를 생성하고 그 폴더로 이동해서 tuist project를 시작합니다.mkdir tuist-template-for-scalable-app
cd tuist-template-for-scalable-app
tuist init --platform ios
tree 명령어를 이용하면 아래와 같이 폴더 및 파일들이 생성된 걸 알 수가 있어요.&nbsp;tree .
├── Plugins
│&nbsp;&nbsp; └── TuistTemplateForScalableApp
│&nbsp;&nbsp; ├── Package.swift
│&nbsp;&nbsp; ├── Plugin.swift
│&nbsp;&nbsp; ├── ProjectDescriptionHelpers
│&nbsp;&nbsp; │&nbsp;&nbsp; └── LocalHelper.swift
│&nbsp;&nbsp; └── Sources
│&nbsp;&nbsp; └── tuist-my-cli
│&nbsp;&nbsp; └── main.swift
├── Project.swift
├── Targets
│&nbsp;&nbsp; ├── TuistTemplateForScalableApp
│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Resources
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── LaunchScreen.storyboard
│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Sources
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── AppDelegate.swift
│&nbsp;&nbsp; │&nbsp;&nbsp; └── Tests
│&nbsp;&nbsp; │&nbsp;&nbsp; └── AppTests.swift
│&nbsp;&nbsp; ├── TuistTemplateForScalableAppKit
│&nbsp;&nbsp; │&nbsp;&nbsp; ├── Sources
│&nbsp;&nbsp; │&nbsp;&nbsp; │&nbsp;&nbsp; └── TuistTemplateForScalableAppKit.swift
│&nbsp;&nbsp; │&nbsp;&nbsp; └── Tests
│&nbsp;&nbsp; │&nbsp;&nbsp; └── TuistTemplateForScalableAppKitTests.swift
│&nbsp;&nbsp; └── TuistTemplateForScalableAppUI
│&nbsp;&nbsp; ├── Sources
│&nbsp;&nbsp; │&nbsp;&nbsp; └── TuistTemplateForScalableAppUI.swift
│&nbsp;&nbsp; └── Tests
│&nbsp;&nbsp; └── TuistTemplateForScalableAppUITests.swift
└── Tuist ├── Config.swift └── ProjectDescriptionHelpers └── Project+Templates.swift
tuist edit
이 디렉토리에서 tuist edit을 입력하면, Xcode 창이 뜨는데요. 이곳에서 우리가 개발할 어플리케이션에 대한 설정을 하는 겁니다. 기능들과 모듈들에 대한 것들은 Manifests Project에서 작성할 것입니다. 이것을 작성하기 전에 기능, 모듈들을 구성하기 쉽게 해주는 Plugins부터 작성하도록 하겠습니다.플러그인을 이용하면 가독성 있게 쉽게 프로젝트를 관리할 수 있습니다. Plugins를 끝까지 열면 ProjectDescription 폴더가 있는데 이곳에&nbsp;swift file을 생성하고 코드를 작성합니다.여기에서 작성한 코드들을 실제 모듈을 생성하는 코드를 작성할 때 사용하게 됩니다. 이 코드가 유용한 모듈을 생성하는 함수가 String을 parameter로 많이 필요로 합니다. 이게 모듈이 증가하게 되면 관리하기가 불편해져서, extension을 추가해서 사용하면 아주 편해집니다.한번 맛보기로 비교를 해볼까요. 왼쪽이 플러그인 사용 전이고, 오른쪽이 후입니다. 사실 왼쪽에 있는 코드도 extension을 이용해서 많이 줄인 것임에도 불구하고 오른쪽에 비하면 예쁘지 않네요. String을 그대로 넣다 보니까 재사용하기도 불편해 보이기도 하고요.<br><img src="https://blog.kakaocdn.net/dn/DBaUZ/btr7gSU98iI/dM9KZsQN5ZAAnhkZXErBSK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/An4BP/btr7e1STAEj/ZsPgiwRdJKdXagRryfzwY1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">플러그인 사용 전(왼), 플러그인 사용 후(오)그러면 플러그인에 어떤 코드를 작성해야 할까요? 많은 Sugar 코드가 있지만 TargetDependency에 관한 extension이 가장 중요하다고 생각합니다. 그도 그럴 것이 Tuist를 이용해서 App을 만든다는 것은 보통 모듈화를 염두에 두었다는 것이고 이는 필연적으로 의존성을 잘 핸들링해야 한다는 것을 의미하게 됩니다.첫 번째로 할 것은 이름이 너무 긴 TargetDependency를 typealias 걸어서 Dep으로 하겠습니다. 그러면 앞으로 우리는 TargetDependency라는 것 대신에 Dep이라는 이름으로 사용할 수 있게 되겠죠? 그다음으로는 Dep에 대한 Path 설정을 자동 완성으로 쉽게 접근하고 싶기 때문에 Path + Extension을 만들도록 하겠습니다.// Alias.swift import Foundation
import ProjectDescription public typealias Dep = TargetDependency import Foundation
import ProjectDescription // Path + Extension.swift public extension ProjectDescription.Path { static func relativeToModule(_ pathString: String) -&gt; Self { return .relativeToRoot("Projects/Modules/\(pathString)") } static func relativeToFeature(_ pathString: String) -&gt; Self { return .relativeToRoot("Projects/Features/\(pathString)") } static func relativeToApplication(_ pathString: String) -&gt; Self { return .relativeToRoot("Projects/Application/\(pathString)") } static var app: Self { return .relativeToRoot("Projects/Application") }
}
그리고 Dep(TargetDependency)는 Project가 될 수도 있고, xcframework가 될 수도 있고, target이 될 수도 있고 등등이 될 수 있습니다. 위에서 언급했듯이, Project로 구성할 것이기 때문에 이와 관련된 코드도 작성하도록 하겠습니다.// Dep + Extension.swift extension Dep { static func module(name: String) -&gt; Self { return .project(target: name, path: .relativeToModule(name)) } static func feature(name: String) -&gt; Self { return .project(target: name, path: .relativeToFeature(name)) }
}
다음으로는 Application이 의존성을 가질 Feature들에 대한 것을 확장을 할거예요. Feature들도 당연히 Dep(TargetDependency)입니다. 위 왼쪽 사진에서 보면 .project(~~~) 이런식으로 들어가는데, 오른쪽은 깔끔하게 . 을 이용해 깔끔하게 접근할 수 있는 걸 볼 수 있어요.&nbsp;// Dep + Project.swift import Foundation
import ProjectDescription extension Dep { public struct Project { public struct Feature { } public struct Module { } }
} public extension Dep.Project.Feature { static let Main = Dep.feature(name: "Main") } public extension Dep.Project.Module { static let Util = Dep.module(name: "Util") static let ThirdPartyWrapper = Dep.module(name: "ThirdPartyWrapper") static let Networkit = Dep.module(name: "NetworkKit") static let Design = Dep.module(name: "Design")
}
마지막으로 외부의존성에 관한 확장 코드를 작성할 거에요. Tuist에서 공식적으로 지원하는 외부 의존성은 크게 네 가지예요.
Carthage
Xcode Swift Package Manager (Package)
Tuist Swift Package Manager (External)
Framework
SPM이 두 개라서 조금 이상한 것 같기도 합니다.Carthage와&nbsp;Tuist&nbsp;Swift Package Manager는 Dependencies.swift에서 작성하면 Tuist가 이를 처리해서 프레임워크로 만들어서 사용합니다.&nbsp;Xcode&nbsp;Swift Package Manager는 Project에 Package가 바로 들어갑니다. (우리가 평소 사용하는 SPM을 떠올리시면 될 것 같아요.) Tuist SPM을 사용하고 external을 하면 그래프에 안 그려지는 이슈가 있어서 저는 package를 이용하도록 하겠습니다. Carthage나 local xcframework를 사용하는 경우에도 같은 방식으로 확장해 주시면 되겠습니다.// Dep+SPM.swift import Foundation
import ProjectDescription extension Dep { public struct SwiftPM { }
} public extension Dep.SwiftPM { static let Alamofire = Dep.package(product: "Alamofire")
} public extension Package { static let Alamofire = Package.package(url: "https://github.com/Alamofire/Alamofire.git", from: "5.6.4")
}
여기까지가 유용한 기본적인 플러그인입니다. 이제 모듈을 생성하는 코드를 작성해 보도록 합시다.&nbsp;기억이 정확한 건 아닌데, 객체지향프로그래밍 수업을 들을 때 교수님께서 manifest를 언급하셨던 것 같습니다. A를 맞기 위해 6~7년 전 자바를 열심히 했던 기억이 있네요.&nbsp; 매니페스트는 무엇일까요?
매니페스트 파일(manifest file)은&nbsp;
컴퓨팅에서 집합의 일부 또는 논리 정연한 단위인 파일들의 그룹을 위한 메타데이터를 포함하는 파일
이다. 예를 들어, 컴퓨터 프로그램의 파일들은 이름, 버전 번호, 라이선스, 프로그램의 구성 파일들을 가질 수 있다. - 위키백과 Manifests에 파일을 생성하는 것은 모듈에 관한 메타데이터를 작성하는 것입니다. tuist generate를 통해서 실제로 생성하는 것이고요.그러면 Manifest file을 작성합시다.&nbsp;Tuist에서 manifest file은 무조건 Project.swift라는 이름으로 생성해야 해요. 그래서 모듈을 하나 추가한다고 하면 폴더를 하나 만들고 그 안에 Project.swift를 만들면 되는 것입니다.&nbsp;그전에 file을 하나 추가하도록 할게요. 위치는 Mainfests Project 안에 있는 Tuist/ProjectDescriptionHelper에 생성하면 됩니다. 이 파일은 Project에 기본값을 추가해서 반복적인 코드를 좀 줄여줄 수 있어요. 쭉 읽어보면 어떤 내용인 지 감 잡으실 수 있을 것 같아요.// Project+Templates.swift import ProjectDescription
import MyPlugin public extension Project { static func project(name: String, organizationName: String = "YourOrganizationName", options: Options = .options(), packages: [Package] = [], product: Product, platform: Platform = .iOS, deploymentTarget: DeploymentTarget? = .iOS(targetVersion: "15.0", devices: .iphone), dependencies: [Dep] = [], infoPlist: [String: InfoPlist.Value] = [:], sources: SourceFilesList = ["Sources/**"], resources: ResourceFileElements = ["Resources/**"], scriptAction: [TargetScript] = [], resourceSynthesizers: [ResourceSynthesizer] = []) -&gt; Project { let settings: Settings = Settings.settings() let bundleID = product == .app ? "com.YourAppName" : "com.\(organizationName).\(name)" let isEnableResource = (product == .app || product == .framework) let target = Target(name: name, platform: platform, product: product, bundleId: bundleID, deploymentTarget: deploymentTarget, infoPlist: .extendingDefault(with: infoPlist), sources: sources, resources: isEnableResource ? resources : [], scripts: scriptAction, dependencies: dependencies) let testTargetDependencies: [Dep] = [.target(name: "\(name)")] let testTarget = Target(name: "\(name)Tests", platform: platform, product: .unitTests, bundleId: "\(bundleID)Tests", deploymentTarget: deploymentTarget, infoPlist: .default, sources: "\(name)Tests/**", dependencies: testTargetDependencies) let targets: [Target] = [target, testTarget] return Project(name: name, organizationName: organizationName, options: options, packages: packages, settings: settings, targets: targets, resourceSynthesizers: resourceSynthesizers) }
}
이제 본격적으로 진짜로 Manifest file(Project.swift)를 작성해 봐요. Manifest 폴더 아래에 Projects라는 폴더를 생성할게요. 이곳에 모듈에 관한 Project.swift 들을 만들어줄 거예요. 그리고 Projects 폴더 안에 Application 폴더를 만들고 그 하위에 Project.swift 파일을 만들겠습니다. 다음처럼 되겠습니다.<br><img src="https://blog.kakaocdn.net/dn/Jq0wH/btr7gy3Kjpl/7LRPMwWPXYkhAY7NAzjnak/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// Project.swift (Application 폴더) import Foundation
import ProjectDescription
import ProjectDescriptionHelpers
import MyPlugin let project = Project.project( name: "Application", product: .app, dependencies: [ Dep.Project.Feature.Main ]
)
이렇게 하면 모듈 하나의 메타데이터를 작성한 것이고 tuist generate를 하게 되면 모듈 하나를 생성할 수 있게 됩니다. 여기까지 오는데 플러그인도 만들고 힘들었지만 그 대가로 앞으로 엄청 편하게 모듈을 확장할 수 있게 되었어요.&nbsp; 같은 방식으로 Main 기능 모듈을 만들겠습니다.// Project.swift (Projects/Features/Main 안에) import Foundation
import ProjectDescription
import ProjectDescriptionHelpers
import MyPlugin let project = Project.project( name: "Main", product: .framework, dependencies: [ ]
)
이번에는 product가 .framework 입니다. 이것은 개발에 따라 달라지는 거라 적절히 선택해 주시면 되겠습니다. 그러면 Project.swift 파일에 메타데이터들을 다 입력했으니 generate를 하면 되겠네요. 그전에. xcodeproj를 한 번에 관리하고 싶으니 xcworkspace부터 만들어주도록 하겠습니다. tuist edit을 해서 Manifests 폴더 아래에 Projects, Tuist 폴더와 같은 레벨로 Workspace.swift를 생성해 주시면 됩니다.import Foundation
import ProjectDescription let workspace = Workspace( name: "Application", projects: [ "Projects/Application" ], generationOptions: .options( enableAutomaticXcodeSchemes: false, autogeneratedWorkspaceSchemes: .disabled, lastXcodeUpgradeCheck: nil, renderMarkdownReadme: false )
)
그러고 나서 이제 어플리케이션을 생성해 보도록 할게요. 'tuist generate'를 입력하면The target Application has the following invalid source files globs:
- The directory "/tuist-template-for-scalable-app/Projects/Application/Sources" defined in the glob pattern "/tuist-template-for-scalable-app/Projects/Application/Sources/**" does not exist.
Consider creating an issue using the following link: https://github.com/tuist/tuist/issues/new/choose
이런 에러가 발생할 거예요. 왜냐하면 모듈을 생성할 때, 소스 파일들이 필요하고 그것들의 위치를 정했는데 해당 Path에 소스파일들이 없어서입니다. 해당 Path로 가서 파일들을 붙여 넣기 하면 해결되는 문제입니다. 다만 모듈이 엄청 많다고 가정하면 일일이 붙여넣기 하는 게 귀찮을 수가 있어요. 그래서 tuist가 제공하는 scaffold 기능을 이용하면 됩니다. scaffold 기능을 이용하면 템플릿을 만들어놓고 터미널 명령어로 인자를 받아서 해당 path에 원하는 파일들을 생성할 수가 있습니다.먼저 템플릿부터 만들어야 합니다. Tuist 폴더 아래에 Templates 폴더를 만들고 그 아래에 어떤 단어로 명령어를 만들지 정해서 .swift 파일을 만들면 되겠습니다. 저는 dummy라는 명령어로 만들겠습니다. tuist scaffold dummy -name// Templates/dummy/dummy.swift
import ProjectDescription let nameAttribute: Template.Attribute = .required("name") let template = Template( description: "Custom template", attributes: [ nameAttribute ], items: [ .file( path: "Projects/Features/\(nameAttribute)/Sources/dummy.swift", templatePath: "dummy.stencil" ), .file( path: "Projects/Features/\(nameAttribute)/Resources/dummy.swift", templatePath: "dummy.stencil" ), .file( path: "Projects/Features/\(nameAttribute)/\(nameAttribute)Tests/\(nameAttribute)Tests.swift", templatePath: "Tests.stencil" ), ]
)
Attribute는 인자값 설정입니다. required는 필수로 입력해줘야 하고, optional은 말 그대로 해도 되고 안 해도 되는데, 여기에서는 required로 하나만 사용하겠습니다. items에 생성할 file들의 path, 어떤 template를 사용할지 해당 stencil file의 Path를 작성합니다.&nbsp; {{ name }}이 아까 인자로 받은 그 값을 여기에 넣어주겠다는 것을 의미해요. 단! stencil file에 어떤 것이라도 입력해야 scaffold 할 때 생성되는 것 같아요.&nbsp; import XCTest final class {{ name }}Tests: XCTestCase { override func setUpWithError() throws { // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDownWithError() throws { // Put teardown code here. This method is called after the invocation of each test method in the class. } func testExample() throws { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. // Any test you write for XCTest can be annotated as throws and async. // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error. // Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards. } func testPerformanceExample() throws { // This is an example of a performance test case. self.measure { // Put the code you want to measure the time of here. } } }
이제 scaffold를 위한 작업을 끝마쳤으니 파일들을 생성해 보도록 할게요.tuist scaffold dummy -name Main
<br><img src="https://blog.kakaocdn.net/dn/370tB/btr7hyCUiWz/H8kgsejIf3Ztky0jNTMkzk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">다음과 같이 잘 생성되었어요. Application도 비슷한 방식으로 만들어주겠습니다. 이번에는 인자를 넣지 않았어요.// Template/app/app.swift import ProjectDescription let template = Template( description: "Custom template", attributes: [ ], items: [ .file( path: "Projects/Application/Sources/AppDelegate.swift", templatePath: "AppDelegate.stencil" ), .file( path: "Projects/Application/Resources/dummy.swift", templatePath: "../dummy/dummy.stencil" ), .file( path: "Projects/Application/ApplicationTests/ApplicationTests.swift", templatePath: "AppDelegateTest.stencil" ), ]
)
// Template/app/AppDelegate.stencil import UIKIt
@main
class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil ) -&gt; Bool { let vc = UIViewController() let window = UIWindow(frame: UIScreen.main.bounds) window.rootViewController = vc window.makeKeyAndVisible() self.window = window return true }
} // Template/app/AppDelegateTests.stencil import XCTest final class AppDelegateTests: XCTestCase { override func setUpWithError() throws { // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDownWithError() throws { // Put teardown code here. This method is called after the invocation of each test method in the class. } func testExample() throws { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. // Any test you write for XCTest can be annotated as throws and async. // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error. // Mark your test async to allow awaiting for asynchronous code to complete. Check the results with assertions afterwards. } func testPerformanceExample() throws { // This is an example of a performance test case. self.measure { // Put the code you want to measure the time of here. } } }
$ tuist scaffold app
<br><img src="https://blog.kakaocdn.net/dn/xfbnE/btr7C2JhRaS/eqQZlpsYTkp8W7WclmKlXk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">잘 생성되었네요. 이제 정말로 프로젝트들을 생성할 수 있어요.$ tuist generate
<br><img src="https://blog.kakaocdn.net/dn/cFwBVJ/btr7s4OwCrR/cZy3vU0LGv5iZeYmMiab4K/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">프로젝트가 제대로 만들어졌고, 이제 이것을 바탕으로 Scalable Application을 설계하고 개발할 수 있게 되었습니다.정말 많은 것들을 했는데 한번 잘 만들어놓으면 다른 개발을 할 때 빠르게 시작할 수 있을 것 같습니다. 최대한 상세히 적다 보니 포스팅이 꽤 길어진 것 같아요. 저도 제 지식을 점검할 수 있어서 좋았고 scaffold 기능을 좀 더 잘 이용해 봐야겠다는 생각이 듭니다.&nbsp;<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/tuist-template-for-scalable-app" target="_self">https://github.com/psychehose/tuist-template-for-scalable-app</a>]]></description><link>ios/scalable-application-설계부터-구현까지-(1)-tuist.html</link><guid isPermaLink="false">iOS/Scalable Application 설계부터 구현까지 - (1) Tuist.md</guid><pubDate>Tue, 11 Feb 2025 12:49:47 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/DBaUZ/btr7gSU98iI/dM9KZsQN5ZAAnhkZXErBSK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/DBaUZ/btr7gSU98iI/dM9KZsQN5ZAAnhkZXErBSK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[C++ 프로젝트에서 JNI를 이용해서 Android 호출]]></title><description><![CDATA[C++ 기반의 프로젝트에서 안드로이드 함수를 사용 해야하는 경우가 있다. 안드로이드 게임을 타겟으로 하는 언리얼 엔진 프로젝트가 예시이다.어떻게 하면 C++ 프로젝트에서 안드로이드 개발자가 정의한 함수를 호출할 수 있을까? JNI를 이용하면 된다. JNI는 Java Native Interface의 준말로 안드로이드 앱(자바/코틀린)과 네이티브 코드(C/C++) 사이를 연결해주는 인터페이스다. C++ 기반 코드에서 JNIEnv*라는 환경 포인터를 이용하여, 자바 클래스를 찾고 메서드를 호출하거나, 자바 타입과 C++ 타입 간 데이터를 변환할 수 있다.C++ 코드베이스에서 JNI를 이용해서 Android 플랫폼 코드를 호출 하기 위해서 먼저 안드로이드 라이브러리를 빌드 해야한다. aar은 Android Archive package의 준말이다. 자바 코드만 포함할 수 있는jar과 다르게 aar은 안드로이드 리소스 파일(레이아웃 등)과 매니페스트 파일과 C++ Library를 포함하수 있다. 안드로이드 스튜디오를 이용해서 Java / Kotlin으로 로직을 작성한다. AGP 버전, gradle 버전, 안드로이드 필수 라이브러리 호환성 체크 gradle을 이용해서 안드로이드 라이브러리(aar) 빌드 $ ./gradlew --version # gradle 버전
$ ./gradlew :AndroidUtil:assembleRelease # build/output 폴더로 라이브러리 빌드
언리얼엔진과 안드로이드 라이브러리 파일(aar)을 통합하기 위해서는 JNI를 이용 해야 한다. 프로젝트에 바로 추가하는 것보다 플러그인에 추가하는 것이 낫다.
플러그인 모듈을 만들고 $(PluginDir)/../..Resource/Library/Android에 빌드한 aar을 넣는다.
PluginDir에 {Module_Name}_UPL.xml을 생성한다.
{Module_Name}_UPL.xml 작성 PrivateDependencyModuleNames.Add("Launch"); 필수 Launch 모듈에 언리얼 JNI 헬퍼 함수들이 구현되어 있음. // MyModule.Build.cs
using UnrealBuildTool;
using System.IO;
public class MyModule : ModuleRules
{ public MyModule(ReadOnlyTargetRules Target) : base(Target) { // ... // string PluginPath = Utils.MakePathRelativeTo(ModuleDirectory, Target.RelativeEnginePath) if (Target.Platform == UnrealTargetPlatform.Android) { // ... // PrivateDependencyModuleNames.Add("Launch"); AdditionalPropertiesForReceipt.Add("AndroidPlugin", Path.Combine(PluginPath), "MyModule_UPL.xml") } }
} UPL을 작성한다. 안드로이드 패키징을 할 때 aar 파일을 안드로이드 앱에 복사함
복사한 aar을 dependency로 설정함
GameActivity에 aar에 있는 package를 import 함
안드로이드 매니페스트 업데이트 (권한) &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- Copyright (c) 2024 Hose --&gt; &lt;root xmlns:android="[http://schemas.android.com/apk/res/android"&gt; &lt;init&gt; &lt;log text="Android UPL initialization" /&gt; &lt;/init&gt; &lt;prebuildCopies&gt; &lt;copyFile src="$S(PluginDir)/../../Resources/Library/Android/AndroidUtil-release.aar" dst="$S(BuildDir)/gradle/app/libs/AndroidUtil-release.aar" /&gt; &lt;log text="Copy Success" /&gt; &lt;/prebuildCopies&gt; &lt;!-- 프로젝트의 빌드 스크립트 자체를 구성하는 데 필요한 종속성을 정의 gradle version 지정
--&gt; &lt;buildscriptGradleAdditions&gt; &lt;insert&gt; dependencies { classpath 'com.android.tools.build:gradle:7.4.2' } &lt;/insert&gt; &lt;/buildscriptGradleAdditions&gt; &lt;!-- 앱의 종속성을 정의
--&gt; &lt;buildGradleAdditions&gt; &lt;insert&gt; dependencies { implementation files('libs/AndroidUtil-release.aar') } &lt;/insert&gt; &lt;/buildGradleAdditions&gt; &lt;!-- GameActivity에서 네이티브 메서드를 인식하도록 설정 --&gt; &lt;gameActivityImportAdditions&gt; &lt;insert&gt; import com.psychehose.androidutil.network.NativeNetworkManager; &lt;/insert&gt; &lt;/gameActivityImportAdditions&gt; &lt;gradleProperties&gt; &lt;insert&gt; android.useAndroidX=true android.enableJetifier=true &lt;/insert&gt; &lt;/gradleProperties&gt; &lt;proguardAdditions&gt; &lt;insert&gt; &lt;/insert&gt; &lt;/proguardAdditions&gt; &lt;androidManifestUpdate&gt; &lt;addPermission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;addPermission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;addPermission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;addPermission android:name="android.permission.CHANGE_NETWORK_STATE"/&gt; &lt;addPermission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;addPermission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;addPermission android:name="android.permission.NEARBY_WIFI_DEVICES" android:usesPermissionFlags="neverForLocation" android:minSdkVersion="33"/&gt; &lt;/androidManifestUpdate&gt; &lt;/root&gt; 라이브러리 내에 있는 AndroidManifest.xml에서 권한 처리를 한다면 &lt;androidManifestUpdate&gt;를 생략하면 된다.안드로이드는 자바 또는 코틀린으로 구현되어 있어서 JVM 위에서 구동된다. 그래서 C++ 코드베이스에서 Java 환경을 먼저 가져오고 함수를 호출 해야한다.
JNIEnv를 가져온다.
실행하고자 하는 Java Class를 찾는다.
Java Class에서 Java method를 찾는다.(jmethod에 캐싱)
Java Class를 통해서 instance를 생성한다. (jobject에 캐싱)
jobject와 jmethod를 이용해서 호출
아래 static 함수 signaturepublic static NativeNetworkManager getInstance(Context context) { if (instance == null) { synchronized (NativeNetworkManager.class) { if (instance == null) { instance = new NativeNetworkManager(context); } } } return instance;
}
private static native void nativeCallbackMessage(); // callback을 위한 public void helloMessage() { nativeCallbackMessage(); } UWifiManager::UWifiManager()
{
} UWifiManager::~UWifiManager()
{ JNIEnv* Env = FAndroidApplication::GetJavaEnv(); Env-&gt;DeleteGlobalRef(NativeNetworkManagerObject);
} void UWifiManager::Init()
{ JNIEnv* Env = FAndroidApplication::GetJavaEnv(); if (Env == nullptr) { UE_LOG(LogTemp, Log, TEXT("Env is nullptr")); return; } // class를 가져옴 (instance가 아님을 주의) NativeNetworkManagerClass = FAndroidApplication::FindJavaClass("com/psychehose/androidutil/network/NativeNetworkManager"); if (!NativeNetworkManagerClass) { UE_LOG(LogTemp, Error, TEXT("Failed to find the NativeNetworkManager class.")); return; } if (Env-&gt;ExceptionCheck()) { Env-&gt;ExceptionDescribe(); Env-&gt;ExceptionClear(); UE_LOG(LogTemp, Error, TEXT("Exception occurred after finding class")); return; } // 안드로이드의 화면 - Activity jobject Context = FAndroidApplication::GetGameActivityThis(); // Static Method를 찾고 변수에 캐싱함 jmethodID alternativeMethod = Env-&gt;GetStaticMethodID(NativeNetworkManagerClass, "getInstance", "(Landroid/content/Context;)Lcom/psychehose/androidutil/network/NativeNetworkManager;"); if (!alternativeMethod) { UE_LOG(LogTemp, Error, TEXT("Failed to find the alternativeMethod getInstance method.")); } if (Env-&gt;ExceptionCheck()) { Env-&gt;ExceptionDescribe(); Env-&gt;ExceptionClear(); UE_LOG(LogTemp, Error, TEXT("Exception occurred after finding method")); } jmethodID NativeNetworkManagerGetInstanceMethod = FJavaWrapper::FindStaticMethod(Env, NativeNetworkManagerClass, "getInstance", "(Landroid/content/Context;)Lcom/psychehose/androidutil/network/NativeNetworkManager;", true); if (Env-&gt;ExceptionCheck()) { Env-&gt;ExceptionDescribe(); Env-&gt;ExceptionClear(); UE_LOG(LogTemp, Error, TEXT("Exception occurred after finding method2")); } if (!NativeNetworkManagerGetInstanceMethod) { UE_LOG(LogTemp, Error, TEXT("Failed to find the getInstance method.")); } // Static Method Call (인스턴스 필요 없음) // static 함수의 리턴값은 NativeNetworkManager 인스턴스 이건 jobject에 캐싱함 NativeNetworkManagerObject = Env-&gt;CallStaticObjectMethod(NativeNetworkManagerClass, alternativeMethod, Context); if (!NativeNetworkManagerObject) { UE_LOG(LogTemp, Error, TEXT("Failed to get the NativeNetworkManager object.")); return; } // 클래스에서 찾은 함수들을 캐싱함 IsLocationPermissionGrantedMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, "isLocationPermissionGranted", "()Z", true ); if (!IsLocationPermissionGrantedMethod) { UE_LOG(LogTemp, Error, TEXT("Failed to find the isLocationPermissionGranted method.")); return; } GrantLocationPermissionMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, "grantLocationPermission", "()Z", true ); if (!GrantLocationPermissionMethod) { UE_LOG(LogTemp, Error, TEXT("Failed to find the grantLocationPermission method.")); return; } FetchCurrentNetworkInformationMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, "fetchCurrentNetworkInformation", "()V", true ); if (!FetchCurrentNetworkInformationMethod) { UE_LOG(LogTemp, Error, TEXT("Failed to find the fetchCurrentNetworkInformation method.")); return; } ConnectWifiMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, "connectWifi", "(Ljava/lang/String;Ljava/lang/String;Z)V", true ); if (!ConnectWifiMethod) { UE_LOG(LogTemp, Error, TEXT("Failed to find the connectWifi method.")); return; } HelloMessageMethod = FJavaWrapper::FindMethod( Env, NativeNetworkManagerClass, "helloMessage", "()V", true );
} void UWifiManager::HelloMessage()
{ JNIEnv* Env = FAndroidApplication::GetJavaEnv(); if (Env == nullptr) { UE_LOG(LogTemp, Log, TEXT("Env is nullptr")); return; } // 캐싱한 object와 method로 자바 함수 호출 Env-&gt;CallVoidMethod(NativeNetworkManagerObject, HelloMessageMethod);
} JNI_METHOD void Java_com_psychehose_androidutil_network_NativeNetworkManager_nativeCallbackMessage(JNIEnv* jenv, jobject thiz)
{ // Callback은 여기를 통해서 받을 수 있다. UE_LOG(LogTemp, Log, TEXT("Native Callback Message"));
} gradle/libs.versions.toml 파일 열어서 AGP 버전 변경 gradle/wrapper/gradle-wrapper.properties 파일을 연다.
distributionUrl=https\://services.gradle.org/distributions/gradle-X.X-all.zip X.X에 버전을 지정 한다.
./gradlew --version 버전 확인. Activity는 안드로이드 앱에서 하나의 화면을 나타내는 구성 요소
사용자가 앱을 실행하면 화면에 보이는 인터페이스를 담당하며, 화면 전환, 사용자 입력 처리 등을 관리
게임은 모든 화면을 다 지우니까 하나의 Activity만 유지함. 그게 바로 GameActivity
Context는 현재 앱의 상태나 환경 정보를 제공하는 객체
자원(리소스), 시스템 서비스, 파일 입출력, 테마, 디바이스 관련 정보 등에 접근할 때 필요
Activity는 Context의 하위 개념이며, Activity 자신도 Context 역할
UI를 생성하거나 변경할 때, UI 위젯이나 Dialog, Toast 등을 생성하는 데 Context가 필요
언리얼엔진에서는 Context를 매개변수로 받는 것이 있으면 GameActivity를 넣으면 됨.]]></description><link>cpp_crossplatform/c++-프로젝트에서-jni를-이용해서-android-호출.html</link><guid isPermaLink="false">CPP_CrossPlatform/C++ 프로젝트에서 JNI를 이용해서 Android 호출.md</guid><pubDate>Tue, 11 Feb 2025 12:46:49 GMT</pubDate></item><item><title><![CDATA[Perforce Label]]></title><description><![CDATA[체리 픽을 위해서 changing list (정확히는 파일)에 label을 태그할 수 있다. label은 반드시 'super' 계정으로 만든다.Development에 submit -&gt; p4 trigger -&gt; 'auto_label.sync.sh' 실행
script path: /opt/perforce/triggers/auto_label_sync.sh
p4 login -&gt; chaging_list number로 description 조회
Regex pattern으로 [yyyy.mm] 패턴 찾기
label_name 생성: REL-yyyy.mm
label_name으로 조회 및 없는 경우 생성
Regex를 이용해서 변경 파일들 조회
p4 tag 실행
#/opt/perforce/triggers/auto_label_sync.sh P4PASSWD="" p4 login &lt;&lt;EOF
$P4PASSWD
EOF changelist_number=$1 desc=$(p4 -ztag describe -s "$changelist_number" | grep "^... desc" | sed 's/^... desc //') # [yyyy.mm] 형식을 추출하는 정규표현식 패턴
date_pattern=$(echo "$desc" | grep -o '\[[0-9]\{4\}\.[0-9]\{2\}\]' | sed 's/\[//;s/\]//')
label_name="REL-$date_pattern" # Label이 있는지 체크
label_exists=$(p4 labels | grep "^$label_name") # 만약 Label이 없다면, 만들어주기
if [ -z "$label_exists" ]; then p4 label -i &lt;&lt; EOF
Label: $label_name
Owner: super
Description: auto $label_name description
Options: unlocked
View: //reltest/dev/...
EOF
fi files=$(p4 -ztag describe -s "$changelist_number" | grep "^... depotFile[0-9]* " | sed 's/^... depotFile[0-9]* //' | sed "s|$|@$changelist_number|" | tr '\n' ' ')
p4 tag -l "$label_name" $files p4 label - 모든 레이블 조회
p4 files {label_name} - label과 파일 연관 관계 조회. p4 tag -d -l {label_name} {depot_path} - label과 파일 연관 관계 끊기
p4 label -d {label_name} - label 삭제
]]></description><link>infra/perforce-label.html</link><guid isPermaLink="false">Infra/Perforce Label.md</guid><pubDate>Mon, 10 Feb 2025 12:02:54 GMT</pubDate></item><item><title><![CDATA[vscode clang++ 설정]]></title><description><![CDATA[{ "workbench.colorTheme": "Default Dark Modern", "cmake.configureOnOpen": true, "terminal.external.osxExec": "iTerm.app", "editor.fontSize": 15, "workbench.iconTheme": "material-icon-theme", "cmake.showOptionsMovedNotification": false, "git.openRepositoryInParentFolders": "always", "workbench.startupEditor": "none", "windsurf.autocompleteSpeed": "default", "editor.defaultFormatter": "llvm-vs-code-extensions.vscode-clangd", "editor.formatOnSave": true, "C_Cpp.clang_format_fallbackStyle": "{BasedOnStyle: Google, IndentWidth: 2, ColumnLimit: 0, UseTab: Never}", "editor.tabSize": 2, "editor.insertSpaces": true, "editor.detectIndentation": false, "windsurf.autoExecutionPolicy": "off", "windsurf.chatFontSize": "default", "clangd.fallbackFlags": [ "-std=c++17", "-I/Users/psyche95/.asdf/installs/java/zulu-17.56.15/zulu-17.jdk/Contents/Home/include", "-I/Users/psyche95/.asdf/installs/java/zulu-17.56.15/zulu-17.jdk/Contents/Home/include/darwin" ], "C_Cpp.intelliSenseEngine": "disabled"
} { "workbench.colorTheme": "Default Dark Modern", "git.openRepositoryInParentFolders": "always", "cmake.configureOnOpen": false, "cmake.pinnedCommands": [ "workbench.action.tasks.configureTaskRunner", "workbench.action.tasks.runTask" ], "editor.defaultFormatter": "llvm-vs-code-extensions.vscode-clangd", "editor.formatOnSave": true, "C_Cpp.intelliSenseEngine": "disabled", "clangd.fallbackFlags": [ "--std=c++17", "-I//Users/psychehose/.asdf/installs/java/zulu-17.42.19/zulu-17.jdk/Contents/Home/include", "-I//Users/psychehose/.asdf/installs/java/zulu-17.42.19/zulu-17.jdk/Contents/Home/include/darwin" ], "windsurf.autocompleteSpeed": "default", "windsurf.enableAutocomplete": true, "windsurf.enableSupercomplete": true, "windsurf.enableTabToJump": true,
} 프로젝트 루트에 .clang-formatBasedOnStyle: Google
IndentWidth: 2
ColumnLimit: 0
UseTab: Never
AlwaysBreakTemplateDeclarations: Yes
]]></description><link>tip/vscode-clang++-설정.html</link><guid isPermaLink="false">Tip/vscode clang++ 설정.md</guid><pubDate>Sun, 09 Feb 2025 15:37:03 GMT</pubDate></item><item><title><![CDATA[4. shared, weak ptr]]></title><description><![CDATA[여러 개의 스마트 포인터가 하나의 객체를 같이 소유 해야 하는 경우가 발생합니다. 예를 들어서 여러 객체에서 하나의 자원을 사용하고자 합니다. 후에 자원을 해제하기 위해서는 이 자원을 사용하는 모든 객체들이 소멸되야 하는데, 어떤 객체가 먼저 소멸되는지 알 수 없기 때문에 이 자원 역시 어느 타이밍에 해제 시켜야 할 지 알 수 없게 됩니다.특정 자원을&nbsp;몇 개의 객체에서 가리키는지를 추적한 다음에, 그 수가 0 이 되야만 비로소 해제를 시켜주는 방식의 포인터가 필요 : reference countstd::shared_ptr&lt;A&gt; p1(new A());
std::shared_ptr&lt;A&gt; p2(p1); // p2 역시 생성된 객체 A 를 가리킨다.
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt; class A { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; }
}; int main() { std::vector&lt;std::shared_ptr&lt;A&gt;&gt; vec; vec.push_back(std::shared_ptr&lt;A&gt;(new A())); vec.push_back(std::shared_ptr&lt;A&gt;(vec[0])); vec.push_back(std::shared_ptr&lt;A&gt;(vec[1])); // 벡터의 첫번째 원소를 소멸 시킨다. std::cout &lt;&lt; "첫 번째 소멸!" &lt;&lt; std::endl; vec.erase(vec.begin()); // 그 다음 원소를 소멸 시킨다. std::cout &lt;&lt; "다음 원소 소멸!" &lt;&lt; std::endl; vec.erase(vec.begin()); // 마지막 원소 소멸 std::cout &lt;&lt; "마지막 원소 소멸!" &lt;&lt; std::endl; vec.erase(vec.begin()); std::cout &lt;&lt; "프로그램 종료!" &lt;&lt; std::endl;
}
자원을 획득함!
첫 번째 소멸!
다음 원소 소멸!
마지막 원소 소멸!
소멸자 호출!
프로그램 종료!
shared_ptr&nbsp;들은 참조 개수가 몇 개 인지 알고 있어야만 합니다. 이 경우 어떻게 하면 같은 객체를 가리키는&nbsp;shared_ptr&nbsp;끼리 동기화를 시킬 수 있을까요?처음으로 실제 객체를 가리키는&nbsp;shared_ptr&nbsp;가&nbsp;제어 블록(control block)&nbsp;을 동적으로 할당한 후,&nbsp;shared_ptr&nbsp;들이 이 제어 블록에 필요한 정보를 공유하는 방식으로 구현<img alt="cpp_10.png" src="images/cpp_10.png" target="_self">shared_ptr&nbsp;는 복사 생성할 때 마다 해당 제어 블록의 위치만 공유하면 되고,&nbsp;shared_ptr&nbsp;가 소멸할 때 마다 제어 블록의 참조 개수를 하나 줄이고, 생성할 때 마다 하나 늘리는 방식으로 작동shared_ptr&nbsp;은 인자로 주소값이 전달된다면, 마치 자기가 해당 객체를 첫번째로 소유하는&nbsp;shared_ptr&nbsp;인 것 마냥 행동A* a = new A();
std::shared_ptr&lt;A&gt; pa1(a);
std::shared_ptr&lt;A&gt; pa2(a);
<br><img alt="cpp_11.png" src="images/cpp_11.png" target="_self">따라서 위와 같이 각각의 제어 블록들은, 다른 제어 블록들의 존재를 모르고 참조 개수를 1 로 설정하게 되겠지요. 만약에&nbsp;pa1&nbsp;이 소멸된다면, 참조 카운트가 0 이 되어서 자신이 가리키는 객체 A 를 소멸시켜 버립니다.&nbsp;pa2&nbsp;가 아직 가리키고 있는데도 말이지요!물론&nbsp;pa2&nbsp;의 참조 카운트는 계속 1 이기 때문에 자신이 가리키는 객체가 살아 있을 것이라 생각할 것입니다. 설사 운 좋게도&nbsp;pa2&nbsp;를 사용하지 않아도,&nbsp;pa2&nbsp;가 소멸되면 참조 개수가 0 으로 떨어지고 자신이 가리키고 있는 (이미 해제된) 객체를 소멸시키기 때문에 오류가 발생#include &lt;iostream&gt;
#include &lt;memory&gt; class A { int* data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; }
}; int main() { A* a = new A(); std::shared_ptr&lt;A&gt; pa1(a); std::shared_ptr&lt;A&gt; pa2(a); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;
}
자원을 획득함!
1
1
소멸자 호출!
소멸자 호출!
test(37272,0x11254d5c0) malloc: *** error for object 0x4000000000000000: pointer being freed was not allocated
test(37272,0x11254d5c0) malloc: *** set a breakpoint in malloc_error_break to debug
[1] 37272 abort ./test
이와 같은 상황을 방지하려면&nbsp;shared_ptr&nbsp;를 주소값을 통해서 생성하는 것을 지양해야 합니다.하지만, 어쩔 수 없는 상황도 있습니다. 바로 객체 내부에서 자기 자신을 가리키는&nbsp;shared_ptr&nbsp;를 만들 때 를 생각해봅시다.#include &lt;iostream&gt;
#include &lt;memory&gt; class A { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; } std::shared_ptr&lt;A&gt; get_shared_ptr() { return std::shared_ptr&lt;A&gt;(this); }
}; int main() { std::shared_ptr&lt;A&gt; pa1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;A&gt; pa2 = pa1-&gt;get_shared_ptr(); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;
}
자원을 획득함!
1
1
소멸자 호출!
소멸자 호출!
test(38479,0x10e0945c0) malloc: *** error for object 0x7fa1e0e02700: pointer being freed was not allocated
test(38479,0x10e0945c0) malloc: *** set a breakpoint in malloc_error_break to debug
[1] 38479 abort ./test
위와 같이 이전과 같은 이유로 오류가 발생하게 됩니다.&nbsp;get_shared_ptr&nbsp;함수에서&nbsp;shared_ptr&nbsp;을 생성할 때, 이미 자기 자신을 가리키는&nbsp;shared_ptr&nbsp;가 있다는 사실을 모른채 새로운 제어 블록을 생성하기 때문이 문제는&nbsp;enable_shared_from_this&nbsp;를 통해 깔끔하게 해결#include &lt;iostream&gt;
#include &lt;memory&gt; class A : public std::enable_shared_from_this&lt;A&gt; { int *data; public: A() { data = new int[100]; std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; delete[] data; } std::shared_ptr&lt;A&gt; get_shared_ptr() { return shared_from_this(); }
}; int main() { std::shared_ptr&lt;A&gt; pa1 = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;A&gt; pa2 = pa1-&gt;get_shared_ptr(); std::cout &lt;&lt; pa1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; pa2.use_count() &lt;&lt; std::endl;
}
근데 위의 코드는 보통 언제쯤 사용하는걸까?콜백이나 비동기 작업에서 객체의 안전한 수명 관리가 필요할 때 주로 사용한다고 함. 순환참조 문제 발생 이러한 순환 참조 문제를 해결하기 위해 나타난 것이 바로&nbsp;weak_ptr우리는 트리 구조를 지원하는 클래스를 만드려고 합니다. 트리 구조라 함은 아래와 가계도와 비슷하다고 생각하시면 됩니다.<br><img alt="cpp_12.png" src="images/cpp_12.png" target="_self">class Node { std::vector&lt;std::shared_ptr&lt;Node&gt;&gt; children; /* 어떤 타입이 와야할까? */ parent; public: Node(){}; void AddChild(std::shared_ptr&lt;Node&gt; node) { children.push_back(node); }
}; 만약에 일반 포인터(Node *) 로 하게 된다면, 메모리 해제를 까먹고 하지 않을 경우 혹은 예외가 발생하였을 경우 적절하게 자원을 해제하기 어렵습니다. 물론 이미 해제된 메모리를 계속 가리키고 있을 위험도 있습니다. 하지만 이를&nbsp;shared_ptr&nbsp;로 하게 된다면 앞서 본 순환 참조 문제가 생깁니다. 부모와 자식이 서로를 가리키기 때문에 참조 개수가 절대로 0 이 될 수 없습니다. 따라서, 이들 객체들은 프로그램 끝날 때 까지 절대로 소멸되지 못하고 남아있게 됩니다.
weak_ptr&nbsp;는 일반 포인터와&nbsp;shared_ptr&nbsp;사이에 위치한 스마트 포인터로, 스마트 포인터 처럼 객체를 안전하게 참조할 수 있게 해주지만,&nbsp;shared_ptr&nbsp;와는 다르게 참조 개수를 늘리지는 않습니다. 이름 그대로&nbsp;약한&nbsp;포인터 인것이지요.따라서 설사 어떤 객체를&nbsp;weak_ptr&nbsp;가 가리키고 있다고 하더라도, 다른&nbsp;shared_ptr&nbsp;들이 가리키고 있지 않다면 이미 메모리에서 소멸되었을 것입니다.이 때문에&nbsp;weak_ptr&nbsp;자체로는 원래 객체를 참조할 수 없고, 반드시&nbsp;shared_ptr&nbsp;로 변환해서 사용해야 합니다. 이 때 가리키고 있는 객체가 이미 소멸되었다면 빈&nbsp;shared_ptr&nbsp;로 변환되고, 아닐경우 해당 객체를 가리키는&nbsp;shared_ptr&nbsp;로 변환#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt; class A { std::string s; std::weak_ptr&lt;A&gt; other; public: A(const std::string&amp; s) : s(s) { std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "소멸자 호출!" &lt;&lt; std::endl; } void set_other (std::weak_ptr&lt;A&gt; o) { other = o; } void access_other() { std::shared_ptr&lt;A&gt; o = other.lock(); if (o) { std::cout &lt;&lt; "접근 : " &lt;&lt; o-&gt;name() &lt;&lt; std::endl; } else { std::cout &lt;&lt; "이미 소멸됨 ㅠ" &lt;&lt; std::endl; } } std::string name() { return s; }
}; int main() { std::vector&lt;std::shared_ptr&lt;A&gt;&gt; vec; vec.push_back(std::make_shared&lt;A&gt;("자원 1")); vec.push_back(std::make_shared&lt;A&gt;("자원 2")); vec[0]-&gt;set_other(vec[1]); vec[1]-&gt;set_other(vec[0]); // pa 와 pb 의 ref count 는 그대로다. std::cout &lt;&lt; "vec[0] ref count : " &lt;&lt; vec[0].use_count() &lt;&lt; std::endl; std::cout &lt;&lt; "vec[1] ref count : " &lt;&lt; vec[1].use_count() &lt;&lt; std::endl; // weak_ptr 로 해당 객체 접근하기 vec[0]-&gt;access_other(); // 벡터 마지막 원소 제거 (vec[1] 소멸) vec.pop_back(); vec[0]-&gt;access_other(); // 접근 실패!
} <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/modern/4.-shared,-weak-ptr.html</link><guid isPermaLink="false">CPP/Modern/4. shared, weak ptr.md</guid><pubDate>Sun, 09 Feb 2025 04:13:43 GMT</pubDate><enclosure url="images/cpp_10.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_10.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[7.  Event System]]></title><description><![CDATA[Event System 구현, 학습내용
타입 안전한 이벤트 시스템
std::variant와 std::any의 활용
함수형 프로그래밍 개념
옵저버 패턴
weak_ptr을 이용한 수명 관리
]]></description><link>cpp/concurrency/7.-event-system.html</link><guid isPermaLink="false">CPP/Concurrency/7.  Event System.md</guid><pubDate>Sun, 09 Feb 2025 02:12:40 GMT</pubDate></item><item><title><![CDATA[152. Maximum Product Subarray]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> Given an integer array&nbsp;nums, find a&nbsp;subarray&nbsp;that has the largest product, and return&nbsp;the product.The test cases are generated so that the answer will fit in a&nbsp;32-bit&nbsp;integer.Example 1:Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.Example 2:Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.Constraints:
1 &lt;= nums.length &lt;= 2 * 104
-10 &lt;= nums[i] &lt;= 10
The product of any subarray of&nbsp;nums&nbsp;is&nbsp;guaranteed&nbsp;to fit in a&nbsp;32-bit&nbsp;integer.
#include &lt;algorithm&gt;
#include &lt;vector&gt; using namespace std; class Solution {
public: int maxProduct(vector&lt;int&gt; &amp;nums) { int res = *std::max_element(nums.begin(), nums.end()); int curMin = 1; int curMax = 1; for (auto n : nums) { if (n == 0) { curMin = 1; curMax = 1; continue; } int tempMax = curMax * n; int tempMin = curMin * n; curMax = max(tempMin, tempMax); curMax = max(curMax, n); curMin = min(tempMin, tempMax); curMin = min(curMin, n); res = max(curMax, res); } return res; }
};
vector를 순회한다.
0을 제외한 아이템은 곱해서 min, max를 구한다.
0인 경우는 min max를 1로 초기화 한다. (다음 아이템 반영)
example. [2. -5, -2]iter = 2
min: 2, max: 2, n = 2 iter = -5
min: -10, max: -10, n = -5
최종: min: -10, max: -5 iter = -2
min: 10, max: 20, n = -2
최종: min: -2, max: 20 result = 20.
]]></description><link>algorithm/leetcode/152.-maximum-product-subarray.html</link><guid isPermaLink="false">Algorithm/LeetCode/152. Maximum Product Subarray.md</guid><pubDate>Sun, 02 Feb 2025 06:07:54 GMT</pubDate></item><item><title><![CDATA[2. 생성자]]></title><description><![CDATA[class Employee { std::string name; int age; std::string position; // 직책 (이름) int rank; // 순위 (값이 클 수록 높은 순위) public: Employee(std::string name, int age, std::string position, int rank) : name(name), age(age), position(position), rank(rank) {} // 복사 생성자 Employee(const Employee&amp; employee) { name = employee.name; age = employee.age; position = employee.position; rank = employee.rank; } // 디폴트 생성자 Employee() {} void print_info() { std::cout &lt;&lt; name &lt;&lt; " (" &lt;&lt; position &lt;&lt; " , " &lt;&lt; age &lt;&lt; ") ==&gt; " &lt;&lt; calculate_pay() &lt;&lt; "만원" &lt;&lt; std::endl; } int calculate_pay() { return 200 + rank * 50; }
}; Q1. b와 c의 메모리주소는 a와 비교하면 어떻게 되어있는가?
Employee* a = new Employee(); // 객체 a 생성 (디폴트 생성자 호출) Employee* b = new Employee(*a); // 객체 b 생성 (복사 생성자 호출)
Employee* c = a; b는 복사생성자를 호출했기 때문에 a와 b의 메모리 주소는 다르다. 그러나 c는 a의 주소값을 대입했기 때문에 메모리 주소가 같다.Q2. 두 생성자의 차이점은 무엇인가?Employee(std::string name, int age, std::string position, int rank) : name(name), age(age), position(position), rank(rank) {} // 생성자 본문에서 초기화하는 생성자 Employee(std::string name, int age, std::string position, int rank) { this-&gt;name = name; this-&gt;age = age; this-&gt;position = position; this-&gt;rank = rank; }
첫번째 생성자는 멤버 변수가 생성될 때 해당하는 값으로 초기화 하고 두번째 생성자는 멤버 변수가 기본 생성자로 한 번 초기화된 후 다시 값이 대입된다. 그래서 비효율적이다.아래 코드에서 "복사 생성"은 몇번 호출 되는가
class A { int x; public: A(int c) : x(c) {} A(const A&amp; a) { x = a.x; std::cout &lt;&lt; "복사 생성" &lt;&lt; std::endl; }
}; class B { A a; public: B(int c) : a(c) {} B(const B&amp; b) : a(b.a) {} A get_A() { A temp(a); return temp; }
}; int main() { B b(10); std::cout &lt;&lt; "---------" &lt;&lt; std::endl; A a1 = b.get_A();
}
Copy Elision(복사 생략) 중 Return Optimization왜냐하면 어떤 함수가 함수 내에서 생성한 객체를 리턴 한다면, 굳이 그걸 그냥 사용하면 되지 이를 복사 생성을 또할 필요가 없기 때문
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/basic/2.-생성자.html</link><guid isPermaLink="false">CPP/Basic/2. 생성자.md</guid><pubDate>Sun, 02 Feb 2025 04:26:38 GMT</pubDate></item><item><title><![CDATA[3. Overloading]]></title><description><![CDATA[#include &lt;iostream&gt; class Complex { private: double real, img; double get_number(const char* str, int from, int to) const; public: Complex(double real, double** img) : real(real), img(img) { } Complex(const Complex&amp; c) { real = c.real; img = c.img ; } Complex(const char* str); Complex operator+(const Complex&amp; c) const; Complex operator-(const Complex&amp; c) const; Complex operator*(const Complex&amp; c) const; Complex operator/(const Complex&amp; c) const; Complex&amp; operator=(const Complex&amp; c); Complex&amp; operator+=(const Complex&amp; c); Complex&amp; operator-=(const Complex&amp; c); Complex&amp; operator=(const Complex&amp; c); Complex&amp; operator/=(const Complex&amp; c); void println() { std::cout &lt;&lt; "( " &lt;&lt; real &lt;&lt; " , " &lt;&lt; img &lt;&lt; " ) " &lt;&lt; std::endl; } }; Complex Complex::operator+(const Complex&amp; c) const { Complex temp(real + c.real, img + c.img); return temp;
} Complex Complex::operator-(const Complex&amp; c) const { Complex temp(real - c.real, img - c.img); return temp;
} Complex Complex::operator*(const Complex&amp; c) const { Complex temp(real * c.real - img * c.img, real * c.img + img * c.real); return temp;
} Complex Complex::operator/(const Complex&amp; c) const { Complex temp( (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img), (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img)); return temp;
} Complex&amp; Complex::operator=(const Complex&amp; c) { real = c.real; img = c.img; return *this; } Complex&amp; Complex::operator+=(const Complex&amp; c) { (*this) = (*this) + c; return *this; } Complex&amp; Complex::operator-=(const Complex&amp; c) { (*this) = (*this) - c; return *this; } Complex&amp; Complex::operator*=(const Complex&amp; c) { (*this) = (*this) * c; return *this; } Complex&amp; Complex::operator/=(const Complex&amp; c) { (*this) = (*this) / c; return *this; } Complex::Complex(const char* str) { int begin = 0, end = strlen(str); img = 0.0; real = 0.0; // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다. int pos_i = -1; for (int i = 0; i != end; i++) { if (str[i] == 'i') { pos_i = i; break; } } // 만일 'i' 가 없다면 이 수는 실수 뿐이다. if (pos_i == -1) { real = get_number(str, begin, end - 1); return; } // 만일 'i' 가 있다면, 실수부와 허수부를 나누어서 처리하면 된다. real = get_number(str, begin, pos_i - 1); img = get_number(str, pos_i + 1, end - 1); if (pos_i &gt;= 1 &amp;&amp; str[pos_i - 1] == '-') img *= -1.0;
} double Complex::get_number(const char *str, int from, int to) const { bool minus = false; if (from &gt; to) return 0; if (str[from] == '-') minus = true; if (str[from] == '-' || str[from] == '+') from++; double** num = 0.0; double** decimal = 1.0; bool integer_part = true; for (int i = from; i &lt;= to; i++) { if (isdigit(str[i]) &amp;&amp; integer_part) { num *= 10.0; num += (str[i] - '0'); } else if (str[i] == '.') integer_part = false; else if (isdigit(str[i]) &amp;&amp; !integer_part) { decimal /= 10.0; num += ((str[i] - '0') * decimal); } else // 그 이외의 이상한 문자들이 올 경우 break; } if (minus) num *= -1.0; return num;
}
int main() { Complex a(0, 0); a = a + "-1.1 + i3.923"; a.println(); a = a - "1.2 -i1.823"; a.println(); a = a * "2.3+i22"; a.println(); a = a / "-12+i55"; a.println(); } Complex a = b + c + b;를 고려 했을 때 (b.plus(c)).plus(b) 가 되므로 -&gt; (b + c) + (b + c)가 되어버림
그래서 사칙연산에는 주소값을 리턴하지 않는다.전자는 복사생성자, 후자는 생성 후 대입연산자 여기에서는 얕은 복사가 일어난다.Complex operator+(const char* str) const;
Complex operator-(const char* str) const;
Complex operator*(const char* str) const;
Complex operator/(const char* str) const; Complex Complex::operator+(const char* str) const { Complex temp(str); return (*this) + temp;
} Complex Complex::operator-(const char* str) const { Complex temp(str); return (*this) - temp;
} Complex Complex::operator*(const char* str) const { Complex temp(str); return (*this) * temp;
} Complex Complex::operator/(const char* str) const { Complex temp(str); return (*this) - temp;
}
컴파일러는 문자열 리터럴로부터&nbsp;const Complex&nbsp;타입의 객체를 새롭게 생성할 수 있다.a = a + "-1.1 + i3.923"; 를 a = a.operator+("-1.1 + i3.923")로
그리고 이것을 a = a.operator+(Complex("-1.1 + i3.923")); 변환할 수 있다.그러나 a = "-1.1 + i3.923" + a;는 컴파일 실패한다. 변환할 수 없는 형태이기 때문이다.friend 키워드는 클래스 내부에서 다른 클래스나 함수를 friend로 정의할 수 있음.friend로 정의 되면 원래 클래스의 private로 정의된 변수, 함수들에 접근 가능lass A { private: void private_func() {} int private_num; // B 는 A 의 친구! friend class B; // func 은 A 의 친구! friend void func();
}; class B { public: void b() { A a; // 비록 private 함수의 필드들이지만 친구이기 때문에 접근 가능하다. a.private_func(); a.private_num = 2; }
}; void func() { A a; // 비록 private 함수의 필드들이지만 위와 마찬가지로 친구이기 때문에 접근 // 가능하다. a.private_func(); a.private_num = 2;
} int main() {} <a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/basic/3.-overloading.html</link><guid isPermaLink="false">CPP/Basic/3. Overloading.md</guid><pubDate>Sun, 02 Feb 2025 04:26:35 GMT</pubDate></item><item><title><![CDATA[4. 상속]]></title><description><![CDATA[
#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("기반") { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
class Derived : public Base { std::string s; public: Derived() : s("파생"), Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Base* p_c = &amp;c; p_c-&gt;what(); return 0;
}
기반 클래스
기반 클래스
파생 클래스
=== 포인터 버전 ===
기반
<img alt="cpp_1.png" src="images/cpp_1.png" target="_self">위처럼 파생클래스에서 기반클래스로 캐스팅 하는 것은 업 캐스팅
#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("기반") { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
class Derived : public Base { std::string s; public: Derived() : s("파생"), Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Derived* p_p = &amp;p; p_p-&gt;what(); return 0;
}
error C2440: 'initializing' : cannot convert from 'Base *' to 'Derived *'
<br><img alt="cpp_2.png" src="images/cpp_2.png" target="_self">위처럼 다운 캐스팅은 컴파일러 에러를 내뱉음 -&gt; 다운 캐스팅은 매우 위험한 행동임.그럼 아래와 같은 경우는 어떨까?#include &lt;iostream&gt;
#include &lt;string&gt; class Base { std::string s; public: Base() : s("기반") { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
class Derived : public Base { std::string s; public: Derived() : s("파생"), Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; s &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; std::cout &lt;&lt; "=== 포인터 버전 ===" &lt;&lt; std::endl; Base* p_p = &amp;c; Derived* p_c = p_p; p_c-&gt;what(); return 0;
}
위의 다운캐스팅 경우와 똑같이 에러가 발생함. 다만 우리는 실제 p_p가 Derived c를 가리킨다는 것을 알고 있기 때문에 강제로 static_cast를 이용해서 다운캐스팅을 할 수 있다. Derived* p_c = static_cast&lt;Derived*&gt;(p_p);
이를 실행하면 어떻게 될까.clang++ 로 빌드한 결과 실행은 된다. (책에서는 안된다고 적혀있긴 한다.)상속관계에서 캐스팅 하는 것은 dynamic_cast를 사용하면 된다.Derived* p_c = dyanmic_cast&lt;Derived*&gt;(p_p);
그러나 아래와 같은 에러가 발생한다.error: 'Base' is not polymorphic Derived* p_c = dynamic_cast&lt;Derived*&gt;(p_p);
왜 에러가 발생할까?downcasting 을 dynamic_cast 를 통해 시도할때, compile time 에서 에러가 나오는 경우는 Base class 가 "polymorphic" 하지 않을 경우(즉, 가상함수가 없을 경우) 에 한정됩니다. 그 외의 경우는, 컴파일 타임에서 에러를 내지 않고 대신 nullptr 값을 리턴합니다. 또한, 레퍼런스 타입으로 캐스팅하려 할 경우는 bad_cast 를 throw 하게 됩니다. dynamic_cast 를 이용한 다운캐스팅시, 컴파일타임에 에러가 검출#include &lt;iostream&gt; class Base { public: Base() { std::cout &lt;&lt; "기반 클래스" &lt;&lt; std::endl; } virtual void what() { std::cout &lt;&lt; "기반 클래스의 what()" &lt;&lt; std::endl; }
};
class Derived : public Base { public: Derived() : Base() { std::cout &lt;&lt; "파생 클래스" &lt;&lt; std::endl; } void what() { std::cout &lt;&lt; "파생 클래스의 what()" &lt;&lt; std::endl; }
};
int main() { Base p; Derived c; Base* p_c = &amp;c; Base* p_p = &amp;p; std::cout &lt;&lt; " == 실제 객체는 Base == " &lt;&lt; std::endl; p_p-&gt;what(); std::cout &lt;&lt; " == 실제 객체는 Derived == " &lt;&lt; std::endl; p_c-&gt;what(); return 0;
}
위에서 공부한 것에 의하면,p_c는 업캐스팅, p_p는 그냥 포인터 가르키기이므로 아래와 같이 결과가 출력되어야 함.기반 클래스
기반 클래스
파생 클래스
== 실제 객체는 Base ==
기반 클래스의 what()
== 실제 객체는 Derived == 파생 클래스의 what()
근데 실제 결과는 기반 클래스
기반 클래스
파생 클래스 == 실제 객체는 Base == 기반 클래스의 what() == 실제 객체는 Derived == 파생 클래스의 what()
virtual 키워드 사용 때문에 이런 일이 발생하는 것임 어떻게 이런 일이 발생하는 것이냐면아래 코드 실행시에 p_c-&gt;what();
컴퓨터(런타임) 입장에서"흠, p_c 는 Base 포인터니까 Base 의 what() 을 실행해야지"
"어 근데 what 이 virtual 이네?" "잠깐. 이거 실제 Base 객체 맞어? 아니네 Derived 객체네"
"그럼 Derived 의 what 을 실행해야지"
p_p-&gt;what();
"흠, p_c 는 Base 포인터니까 Base 의 what() 을 실행해야지"
"어 근데 what 이 virtual 이네?" "잠깐. 이거 실제 Base 객체 맞어? 어 맞네."
"Base 의 what 을 실행하자"
이렇게 컴파일 시에 어떤 함수가 실행될 지 정해지지 않고 런타임 시에 정해지는 일을 가리켜서&nbsp;동적 바인딩(dynamic binding)&nbsp;이라고 부름!-&gt; virtual를 붙이면 동적바인딩이겠네 어떤 함수를 실행할 지 모르니까// i 는 사용자로부터 입력받는 변수
if (i == 1) { p_p = &amp;c;
} else { p_p = &amp;p;
}
p_p-&gt;what();
다음과 같은 코드는 정적 바인딩임. 컴파일 타임에서 어떤 함수가 실행될 지 정해지니까 #include &lt;iostream&gt; class Base {
public: void display() { std::cout &lt;&lt; "Display Base" &lt;&lt; std::endl; }
}; class Derived : public Base {
public: void display() { std::cout &lt;&lt; "Display Derived" &lt;&lt; std::endl; }
};
int main() { Base base; Derived derived; base.display(); // 정적 바인딩, Base::display() 호출 derived.display(); // 정적 바인딩, Derived::display() 호출 return 0;
}
C++ 11 에서는 파생 클래스에서 기반 클래스의 가상 함수를 오버라이드 하는 경우,&nbsp;override&nbsp;키워드를 통해서 명시적으로 나타낼 수 있음그렇다면 프로그램 내부적으로&nbsp;virtual&nbsp;함수들은 어떻게 처리될까요? 즉, 이 포인터가 어떠한 객체를 가리키는지 어떻게 알 수 있을까요? (난이도 : 上)Answerc++에서 virtual 함수는 동적 바인딩(dynamic binding) 또는 런타임 바인딩(run-time binding)을 통해 처리됩니다. 이는 실행 시간에 호출될 함수가 결정되는 방식입니다. 이를 위해 C++는 가상 함수 테이블(Virtual Table, vtable)과 가상 함수 포인터(Virtual Table Pointer, vptr)를 사용합니다.가상 함수 테이블(vtable)과 가상 함수 포인터(vptr)1. 가상 함수 테이블(vtable) • 가상 함수 테이블은 클래스마다 존재하는 함수 포인터 테이블입니다.
• 클래스에 가상 함수가 정의되면, 컴파일러는 해당 가상 함수를 가리키는 포인터를 가상 함수 테이블에 저장합니다.
2. 가상 함수 포인터(vptr) • 가상 함수 포인터는 객체마다 존재합니다.
• 이 포인터는 객체가 속한 클래스의 가상 함수 테이블을 가리킵니다.
• 객체가 생성될 때, 이 포인터는 해당 객체의 클래스에 맞는 가상 함수 테이블을 가리키도록 초기화됩니다.
동작 원리
객체 생성 시
• 객체가 생성되면, 객체의 vptr은 해당 클래스의 vtable을 가리키도록 설정됩니다.
가상 함수 호출 시
• 가상 함수가 호출될 때, 객체의 vptr을 통해 vtable에 접근합니다.
• vtable에서 적절한 함수 포인터를 찾아 해당 함수를 호출합니다.
#include &lt;iostream&gt; class Base {
public: virtual void show() { std::cout &lt;&lt; "Base class" &lt;&lt; std::endl; }
}; class Derived : public Base {
public: void show() override { std::cout &lt;&lt; "Derived class" &lt;&lt; std::endl; }
}; void display(Base* obj) { obj-&gt;show(); // 동적 바인딩을 통해 적절한 함수 호출
} int main() { Base base; Derived derived; display(&amp;base); // "Base class" display(&amp;derived); // "Derived class" return 0;
} Base* b = new Derived(); b-&gt;show(); // Derived show b-&gt;display(); // Derived display
vtable 구성
• Base vtable:• Base::show
• Base::display
• Derived vtable:• Derived::show (Base의 show 함수 재정의)
• Derived::display (Base의 display 함수 재정의)
vptr 초기화• Base 포인터가 Derived 객체를 가리킬 때, Derived 객체의 vptr은 Derived 클래스의 vtable을 가리킵니다.
• 따라서 b-&gt;show()와 b-&gt;display() 호출 시 Derived 클래스의 가상 함수 테이블을 참조하여 각각 Derived::show와 Derived::display가 호출됩니다.
상속 시에 Base 클래스 소멸자를 가상함수로 만들어야 됨#include &lt;iostream&gt; class Parent { public: Parent() { std::cout &lt;&lt; "Parent 생성자 호출" &lt;&lt; std::endl; } ~Parent() { std::cout &lt;&lt; "Parent 소멸자 호출" &lt;&lt; std::endl; }
};
class Child : public Parent { public: Child() : Parent() { std::cout &lt;&lt; "Child 생성자 호출" &lt;&lt; std::endl; } ~Child() { std::cout &lt;&lt; "Child 소멸자 호출" &lt;&lt; std::endl; }
};
int main() { std::cout &lt;&lt; "--- 평범한 Child 만들었을 때 ---" &lt;&lt; std::endl; { Child c; } std::cout &lt;&lt; "--- Parent 포인터로 Child 가리켰을 때 ---" &lt;&lt; std::endl; { Parent *p = new Child(); delete p; }
}
--- 평범한 Child 만들었을 때 ---
Parent 생성자 호출
Child 생성자 호출
Child 소멸자 호출
Parent 소멸자 호출
--- Parent 포인터로 Child 가리켰을 때 ---
Parent 생성자 호출
Child 생성자 호출
Parent 소멸자 호출
delete p&nbsp;를 하더라도,&nbsp;p&nbsp;가 가리키는 것은&nbsp;Parent&nbsp;객체가 아닌&nbsp;Child&nbsp;객체 이기 때문에, Child&nbsp;객체가 소멸되는 것과 같은 순서로 생성자와 소멸자들이 호출되어야만 합니다. 그런데 실제로는,&nbsp;Child&nbsp;소멸자가 호출되지 않습니다. 캐스팅한 타입 Parent만을 해제하고 있음.위의 코드에서 Parent 클래스의 소멸자를 가상함수로 만든다면 우리가 원하는대로 동작할것임. Child 소멸자를 호출하게 됨 그렇다며 왜 Parent 소멸자가 호출 되는 것일까?Child&nbsp;소멸자가 '알아서'&nbsp;Parent&nbsp;의 소멸자도 호출함(Child&nbsp;는 자신이&nbsp;Parent&nbsp;를 상속받는다는 것을 알고 있습니다).반면에&nbsp;Parent&nbsp;소멸자를 먼저 호출하게 되면,&nbsp;Parent&nbsp;는&nbsp;Child&nbsp;가 있는지 없는지 모르므로,&nbsp;Child&nbsp;소멸자를 호출해줄 수 없습니다 (Parent 는 자신이 누구에서 상속해주는지 알 수 없지요).이와 같은 연유로,상속될 여지가 있는&nbsp;Base&nbsp;클래스들은 (위 경우&nbsp;Parent) 반드시 소멸자를&nbsp;virtual&nbsp;로 만들어주어야 나중에 문제가 발생할 여지가 없게 됩니다.#include &lt;iostream&gt; class A { public: virtual void show() { std::cout &lt;&lt; "Parent !" &lt;&lt; std::endl; }
};
class B : public A { public: void show() override { std::cout &lt;&lt; "Child!" &lt;&lt; std::endl; }
}; void test(A&amp; a) { a.show(); }
int main() { A a; B b; test(a); test(b); return 0;
}
가상함수는 약간의 오버헤드가 발생class Parent { public: virtual void func1(); virtual void func2();
};
class Child : public Parent { public: virtual void func1(); void func3();
};
<br><img alt="cpp_3.png" src="images/cpp_3.png" target="_self">Parent* p = Parent();
p-&gt;func1(); p&nbsp;가&nbsp;Parent&nbsp;를 가리키는 포인터 이니까,&nbsp;func1()&nbsp;의 정의를&nbsp;Parent&nbsp;클래스에서 찾아봐야겠다.
func1()&nbsp;이 가상함수네? 그렇다면&nbsp;func1()&nbsp;을 직접 실행하는게 아니라, 가상 함수 테이블에서&nbsp;func1()&nbsp;에 해당하는 함수를 실행해야겠다.
Parent* c = Child();
c-&gt;func1();
p&nbsp;가 실제로는&nbsp;Child&nbsp;객체를 가리키고 있으므로,&nbsp;Child&nbsp;객체의 가상 함수 테이블을 참조하여,&nbsp;Child::func1()&nbsp;을 호출두 단계에 걸쳐서 함수를 호출함 -&gt; 약간의 오버헤드#include &lt;iostream&gt; class Animal { public: Animal() {} virtual ~Animal() {} virtual void speak() = 0; // 순수 가상함수
}; class Dog : public Animal { public: Dog() : Animal() {} void speak() override { std::cout &lt;&lt; "왈왈" &lt;&lt; std::endl; }
}; class Cat : public Animal { public: Cat() : Animal() {} void speak() override { std::cout &lt;&lt; "야옹야옹" &lt;&lt; std::endl; }
}; int main() { Animal* dog = new Dog(); Animal* cat = new Cat(); dog-&gt;speak(); cat-&gt;speak();
}
가상 함수에&nbsp;= 0;&nbsp;을 붙여서, 반드시 오버라이딩 되도록 만든 함수를 완전한 가상 함수라 해서,&nbsp;순수 가상 함수(pure virtual function)라고 부름Dataview (inline field '0;'): Error: -- PARSING FAILED -------------------------------------------------- &gt; 1 | 0; | ^ Expected one of the following: '(', '*' or '/' or '%', '+' or '-', '.', '&gt;=' or '&lt;=' or '!=' or '=' or '&gt;' or '&lt;', '[', 'and' or 'or', EOF
순수 가상 함수는 본체가 없음 -&gt; 함수 호출 불가 -&gt; 순수 가상함수를 담고 있는 객체는 생성 불가능 (추상클래스를 가르키는 포인터는 생성가능)인스턴스화를 하기 위해서는 상속 받는 클래스를 만들고 순수 가상함수를 모두 오버라이드 해야함순수 가상함수를 하나 이상 포함하고 있는 클래스 -&gt; 추상 클래스Animal a; // 스택할당 - 불가능
a.speak(); Animal* dog = new Dog();
Animal* cat = new Cat(); dog-&gt;speak();
cat-&gt;speak(); #include &lt;iostream&gt; class A { public: int a; A() { std::cout &lt;&lt; "A 생성자 호출" &lt;&lt; std::endl; }
}; class B { public: int b; B() { std::cout &lt;&lt; "B 생성자 호출" &lt;&lt; std::endl; }
}; class C : public B, public A { public: int c; C() : A(), B() { std::cout &lt;&lt; "C 생성자 호출" &lt;&lt; std::endl; }
};
int main() { C c; }
상속 순서에 따라서 생성자 호출B 생성자 호출
A 생성자 호출
C 생성자 호출
다중 상속시 주의할 점base 클래스의 함수나 변수가 동일한 이름인 경우 문제가 발생 (다이아몬드 상속)class A { public: int a;
}; class B { public: int a;
}; class C : public B, public A { public: int c;
}; int main() { C c; c.a = 3;
}
error C2385: ambiguous access of 'a'
1&gt; could be the 'a' in base 'B'
1&gt; or could be the 'a' in base 'A' 다이아몬드 상속class Human { // ...
};
class HandsomeHuman : public Human { // ...
};
class SmartHuman : public Human { // ...
};
class Me : public HandsomeHuman, public SmartHuman { // ...
};
<br><img alt="cpp_4.png" src="images/cpp_4.png" target="_self">만약 Human에 name이라는 변수가 있다면 상속을 받은 HandsomeHuman, SmartHuman에도 name이라는 변수가 있는 것Me는 두 클래스를 상속 받으니 name 변수가 중복되는 문제 발생해결할 수 있는 방법class Human { public: // ...
};
class HandsomeHuman : public virtual Human { // ...
};
class SmartHuman : public virtual Human { // ...
};
class Me : public HandsomeHuman, public SmartHuman { // ...
};
이러한 형태로&nbsp;Human&nbsp;을&nbsp;virtual&nbsp;로 상속 받는다면,&nbsp;Me&nbsp;에서 다중 상속 시에도, 컴파일러가 언제나&nbsp;Human&nbsp;을 한 번만 포함하도록 지정할 수 있게 됩니다. 참고로, 가상 상속 시에,&nbsp;Me&nbsp;의 생성자에서&nbsp;HandsomeHuman&nbsp;과&nbsp;SmartHuman&nbsp;의 생성자를 호출함은 당연하고 Human&nbsp;의 생성자 또한 호출해주어야만 합니다.최상단 base의 생성자를 호출한다는 것이 특이
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/basic/4.-상속.html</link><guid isPermaLink="false">CPP/Basic/4. 상속.md</guid><pubDate>Sun, 02 Feb 2025 04:26:31 GMT</pubDate><enclosure url="images/cpp_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5. 다중 상속]]></title><description><![CDATA[예를 들어서 여러분이&nbsp;차량(Vehicle)&nbsp;에 관련한 클래스를 생성한다고 해봅시다. 차량의 종류로는 땅에서 다니는 차, 물에서 다니는 차, 하늘에서 다니는 차, 우주에서 다니는 차들이 있다고 해봅시다. (차 라고 하기 보다는 운송 수단이 좀 더 적절한 표현이겠네요..)또한, 이 차량들은 각기 다른 동력원들을 사용하는데, 휘발유를 사용할 수 도 있고, 풍력으로 갈 수 도 있고 원자력으로 갈 수도 있고, 페달을 밟아서 갈 수 도 있습니다.이러한 차량들을 클래스로 나타내기 위해서, 다중 상속을 활용할 수 있지만 그 전에, 아래와 같은 질문들에 대한 대답을 생각해봅시다.
LandVehicle&nbsp;을 가리키는&nbsp;Vehicle&amp;&nbsp;레퍼런스를 필요로 할까? 다시 말해,&nbsp;Vehicle&nbsp;레퍼런스가 실제로는&nbsp;LandVehicle&nbsp;을 참조하고 있다면,&nbsp;Vehicle&nbsp;의 멤버 함수를 호출하였을 때, LandVehicle 의 멤버 함수가 오버라이드 되서 호출되기를 바라나요? GasPoweredVehicle&nbsp;의 경우도 마찬가지 입니다. 만일&nbsp;Vehicle&nbsp;레퍼런스가 실제로는&nbsp;GasPoweredVehicle&nbsp;을 참조하고 있을 때,&nbsp;Vehicle&nbsp;레퍼런스의 멤버함수를 호출한다면,&nbsp;GasPoweredVehicle&nbsp;의 멤버 함수가 오버라이드 되서 호출되기를 원하나요? 만일 두 개의 질문에 대한 대답이 모두&nbsp;예&nbsp;라면 다중 상속을 사용하는 것이 좋을 것입니다. 하지만 그 전에, 몇 가지 고려할 점이 더 있습니다. 만약에 이 차량이 작동하는 환경이&nbsp;𝑁N&nbsp;개가 있고 (땅, 물, 하늘, 우주 등등), 동력원의 종류가&nbsp;𝑀M&nbsp;개가 있다고 해봅시다.이를 위해서, 크게 3 가지 방법으로 이러한 클래스를 디자인 할 수 있습니다. 바로 브리지 패턴 (bridge pattern), 중첩된 일반화 방식 (nested generalization), 다중 상속 입니다. 각각의 방식에는 모두 장단점이 있습니다. 브리지 패턴의 경우 차량을 나타내는 한 가지 카테고리를 아예 멤버 포인터로 만들어버립니다. 예를 들어서&nbsp;Vehicle&nbsp;클래스의 파생 클래스로&nbsp;LandVehicle,&nbsp;SpaceVehicle&nbsp;클래스들이 있고,&nbsp;Vehicle&nbsp;클래스의 멤버 변수로 어떤 엔진을 사용하는지 가리키는&nbsp;Engine*&nbsp;멤버 변수가 있습니다. 이&nbsp;Engine&nbsp;은&nbsp;GasPowered,&nbsp;NuclearPowered&nbsp;와 같은&nbsp;Engine&nbsp;의 파생 클래스들의 객체들을 가리키게 됩니다. 그리고 런타임 시에 사용자가&nbsp;Engine&nbsp;을 적절히 설정해주면 됩니다. 이 경우 동력원 이나 환경을 하나 추가하더라도 클래스를 1 개만 더 만들면 됩니다. 즉, 총&nbsp;𝑁+𝑀N+M&nbsp;개의 클래스만 생성하면 된다는 뜻입니다. 하지만 오버라이딩 가지수가&nbsp;𝑁+𝑀N+M&nbsp;개 뿐이므로 최대&nbsp;𝑁+𝑀N+M&nbsp;개 알고리즘 밖에 사용할 수 없습니다. 만일 여러분이&nbsp;𝑁×𝑀N×M&nbsp;개의 모든 상황에 대한 섬세한 제어가 필요하다면 브리지 패턴을 사용하지 않는 것이 좋습니다. 또한, 컴파일 타임 타입 체크를 적절히 활용할 수 없다는 문제가 있습니다. 예를 들어서&nbsp;Engine&nbsp;이 페달이고 작동 환경이 우주라면, 애초에 해당 객체를 생성할 수 없어야 하지만 이를 컴파일 타임에서 강제할 방법이 없고 런타임에서나 확인할 수 있게 됩니다. 뿐만 아니라, 우주에서 작동하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 있지만 (SpaceVehicle&nbsp;클래스), 작동 환경에 관계 없이 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 는 없습니다. 중첩된 일반화&nbsp;방식을 사용하게 된다면, 한 가지 계층을 먼저 골라서 파생 클래스들을 생성합니다. 예를 들어서&nbsp;Vehicle&nbsp;클래스의 파생 클래스들로&nbsp;LandVehicle,&nbsp;WaterVehicle, 등등이 있겠지요. 그 후에, 각각의 클래스들의 대해 다른 계층에 해당하는 파생 클래스들을 더 생성합니다. 예컨대&nbsp;LandVehicle&nbsp;의 경우 동력원으로 휘발유를 사용한다면&nbsp;GasPoweredLandVehicle, 원자력을 사용한다면&nbsp;NuclearPoweredLandVehicle&nbsp;클래스를 생성할 수 있겠지요.
따라서 최대&nbsp;𝑁×𝑀N×M&nbsp;가지의 파생 클래스들을 생성할 수 있게 됩니다. 따라서 브릿지 패턴에 비해서 좀 더 섬세한 제어를 할 수 있게 됩니다. 왜냐하면 오버라이딩 가지수가&nbsp;𝑁+𝑀N+M&nbsp;이 아닌&nbsp;𝑁×𝑀N×M&nbsp;이 되기 때문이지요. 하지만 동력원을 하나 더 추가하게 된다면 최대&nbsp;𝑁N&nbsp;개의 파생 클래스를 더 만들어야 합니다. 뿐만 아니라 앞서 브릿지 패턴에서 나왔던 문제 - 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 없다가 여전히 있습니다. 따라서 만약에 휘발유를 사용하는 차량들에서 공통적으로 사용되는 코드가 있다면 매 번 새로 작성해줘야만 합니다. 다중 상속을 이용하게 된다면, 브리지 패턴 처럼 각 카테고리에 해당하는 파생 클래스들을 만들게 되지만, 그 대신&nbsp;Engine*&nbsp;멤버 변수를 없애고 동력원과 환경에 해당하는 클래스를 상속받는 파생 클래스들을 최대&nbsp;𝑁×𝑀N×M&nbsp;개 만들게 됩니다. 예를 들어서 휘발유를 사용하며 지상에서 다니는 차량을 나타내는&nbsp;GasPoweredLandVehicle&nbsp;클래스의 경우&nbsp;GasPoweredEngine&nbsp;과&nbsp;LandVehicle&nbsp;두 개의 클래스를 상속받겠지요.
따라서 이 방식을 통해서 브리지 패턴에서 불가능 하였던 섬세한 제어를 수행할 수 있을 뿐더러, 말도 안되는 조합을 (예컨대&nbsp;PedalPoweredSpaceVehicle) 컴파일 타입에서 확인할 수 있습니다 (애초에 정의 자체를 안하면 되니까요!). 또한 이전에 두 방식에서 발생하였던&nbsp;휘발유를 사용하는 모든 차량을 가리킬 수 없다&nbsp;문제를 해결할 수 있습니다. 왜냐하면 이제&nbsp;GasPoweredEngine&nbsp;을 통해서 휘발유를 사용하는 모든 차량을 가리킬 수 있기 때문이지요. <a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/basic/5.-다중-상속.html</link><guid isPermaLink="false">CPP/Basic/5. 다중 상속.md</guid><pubDate>Sun, 02 Feb 2025 04:26:26 GMT</pubDate></item><item><title><![CDATA[6. 파일 입출력]]></title><description><![CDATA[<img alt="cpp_5.png" src="images/cpp_5.png" target="_self">ios_base - 스트림의 입출력 형식 관련 데이터 처리ios - 스트림 버퍼 초기화, 입출력 작업 상태 처리
스트림버퍼: 데이터를 내보내거나 받아들이기 전에 임시로 저장하는 곳
사용자가 1byte씩 쓰거나 읽는다고 할 때 실제 프로그램은 1byte씩 읽는게 아님 -&gt; 하드디스크에 쓰거나 읽을 때 시간이 오래걸리기 때문에 한 뭉터기로 쓰거나 읽어옴
istream - 실제로 입력을 수행하는 클래스operator&gt;&gt;는 모든 공백문자(띄어쓰기, 엔터, 탭)을 입력시에 무시함
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { std::string s; while (true) { std::cin &gt;&gt; s; std::cout &lt;&lt; "word : " &lt;&lt; s &lt;&lt; std::endl; }
}
this is a long sentence
word : this
word : is
word : a
word : long
word : sentence
ABCD EFGH IJKL
word : ABCD
word : EFGH
word : IJKL
주의할 점// 주의할 점
#include &lt;iostream&gt;
using namespace std;
int main() { int t; while (true) { std::cin &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (t == 0) break; }
}
3
입력 :: 3
4
입력 :: 4
5
입력 :: 5
6
입력 :: 6
7
입력 :: 7
숫자만 입력시에 잘 동작함. 그러나 문자('c\n')를 입력한다면 기괴환 무한루프 결과가 나옴.<br><img alt="cpp_6.png" src="images/cpp_6.png" target="_self">ios 클래스에서 스트림 상태를 관리하는 플래그가 4개가 정의되어 있음
goodbit: 스트림에 입출력 작업이 가능할 때
badbit: 스트림에 복구 불가능한 오류 발생시
eofbit: 입력 작업시에&nbsp;EOF 도달시
failbit: 스트림에 복구 가능한 오류 발생시
'c\n'을 입력하는 경우 타입에 맞지 않는 값이기 때문에 failbit가 켜짐. 그리고 입력값을 받지 않고 리턴함. 그러나 스트림에 'c\n'이 남아있는데 이를 처리하지 않는다는 것 -&gt; 무한루프// 해결 방안
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { int t; while (std::cin &gt;&gt; t) { std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (t == 0) break; }
}
whilecin &gt;&gt; t로 인해서 무한루프에 빠지지 않고 제대로 처리됨.이게 어떻게 처리되는 지를 이해하기 위해서는 ios에 정의되어 있는 함수 operator void*() const;에 대해 알아야함.operator void*() const;
이 함수는&nbsp;ios 객체를&nbsp;void*&nbsp;로 변환함. 이 떄 Null 포인터가 아닌 값을 반환하기 위해서는 failbit와 badbit가 모두 off인 경우임.즉 정상적으로 입출력 작업을 수행할 수 있는 경우임.코드로 돌아가서 문자 's'를 입력 한다면 failbit가 켜지게 됨
std::cin &gt;&gt; t를 후에 cin이 리턴되는데 null 포인터를 리턴하게 되어서 루프를 돌지 않게 됨.문제를 해결한 상태지만 입력을 계속 진행할 수 없음. cin에 failbit가 켜져있기 때문임. 그래서 플래그를 초기화 해야함#include &lt;iostream&gt;
#include &lt;string&gt; int main() { int t; while (true) { std::cin &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; "제대로 입력해주세요" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 std::cin.ignore(100, '\n'); // 개행문자가 나올 때 까지 무시한다 } if (t == 1) break; }
}
fail()함수는 ios에 정의되어 있고 failbit || badbit가 true인 경우 true를 리턴함.clear()도 ios에 정의되어 있고 인자를 주지 않으면 플래그를 goodbit로 초기화함 따라서 fail 상태 초기화할 수 있음.ignore() istream에 정의되어 있고 최대 첫번째 인자(100)만큼 두번째 인자('\n')이 나올 때까지 버퍼에서 무시함.ios_base 클래스에서 스트림 입출력 형식 바꾸기 가능: 10진수 -&gt; 16진수로 처리#include &lt;string&gt;
#include &lt;iostream&gt; int main() { int t; while (true) { std::cin.setf(std::ios_base::hex, std::ios_base::basefield); std::cin &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; "제대로 입력해주세요" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 // std::cin.ignore(100,'n');//개행문자가 나올 때까지 // 무시한다 } if (t == 0) break; }
}
위의 코드는 16진수로 입력받기 -&gt; 10진수로 출력std::cin.setfhex, ios_base::basefieldsetf의 버전은 2가지임.인자를 1개 받는 경우와 위의 경우처럼 2개를 받는 것1개를 받는 경우: 하나의 인자를 받는 setf는 새로운 포맷 플래그를 설정하고, 기존 플래그와 병합합니다.
이 경우, std::ios::hex 플래그를 설정하여 이후의 입력을 16진수로 처리합니다. 이전에 설정된 다른 플래그는 유지되며, 새로운 플래그와 병합됩니다.2개를 받는 경우
두 개의 인자를 받는 setf는 첫 번째 인자로 전달된 플래그를 설정하고, 두 번째 인자로 전달된 마스크에 해당하는 플래그를 클리어(지움)합니다.이 경우, std::ios::hex 플래그를 설정하면서, std::ios::basefield에 해당하는 플래그 ios::dec, std::ios::oct, std::ios::hex는 모두 클리어합니다. 즉, std::ios::hex만 남게 됩니다.위의 방법말고 16진수로 입력을 조작하는 방법은 조작자를 사용하는 것// 조작자의 사용
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { int t; while (true) { std::cin &gt;&gt; std::hex &gt;&gt; t; std::cout &lt;&lt; "입력 :: " &lt;&lt; t &lt;&lt; std::endl; if (std::cin.fail()) { std::cout &lt;&lt; "제대로 입력해주세요" &lt;&lt; std::endl; std::cin.clear(); // 플래그들을 초기화 하고 std::cin.ignore(100, 'n'); //개행문자가 나올 때까지 무시한다 } if (t == 0) break; }
}
std::cin &gt;&gt; hex &gt;&gt; t; hex가 cin에서 수를 받는 방식을 바꿈 여기에서 hex는 함수고 조작자라고 부름. 그 전의 경우 hex는 이름은 같지만 형식플래그고 ios_base::hex 정의되어 있는 상수 '값'임.그러나 조작자 hex는 ios_base객체를 레퍼런스로 받고 다시 그 객체를 리턴하도록 정의된 함수임.std::ios_base&amp; hex(std::ios_base&amp; str);
operator&gt;&gt; 중에서도 위 함수를 인자로 가지도록 오버로딩 되어 있음istream&amp; operator&gt;&gt;(ios_base&amp; (*pf)(ios_base&amp;));
조작자를 사용하면 입력 형식을 쉽게 바꿀 수 있음. endl는 출력을 관장하는 ostream에 정의되어 있는 조작자임. 한줄 개행문자를 출력하는 것말고 버퍼를 flush 역할을 수행함.기본적으로 문자 1개를 내보낸다고 화면에 바로 출력하는 것이 아니라 버퍼에 모은 다음에 버퍼에 어느정도 쌓이면 출력하게 되지만 flush()는 버퍼에 데이터가 얼마나 쌓여있든지 바로 출력을 해줌.c++에 streambuf 클래스가 있음 streambuf 클래스는 스트림에 대한 가장 기본적인 제어를 담당<br><img alt="cpp_7.png" src="images/cpp_7.png" target="_self">
(streambuf 클래스에서 스트림을 어떤 식으로 추상화하고 있는지 나타내는 그림)streambuf 클래스는 스트림의 상태를 나타내기 위해서 세 개의 포인터 정의
버퍼의 시작 부분을 가르키는 시작 포인터
다음으로 읽을 문자를 가르키고 있는 포인터(스트림 위치 지정자)
버퍼의 끝 부분을 가르키는 끝 포인터
streambuf 클래스는 입력 버퍼와 출력 버퍼를 구분해서 get area, put area라 부름. 이를 각각 가르키는 포인터도 g, p를 붙여서 표현입력 객체 cin.rdbuf()를 호출하면 cin 객체가 수행하고 있던 streambuf 객체를 가르키는 포인터를 리턴하게 됨. cin 객체는 istream 객체이므로 오직 입력만을 수행하고 있음. 따라서 streambuf 객체에는 get area만 있음snextc() 함수는 스트림 위치 지정자를 한 칸 전진한 해당 문자를 엿봄.(읽는 것이 아님)peek의 결과가 왜 'w'일까?<br><img alt="cpp_8.png" src="images/cpp_8.png" target="_self"><br><img alt="cpp_9.png" src="images/cpp_9.png" target="_self">streambuf&nbsp;에는&nbsp;snextc&nbsp;함수 말고도 수 많은 함수들이 정의되어있음.
C++ 입출력 라이브러리는 스트림 버퍼도 추상화해서 클래스로 만들었다는 것을 기억하기cin은 스트림버퍼에서 공백을 기준으로 가져옴#include &lt;iostream&gt;
#include &lt;string&gt; int main()
{ std::string s; std::cin &gt;&gt; s; std::cout &lt;&lt; "1: " &lt;&lt; s &lt;&lt; std::endl; // std::cin &gt;&gt; s; std::cout &lt;&lt; "2: " &lt;&lt; s &lt;&lt; std::endl; return 0; }
Q) 입력값으로 hello world 를 입력했을 때 std::cin &gt;&gt; s 를 주석처리한 경우와 아닌 경우 결과는?주석처리 하지 않은 경우 1: hello
2: world 주석처리한 경우 1: hello
2: hello #include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in("test.txt"); std::string s; if (in.is_open()) { // 위치 지정자를 파일 끝으로 옮긴다. in.seekg(0, std::ios::end); // 그리고 그 위치를 읽는다. (파일의 크기) int size = in.tellg(); // 그 크기의 문자열을 할당한다. s.resize(size); // 위치 지정자를 다시 파일 맨 앞으로 옮긴다. in.seekg(0, std::ios::beg); // 파일 전체 내용을 읽어서 문자열에 저장한다. // read의 파라미터: 저장할 객체, 버퍼 사이즈 in.read(&amp;s[0], size); std::cout &lt;&lt; s &lt;&lt; std::endl; } else { std::cout &lt;&lt; "파일을 찾을 수 없습니다!" &lt;&lt; std::endl; } return 0;
}
// getline 으로 읽어들이기
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in("test.txt"); char buf[100]; if (!in.is_open()) { std::cout &lt;&lt; "파일을 찾을 수 없습니다!" &lt;&lt; std::endl; return 0; } // getline 함수는 개행 문자 (혹은 지정한 문자) 가 나오기 전에 지정한 버퍼의 크기가 다 차게 된다면 `failbit` 를 켜게 됨 while (in) { in.getline(buf, 100); // in.getline(buf, 100, '.')로 하면 .나올 때까지 읽음 // 기본적으로 '\n' std::cout &lt;&lt; buf &lt;&lt; std::endl; } return 0;
}
in.getline: ifstream에 정의된 getline은 buffer를 입력해줘야 함. 버퍼의 크기를 너무 작게 만든다면 정상적으로 데이터를 받을 수 없음.이러한 한계점을 극복하기 위해서 std::string::getline을 이용string::getline은 첫번째 인자를 istream(인풋 파일 스트림만을 의미하는 것 아님. 전체)
두번째 인자는 저장할 스트링 객체#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int main() { // 파일 읽기 준비 std::ifstream in("test.txt"); if (!in.is_open()) { std::cout &lt;&lt; "파일을 찾을 수 없습니다!" &lt;&lt; std::endl; return 0; } std::string s; while (in) { getline(in, s); std::cout &lt;&lt; s &lt;&lt; std::endl; } return 0;
}
한 가지 주의할 사항으로&nbsp;`while`&nbsp;문 조건으로&nbsp;절대&nbsp;`in.eof()`&nbsp;를 사용하면 안됩니다. 이러한 코드를 사용했다면 99 퍼센트의 확률로 잘못된 코드 입니다. 왜냐하면&nbsp;[eof]&nbsp;함수는 파일 위치 지시자가 파일에 끝에 도달한&nbsp;이후&nbsp;에&nbsp;`true`&nbsp;를 리턴하기 때문입니다. 예를 들어서&nbsp;`while`&nbsp;문 안에서 파일을 쭈르륵 읽다가 파일 끝(EOF) 바로 직전까지 읽었다고 해봅시다. 그렇다면 아직 EOF 를 읽지 않았으므로&nbsp;`in.eof()`&nbsp;는 참인 상태일 것입니다. 그 상태에서 예컨대&nbsp;`in &gt;&gt; data`&nbsp;를 하게 된다면&nbsp;`data`&nbsp;에는 아무것도 들어가지 않게 됩니다. 즉 초기화가 되지 않은 상태로 남아있는 것입니다! 다시 말해&nbsp;`in.eof()`&nbsp;는&nbsp;`while`&nbsp;문 안에서&nbsp;파일 읽기가 안전하다 라는 것을 보장하지 않습니다. 정확한 사용법은 그냥&nbsp;`while(in)`&nbsp;처럼 스트림 객체 자체를 전달하는 것입니다. 앞에서도 말했듯이&nbsp;[istream]&nbsp;객체는 다음 읽기가 안전할 때만&nbsp;`true`&nbsp;로 캐스팅됩니다.
ofstream을 이용해서 파일을 쓸 수 있음.#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt; int main() { // 파일 쓰기 준비 std::ofstream out("test.txt"); std::string s; if (out.is_open()) { out &lt;&lt; "이걸 쓰자~~"; } return 0;
}
다만 out에 특별한 설정이 없다면 딱 저대로 텍스트 파일이 생성됨 (기존의 파일 내용 없어짐) 만약 덧붙이고 싶다면 std::ios::app 옵션을 사용한다.std::ofstream out("test.txt", std::ios::app);
out 객체를 생성할 때 옵션은 몇가지 더 있음
ios::binary
ios::app
ios::ate - 자동으로 파일 끝에서 부터 읽기와 쓰기를 실시합니다. (즉 파일을 열 때 위치 지정자가 파일 끝을 가리키고 있게 됨
ios::trunc - 파일 스트림을 열면 기존에 있던 내용들이 모두 지워짐. 기본적으로&nbsp;ofstream&nbsp;객체를 생성할 때 이와 같은 설정으로 만들어짐
ios::app 과 ios::ate는 비슷하지만 중요한 차이가 있음.ios::app은 원본 내용 무조건 보장, ios::ate는 기존 파일의 내용을 보존X#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class Human { std::string name; int age; public: Human(const std::string&amp; name, int age) : name(name), age(age) {} std::string get_info() { return "Name :: " + name + " / Age :: " + std::to_string(age); } friend std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; o, Human&amp; h);
}; std::ofstream&amp; operator&lt;&lt;(std::ofstream&amp; o, Human&amp; h) { o &lt;&lt; h.get_info(); return o;
}
int main() { // 파일 쓰기 준비 std::ofstream out("test.txt"); Human h("이재범", 60); out &lt;&lt; h &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;sstream&gt; int main() { std::istringstream ss("123"); int x; ss &gt;&gt; x; std::cout &lt;&lt; "입력 받은 데이터 :: " &lt;&lt; x &lt;&lt; std::endl; return 0;
}
sstream에 std::istringstream이 정의되어 있음 -&gt; 마치 문자열을 하나의 스트림이라고 생각하게 하는 가상화 장치std::istringstream ss("123"); // 입력스트림 생성 (입력받은 것같음)
활용 어케하냐#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt; double to_number(std::string s) { std::istringstream ss(s); double x; ss &gt;&gt; x; return x;
} std::string to_str(int x) { std::ostringstream ss; ss &lt;&lt; x; return ss.str();
} int main() { std::cout &lt;&lt; "변환:: 1 + 2 = " &lt;&lt; to_number("1") + to_number("2") &lt;&lt; std::endl; std::cout &lt;&lt; "문자열로 변환:: 1 + 2 = " &lt;&lt; to_str(1 + 2) &lt;&lt; std::endl; return 0;
} <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/basic/6.-파일-입출력.html</link><guid isPermaLink="false">CPP/Basic/6. 파일 입출력.md</guid><pubDate>Sun, 02 Feb 2025 04:26:23 GMT</pubDate><enclosure url="images/cpp_5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_5.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. thread]]></title><description><![CDATA[프로세스끼리 메모리 공유하지 않음.쓰레드: 프로그램 내에서 동시에 실행될 수 있는 작은 실행 단위임쓰레드는 같은 프로세스 내에 있으면 같은 메모리 공유#include &lt;iostream&gt;
#include &lt;thread&gt;
using std::thread; void func1() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; "쓰레드 1 작동중! \n"; }
} void func2() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; "쓰레드 2 작동중! \n"; }
} void func3() { for (int i = 0; i &lt; 10; i++) { std::cout &lt;&lt; "쓰레드 3 작동중! \n"; }
}
int main() { thread t1(func1); thread t2(func2); thread t3(func3); t1.join(); t2.join(); t3.join();
}
join은 쓰레드들이 실행을 종료하면 리턴하는 함수
detatch는 해당 쓰레드를 실행 시킨 후,&nbsp;잊어버리는 것&nbsp;이라 생각하시면 됩니다. 대신 쓰레드는 알아서 백그라운드에서 돌아감#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using std::thread;
using std::vector; void worker(vector&lt;int&gt;::iterator start, vector&lt;int&gt;::iterator end, int* result) { int sum = 0; for (auto itr = start; itr &lt; end; ++itr) { sum += *itr; } *result = sum; // 쓰레드의 id 를 구한다. thread::id this_id = std::this_thread::get_id(); printf("쓰레드 %x 에서 %d 부터 %d 까지 계산한 결과 : %d \n", this_id, *start, *(end - 1), sum);
} int main() { vector&lt;int&gt; data(10000); for (int i = 0; i &lt; 10000; i++) { data[i] = i; } // 각 쓰레드에서 계산된 부분 합들을 저장하는 벡터 vector&lt;int&gt; partial_sums(4); vector&lt;thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(thread(worker, data.begin() + i * 2500, data.begin() + (i + 1) * 2500, &amp;partial_sums[i])); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } int total = 0; for (int i = 0; i &lt; 4; i++) { total += partial_sums[i]; } std::cout &lt;&lt; "전체 합 : " &lt;&lt; total &lt;&lt; std::endl;
}
worker에서 std::cout 대신에 printf를 사용한 이유한 번 여러분이 컴퓨터라고 생각하고 위&nbsp;std::cout&nbsp;명령을 실행한다고 생각해보세요. 만약에&nbsp;std::cout &lt;&lt; "쓰레드 "&nbsp;까지 딱 실행했는데 운영체제가 갑자기 다른 쓰레드를 실행시키면 어떨까요? 그렇다면 화면에는&nbsp;쓰레드&nbsp;만 딱 나오고 그 뒤로 다른 쓰레드의 메세지가 표시될 것입니다.따라서 위와 같이&nbsp;std::cout&nbsp;의&nbsp;&lt;&lt;&nbsp;를 실행하는 과정 중간 중간에 계속 실행되는 쓰레드들이 바뀌면서 결과적으로 메세지가 뒤섞여서 나타나게 됩니다.std::cout&nbsp;의 경우&nbsp;std::cout &lt;&lt; A;&nbsp;를 하게 된다면 A 의 내용이 출력되는 동안 중간에 다른 쓰레드가 내용을 출력할 수 없게&nbsp;보장을 해줍니다 (그 사이에 컨텍스트 스위치가 되더라도 말이지요). 하지만&nbsp;std::cout &lt;&lt; A &lt;&lt; B;&nbsp;를 하게 되면&nbsp;A&nbsp;를 출력한 이후에&nbsp;B&nbsp;를 출력하기 전에 다른 쓰레드가 내용을 출력할 수 있습니다.반면에&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/35" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/35" target="_self">printf</a>&nbsp;는 조금 다릅니다.&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/35" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/35" target="_self">printf</a>&nbsp;는&nbsp;"..."&nbsp;안에 있는 문자열을 출력할 때, 컨텍스트 스위치가 되더라도 다른 쓰레드들이 그 사이에 메세지를 집어넣지 못하게 막습니다. (자세한 내용은 여기&nbsp;<a data-tooltip-position="top" aria-label="https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads" rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/23586682/how-to-use-printf-in-multiple-threads" target="_self">참고</a>)따라서, 방해받지 않고 전체 메세지를 제대로 출력할 수 있게 해줍니다.#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using std::thread;
using std::vector; void worker(int&amp; counter) { for (int i = 0; i &lt; 10000; i++) { counter += 1; }
} int main() { int counter = 0; vector&lt;thread&gt; workers; for (int i = 0; i &lt; 4; i++) { // 레퍼런스로 전달하려면 ref 함수로 감싸야 한다 (지난 강좌 bind 함수 참조) workers.push_back(thread(worker, std::ref(counter))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
흠 결과가 조금 이상하네요? 분명히 각 쓰레드에서 10000 씩 더했기 때문에 정상적인 상황이였다면 40000 이 출력되어야 했을 것입니다. 그런데, 모든 쓰레드들이 종료되고 최종적으로&nbsp;Counter&nbsp;에 써진 값은 10000 이 되었습니다 -&gt; 레이스 컨디션
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/concurrency/1.-thread.html</link><guid isPermaLink="false">CPP/Concurrency/1. thread.md</guid><pubDate>Sun, 02 Feb 2025 04:26:18 GMT</pubDate></item><item><title><![CDATA[2. Mutex, deadlock]]></title><description><![CDATA[한 쓰레드에서만 위 코드를 실행시키기
race condition을 방지하기 위함#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt;
#include &lt;vector&gt; void worker(int&amp; result, std::mutex&amp; m) { for (int i = 0; i &lt; 10000; i++) { m.lock(); result += 1; m.unlock(); }
} int main() { int counter = 0; std::mutex m; // 우리의 mutex 객체 std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, std::ref(counter), std::ref(m))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
m.lock();
result += 1;
m.unlock();
m.lock()&nbsp;은&nbsp;뮤텍스&nbsp;m&nbsp;을 내가 쓰게 달라!&nbsp;라고 이야기 하는 것입니다. 이 때 중요한 사실은,&nbsp;한 번에 한 쓰레드에서만&nbsp;m&nbsp;의 사용 권한을 갖는다는 것입니다. 그렇다면, 다른 쓰레드에서&nbsp;m.lock()&nbsp;을 하였다면 어떻게될까요? 이는&nbsp;m&nbsp;을 소유한 쓰레드가&nbsp;m.unlock()&nbsp;을 통해&nbsp;m&nbsp;을 반환할 때 까지 무한정 기다리게 됩니다.m.unlock을 만약 하지 않는다면 다른 쓰레드에서 무한정 기다림 -&gt; 데드락위와 같은 문제를 해결하기 위해서는 취득한 뮤텍스는 사용이 끝나면 반드시 반환을 해야 합니다. 하지만 코드 길이가 길어지게 된다면 반환하는 것을 까먹을 수 있기 마련입니다.곰곰히 생각해보면 이전에 비슷한 문제를 해결한 기억이 있습니다.&nbsp;unique_ptr&nbsp;를 왜 도입을 하였는지 생각을 해보자면, 메모리를 할당 하였으면 사용 후에 반드시 해제를 해야 하므로, 아예 이 과정을&nbsp;unique_ptr&nbsp;의 소멸자에서 처리하도록 했었습니다.뮤텍스도 마찬가지로 사용 후 해제 패턴을 따르기 때문에 동일하게 소멸자에서 처리#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt;
#include &lt;vector&gt; void worker(int&amp; result, std::mutex&amp; m) { for (int i = 0; i &lt; 10000; i++) { // lock 생성 시에 m.lock() 을 실행한다고 보면 된다. std::lock_guard&lt;std::mutex&gt; lock(m); result += 1; // scope 를 빠져 나가면 lock 이 소멸되면서 // m 을 알아서 unlock 한다. }
} int main() { int counter = 0; std::mutex m; // 우리의 mutex 객체 std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, std::ref(counter), std::ref(m))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
데드락을 방지하기 위해서 한 쓰레드에 우선권을 주면, 다른 쓰레드만 일하고 남은 쓰레드는 일하지 않는 경우가 생김 -&gt; Starvation이 생길 가능성이 있음.#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt; void worker1(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { m1.lock(); m2.lock(); std::cout &lt;&lt; "Worker1 Hi! " &lt;&lt; i &lt;&lt; std::endl; m2.unlock(); m1.unlock(); }
} void worker2(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { while (true) { m2.lock(); // m1 이 이미 lock 되어 있다면 "야 차 빼" 를 수행하게 된다. if (!m1.try_lock()) { m2.unlock(); continue; } std::cout &lt;&lt; "Worker2 Hi! " &lt;&lt; i &lt;&lt; std::endl; m1.unlock(); m2.unlock(); break; } }
} int main() { std::mutex m1, m2; // 우리의 mutex 객체 std::thread t1(worker1, std::ref(m1), std::ref(m2)); std::thread t2(worker2, std::ref(m1), std::ref(m2)); t1.join(); t2.join(); std::cout &lt;&lt; "끝!" &lt;&lt; std::endl;
}
worker 1에 우선권을 줬음.#include &lt;iostream&gt;
#include &lt;mutex&gt; // mutex 를 사용하기 위해 필요
#include &lt;thread&gt; void worker1(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { m1.lock(); m2.lock(); std::cout &lt;&lt; "Worker1 Hi! " &lt;&lt; i &lt;&lt; std::endl; m2.unlock(); m1.unlock(); }
} void worker2(std::mutex&amp; m1, std::mutex&amp; m2) { for (int i = 0; i &lt; 10; i++) { while (true) { m2.lock(); // m1 이 이미 lock 되어 있다면 "야 차 빼" 를 수행하게 된다. if (!m1.try_lock()) { m2.unlock(); continue; } std::cout &lt;&lt; "Worker2 Hi! " &lt;&lt; i &lt;&lt; std::endl; m1.unlock(); m2.unlock(); break; } }
} int main() { std::mutex m1, m2; // 우리의 mutex 객체 std::thread t1(worker1, std::ref(m1), std::ref(m2)); std::thread t2(worker2, std::ref(m1), std::ref(m2)); t1.join(); t2.join(); std::cout &lt;&lt; "끝!" &lt;&lt; std::endl;
}
데드락을 해결하는건 매우매우 복잡하고 완벽하지 않음. 그래서, 데드락 상황이 발생하지 않게 잘 설계하는 것이 중요데드락 상황을 피하기 위해 다음과 같은 가이드라인을 제시모든 쓰레드들이 최대 1 개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;만을 소유한다면 (일반적인 경우에) 데드락 상황이 발생하는 것을 피할 수 있습니다. 또한 대부분의 디자인에서는 1 개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;으로도 충분합니다. 만일 여러개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;을 필요로 한다면&nbsp;정말 필요로 하는지&nbsp;를 되물어보는 것이 좋습니다.<br>사실 이 가이드라인 역시 위에서 말한 내용과 자연스럽게 따라오는 것이긴 한데, 유저 코드에서&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;을 소유할 수 도 있기에 중첩된&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;을 얻는 것을 피하려면&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;소유시 유저 코드를 호출하는 것을 지양해야 합니다.<br>만일 여러개의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">Lock</a>&nbsp;들을 획득해야 할 상황이 온다면,&nbsp;반드시 이 Lock 들을 정해진 순서로 획득해야 합니다. 우리가 앞선 예제에서 데드락이 발생했던 이유 역시,&nbsp;worker1&nbsp;에서는&nbsp;m1, m2&nbsp;순으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;을 하였지만&nbsp;worker2&nbsp;에서는&nbsp;m2, m1&nbsp;순으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;을 하였기 때문이지요. 만일&nbsp;worker2&nbsp;에서 역시&nbsp;m1, m2&nbsp;순으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;을 하였다면 데드락은 발생하지 않았을 것입니다.
#include &lt;chrono&gt; // std::chrono::miliseconds
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void producer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int index) { for (int i = 0; i &lt; 5; i++) { // 웹사이트를 다운로드 하는데 걸리는 시간이라 생각하면 된다. // 각 쓰레드 별로 다운로드 하는데 걸리는 시간이 다르다. std::this_thread::sleep_for(std::chrono::milliseconds(100 * index)); std::string content = "웹사이트 : " + std::to_string(i) + " from thread(" + std::to_string(index) + ")\n"; // data 는 쓰레드 사이에서 공유되므로 critical section 에 넣어야 한다. m-&gt;lock(); downloaded_pages-&gt;push(content); m-&gt;unlock(); }
} void consumer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int* num_processed) { // 전체 처리하는 페이지 개수가 5 * 5 = 25 개. while (*num_processed &lt; 25) { m-&gt;lock(); // 만일 현재 다운로드한 페이지가 없다면 다시 대기. if (downloaded_pages-&gt;empty()) { m-&gt;unlock(); // (Quiz) 여기서 unlock 을 안한다면 어떻게 될까요? // 10 밀리초 뒤에 다시 확인한다. std::this_thread::sleep_for(std::chrono::milliseconds(10)); continue; } // 맨 앞의 페이지를 읽고 대기 목록에서 제거한다. std::string content = downloaded_pages-&gt;front(); downloaded_pages-&gt;pop(); (*num_processed)++; m-&gt;unlock(); // content 를 처리한다. std::cout &lt;&lt; content; std::this_thread::sleep_for(std::chrono::milliseconds(80)); }
} int main() { // 현재 다운로드한 페이지들 리스트로, 아직 처리되지 않은 것들이다. std::queue&lt;std::string&gt; downloaded_pages; std::mutex m; std::vector&lt;std::thread&gt; producers; for (int i = 0; i &lt; 5; i++) { producers.push_back(std::thread(producer, &amp;downloaded_pages, &amp;m, i + 1)); } int num_processed = 0; std::vector&lt;std::thread&gt; consumers; for (int i = 0; i &lt; 3; i++) { consumers.push_back( std::thread(consumer, &amp;downloaded_pages, &amp;m, &amp;num_processed)); } for (int i = 0; i &lt; 5; i++) { producers[i].join(); } for (int i = 0; i &lt; 3; i++) { consumers[i].join(); }
}
먼저&nbsp;producer&nbsp;쓰레드에서는 웹사이트에서 페이지를 계속 다운로드 하는 역할을 하게 됩니다. 이 때, 다운로드한 페이지들을&nbsp;downloaded_pages&nbsp;라는 큐에 저장<br>
<img alt="cpp_13.png" src="images/cpp_13.png" target="_self">그리고 다운 받은 웹사이트 내용이&nbsp;content&nbsp;라고 생각해봅시다.그렇다면, 이제 다운 받은 페이지를 작업 큐에 집어 넣어야 합니다. 이 때 주의할 점으로,&nbsp;producer&nbsp;쓰레드가 1 개가 아니라 5 개나 있다는 점입니다. 따라서&nbsp;downloaded_pages&nbsp;에 접근하는 쓰레드들 사이에&nbsp;race condition&nbsp;이 발생할 수 있습니다.이를 방지 하기 위해서 뮤텍스&nbsp;m&nbsp;으로 해당 코드를 감싸서 문제가 발생하지 않게 해줍니다.먼저&nbsp;consumer&nbsp;쓰레드의 입장에서는&nbsp;언제 일이 올지 알 수 없습니다. 따라서&nbsp;downloaded_pages&nbsp;가 비어있지 않을 때 까지 계속&nbsp;while&nbsp;루프를 돌아야겠지요. 한 가지 문제는 컴퓨터 CPU 의 속도에 비해 웹사이트 정보가 큐에 추가되는 속도는 매우 느리다는 점입니다.우리의&nbsp;producer&nbsp;의 경우 대충 100ms 마다 웹사이트 정보를 큐에 추가하게 되는데, 이 시간 동안&nbsp;downloaded_pages-&gt;empty()&nbsp;이 문장을 수십 만 번 호출할 수 있을 것입니다. 이는 상당한 CPU 자원의 낭비가 아닐 수 없지요. 그래서 empty인 경우 10 밀리 세컨드 후에 다시 실행 (continue;) <br>정상 작동함..근데 consumer가 10밀리 세컨드마다 downloaded_pages에 할일이 있는 지 확인하고 있으면 하고 없으면 기다리는 형태라서 비효율임 매 번 언제 올지 모르는 데이터를 확인하기 위해 지속적으로&nbsp;mutex&nbsp;를&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/lock" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/lock" target="_self">lock</a>&nbsp;하고, 큐를 확인해야 하기 때문어떻게 개선할까?consumer는 그냥 재워놓고 producer에서 할 일이 온다면 그때 consumer를 깨우자.위와 같은 상황에서 쓰레드들을 10 밀리초 마다 재웠다 깨웠다 할 수 밖에 없었던 이유는&nbsp;어떠 어떠한 조건을 만족할 때 까지 자라!&nbsp;라는 명령을 내릴 수 없었기 때문입니다.위 경우&nbsp;downloaded_pages&nbsp;가&nbsp;empty()&nbsp;가 참이 아닐 때 까지 자라&nbsp;라는 명령을 내리고 싶었겠지요.#include &lt;chrono&gt; // std::chrono::miliseconds
#include &lt;condition_variable&gt; // std::condition_variable
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void producer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int index, std::condition_variable* cv) { for (int i = 0; i &lt; 5; i++) { // 웹사이트를 다운로드 하는데 걸리는 시간이라 생각하면 된다. // 각 쓰레드 별로 다운로드 하는데 걸리는 시간이 다르다. std::this_thread::sleep_for(std::chrono::milliseconds(100 * index)); std::string content = "웹사이트 : " + std::to_string(i) + " from thread(" + std::to_string(index) + ")\n"; // data 는 쓰레드 사이에서 공유되므로 critical section 에 넣어야 한다. m-&gt;lock(); downloaded_pages-&gt;push(content); m-&gt;unlock(); // consumer 에게 content 가 준비되었음을 알린다. cv-&gt;notify_one(); }
} void consumer(std::queue&lt;std::string&gt;* downloaded_pages, std::mutex* m, int* num_processed, std::condition_variable* cv) { while (*num_processed &lt; 25) { std::unique_lock&lt;std::mutex&gt; lk(*m); cv-&gt;wait( lk, [&amp;] { return !downloaded_pages-&gt;empty() || *num_processed == 25; }); if (*num_processed == 25) { lk.unlock(); return; } // 맨 앞의 페이지를 읽고 대기 목록에서 제거한다. std::string content = downloaded_pages-&gt;front(); downloaded_pages-&gt;pop(); (*num_processed)++; lk.unlock(); // content 를 처리한다. std::cout &lt;&lt; content; std::this_thread::sleep_for(std::chrono::milliseconds(80)); }
} int main() { // 현재 다운로드한 페이지들 리스트로, 아직 처리되지 않은 것들이다. std::queue&lt;std::string&gt; downloaded_pages; std::mutex m; std::condition_variable cv; std::vector&lt;std::thread&gt; producers; for (int i = 0; i &lt; 5; i++) { producers.push_back( std::thread(producer, &amp;downloaded_pages, &amp;m, i + 1, &amp;cv)); } int num_processed = 0; std::vector&lt;std::thread&gt; consumers; for (int i = 0; i &lt; 3; i++) { consumers.push_back( std::thread(consumer, &amp;downloaded_pages, &amp;m, &amp;num_processed, &amp;cv)); } for (int i = 0; i &lt; 5; i++) { producers[i].join(); } // 나머지 자고 있는 쓰레드들을 모두 깨운다. cv.notify_all(); for (int i = 0; i &lt; 3; i++) { consumers[i].join(); }
}
std::unique_lock&lt;std::mutex&gt; lk(*m); cv-&gt;wait(lk, [&amp;] { return !downloaded_pages-&gt;empty() || *num_processed == 25; });
<br>condition_variable&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수에 어떤 조건이 참이 될 때 까지 기다릴지 해당 조건을 인자로 여러 쓰레드에서 같은 객체의 값을 수정한다면 Race Condition 이 발생합니다. 이를 해결하기 위해서는 여러가지 방법이 있지만, 한 가지 방법으로 뮤텍스를 사용하는 방법이 있습니다. 뮤텍스는 한 번에 한 쓰레드에서만 획득할 수 있습니다. 획득한 뮤텍스는&nbsp;반드시&nbsp;반환해야 합니다.&nbsp;lock_guard&nbsp;나&nbsp;unique_lock&nbsp;등을 이용하면 뮤텍스의 획득-반환을 손쉽게 처리할 수 있습니다. 뮤텍스를 사용할 때 데드락이 발생하지 않도록 주의해야 합니다. 데드락을 디버깅하는 것은 매우 어렵습니다.&nbsp;condition_variable&nbsp;을 사용하면 생산자-소비자 패턴을 쉽게 구현할 수 있습니다.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/concurrency/2.-mutex,-deadlock.html</link><guid isPermaLink="false">CPP/Concurrency/2. Mutex, deadlock.md</guid><pubDate>Sun, 02 Feb 2025 04:26:15 GMT</pubDate><enclosure url="images/cpp_13.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_13.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. memory order, atomic]]></title><description><![CDATA[CPU 와 컴퓨터 메모리인 RAM 은 물리적으로 떨어져 있습니다. 따라서 CPU 가 메모리에서 데이터를 읽어 오기 위해서는 꽤 많은 시간이 걸립니다. 실제로, 인텔의 i7-6700 CPU 의 경우 최소 42 사이클 정도 걸린다고 보시면 됩니다. CPU 에서 덧셈 한 번을 1 사이클에 끝낼 수 있는데, 메모리에서 데이터 오는 것을 기다리느라, 42 번 덧셈을 연산할 시간을 놓치게 되는 것CPU 에서 연산을 수행하는 부분이랑 거의 붙어 있다 싶이 해서, 읽기 / 쓰기 속도가 매우 빠르다는 점입니다.
CPU 에서 가장 많이 접근하는 메모리 영역은 L1 캐시에 가져다 놓게 되고, 그 다음으로, 자주 접근하는 부분은 L2, 마지막으로 L3 캐시 순임CPU 가 특정한 주소에 있는 데이터에 접근하려 한다면, 일단 캐시에 있는지 확인한 후, 캐시에 있다면 해당 값을 읽고, 없다면 메모리 까지 갔다 오는 방식으로 진행됩니다. 이렇게 캐시에 있는 데이터를 다시 요청해서 시간을 절약하는 것을&nbsp;Cache hit&nbsp;이라과 하며 반대로 캐시에 요청한 데이터가 없어서 메모리 까지 갔다 오는 것을&nbsp;Cache miss&nbsp;라고 부릅니다.&nbsp;CPU 가 어떻게 어느 영역의 메모리에 자주 접근할 지 어떻게 아는 것일까요? 답은&nbsp;알 수 없다&nbsp;입니다. 따라서 보통 CPU 에서 캐시가 작동하는 방식은 다음과 같습니다.&nbsp;
메모리를 읽으면 일단 캐시에 저장해놓는다.
만일 캐시가 다 찼다면 특정한 방식에 따라 처리한다. (LRU: Least Recently Used)
예를 들어서 캐시 크기가 1 KB 밖에 안되고 LRU 방식을 사용하는 CPU 가 있다고 했을 때 첫 번째 코드가 더 빠르게 작동할까요? 아니면 두 번째 코드가 더 빨리 작동할까요? 두 코드는 동일한 연산을 수행합니다.for (int i = 0; i &lt; 10000; i++) { for (int j = 0; j &lt; 10000; j++) { s += data[j]; }
}
for (int j = 0; j &lt; 10000; j++) { for (int i = 0; i &lt; 10000; i++) { s += data[j]; }
}
답은 두 번째 방식입니다. 왜냐하면 첫 번째 경우에서&nbsp;data[0]&nbsp;를 접근하는 것을 생각해봅시다. 일단 첫 번째 루프에서&nbsp;data[0]&nbsp;는 캐시에 들어가게 됩니다. 하지만, CPU 캐시가 매우 작기 때문에&nbsp;j = 256&nbsp;이 되었을 때&nbsp;data[0]&nbsp;는 캐시에서 사라지게 되지요 (1KB = 1024 byte = int 256 개).따라서&nbsp;i = 1&nbsp;인 루프에서&nbsp;data[0]&nbsp;에 다시 접근했을 때 이미&nbsp;data[0]&nbsp;는 캐시에서 사라진 이후기에 Cache Miss 가 발생하게 됩니다. 따지고 보면&nbsp;data&nbsp;원소의 모든 접근이 Cache Miss 가 되서 느리겠지요.반면에 후자의 경우&nbsp;data[0]&nbsp;을&nbsp;10000&nbsp;번 연속으로 접근하므로, 처음에 접근할 때 빼고 나머지&nbsp;9999&nbsp;번 접근이 Cache hit 이 되어서 빠르게 덧셈을 수행할 수 있게 됩니다.컴파일러는 지 알아서 명령어 재배치를 함.이와 같이, 한 작업 (세탁 - 건조 - 개기) 이 끝나기 전에, 다음 작업을 시작하는 방식으로 동시에 여러 개의 작업을 동시에 실행하는 것을&nbsp;파이프라이닝(pipelining)&nbsp;이라고 합니다.
CPU 에서 명령어를 실행할 때 여러 단계를 거치게 됩니다. 명령어를 읽어야 하고 (fetch), 읽은 명령어가 무엇 인지 해석해야 하고 (decode), 해석된 명령어를 실행하고 (execute), 마지막으로 결과를 써야 하지요 (write).따라서, 컴파일러는 우리가 어떠한 최대한 CPU 의 파이프라인을 효율적으로 활용할 수 있도록 명령어를 재배치함.그리고 CPU도 캐시에 따라 실행 순서를 변경할 수 있음.명령어 순서도 뒤죽 박죽 바꾸고 심지어 CPU 에서도 명령어들을 제대로 된 순서로 실행하지 않는다면, 도대체 무엇을 믿을 수 있을까?C++ 의 모든 객체들은&nbsp;수정 순서(modification order)&nbsp;라는 것을 정의
C++ 에서 보장하는 사실은, 원자적 연산을 할 경우에 모든 쓰레드에서 같은 객체에 대해서 동일한 수정&nbsp;순서&nbsp;를 관찰할 수 있다는 사실입니다.같은 시간에 변수&nbsp;a&nbsp;의 값을 관찰했다고 해서 굳이&nbsp;모든 쓰레드들이 동일한 값을 관찰할 필요는 없다 라는 점원자적 연산이란, CPU 가 명령어 1 개로 처리하는 명령으로, 중간에 다른 쓰레드가 끼어들 여지가 전혀 없는 연산
C++ 에서는 몇몇 타입들에 원자적인 연산을 쉽게 할 수 있도록 여러가지 도구들을 지원하고 있습니다. 또한 이러한 원자적 연산들은 올바른 연산을 위해 굳이 뮤텍스가 필요하지 않습니다! 즉 속도가 더 빠름#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void worker(std::atomic&lt;int&gt;&amp; counter) { for (int i = 0; i &lt; 10000; i++) { counter++; }
} int main() { std::atomic&lt;int&gt; counter(0); std::vector&lt;std::thread&gt; workers; for (int i = 0; i &lt; 4; i++) { workers.push_back(std::thread(worker, ref(counter))); } for (int i = 0; i &lt; 4; i++) { workers[i].join(); } std::cout &lt;&lt; "Counter 최종 값 : " &lt;&lt; counter &lt;&lt; std::endl;
}
어셈블리를 까보면lock add DWORD PTR [rdi], 1
이런 부분이 나오는데, x86 컴파일러가 알고 있었기 때문에 사용가능한거.CPU에 따라 사용 못할 수도 있음. 이러한 연산이 가능한지 확인하는 방법std::atomic&lt;int&gt; x;
std::cout &lt;&lt; "is lock free ? : " &lt;&lt; boolalpha &lt;&lt; x.is_lock_free() &lt;&lt; std::endl;
atomic&nbsp;객체들의 경우 원자적 연산 시에 메모리에 접근할 때 어떠한 방식으로 접근하는지 지정할 수 있습니다.가장&nbsp;느슨한&nbsp;조건입니다. 다시 말해,&nbsp;memory_order_relaxed&nbsp;방식으로 메모리에서 읽거나 쓸 경우, 주위의 다른 메모리 접근들과 순서가 바뀌어도 무방#include &lt;atomic&gt;
#include &lt;cstdio&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
using std::memory_order_relaxed; void t1(std::atomic&lt;int&gt;* a, std::atomic&lt;int&gt;* b) { b-&gt;store(1, memory_order_relaxed); // b = 1 (쓰기) int x = a-&gt;load(memory_order_relaxed); // x = a (읽기) printf("x : %d \n", x);
} void t2(std::atomic&lt;int&gt;* a, std::atomic&lt;int&gt;* b) { a-&gt;store(1, memory_order_relaxed); // a = 1 (쓰기) int y = b-&gt;load(memory_order_relaxed); // y = b (읽기) printf("y : %d \n", y);
} int main() { std::vector&lt;std::thread&gt; threads; std::atomic&lt;int&gt; a(0); std::atomic&lt;int&gt; b(0); threads.push_back(std::thread(t1, &amp;a, &amp;b)); threads.push_back(std::thread(t2, &amp;a, &amp;b)); for (int i = 0; i &lt; 2; i++) { threads[i].join(); }
}
x : 1 y : 0 or x : 0 y : 1 or y : 1 x : 1 이 경우는 가능할까?
x : 0 y : 0 x : 0
y : 0위 명령어들이 순서대로 실행된다면 이는 불가능 하다는 사실을 알 수 있습니다.
하지만, 메모리 연산들 사이에서 어떠한 제약조건도 없다고 하였습니다. 다시 말해 서로 다른 변수의&nbsp;relaxed&nbsp;메모리 연산은 CPU 마음대로 재배치 할 수 있습니다 (단일 쓰레드 관점에서 결과가 동일하다면)..emory_order_relaxed&nbsp;는 CPU 에서 메모리 연산 순서에 관련해서 무한한 자유를 주는 것과 같습니다. 덕분에 CPU 에서 매우 빠른 속도로 실행할 수 있게됩니다.#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; void producer(std::atomic&lt;bool&gt;* is_ready, int* data) { *data = 10; is_ready-&gt;store(true, std::memory_order_release);
} void consumer(std::atomic&lt;bool&gt;* is_ready, int* data) { // data 가 준비될 때 까지 기다린다. while (!is_ready-&gt;load(std::memory_order_acquire)) { } std::cout &lt;&lt; "Data : " &lt;&lt; *data &lt;&lt; std::endl;
} int main() { std::vector&lt;std::thread&gt; threads; std::atomic&lt;bool&gt; is_ready(false); int data = 0; threads.push_back(std::thread(producer, &amp;is_ready, &amp;data)); threads.push_back(std::thread(consumer, &amp;is_ready, &amp;data)); for (int i = 0; i &lt; 2; i++) { threads[i].join(); }
}
data&nbsp;에 0 이 들어가는 일 불가능!memory_order_release&nbsp;는&nbsp;해당 명령 이전의 모든 메모리 명령들이 해당 명령 이후로 재배치 되는 것을 금지
또한, 만약에 같은 변수를&nbsp;memory_order_acquire&nbsp;으로 읽는 쓰레드가 있다면,&nbsp;memory_order_release&nbsp;이전에 오는 모든 메모리 명령들이 해당 쓰레드에 의해서&nbsp;관찰&nbsp;될 수 있어야 합니다.쉽게 말해&nbsp;is_ready-&gt;storememory_order_release;&nbsp;밑으로&nbsp;*data = 10&nbsp;이 올 수 없게 됩니다. 또한&nbsp;is_ready&nbsp;가&nbsp;true&nbsp;가 된다면,&nbsp;memory_order_acquire&nbsp;로&nbsp;is_ready&nbsp;를 읽는 쓰레드에서&nbsp;data&nbsp;의 값을 확인했을 때&nbsp;10&nbsp;임을 관찰할 수 있어야하죠.memory_order_acquire&nbsp;의 경우,&nbsp;release&nbsp;와는 반대로&nbsp;해당 명령 뒤에 오는 모든 메모리 명령들이 해당 명령 위로 재배치 되는 것을 금지&nbsp;합니다.이와 같이 두 개의 다른 쓰레드들이 같은 변수의&nbsp;release&nbsp;와&nbsp;acquire&nbsp;를 통해서&nbsp;동기화 (synchronize)&nbsp;를 수행하는 것을 볼 수 있습니다.memory_order_acq_rel&nbsp;은 이름에서도 알 수 있듯이,&nbsp;acquire&nbsp;와&nbsp;release&nbsp;를 모두 수행하는 것입니다. 이는, 읽기와 쓰기를 모두 수행하는 명령들, 예를 들어서&nbsp;fetch_add&nbsp;와 같은 함수에서 사용될 수 있습니다.memory_order_seq_cst&nbsp;는 메모리 명령의&nbsp;순차적 일관성(sequential consistency)&nbsp;을 보장해줍니다.순차적 일관성이란, 메모리 명령 재배치도 없고, 모든 쓰레드에서 모든 시점에 동일한 값을 관찰할 수 있는, 여러분이 생각하는 그대로 CPU 가 작동하는 방식#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt; std::atomic&lt;bool&gt; x(false);
std::atomic&lt;bool&gt; y(false);
std::atomic&lt;int&gt; z(0); void write_x() { x.store(true, std::memory_order_release); } void write_y() { y.store(true, std::memory_order_release); } void read_x_then_y() { while (!x.load(std::memory_order_acquire)) { } if (y.load(std::memory_order_acquire)) { ++z; }
} void read_y_then_x() { while (!y.load(std::memory_order_acquire)) { } if (x.load(std::memory_order_acquire)) { ++z; }
} int main() { thread a(write_x); thread b(write_y); thread c(read_x_then_y); thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); std::cout &lt;&lt; "z : " &lt;&lt; z &lt;&lt; std::endl;
}
실행결과
z : 0
or
z : 1
or
z : 2
왜 0이 나올 수 있을까?memory_order_seq_cst&nbsp;를 사용하게 된다면, 해당 명령을 사용하는 메모리 연산들 끼리는 모든 쓰레드에서 동일한 연산 순서를 관찰할 수 있도록 보장#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using std::memory_order_seq_cst;
using std::thread; std::atomic&lt;bool&gt; x(false);
std::atomic&lt;bool&gt; y(false);
std::atomic&lt;int&gt; z(0); void write_x() { x.store(true, memory_order_seq_cst); } void write_y() { y.store(true, memory_order_seq_cst); } void read_x_then_y() { while (!x.load(memory_order_seq_cst)) { } if (y.load(memory_order_seq_cst)) { ++z; }
} void read_y_then_x() { while (!y.load(memory_order_seq_cst)) { } if (x.load(memory_order_seq_cst)) { ++z; }
} int main() { thread a(write_x); thread b(write_y); thread c(read_x_then_y); thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); std::cout &lt;&lt; "z : " &lt;&lt; z &lt;&lt; std::endl;
}
z : 2 or z : 1
z&nbsp;의 값이 0 이 되는 경우는 발생X
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/concurrency/3.-memory-order,-atomic.html</link><guid isPermaLink="false">CPP/Concurrency/3. memory order, atomic.md</guid><pubDate>Sun, 02 Feb 2025 04:26:10 GMT</pubDate></item><item><title><![CDATA[4. future, async, promise]]></title><description><![CDATA[c++ 초기에는 비동기 하려면 쓰레드로 직접 했어야 했다.
c++11 std에서 도구 제공 되기 시작.동기적 실행으로 하고 싶은 일은, 어떠한 데이터를 다른 쓰레드를 통해 처리해서 받아내는 것
어떤 쓰레드 T 를 사용해서, 비동기적으로 값을 받아내겠다 라는 의미는,&nbsp;미래에 (future) 쓰레드 T 가 원하는 데이터를 돌려 주겠다 라는 약속 (promise) 라고 볼 수 있습니다.#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
using std::string; void worker(std::promise&lt;string&gt;* p) { // 약속을 이행하는 모습. 해당 결과는 future 에 들어간다. p-&gt;set_value("some data");
}
int main() { std::promise&lt;string&gt; p; // 미래에 string 데이터를 돌려 주겠다는 약속. std::future&lt;string&gt; data = p.get_future(); std::thread t(worker, &amp;p); // 미래에 약속된 데이터를 받을 때 까지 기다린다. data.wait(); // wait 이 리턴했다는 뜻이 future 에 데이터가 준비되었다는 의미. // 참고로 wait 없이 그냥 get 해도 wait 한 것과 같다. std::cout &lt;&lt; "받은 데이터 : " &lt;&lt; data.get() &lt;&lt; std::endl; t.join(); }
promise&nbsp;객체는 자신이 가지고 있는&nbsp;future&nbsp;객체에 값을 넣어주게 됩니다.
대응되는&nbsp;future&nbsp;객체의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수를 통해 얻어낼 수 있습니다. 한 가지 중요한 점은&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 값을 전달하기 전 까지&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수가 기다린다는 점입니다.&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수가 리턴을 하였다면&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 통해서&nbsp;future&nbsp;에 전달된 객체를 얻을 수 있습니다.<br>참고로 굳이&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;함수를 따로 호출할 필요는 없는데,&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수를 바로 호출하더라도 알아서&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 객체를 전달할 때 까지 기다린다음에 리턴합니다. 참고로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 호출하면&nbsp;future&nbsp;내에 있던 데이터가 이동 됩니다. 따라서&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 다시 호출하면 안됩니다.`future`&nbsp;에서 get 을 호출하면, 설정된 객체가&nbsp;이동&nbsp;됩니다. 따라서 절대로&nbsp;get을 두 번 호출하면 안됩니다.
<br>그냥&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/wait-fwait" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/wait-fwait" target="_self">wait</a>&nbsp;을 하였다면&nbsp;promise&nbsp;가&nbsp;future&nbsp;에 전달할 때 까지 기다리게 됩니다. 하지만&nbsp;wait_for&nbsp;을 사용하면, 정해진 시간 동안만 기다리고 그냥 진행할 수 있습니다.#include &lt;chrono&gt;
#include &lt;exception&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt; void worker(std::promise&lt;void&gt;* p) { std::this_thread::sleep_for(std::chrono::seconds(10)); p-&gt;set_value();
}
int main() { // void 의 경우 어떠한 객체도 전달하지 않지만, future 가 set 이 되었냐 // 안되었느냐의 유무로 마치 플래그의 역할을 수행할 수 있습니다. std::promise&lt;void&gt; p; // 미래에 string 데이터를 돌려 주겠다는 약속. std::future&lt;void&gt; data = p.get_future(); std::thread t(worker, &amp;p); // 미래에 약속된 데이터를 받을 때 까지 기다린다. while (true) { std::future_status status = data.wait_for(std::chrono::seconds(1)); // 아직 준비가 안됨 if (status == std::future_status::timeout) { std::cerr &lt;&lt; "&gt;"; } // promise 가 future 를 설정함. else if (status == std::future_status::ready) { break; } } t.join();
}
future_status&nbsp;는 총 3 가지 상태를 가질 수 있습니다. 먼저&nbsp;future&nbsp;에 값이 설정 됬을 때 나타나는&nbsp;future_status::ready&nbsp;가 있고,&nbsp;wait_for&nbsp;에 지정한 시간이 지났지만 값이 설정되지 않아서 리턴한 경우에는&nbsp;future_status::timeout&nbsp;이 리턴됩니다.마지막으로&nbsp;future_status::deferred&nbsp;가 있는데 이는 결과값을 계산하는 함수가 채 실행되지 않았다는 의미인데, 뒤에서 좀더 자세히 다루도록 하겠습니다.<br>앞서&nbsp;future&nbsp;의 경우 딱 한 번만&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 할 수 있다고 하였습니다. 왜냐하면&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 호출하면&nbsp;future&nbsp;내부의 객체가 이동되기 때문<br>but 종종 여러 개의 다른 쓰레드에서&nbsp;future&nbsp;를&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;할 필요성이 있음#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using std::thread; void runner(std::shared_future&lt;void&gt; start) { start.get(); std::cout &lt;&lt; "출발!" &lt;&lt; std::endl;
} int main() { std::promise&lt;void&gt; p; std::shared_future&lt;void&gt; start = p.get_future(); thread t1(runner, start); thread t2(runner, start); thread t3(runner, start); thread t4(runner, start); // 참고로 cerr 는 std::cout 과는 다르게 버퍼를 사용하지 않기 때문에 터미널에 // 바로 출력된다. std::cerr &lt;&lt; "준비..."; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cerr &lt;&lt; "땅!" &lt;&lt; std::endl; p.set_value(); t1.join(); t2.join(); t3.join(); t4.join();
}
C++ 에서는 위&nbsp;promise-future&nbsp;패턴을 비동기적 함수(정확히는 Callable - 즉 람다 함수, Functor 포함) 의 리턴값에 간단히 적용할 수 있는&nbsp;packaged_task&nbsp;라는 것을 지원<br>
<img alt="cpp_14.png" src="images/cpp_14.png" target="_self">#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt; int some_task(int x) { return 10 + x; } int main() { // int(int) : int 를 리턴하고 인자로 int 를 받는 함수. (std::function 참조) std::packaged_task&lt;int(int)&gt; task(some_task); std::future&lt;int&gt; start = task.get_future(); std::thread t(std::move(task), 5); std::cout &lt;&lt; "결과값 : " &lt;&lt; start.get() &lt;&lt; std::endl; t.join();
}
<br>생성된&nbsp;packaged_task&nbsp;를 쓰레드에 전달하면 됩니다. 참고로&nbsp;packaged_task&nbsp;는 복사 생성이 불가능하므로 (promise&nbsp;도 마찬가지 입니다.) 명시적으로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/301" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/301" target="_self">move</a>&nbsp;해줘야만 합니다.<br>비동기적으로 실행된 함수의 결과값은 추후에&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수로 받을 수 있게 됩니다. 이와 같이&nbsp;packaged_task&nbsp;를 사용하게 된다면 쓰레드에 굳이&nbsp;promise&nbsp;를 전달하지 않아도 알아서&nbsp;packaged_task&nbsp;가 함수의 리턴값을 처리해줘서 매우 편리 -&gt; some_task 함수에 set_value() 같은 거 없음std::async&nbsp;에 어떤 함수를 전달한다면, 아예 쓰레드를 알아서 만들어서 해당 함수를 비동기적으로 실행하고, 그 결과값을&nbsp;future&nbsp;에 전달즉 thread 만들 필요 없음parallel&nbsp;함수는 1 부터 1000 까지의 덧셈을 총 2 개의 쓰레드에서 실행한다고 보면 됩니다. 1 부터 500 까지의 합은,&nbsp;async&nbsp;를 통해 생성된 새로운 쓰레드에서 더하게 되고, 나머지 501 부터 1000 까지의 합은 원래의 쓰레드에서 처리하게 되죠.#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; // std::accumulate 와 동일
int sum(const std::vector&lt;int&gt;&amp; v, int start, int end) { int total = 0; for (int i = start; i &lt; end; ++i) { total += v[i]; } return total;
} int parallel_sum(const std::vector&lt;int&gt;&amp; v) { // lower_half_future 는 1 ~ 500 까지 비동기적으로 더함 // 참고로 람다 함수를 사용하면 좀 더 깔끔하게 표현할 수 도 있다. // --&gt; std::async([&amp;v]() { return sum(v, 0, v.size() / 2); }); std::future&lt;int&gt; lower_half_future = std::async(std::launch::async, sum, cref(v), 0, v.size() / 2); // upper_half 는 501 부터 1000 까지 더함 int upper_half = sum(v, v.size() / 2, v.size()); return lower_half_future.get() + upper_half;
} int main() { std::vector&lt;int&gt; v; v.reserve(1000); for (int i = 0; i &lt; 1000; ++i) { v.push_back(i + 1); } std::cout &lt;&lt; "1 부터 1000 까지의 합 : " &lt;&lt; parallel_sum(v) &lt;&lt; std::endl;
}
async&nbsp;함수는 인자로 받은 함수를 비동기적으로 실행한 후에, 해당 결과값을 보관할&nbsp;future&nbsp;를 리턴합니다. 첫 번째 인자로는 어떠한 형태로 실행할지를 전달하는데 두 가지 값이 가능합니다.
std::launch::async&nbsp;: 바로 쓰레드를 생성해서 인자로 전달된 함수를 실행한다. <br>std::launch::deferred&nbsp;:&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;함수가 호출되었을 때 실행한다. (새로운 쓰레드를 생성하지 않음) <br>즉&nbsp;launch::async&nbsp;옵션을 주면 바로 그 자리에서 쓰레드를 생성해서 실행하게 되고,&nbsp;launch::deferred&nbsp;옵션을 주면,&nbsp;future&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/191" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/191" target="_self">get</a>&nbsp;을 하였을 때 비로소 (동기적으로) 실행하게 됩니다. 다시 말해, 해당 함수를 굳이 바로 당장 비동기적으로 실행할 필요가 없다면&nbsp;deferred&nbsp;옵션을 주면 됩니다.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/concurrency/4.-future,-async,-promise.html</link><guid isPermaLink="false">CPP/Concurrency/4. future, async, promise.md</guid><pubDate>Sun, 02 Feb 2025 04:26:06 GMT</pubDate><enclosure url="images/cpp_14.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_14.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5. 비동기, promise & future, callback, async, ThreadPool]]></title><description><![CDATA[
개념: "나중에 끝날 작업을 시작하고, 다른 일을 하는 것"
일종의 프로그래밍 패러다임
Promise &amp; Future, Callback은 비동기를 구현하는 서로 다른 방식
// 상황: 오래 걸리는 파일 읽기 작업 // 1. Promise/Future 방식
std::future&lt;string&gt; readFile(string path) { return std::async([path]() { // 파일 읽기 return content; });
} // 사용
auto future = readFile("data.txt");
// 다른 작업 수행
string content = future.get(); // 필요할 때 결과를 가져옴 // 2. Callback 방식
void readFile(string path, function&lt;void(string)&gt; callback) { std::thread([path, callback]() { // 파일 읽기 callback(content); // 완료되면 callback 호출 }).detach();
} // 사용
readFile("data.txt", [](string content) { // 여기서 결과 처리
}); 결과 처리 방식 Promise/Future: 결과가 필요한 시점에 우리가 직접 가져옴 (get)
Callback: 결과가 준비되면 자동으로 호출 코드 구조 Promise/Future: 선형적
Callback: 중첩될 수록 복잡 예외처리
// Promise/Future
try { auto result = future.get();
} catch (exception&amp; e) { // 에러 처리
} // Callback
readFile("data.txt", [](string content) { /* 성공 처리 */ }, [](error_code e) { /* 에러 처리 */ }
); Promise/Future 선호 상황 결과를 특정 시점에 확실히 필요로 할 때
여러 비동기 작업의 결과를 한번에 모아야 할 때
예외 처리가 중요할 때 Callback 선호 상황 이벤트 기반 프로그래밍
GUI 프로그래밍
결과를 즉시 처리해야 할 때 std::async는 C++11에서 도입된 고수준 비동기 실행 도구. 쓰레드 생성과 관리를 자동으로 처리해주는 편리한 함수// 기본적인 async 사용
std::future&lt;int&gt; result = std::async([]() { return 42; // 비동기로 실행될 작업
});
[async의 장점]
쓰레드 관리 자동화 직접 std::thread를 생성/관리할 필요가 없습니다
리소스 정리가 자동으로 이루어집니다. 예외 처리 용이
try { auto future = std::async([]() { throw std::runtime_error("에러 발생!"); }); future.get(); // 예외가 여기서 캐치됩니다
} catch (const std::exception&amp; e) { std::cout &lt;&lt; "에러: " &lt;&lt; e.what() &lt;&lt; std::endl;
}
stdasync vs ThreadPool std::async 간단한 비동기 작업에 적합
시스템이 쓰레드 관리
작업량이 적을 때 사용 ThreadPool 많은 작업을 효율적으로 처리
쓰레드 재사용으로 성능 향상
대규모 작업에 적합 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/concurrency/5.-비동기,-promise-&amp;-future,-callback,-async,-threadpool.html</link><guid isPermaLink="false">CPP/Concurrency/5. 비동기, promise &amp; future, callback, async, ThreadPool.md</guid><pubDate>Sun, 02 Feb 2025 04:26:02 GMT</pubDate></item><item><title><![CDATA[6. ThreadPool]]></title><description><![CDATA[#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; namespace ThreadPool {
class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); // job 을 추가한다. void EnqueueJob(std::function&lt;void()&gt; job); private: // 총 Worker 쓰레드의 개수. size_t num_threads_; // Worker 쓰레드를 보관하는 벡터. std::vector&lt;std::thread&gt; worker_threads_; // 할일들을 보관하는 job 큐. std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 위의 job 큐를 위한 cv 와 m. std::condition_variable cv_job_q_; std::mutex m_job_q_; // 모든 쓰레드 종료 bool stop_all; // Worker 쓰레드 void WorkerThread();
}; ThreadPool::ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_all(false) { worker_threads_.reserve(num_threads_); for (size_t i = 0; i &lt; num_threads_; ++i) { worker_threads_.emplace_back([this]() { this-&gt;WorkerThread(); }); }
} void ThreadPool::WorkerThread() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(m_job_q_); cv_job_q_.wait(lock, [this]() { return !this-&gt;jobs_.empty() || stop_all; }); if (stop_all &amp;&amp; this-&gt;jobs_.empty()) { return; } // 맨 앞의 job 을 뺀다. std::function&lt;void()&gt; job = std::move(jobs_.front()); jobs_.pop(); lock.unlock(); // 해당 job 을 수행한다 :) job(); }
} ThreadPool::~ThreadPool() { stop_all = true; cv_job_q_.notify_all(); for (auto&amp; t : worker_threads_) { t.join(); }
} void ThreadPool::EnqueueJob(std::function&lt;void()&gt; job) { if (stop_all) { throw std::runtime_error("ThreadPool 사용 중지됨"); } { std::lock_guard&lt;std::mutex&gt; lock(m_job_q_); jobs_.push(std::move(job)); } cv_job_q_.notify_one();
} } // namespace ThreadPool void work(int t, int id) { printf("%d start \n", id); std::this_thread::sleep_for(std::chrono::seconds(t)); printf("%d end after %ds\n", id, t);
} int main() { ThreadPool::ThreadPool pool(3); for (int i = 0; i &lt; 10; i++) { pool.EnqueueJob([i]() { work(i % 3 + 1, i); }); }
}
한계: 우리가 전달한 함수가 어떠한 값을 리턴할 때 입니다. 물론 그 함수에 포인터로 리턴값을 저장할 변수를 전달하면 되기는 합니다. 하지만, 기존의&nbsp;future&nbsp;처럼 그 값이 설정될 때 까지 기다리는 것은 불가능따라서 더 나은 구조로는&nbsp;EnqueueJob&nbsp;함수가 임의의 형태의 함수를 받고, 그 함수의 리턴값을 보관하는&nbsp;future&nbsp;를 리턴#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; namespace ThreadPool {
class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); // job 을 추가한다. template &lt;class F, class... Args&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; EnqueueJob( F f, Args... args); private: // 총 Worker 쓰레드의 개수. size_t num_threads_; // Worker 쓰레드를 보관하는 벡터. std::vector&lt;std::thread&gt; worker_threads_; // 할일들을 보관하는 job 큐. std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 위의 job 큐를 위한 cv 와 m. std::condition_variable cv_job_q_; std::mutex m_job_q_; // 모든 쓰레드 종료 bool stop_all; // Worker 쓰레드 void WorkerThread();
}; ThreadPool::ThreadPool(size_t num_threads) : num_threads_(num_threads), stop_all(false) { worker_threads_.reserve(num_threads_); for (size_t i = 0; i &lt; num_threads_; ++i) { worker_threads_.emplace_back([this]() { this-&gt;WorkerThread(); }); }
} void ThreadPool::WorkerThread() { while (true) { std::unique_lock&lt;std::mutex&gt; lock(m_job_q_); cv_job_q_.wait(lock, [this]() { return !this-&gt;jobs_.empty() || stop_all; }); if (stop_all &amp;&amp; this-&gt;jobs_.empty()) { return; } // 맨 앞의 job 을 뺀다. std::function&lt;void()&gt; job = std::move(jobs_.front()); jobs_.pop(); lock.unlock(); // 해당 job 을 수행한다 :) job(); }
} ThreadPool::~ThreadPool() { stop_all = true; cv_job_q_.notify_all(); for (auto&amp; t : worker_threads_) { t.join(); }
} template &lt;class F, class... Args&gt;
std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; ThreadPool::EnqueueJob( F f, Args... args) { if (stop_all) { throw std::runtime_error("ThreadPool 사용 중지됨"); } using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto job = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(std::bind(f, args...)); std::future&lt;return_type&gt; job_result_future = job-&gt;get_future(); { std::lock_guard&lt;std::mutex&gt; lock(m_job_q_); jobs_.push([job]() { (*job)(); }); } cv_job_q_.notify_one(); return job_result_future;
} } // namespace ThreadPool int work(int t, int id) { printf("%d start \n", id); std::this_thread::sleep_for(std::chrono::seconds(t)); printf("%d end after %ds\n", id, t); return t + id;
} int main() { ThreadPool::ThreadPool pool(3); std::vector&lt;std::future&lt;int&gt;&gt; futures; for (int i = 0; i &lt; 10; i++) { futures.emplace_back(pool.EnqueueJob(work, i % 3 + 1, i)); } for (auto&amp; f : futures) { printf("result : %d \n", f.get()); }
}
EnqueueJob&nbsp;함수의 경우 인자들의 복사본을 받는다는 것 하지만 이는 불필요한 복사를 야기하므로&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/228" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/228" target="_self">완벽한 전달</a>&nbsp;패턴을 사용EnqueueJob 파라미터에서 우측값 레퍼런스로 변경, bind 함수에 forward로 인자 전달#include &lt;condition_variable&gt;
#include &lt;cstdio&gt;
#include &lt;functional&gt;
#include &lt;future&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;vector&gt; class ThreadPool { public: ThreadPool(size_t num_threads); ~ThreadPool(); template &lt;class F, class... Args&gt; std::future&lt;typename std::invoke_result&lt;F, Args...&gt;::type&gt; EnqueueJob( F&amp;&amp; f, Args&amp;&amp;... args) { if (stop_all) { throw std::runtime_error("ThreadPool is stopped"); } using return_type = typename std::invoke_result&lt;F, Args...&gt;::type; auto job = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)); std::future&lt;return_type&gt; job_result_future = job-&gt;get_future(); jobs_.push([job]() { (*job)(); }); cv_job_q_.notify_one(); return job_result_future; } private: size_t num_threads_; std::vector&lt;std::thread&gt; worker_threads_; std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; std::condition_variable cv_job_q_; std::mutex m_job_q_; bool stop_all; void WorkerThread(); };
ThreadPool은 Thread에 일을 시키는 거야. 그러니까 Thread에 일을 시키기 위해서는 어떤 일을 할당할 지 함수를 매개변수로 넘겨 줘야해. c에서는 이걸 함수 포인터로 처리해 하지만 c++에서는 다른 방법이 있어. (1.이 부분을 좀 더 풀어서 설명하고 싶어. 지금과 같은 상황에서는 어떤 용어를 써야하지? )
그걸 템플릿 메서드를 이용해서 F f 로 받을거야.
우리가 넘겨줄 함수 f에는 매개변수가 들어갈수도 있어. 이 매개변수를 처리하기 위해 파라미터 팩을 이용할거야. class ... Args를 이용해서 함수 f의 매개변수의 값을 받는거지.return type은 비동기 처리를 위해서 future로 설정했어.
(2.이 부분이 비동기 처리를 위해서 future를 사용했는 지 확실하지 않아.)
그리고 invoke_result 함수를 통해서 함수 f의 리턴 값을 추론 할 수 있어.invoke_result를 이용해서 함수 f의 리턴 값 추론 하고 비동기 지원을 위해 future에 담아서 return 하는거지. (3.만약 future가 아니라면 어떻게 될까?)이제 함수 내용을 살펴보자stop_all 플래그가 이미 true면 runtime_error를 던져주자.리턴 타입이 너무 길어 그래서 using을 이용해서 return_type을 정의할게.이제 우리는 함수 f, f에 들어갈 파라미터 args, 그리고 함수 f의 리턴값이 준비되었어.이제 job을 만들거야. 이걸 shared_ptr로 만들자.
(4. 왜 인지 보충 설명이 필요해) 타입은 std::packaged_task&lt;return_type()&gt;이거야. (5.return_type을 packaged_task로 감싼 이유를 알려줘. 그냥 return_type을 사용하면 안되는건지..)그리고 bind 함수를 통해서 f와, args를 결합할거야.job_result_future = job-&gt;get_future();를 해서 패키지된 task에서 future를 추출했어.<br>(6. jobs_.push(<a data-tooltip-position="top" aria-label="" rel="noopener nofollow" class="external-link is-unresolved" href="" target="_self">job</a> { (*job)(); });를 하는 이유가 뭘까? 이 부분은 문법적으로 이해가 잘 가지 않아.)그런 다음에 job_result_future을 리턴할거야.main에서 사용법을 보자. EnqueueJob을 하고 값을 futres에 넣을거야.
futures는 job_result_future를 원소로 가지고 있고 이걸 .get을 하면 그 함수 내용이 실행될거야. get을 하면 함수가 실행되니까.
C와 C++의 함수 처리 방식 차이에 대해 설명하자면: C에서는 함수 포인터를 사용해서 콜백 함수를 전달하는데, 이는 문법이 복잡하고 타입 안전성이 떨어집니다. 반면 C++에서는 std::function이라는 개념을 사용합니다. 이것을 "함수 객체" 또는 "콜러블(callable) 객체"라고 부릅니다.
std::function은 일반 함수, 멤버 함수, 람다 함수 등 모든 종류의 호출 가능한 객체를 저장할 수 있어서 더 유연하고 안전합니다.
future의 비동기 처리 역할: 네, 정확합니다. std::future는 비동기 작업의 결과를 나중에 가져올 수 있게 해주는 객체입니다. 쓰레드 풀에서 작업이 완료되면, 그 결과를 future를 통해 메인 쓰레드에서 받아올 수 있습니다.
future를 사용하지 않았다면: 만약 future를 사용하지 않았다면: 작업의 완료 여부를 알 수 없습니다
작업의 결과값을 받아올 방법이 없습니다
작업이 실패했을 때 예외 처리를 할 수 없습니다
비동기 작업의 동기화가 매우 어려워집니다 shared_ptr을 사용하는 이유: shared_ptr을 사용하는 이유는 메모리 관리 때문입니다. job은 여러 쓰레드에서 공유될 수 있고, 마지막 쓰레드가 작업을 완료했을 때 자동으로 메모리가 해제되어야 합니다. shared_ptr은 이런 참조 카운팅을 자동으로 처리해줍니다.
packaged_task를 사용하는 이유: std::packaged_task는 함수와 그 결과를 연결해주는 래퍼(wrapper)입니다. 이것을 사용하는 이유는: 함수의 실행을 지연시킬 수 있습니다
함수의 결과를 future를 통해 받을 수 있습니다
예외 처리를 안전하게 할 수 있습니다
그냥 return_type만 사용하면 이런 기능들을 구현할 수 없습니다.
jobs_.push(job { (*job)(); }); 설명: 이 부분은 람다 함수를 만들어 큐에 push하는 것입니다. [job]은 람다 함수가 캡처할 변수입니다 (job을 람다 안에서 사용하기 위함)
()는 람다 함수의 매개변수입니다 (여기서는 없음)
{ (*job)(); }는 람다 함수의 본문입니다
이렇게 하는 이유는 job(packaged_task)을 나중에 실행하기 위해서입니다. 실제 실행은 WorkerThread에서 이루어집니다.왜 Mutex가 필요한지// mutex가 없다면 발생할 수 있는 문제 예시
std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 공유 자원 // 쓰레드 1이 작업을 추가하려고 함
jobs_.push(new_job); // 이 순간에 // 쓰레드 2가 작업을 가져가려고 함
auto job = jobs_.front(); // 동시 접근! 데이터 손상 발생!
왜 꼭 packaged_task를 사용해야하는 지 - 함수 실행 지연 &amp; 예외처리packaged_task는 "작업의 패키징"이 주 목적이고, future는 "결과값을 받는 것"이 주 목적// 1. std::future만 사용할 경우
std::future&lt;int&gt; future = std::async(작업함수);
// 이 시점에서 작업이 이미 시작됨! // 2. std::packaged_task 사용
std::packaged_task&lt;int()&gt; task(작업함수);
std::future&lt;int&gt; future = task.get_future();
// 이 시점에서는 작업이 시작되지 않음
// 나중에...
task(); // 이 시점에 작업 시작
[ThreadPool에서 필요한 이유]
작업 큐잉(Queueing)class ThreadPool { std::queue&lt;std::function&lt;void()&gt;&gt; jobs_; // 작업 대기열 // packaged_task를 사용하면: void addJob(std::packaged_task&lt;int()&gt; task) { jobs_.push([task = std::move(task)]() { task(); // 나중에 실행 가능 }); }
};
// ThreadPool이 하는 일:
1. 작업 받기
auto future = pool.EnqueueJob(work, args...); 2. 내부적으로는:
- packaged_task로 작업을 감싸서
- 큐에 저장했다가
- worker 쓰레드가 나중에 실행 // future만 사용하면:
- 작업이 즉시 시작되어 버림
- 큐잉이 불가능
- 쓰레드 풀의 의미가 없어짐
WorkerThread()에서 job(); 할 때 실제 실행// 1. main에서:
auto future = pool.EnqueueJob(work, 1, 2); // 2. EnqueueJob 내부:
jobs_.push([task]() { (*task)(); }); // 3. WorkerThread에서:
job(); // 실제로 work(1, 2)가 실행되는 시점! <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/concurrency/6.-threadpool.html</link><guid isPermaLink="false">CPP/Concurrency/6. ThreadPool.md</guid><pubDate>Sun, 02 Feb 2025 04:25:54 GMT</pubDate></item><item><title><![CDATA[7. random, chrono library]]></title><description><![CDATA[
&lt;random&gt;&nbsp;라이브러리를 활용한 난수 생성
&lt;chrono&gt;&nbsp;라이브러리를 활용한 시간 측정
C언어의 srand(), rand()는 좋은 품질의 난수열을 생성 못함.
선형 합동 생성기(LCG) 기반으로 예측 가능한 패턴 발생 주기가 RAND_MAX(보통 32767)로 제한되어 짧음
통계적 특성이 좋지 않아 시뮬레이션/암호화에 부적합
C언어의 srand(), rand()는 사용하지 말자.
대신에 C++의 random을 사용하자#include &lt;iostream&gt;
#include &lt;random&gt; int main() { // 시드값을 얻기 위한 random_device 생성. std::random_device rd; // random_device 를 통해 난수 생성 엔진을 초기화 한다. // 메르센 트위스터 알고리즘 난수 엔진 std::mt19937 gen(rd()); // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의. std::uniform_int_distribution&lt;int&gt; dis(0, 99); for (int i = 0; i &lt; 5; i++) { std::cout &lt;&lt; "난수 : " &lt;&lt; dis(gen) &lt;&lt; std::endl; }
}
이건 정규 분포#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;random&gt; int main() { std::random_device rd; std::mt19937 gen(rd()); std::normal_distribution&lt;double&gt; dist(/* 평균 = */ 0, /* 표준 편차 = */ 1); std::map&lt;int, int&gt; hist{}; for (int n = 0; n &lt; 10000; ++n) { ++hist[std::round(dist(gen))]; } for (auto p : hist) { std::cout &lt;&lt; std::setw(2) &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; std::string(p.second / 100, '*') &lt;&lt; " " &lt;&lt; p.second &lt;&lt; '\n'; }
}
-4 1
-3 38
-2 ****** 638
-1 ************************ 2407 0 ************************************** 3821 1 ************************ 2429 2 ***** 595 3 70 4 1
&lt;chrono&gt;&nbsp;는 4가지 주요 구성요소를 가짐
std::chrono::duration: 시간 간격 표현
std::chrono::time_point: 특정 시점 표현
std::chrono::system_clock: 시스템 시계
std::chrono::steady_clock: 단조 증가 시계 (주로 시간 측정에 사용)
time_point들이 연산하면 duration이 됨.#include &lt;chrono&gt;
using namespace std::chrono; // 현재 시간 얻기
auto now = system_clock::now(); // 시간 간격 정의
hours h(1); // 1시간
minutes m(30); // 30분
seconds s(15); // 15초
milliseconds ms(100); // 100밀리초 // 시간 계산
auto future = now + h + m; // 1시간 30분 후 // 시간 간격 측정
auto start = steady_clock::now();
// ... 작업 수행
auto end = steady_clock::now();
auto duration = duration_cast&lt;milliseconds&gt;(end - start); auto my_time_t = std::chrono::system_clock::to_time_t(boot);
std::tm* my_tm = std::gmtime(&amp;my_time_t); my_tm-&gt;tm_year;
my_tm-&gt;tm_mon;
my_tm-&gt;tm_mday;
my_tm-&gt;tm_hour;
my_tm-&gt;tm_min;
my_tm-&gt;tm_sec;
tm 구조체에서 tm_year는 1900년도부터의 연도 차이를 저장하도록 설계되어 있음.
2000년은 tm_year에 100으로 저장됨 (2000 - 1900 = 100)
2024년은 tm_year에 124로 저장됨 (2024 - 1900 = 124)
그래서 실제 연도를 얻으려면 항상 tm_year + 1900을 해야함
비슷하게, tm_mon도 0부터 시작하므로(0이 1월) 실제 월을 얻으려면 tm_mon + 1을 해야함.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/modern/7.-random,-chrono-library.html</link><guid isPermaLink="false">CPP/Modern/7. random, chrono library.md</guid><pubDate>Sun, 02 Feb 2025 04:25:50 GMT</pubDate></item><item><title><![CDATA[1. rvalue rvalue 참조]]></title><description><![CDATA[
rvalue란? 메모리상의 임시 값입니다
프로그램에서 곧 사라질 값입니다
주소를 가질 수 없는 값입니다 int a = 5 + 3; // 여기서 5 + 3이 rvalue
std::string str = std::string("hello"); // std::string("hello")가 rvalue rvalue 참조(&amp;&amp;)란? rvalue를 참조할 수 있는 특별한 참조 타입
C++11 // 1. 기본적인 rvalue와 참조
int&amp;&amp; rref = 42; // 42는 rvalue, rref는 rvalue 참조
int x = 10;
int&amp;&amp; rref2 = x; // 컴파일 에러! x는 lvalue이므로 rvalue 참조 불가능
int&amp;&amp; rref3 = std::move(x); // OK! std::move는 lvalue를 rvalue로 변환 // 2. 문자열 예제
std::string getName() { return "John"; // "John"은 임시 객체(rvalue)
} std::string&amp;&amp; name = getName(); // 임시 객체를 rvalue 참조로 받음
성능 최적화, 불필요한 복사 방지class BigData { int* data; size_t size;
public: // 이동 생성자 (rvalue 참조 사용) BigData(BigData&amp;&amp; other) noexcept { // 포인터만 복사 (매우 빠름) data = other.data; size = other.size; // 원본 무효화 other.data = nullptr; other.size = 0; }
}; rvalue 참조 변수는 lvalue
void process(int&amp;&amp; x) { int&amp;&amp; y = x; // 에러! x는 rvalue 참조지만, 그 자체는 lvalue입니다 int&amp;&amp; y = std::move(x); // OK
} std::move는 실제로 객체 이동X
std::string str = "hello";
std::move(str); // 아무 일도 일어나지 않음
std::string str2 = std::move(str); // 여기서 실제 이동 발생 rvalue: 임시적이고 곧 사라질 값
rvalue 참조(&amp;&amp;): 이러한 임시 값을 참조할 수 있는 방법
주요 용도: 이동 생성자와 이동 대입 연산자 구현
성능 최적화: 불필요한 복사를 줄이고 효율적인 리소스 이동 가능 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/modern/1.-rvalue-rvalue-참조.html</link><guid isPermaLink="false">CPP/Modern/1. rvalue rvalue 참조.md</guid><pubDate>Sun, 02 Feb 2025 04:25:41 GMT</pubDate></item><item><title><![CDATA[2. move, 레퍼런스 겹침 규칙]]></title><description><![CDATA[lvalue는 "주소가 있는 값"으로 생각할 수 있음
마치 우리가 집 주소로 찾아갈 수 있는 집처럼, 프로그램에서 다시 찾아갈 수 있는 위치를 가진 값rvalue는 "임시 값"으로 생각할 수 있음.
마치 계산기로 계산한 결과 값처럼, 잠시 존재했다가 사라지는 값int x = 10; // x는 lvalue
int y = x; // x는 lvalue
int z = x + y; // (x + y)는 rvalue
class String { char* data;
public: // 이동 생성자 String(String&amp;&amp; other) noexcept { data = other.data; // 데이터 포인터만 가져옴 other.data = nullptr; // 원본은 무효화 } // 이동 대입 연산자 String&amp; operator=(String&amp;&amp; other) noexcept { if (this != &amp;other) { delete[] data; // 기존 데이터 해제 data = other.data; // 새 데이터 이동 other.data = nullptr; // 원본 무효화 } return *this; }
}; // 사용 예시
String str1("Hello");
String str2 = std::move(str1); // str1의 내용이 str2로 이동됨
여기서 std::move는 실제로 객체를 이동시키지 않고, 단지 lvalue를 rvalue로 캐스팅하는 역할. 실제 이동은 이동 생성자나 이동 대입 연산자에서 일어남Perfect forwarding은 함수 템플릿에서 인자의 값 카테고리(lvalue/rvalue)를 그대로 유지하면서 전달하는 기능template&lt;typename T&gt;
void wrapper(T&amp;&amp; param) { // 보편 참조(universal reference) foo(std::forward&lt;T&gt;(param)); // perfect forwarding
} // 사용 예시
std::string str = "hello";
wrapper(str); // str은 lvalue로 전달됨
wrapper(std::string("world")); // 임시 객체는 rvalue로 전달됨
std::forward가 하는 일을 자세히 살펴보면:
lvalue가 전달되면 lvalue 참조로 전달
rvalue가 전달되면 rvalue 참조로 전달
이를 통해 얻는 이점:
불필요한 복사를 방지할 수 있습니다
인자의 원래 특성(lvalue/rvalue)을 그대로 보존할 수 있음
템플릿 기반의 제네릭 코드를 효율적으로 작성할 수 있음
class Widget { std::vector&lt;int&gt; data;
public: // 생성자에서 perfect forwarding 사용 template&lt;typename... Args&gt; Widget(Args&amp;&amp;... args) : data(std::forward&lt;Args&gt;(args)...) {}
}; // 사용 예시
std::vector&lt;int&gt; vec = {1, 2, 3};
Widget w1(vec); // lvalue로 전달 - 복사 발생
Widget w2(std::vector&lt;int&gt;{1,2,3}); // rvalue로 전달 - 이동 발생
move 의미론과 perfect forwarding은 현대 C++에서 성능 최적화의 핵심 요소이며, 특히 대용량 데이터를 다루는 프로그램에서 매우 중요한 역할.
이를 통해 불필요한 복사를 줄이고 더 효율적인 코드를 작성할 수 있음
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/modern/2.-move,-레퍼런스-겹침-규칙.html</link><guid isPermaLink="false">CPP/Modern/2. move, 레퍼런스 겹침 규칙.md</guid><pubDate>Sun, 02 Feb 2025 04:25:34 GMT</pubDate></item><item><title><![CDATA[3. RAII, unique ptr]]></title><description><![CDATA[C++ 창시자인 비야네 스트로스트룹은 C++ 에서 자원을 관리하는 방법으로 다음과 같은 디자인 패턴을 제안하였습니다. 바로 흔히&nbsp;RAII&nbsp;라 불리는&nbsp;자원의 획득은 초기화다&nbsp;- Resource Acquisition Is Initialization&nbsp;입니다. 이는 자원 관리를 스택에 할당한 객체를 통해 수행하는 것포인터는 객체가 아님. delete를 하지 않고 포인터가 유실되면 힙에 저장되어 있는 데이터는 그대로 남아있음.객체는 소멸될 떄 소멸자를 호출함.포인터 '객체' 로 만들어서 자신이 소멸 될 때 자신이 가리키고 있는 데이터도 같이&nbsp;delete&nbsp;하게 하면 됩니다. 즉, 자원 (이 경우 메모리) 관리를 스택의 객체 (포인터 객체) 를 통해 수행하게 되는 것임이러한 타입을 스마트 포인터라고 함.특정 객체에 유일한 소유권을 부여하는 포인터 객체를&nbsp;unique_ptr여기서 퀴즈!&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/301" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/301" target="_self">std::move</a>&nbsp;가 왜 필요할까요?void do_something() { std::unique_ptr&lt;A&gt; pa(new A()); std::cout &lt;&lt; "pa : "; pa-&gt;some(); // pb 에 소유권을 이전. std::unique_ptr&lt;A&gt; pb = std::move(pa); std::cout &lt;&lt; "pb : "; pb-&gt;some();
} unique_ptr는 리소스의 독점적 소유권을 보장하기 위해 복사를 허용하지 않습니다. 즉, 복사 생성자와 복사 대입 연산자가 delete되어 있죠.
대신 소유권을 이전하는 방법으로 이동 연산자와 이동 생성자를 사용할 수 있습니다. 이들은 rvalue 참조를 매개변수로 받도록 설계되어 있습니다.
그런데&nbsp;pa와 같은 기존 unique_ptr은 lvalue입니다. 이동 연산자/생성자는 rvalue 참조만 받을 수 있으므로, lvalue인&nbsp;pa를 직접 전달할 수는 없습니다.
여기서 std::move가 필요한 것입니다! move는 lvalue를 rvalue로 캐스팅해주는 역할을 합니다. 이렇게 rvalue가 된 포인터는 이동 연산자/생성자가 받을 수 있는 형태가 되어 소유권 이전이 가능해집니다.
결국 이는 C++의 타입 시스템이 value category(lvalue/rvalue)를 통해 리소스의 소유권 이전을 안전하게 관리하는 방식이라고 볼 수 있습니다.void do_something(std::unique_ptr&lt;A&gt;&amp; ptr) { ptr-&gt;do_sth(3); } int main() { std::unique_ptr&lt;A&gt; pa(new A()); do_something(pa);
}
void do_something(A* ptr) { ptr-&gt;do_sth(3); } int main() { std::unique_ptr&lt;A&gt; pa(new A()); do_something(pa.get());
}
두 차이점은?첫 번째 방식 (참조로 전달):void do_something(std::unique_ptr&lt;A&gt;&amp; ptr)
이 방식은 unique_ptr 자체를 참조로 받습니다. 이는 다음을 의미합니다:
함수가 unique_ptr의 전체 기능에 접근할 수 있습니다. 예를 들어 reset()을 호출하거나, 다른 객체로 재할당할 수 있습니다.
소유권 관점에서 보면, 함수가 포인터의 소유권에 영향을 미칠 수 있는 권한을 가집니다.
함수가 unique_ptr만 받을 수 있고, 일반 포인터는 받을 수 없습니다.
두 번째 방식 (raw 포인터로 전달):void do_something(A* ptr)
이 방식은 get()을 통해 내부의 raw 포인터만 전달합니다:
함수는 단순히 객체의 멤버에만 접근할 수 있습니다.
소유권과 관련된 어떤 작업도 할 수 없습니다.
이 함수는 더 유연합니다. unique_ptr 뿐만 아니라 shared_ptr, raw 포인터 등 다양한 소스로부터 포인터를 받을 수 있습니다.
일반적으로 두 번째 방식이 더 선호됩니다. 그 이유는:
함수의 의도가 더 명확합니다 - "나는 객체를 사용만 할 뿐, 소유권은 건드리지 않겠다"
더 유연합니다 - 다양한 포인터 타입과 함께 사용할 수 있습니다
SOLID 원칙 중 인터페이스 분리 원칙(Interface Segregation Principle)에 더 부합합니다 - 함수는 실제로 필요한 기능만 받습니다
만약 함수가 정말로 포인터의 소유권을 조작해야 한다면, 그때는 첫 번째 방식을 사용하는 것이 적절할 것입니다.c++14 std::make_unique#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt; class A { int *data; public: A(int i) { std::cout &lt;&lt; "자원을 획득함!" &lt;&lt; std::endl; data = new int[100]; data[0] = i; } void some() { std::cout &lt;&lt; "일반 포인터와 동일하게 사용가능!" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; "자원을 해제함!" &lt;&lt; std::endl; delete[] data; }
}; int main() { std::vector&lt;std::unique_ptr&lt;A&gt;&gt; vec; std::unique_ptr&lt;A&gt; pa(new A(1)); vec.push_back(pa); // 에러 발생 <br>삭제된&nbsp;unique_ptr&nbsp;의 복사 생성자에 접근하였기 때문이지요. 기본적으로&nbsp;vector&nbsp;의&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/185" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/185" target="_self">push_back</a>&nbsp;함수는 전달된 인자를 복사해서 집어 넣기 때문에 위와 같은 문제가 발생하게 되는 것이지요.<br>이를 방지하기 위해서는 명시적으로&nbsp;pa&nbsp;를&nbsp;vector&nbsp;안으로 이동 시켜주어야만 합니다. 즉&nbsp;<a data-tooltip-position="top" aria-label="https://modoocode.com/185" rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/185" target="_self">push_back</a>&nbsp;의 우측값 레퍼런스를 받는 버전이 오버로딩 될 수 있도록 말이지요. -&gt; move 이용int main() { std::vector&lt;std::unique_ptr&lt;A&gt;&gt; vec; std::unique_ptr&lt;A&gt; pa(new A(1)); vec.push_back(std::move(pa)); // 잘 실행됨
}
아니면 emplace_back 이용.먼저 perfect forwarding의 핵심을 상기해보면, 이는 함수 템플릿이 인자를 받아서 다른 함수로 전달할 때 인자의 값 카테고리(lvalue/rvalue)와 const/volatile 등의 특성을 그대로 보존하는 것입니다.emplace_back은 이 perfect forwarding을 활용해서 컨테이너 내부에서 객체를 직접 생성합니다. 기본적인 구현은 대략 이렇게 됩니다:template&lt;typename... Args&gt;
reference emplace_back(Args&amp;&amp;... args) { // 메모리 재할당이 필요한지 확인하고 처리 // perfect forwarding을 사용해 객체를 직접 생성 construct_at(data_ + size_, std::forward&lt;Args&gt;(args)...); ++size_; return back();
}
여기서 중요한 점은 Args&amp;&amp;...가 forwarding reference(universal reference)로 사용되어, 어떤 타입의 인자든 받을 수 있고, std::forward를 통해 그 특성을 완벽하게 보존주의할점은 아래 코드를 조심해야함. 어떤 생성자가 호출되는 지.std::vector&lt;std::vector&lt;int&gt;&gt; v;
v.emplace_back(100000); // 100000개의 원소를 가진 벡터를 추가하게 됨.
이건 생성자 정의.vector(size_type count); // count개의 기본값으로 초기화된 원소
vector(size_type count, const T&amp; value); // count개의 value로 초기화된 원소 <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/modern/3.-raii,-unique-ptr.html</link><guid isPermaLink="false">CPP/Modern/3. RAII, unique ptr.md</guid><pubDate>Sun, 02 Feb 2025 04:25:30 GMT</pubDate></item><item><title><![CDATA[5. callable etc.]]></title><description><![CDATA[Callable&nbsp;이란, 이름 그대로 나타내듯이 호출(Call) 할 수 있는 모든 것을 의미C++ 에서는 이러한&nbsp;Callable&nbsp;들을 객체의 형태로 보관할 수 있는&nbsp;std::function&nbsp;이라는 클래스를 제공합니다. C 에서의 함수 포인터는 진짜 함수들만 보관할 수 있는 객체라고 볼 수 있다면 이&nbsp;std::function&nbsp;의 경우 함수 뿐만이 아니라 모든&nbsp;Callable&nbsp;들을 보관할 수 있는 객체#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; int some_func1(const std::string&amp; a) { std::cout &lt;&lt; "Func1 호출! " &lt;&lt; a &lt;&lt; std::endl; return 0;
} struct S { void operator()(char c) { std::cout &lt;&lt; "Func2 호출! " &lt;&lt; c &lt;&lt; std::endl; }
}; int main() { std::function&lt;int(const std::string&amp;)&gt; f1 = some_func1; std::function&lt;void(char)&gt; f2 = S(); std::function&lt;void()&gt; f3 = []() { std::cout &lt;&lt; "Func3 호출! " &lt;&lt; std::endl; }; f1("hello"); f2('c'); f3();
}
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class A { int c; public: A(int c) : c(c) {} int some_func() { std::cout &lt;&lt; "내부 데이터 : " &lt;&lt; c &lt;&lt; std::endl; }
}; int main() { A a(5); std::function&lt;int()&gt; f1 = a.some_func;
}
이건 컴파일 오류test2.cc: In function 'int main()':
test2.cc:17:26: error: invalid use of non-static member function 'int A::some_func()' std::function&lt;int()&gt; f1 = a.some_func; ~~^~~~~~~~~
test2.cc:10:9: note: declared here int some_func() { ^~~~~~~~~
f1&nbsp;을 호출하였을 때, 함수의 입장에서 자신을 호출하는 객체가 무엇인지 알 길이 없기 때문에&nbsp;c&nbsp;를 참조 하였을 때 어떤 객체의&nbsp;c&nbsp;인지를 알 수 없겠지요. 따라서 이 경우&nbsp;f1&nbsp;에&nbsp;a&nbsp;에 관한 정보도 추가로 전달해야 합니다.사실 멤버 함수들은 구현 상 자신을 호출한 객체를 인자로 암묵적으로 받고 있었습니다.#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class A { int c; public: A(int c) : c(c) {} int some_func() { std::cout &lt;&lt; "비상수 함수: " &lt;&lt; ++c &lt;&lt; std::endl; return c; } int some_const_function() const { std::cout &lt;&lt; "상수 함수: " &lt;&lt; c &lt;&lt; std::endl; return c; } static void st() {}
}; int main() { A a(5); std::function&lt;int(A&amp;)&gt; f1 = &amp;A::some_func; std::function&lt;int(const A&amp;)&gt; f2 = &amp;A::some_const_function; /*
위와 같이 원래 인자에 추가적으로 객체를 받는 인자를 전달해주면 됩니다. 이 때 상수 함수의 경우 당연히 상수 형태로 인자를 받아야 하고 (`const A&amp;`), 반면에 상수 함수가 아닌 경우 단순히 `A&amp;` 의 형태로 인자를 받으면 되겠습니다. f1(a); f2(a);
*/
}
vector&nbsp;들을 가지는&nbsp;vector&nbsp;가 있을 때, 각각의&nbsp;vector&nbsp;들의 크기들을 벡터로 만들어주는 코드를 생각해봅시다.#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(b); container.push_back(d); container.push_back(a); container.push_back(c); vector&lt;int&gt; size_vec(4); std::transform(container.begin(), container.end(), size_vec.begin(), &amp;vector&lt;int&gt;::size); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; "벡터 크기 :: " &lt;&lt; *itr &lt;&lt; std::endl; }
}
위 코드를 컴파일 하면 아래와 같은 컴파일 오류왜 그럴까요? 이 역시 전달된&nbsp;size&nbsp;함수가 멤버 함수여서 발생하는 문제 입니다. 위 템플릿에&nbsp;&amp;vector&lt;int&gt;::size&nbsp;가 들어간다면 해당&nbsp;unary_op&nbsp;를 호출하는 부분은 아래와 같이 변환
// from
unary_op(*first1); // to로 변환됨
&amp;vector&lt;int&gt;::size(*first); // 멤버함수의 경우
(*first).(*&amp;vector&lt;int&gt;::size) // or
first-&gt;(*&amp;vector&lt;int&gt;::size)
// 둘중 하나로 호출해야함. c++ 규칙이니까 그래서 std::function을 이용해야함. std::function&nbsp;으로 변환해서 전달#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(a); container.push_back(b); container.push_back(c); container.push_back(d); std::function&lt;size_t(const vector&lt;int&gt;&amp;)&gt; sz_func = &amp;vector&lt;int&gt;::size; vector&lt;int&gt; size_vec(4); std::transform(container.begin(), container.end(), size_vec.begin(), sz_func); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; "벡터 크기 :: " &lt;&lt; *itr &lt;&lt; std::endl; }
}
근데 매번 function&nbsp;객체를 따로 만들어서 전달하는 것은 매우 귀찮습니다. 따라서 C++ 개발자들은 라이브러리에 위&nbsp;function&nbsp;객체를 리턴해버리는 함수를 추가#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using std::vector; int main() { vector&lt;int&gt; a(1); vector&lt;int&gt; b(2); vector&lt;int&gt; c(3); vector&lt;int&gt; d(4); vector&lt;vector&lt;int&gt;&gt; container; container.push_back(a); container.push_back(b); container.push_back(c); container.push_back(d); vector&lt;int&gt; size_vec(4); transform(container.begin(), container.end(), size_vec.begin(), std::mem_fn(&amp;vector&lt;int&gt;::size)); for (auto itr = size_vec.begin(); itr != size_vec.end(); ++itr) { std::cout &lt;&lt; "벡터 크기 :: " &lt;&lt; *itr &lt;&lt; std::endl; }
}
참고로&nbsp;mem_fn&nbsp;은 그리 자주 쓰이지는 않는데, 람다 함수로도 동일한 작업을 수행할 수 있기 때문입니다. 위 코드의 경우&nbsp;mem_fn&nbsp;대신에&nbsp;[](const auto&amp; v){ return v.size()}&nbsp;를 전달해도 동일한 작업을 수행합니다.mem_fn&nbsp;을 사용하기 위해서는&nbsp;&lt;functional&gt;&nbsp;헤더를 추가해야 하지만 람다함수는 그냥 쓸 수 있으니 좀 더 편리한 면이 있습니다. 물론, 코드 길이 면에서는&nbsp;mem_fn&nbsp;을 사용하는 것이 좀더 깔끔한 편입니다.std::bind는 함수 객체를 생성하는 도구로, 함수의 일부 인자를 고정하거나 인자의 순서를 변경할 수 있게 해줍니다.#include &lt;functional&gt;
#include &lt;iostream&gt; void add(int x, int y) { std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y &lt;&lt; std::endl;
} void subtract(int x, int y) { std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x - y &lt;&lt; std::endl;
}
int main() { auto add_with_2 = std::bind(add, 2, std::placeholders::_1); add_with_2(3); // 두 번째 인자는 무시된다. add_with_2(3, 4); auto subtract_from_2 = std::bind(subtract, std::placeholders::_1, 2); auto negate = std::bind(subtract, std::placeholders::_2, std::placeholders::_1); subtract_from_2(3); // 3 - 2 를 계산한다. negate(4, 2); // 2 - 4 를 계산한다
}
bind를 사용할 때 레퍼런스로 넘길 때 주의 해야함.#include &lt;functional&gt;
#include &lt;iostream&gt; struct S { int data; S(int data) : data(data) { std::cout &lt;&lt; "일반 생성자 호출!" &lt;&lt; std::endl; } S(const S&amp; s) { std::cout &lt;&lt; "복사 생성자 호출!" &lt;&lt; std::endl; data = s.data; } S(S&amp;&amp; s) { std::cout &lt;&lt; "이동 생성자 호출!" &lt;&lt; std::endl; data = s.data; }
}; void do_something(S&amp; s1, const S&amp; s2) { s1.data = s2.data + 3; } int main() { S s1(1), s2(2); std::cout &lt;&lt; "Before : " &lt;&lt; s1.data &lt;&lt; std::endl; // s1 이 그대로 전달된 것이 아니라 s1 의 복사본이 전달됨! auto do_something_with_s1 = std::bind(do_something, s1, std::placeholders::_1); do_something_with_s1(s2); std::cout &lt;&lt; "After :: " &lt;&lt; s1.data &lt;&lt; std::endl;
}
일반 생성자 호출!
일반 생성자 호출!
Before : 1
복사 생성자 호출!
After :: 1
그 이유는 위 생성자 호출 메세지에서 확인할 수 있듯이&nbsp;bind&nbsp;함수로 인자가&nbsp;복사&nbsp;되서 전달되기 때문입니다. 따라서 이를 해결 하기 위해서는 명시적으로&nbsp;s1&nbsp;의 레퍼런스를 전달해줘야 합니다.#include &lt;functional&gt;
#include &lt;iostream&gt; struct S { int data; S(int data) : data(data) { std::cout &lt;&lt; "일반 생성자 호출!" &lt;&lt; std::endl; } S(const S&amp; s) { std::cout &lt;&lt; "복사 생성자 호출!" &lt;&lt; std::endl; data = s.data; } S(S&amp;&amp; s) { std::cout &lt;&lt; "이동 생성자 호출!" &lt;&lt; std::endl; data = s.data; }
}; void do_something(S&amp; s1, const S&amp; s2) { s1.data = s2.data + 3; } int main() { S s1(1), s2(2); std::cout &lt;&lt; "Before : " &lt;&lt; s1.data &lt;&lt; std::endl; // s1 이 그대로 전달된 것이 아니라 s1 의 복사본이 전달됨! auto do_something_with_s1 = std::bind(do_something, std::ref(s1), std::placeholders::_1); do_something_with_s1(s2); std::cout &lt;&lt; "After :: " &lt;&lt; s1.data &lt;&lt; std::endl;
}
일반 생성자 호출!
일반 생성자 호출!
Before : 1
After :: 5 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a>
]]></description><link>cpp/modern/5.-callable-etc..html</link><guid isPermaLink="false">CPP/Modern/5. callable etc..md</guid><pubDate>Sun, 02 Feb 2025 04:25:22 GMT</pubDate></item><item><title><![CDATA[6. Uniform Initializer]]></title><description><![CDATA[C++ 11에서 추가된 기능#include &lt;iostream&gt; class A { public: A() { std::cout &lt;&lt; "A 의 생성자 호출!" &lt;&lt; std::endl; }
}; int main() { A a(); // 아무것도 출력되지 않음. } A a() 는 A의 객체 a를 만든 것이 아니다. 컴파일러는 A를 리턴하고 인자를 받지 않는 함수 a를 정의 하는 것으로 판단한다. ()는 함수의 인자를 정의할 때 사용되고 일반적인 객체의 생성자를 호출 할 때에도 사용되기 때문이다.그렇다면 argument가 있는 경우는 어떨까? 함수 정의로 볼 수 없기 때문에 호출 된다.#include &lt;iostream&gt; class A { public: A(int x) { std::cout &lt;&lt; "A 의 생성자 호출!" &lt;&lt; std::endl; }
}; int main() { A a(3); // A의 생성자 호출! 출력
} 이러한 불편함을 줄이기 위해서 도입된 것이 Uniform Initializer 다.#include &lt;iostream&gt; class A { public: A() { std::cout &lt;&lt; "A 의 생성자 호출!" &lt;&lt; std::endl; }
}; int main() { A a{}; // A 의 생성자 호출! 프린트 됨
} (), {} 초기화의 한가지 큰 차이점이 있다. narrow-conversion 허용 여부다.#include &lt;iostream&gt; class A { public: A(int x) { std::cout &lt;&lt; "A 의 생성자 호출!" &lt;&lt; std::endl; }
}; int main() { A a(3.5); // Narrow-conversion 가능 - 3으로 출력 A b{3.5}; // Narrow-conversion 불가능 - 컴파일 실패
} Narrow - conversion 부동 소수점 타입에서 정수 타입으로의 변환
long double&nbsp;에서&nbsp;double&nbsp;혹은&nbsp;float&nbsp;으로의 변환,&nbsp;double&nbsp;에서&nbsp;float&nbsp;으로의 변환
정수 타입에서 부동 소수점 타입으로의 변환 즉 {}를 사용하면 원하지 않는 타입 캐스팅 방지해서 데이터 손실 오류를 잡아낼 수 있다.class B {
public: B(std::initializer_list&lt;int&gt; l) { for (auto itr = l.begin(); itr != l.end(); ++itr) { std::cout &lt;&lt; *itr &lt;&lt; std::endl; } }
};
int main() { B b({1, 2, 3});
} initializer_list&nbsp;는 우리가&nbsp;{}&nbsp;를 이용해서 생성자를 호출할 때, 클래스의 생성자들 중에&nbsp;initializer_list&nbsp;를 인자로 받는 생성자가 있다면 전달된다.{}&nbsp;를 이용해서 객체를 생성할 경우 생성자 오버로딩 시에 해당 함수 Initializer list가&nbsp;최우선&nbsp;으로 고려된다는 점이다.vector에는 vector(size_type count); 형태의 생성자가 존재. 이 생성자는 count 만큼의 원소 자리를 미리 생성해놓는다.vector v{10}는 그냥 원소 1 개 짜리&nbsp;intializer_list&nbsp;라고 생각해서&nbsp;10&nbsp;을 보관하고 있는 벡터를 생성하게 된다.#include &lt;initializer_list&gt;
#include &lt;iostream&gt; class A { public: A(int x, double y) { std::cout &lt;&lt; "일반 생성자! " &lt;&lt; std::endl; } A(std::initializer_list&lt;int&gt; lst) { std::cout &lt;&lt; "초기화자 사용 생성자! " &lt;&lt; std::endl; }
}; int main() { A a(3, 1.5); // Good A b{3, 1.5}; // Bad!
}
위의 코드에서 컴파일러는 initializer_list를 받는 생성자를 최대한 이용하도록 노력한다.
하지만 {}는 narrow conversion이 불가능하기 때문에 b에서 컴파일러 에러가 발생한다.이러한 문제가 발생하지 않으려면 initializer_list&nbsp;의 원소 타입으로 타입 변환 자체가 불가능한 경우여야만 한다. 즉 narrow conversion이라는 것이 아예 일어날 수 없는 경우다.#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
#include &lt;string&gt; class A { public: A(int x, double y) { std::cout &lt;&lt; "일반 생성자! " &lt;&lt; std::endl; } A(std::initializer_list&lt;std::string&gt; lst) { std::cout &lt;&lt; "초기화자 사용 생성자! " &lt;&lt; std::endl; }
}; int main() { A a(3, 1.5); // 일반 A b{3, 1.5}; // 일반 A c{"abc", "def"}; // 초기화자
} int&nbsp;나&nbsp;double&nbsp;이&nbsp;string&nbsp;으로 변환될 수 없기 때문에&nbsp;initializer_list&nbsp;를 받는 생성자는 아예 고려 대상에서 제외된다.만일&nbsp;{}&nbsp;를 이용해서 생성할 때 타입으로&nbsp;auto&nbsp;를 지정한다면&nbsp;initializer_list&nbsp;객체가 생성된다. auto list = {1, 2, 3}; // initializer_list&lt;int&gt;
그런데 c++11과 c++17 차이점이 있다.auto a = {1}; // std::initializer_list&lt;int&gt;
auto b{1}; // std::initializer_list&lt;int&gt;
auto c = {1, 2}; // std::initializer_list&lt;int&gt;
auto d{1, 2}; // std::initializer_list&lt;int&gt;
C++ 11에서 b의 타입이 std::initializer_list&lt;int&gt; 로 추론된다. b의 타입이 그냥 int로 추론 되어야 한다는 것이 이치에 맞다고 판단해서인지 C++ 17에서는 수정 되었다.
auto x = {arg1, arg2...}&nbsp;형태의 경우&nbsp;arg1,&nbsp;arg2&nbsp;... 들이 모두 같은 타입이라면&nbsp;x&nbsp;는&nbsp;std::initializer_list&lt;T&gt;&nbsp;로 추론 auto x {arg1, arg2, ...}&nbsp;형태의 경우 만일 인자가 단 1 개라면 인자의 타입으로 추론되고, 여러 개일 경우 오류를 발생
auto a = {1}; // 첫 번째 형태이므로 std::initializer_list&lt;int&gt;
auto b{1}; // 두 번째 형태 이므로 그냥 int
auto c = {1, 2}; // 첫 번째 형태이므로 std::initializer_list&lt;int&gt;
auto d{1, 2}; // 두 번째 형태 인데 인자가 2 개 이상이므로 컴파일 오류
auto를 사용해서 문자열을 다룰 때, 주의할 점이 있다.auto list = {"a", "b", "c"};
<img alt="initializer_list_char.png" src="images/initializer_list_char.png" target="_self">list&nbsp;는&nbsp;initializer_list&lt;std::string&gt;&nbsp;이 아닌&nbsp;initializer_list&lt;const char*&gt;&nbsp;이 된다는 점이다.C++ 14에서 추가된 리터럴 연산자 활용 -&gt; initializer_list&lt;std::string&gt;&nbsp;으로 추론할 수 있다.using namespace std::string_literals;
auto list = {"a"s, "b"s, "c"s}; <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://modoocode.com/135" target="_self">https://modoocode.com/135</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/example_uniform_initializer" target="_self">https://github.com/psychehose/example_uniform_initializer</a>
]]></description><link>cpp/modern/6.-uniform-initializer.html</link><guid isPermaLink="false">CPP/Modern/6. Uniform Initializer.md</guid><pubDate>Sun, 02 Feb 2025 04:24:53 GMT</pubDate><enclosure url="images/initializer_list_char.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/initializer_list_char.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[initializer_list_char]]></title><description><![CDATA[<img src="images/initializer_list_char.png" target="_self">]]></description><link>images/initializer_list_char.html</link><guid isPermaLink="false">images/initializer_list_char.png</guid><pubDate>Sun, 02 Feb 2025 04:16:27 GMT</pubDate><enclosure url="images/initializer_list_char.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/initializer_list_char.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fmt]]></title><description><![CDATA[fmt는 문자열 포매팅 라이브러리다. Python과 유사한 형식의 문법을 가지고 있어서 사용하기 간편하다. 이러한 점은 c++ 20 표준의 std::format 의 기반이 되었다. 20 이상에서는 표준을 사용하면 된다.
Python과 유사한 형식의 문법
string name = "My Name";
int age = 2;
fmt::print("Name: {}, Age: {}", name, age); 타입 안정성 컴파일 시점에서 포맷 문자열과 인자의 타입 불일치를 검사 fmt::format_string 다양한 포맷팅 옵션 // 숫자 포매팅
fmt::print("Integer: {:d}, Float: {:.2f}", 42, 3.14159); // 정렬과 패딩
fmt::print("Left aligned: {:&lt;10}", "text");
fmt::print("Right aligned: {:&gt;10}", "text"); // 사용자 정의 타입 지원
struct Point { int x, y; };
template &lt;&gt; struct fmt::formatter&lt;Point&gt; { // 사용자 정의 타입을 위한 포매팅 구현
};
주로 CMake를 이용해서 프로젝트에 링크 한다.include(FetchContent) FetchContent_Declare( Fmt GIT_REPOSITORY "https://github.com/fmtlib/fmt" GIT_TAG "7.1.3" ) FetchContent_MakeAvailable(Fmt) target_link_libraries(program PUBLIC fmt) 기본 문자열 포매팅 std::string name = "psychehose"; int age = 31; // basic formatting 순서. fmt::print("Name: {}, Age: {} \n", name, age); // by indexing fmt::print("{1}살을 먹은 {0}\n", name, age); // by name fmt::print("{name}은 {age}살\n", fmt::arg("name", name), fmt::arg("age", age)); fmt::print("{name}은 {age}살\n", fmt::arg("age", age), fmt::arg("name", name)); 이름 기반 포매팅을 할 때는 인자들의 이름을 지정 했기 때문에 순서가 바뀌어도 상관 없다.
숫자 포매팅 int num = 42; fmt::print("10진수 {}\n", num); // 42 fmt::print("16진수 {:x}\n", num); // 2a fmt::print("16진수 (대문자) {:X}\n", num); // 2A fmt::print("8진수 {:o}\n", num); // 52 fmt::print("2진수 {:b}\n", num); // 101010 // 부동소수점 fmt::print("소수점 2자리: {:.2f}\n", 3.141592); fmt::print("지수 표기: {:e}\n", 1000000.0); fmt::print("자동 지수/고정: {:g}\n", 1000000.0); 정렬과 패딩, 최소 너비 설정
// 왼쪽 정렬 (기본값)
fmt::print("왼쪽정렬: {:&lt;10}\n", "left"); // "left " // 오른쪽 정렬
fmt::print("오른쪽정렬: {:&gt;10}\n", "right"); // " right" // 가운데 정렬
fmt::print("가운데정렬: {:^10}\n", "center"); // " center " // 사용자 지정 패딩 문자
fmt::print("패딩: {:*&gt;10}\n", "pad"); // "******pad" // 최소 너비 지정
fmt::print("{:10}\n", "text"); // "text " 부호
fmt::print("{:+}\n", 42); // "+42"
fmt::print("{:+}\n", -42); // "-42" 컨테이너 포맷팅 #include "fmt/ranges.h" std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
fmt::print("{}\n", v); // [1, 2, 3, 4, 5] std::map&lt;std::string, int&gt; m = {{"apple", 1}, {"banana", 2}};
fmt::print("{}\n", m); // {"apple": 1, "banana": 2} 날짜 / 시간 포매팅
#include &lt;fmt/chrono.h&gt; std::time_t t = std::time(nullptr);
fmt::print("현재 시간: {:%Y-%m-%d %H:%M:%S}\n", fmt::gmtime(t)); 문자열 변수로 저장 fmt::format
// 문자열 반환
std::string result = fmt::format("Hello, {}!", "World"); // 여러 인자 사용
int x = 10, y = 20;
std::string coords = fmt::format("좌표: ({}, {})", x, y);
std::cout &lt;&lt; coords &lt;&lt; std::endl; [fmt example github][https://github.com/psychehose/example_fmt]]]></description><link>cpp/lib/fmt.html</link><guid isPermaLink="false">CPP/Lib/fmt.md</guid><pubDate>Thu, 30 Jan 2025 09:24:31 GMT</pubDate></item><item><title><![CDATA[Google Test]]></title><description><![CDATA[EXPECT_EQ(val1, val2); // val1 == val2
EXPECT_NE(val1, val2); // val1 != val2
EXPECT_LT(val1, val2); // val1 &lt; val2
EXPECT_LE(val1, val2); // val1 &lt;= val2
EXPECT_GT(val1, val2); // val1 &gt; val2
EXPECT_GE(val1, val2); // val1 &gt;= val2 EXPECT_TRUE(condition); // condition이 true인지
EXPECT_FALSE(condition); // condition이 false인지 EXPECT_STREQ(str1, str2); // 문자열이 같은지
EXPECT_STRNE(str1, str2); // 문자열이 다른지
EXPECT_STRCASEEQ(str1, str2); // 대소문자 무시하고 같은지
EXPECT_STRCASENE(str1, str2); // 대소문자 무시하고 다른지 EXPECT_FLOAT_EQ(val1, val2); // float 거의 같은지
EXPECT_DOUBLE_EQ(val1, val2); // double 거의 같은지
EXPECT_NEAR(val1, val2, abs_error); // 지정된 오차 범위 내인지
$ ctest
옵션 -V: verbose의 약자로, 자세한 출력을 보여달라는 옵션 테스트 실행 과정
테스트 출력 내용
실패한 경우 실패 원인 등 상세한 정보 -R &nbsp;Regular expression의 약자로, 정규표현식과 일치하는 이름을 가진 테스트만 실행 ]]></description><link>cpp/lib/google-test.html</link><guid isPermaLink="false">CPP/Lib/Google Test.md</guid><pubDate>Thu, 30 Jan 2025 04:16:56 GMT</pubDate></item><item><title><![CDATA[Helix core,  Helix Swarm 구성]]></title><description><![CDATA[
저장소 설정
sudo tee /etc/yum.repos.d/perforce.repo &lt;&lt; 'EOF'
[perforce]
name=Perforce
baseurl=https://package.perforce.com/yum/rhel/9/x86_64
enabled=1
gpgcheck=1
gpgkey=https://package.perforce.com/perforce.pubkey
EOF 공개키 등록
sudo rpm --import https://package.perforce.com/perforce.pubkey 저장소 확인
# 저장소가 제대로 등록되었는지 확인
dnf repolist | grep perforce
# 패키지 검색이 되는지 확인
dnf search helix
# 패키지목록 초기화 하고 다시 받기
sudo dnf clean all
sudo dnf makecache
sudo dnf update Helix Core 서버 설치 (p4d) sudo dnf install helix-p4d p4d 초기 설정
sudo /opt/perforce/sbin/configure-helix-p4d.sh
export P4CHARSET=utf8 # 텍스트 인코딩
master가 config할 때 정한 이름이였던 거 같음 P4 설정 파일 경로: /etc/perforce/p4dctl.conf.d/master.conf P4 루트 디렉토리: /opt/perforce/servers/master/root 서버중지 - sudo systemctl stop p4d 또는 sudo -u perforce p4dctl stop master 서버 재시작 - sudo systemctl restart p4d 또는 sudo -u perforce p4dctl restart master 부팅 시 자동 시작 설정: sudo systemctl enable p4d aws인 경우 인바운드 추가해서 1666 포트 추가로 열기 Swram 필수 패키지 설치
sudo dnf install httpd php php-xml php-mbstring php-json php-gd php-curl Apache 웹 서버 활성화
sudo systemctl enable httpd
sudo systemctl start httpd Swarm 설치
sudo dnf install helix-swarm Swarm 초기설정
sudo /opt/perforce/swarm/bin/configure-swarm.sh post installation 설정 (거의 꼭 해야함)
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://help.perforce.com/helix-core/helix-swarm/swarm/current/Content/Swarm/setup.post.html#Post-install_configuration_options" target="_self">https://help.perforce.com/helix-core/helix-swarm/swarm/current/Content/Swarm/setup.post.html#Post-install_configuration_options</a>p4 configure set filetype.bypasslock=1 #exclusive lock 핸들링
p4 configure show filetype.bypasslock
]]></description><link>infra/helix-core,-helix-swarm-구성.html</link><guid isPermaLink="false">Infra/Helix core,  Helix Swarm 구성.md</guid><pubDate>Fri, 24 Jan 2025 07:45:17 GMT</pubDate></item><item><title><![CDATA[Perforce 명령어]]></title><description><![CDATA[# Open command Windows here 선택 후
p4 changes -m1 "./...#have"
p4 set P4IGNORE=.p4ignore p4 depots # 현재 존재하는 depot 확인
p4 depot -t stream {streamdepotname}
p4 stream -t mainline //mystream/main #mainline 설정
p4 stream -t development -P //mystream/main //mystream/dev #development 설정 -t development: 스트림의 타입을 'development'로 지정. 이는 이 스트림이 개발 작업을 위한 것. -P //mystream/main: 부모 스트림을 지정. //mystream/main은 부모 스트림의 전체 경로.
//mystream/dev: 생성하려는 새 스트림의 전체 경로
p4 streams -a //{Depot_name}/...
#development 스트림 강제 삭제
p4 stream -F -d //{Depot_name}/develop #develop 스트림의 파일 삭제
p4 stream --obliterate -y //{Depot_name}/develop
p4 obliterate -y //{Depot_name}/...
p4 depot -f -d {Depot_name}
p4 edit -t +w -c {changing_list_number} ...
p4 user -f {username} # 아이디 생성
p4 passwd {username} # 비밀번호 설정
p4 users
# 1. 해당 사용자의 클라이언트 워크스페이스 삭제
p4 client -d username-workspace # 2. 그 다음 사용자 삭제
p4 user -d username # 3. 삭제가 제대로 되었는지 확인
p4 users | grep username
$ sudo -u perforce p4dctl restart master
]]></description><link>infra/perforce-명령어.html</link><guid isPermaLink="false">Infra/Perforce 명령어.md</guid><pubDate>Fri, 24 Jan 2025 07:41:06 GMT</pubDate></item><item><title><![CDATA[터미널 명령어로 원하는 .gitignore를 빠르게 생성하기]]></title><description><![CDATA[어떤 프로젝트를 시작하든 버전관리를 위해 Git을 사용하는 것은 좋은 선택이라고 생각해요. 저 같은 경우에는 기능을 추가할 때 바로 앱에 적용하는 경우도 종종 있지만, 보통의 경우에는 기능이 있는 샘플 앱을 먼저 만들어 보고 적용하는 걸 선호합니다. 그렇기 때문에 프로젝트를 자주 만드는데요. 저는 당연히 항상 깃을 사용합니다.&nbsp;저는 주로 iOS 개발을 하기 때문에 Xcode를 통해서 프로젝트를 생성하는데 작업을 마치고 GitHub에 푸시하면 올리기 싫은 파일들이 정말 많이 올라갑니다. 예를 들면 .xcodeproj의 하위 폴더에 있는 xcuserdata, MacOS의 .DS_Store 같은 파일들입니다. 이러한 개인적인 것들을&nbsp;깃에 Staging 하지 않도록&nbsp;도와주는 것이 바로&nbsp;.gitignore&nbsp;입니다.$ vim .gitignore
&nbsp;위와 같이 입력하면 빈 .gitignore 파일이 생성되는데 여기에 자신이 트래킹 하길 원하지 않는 파일이나, 폴더를 작성해 주면 됩니다. 무엇을 작성해야 하는지 잘 모르겠다면 아래의 웹페이지에서 쉽게 확인할 수 있습니다<a data-tooltip-position="top" aria-label="https://www.toptal.com/developers/gitignore" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.toptal.com/developers/gitignore" target="_self">.gitignore 생성하러 가기 </a>이렇게 편리한 툴이 있음에도 불구하고, 매번 .gitignore를 생성하고 웹페이지에 들어가서 복사 붙여 넣기 하는 것도 귀찮았습니다. 그래서 터미널에서 한 줄만 입력하면 내가 원하는 .gitignore 파일이 생성되게 하고 싶었어요. 저는 이것을&nbsp;alias를&nbsp;이용해서 해결했습니다. 항상 이 명령어를 사용하고 싶기 때문에 셀에 아예 등록을 했습니다.vim ~/.zshrc
ignore 변수를 선언하고 Staging 하고 싶지 않은 파일들을 작성하면 됩니다.## ~/.zshrc ignore="
# Mac OS X
*.DS_Store
# Xcode
*.xcuserstate
project.xcworkspace/
xcuserdata/
"
그러고 나서 alias 명령어를 걸면 되겠습니다. 저는 genignore라는 명령어로 .gitignore를 생성하고 싶었어요. 그리고 파일에 쓰고 생성하는데 큰 도움을 주는 명령어&nbsp;cat를 사용할 거예요. 아래의 커맨드라인을 간단하게 말하자면, 'EOF를 만날 때까지 텍스트를 .gitignore에 쓰고 저장할 것이다.'입니다.&nbsp;중간에 있는 $ignore는 위에서 선언한 변수입니다.(셀에서 변수를 사용하려면 $을 붙여줘야 해요)## ~/.zshrc alias genignore="cat &lt;&lt;'EOF'&gt;&gt; .gitignore
$ignore
EOF
"
터미널에서 만든 명령어를 입력하면 다음과 같이 .gitignore 생성되는 것을 확인할 수 있습니다.<br><img src="https://blog.kakaocdn.net/dn/edQGEd/btr33x7VXuV/MXJKPqyXmKq7AhkjCfu5YK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/dwqIHD/btr3U4MvMCZ/YKwKIGSJEYCPoq7xGHUAXK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>tip/터미널-명령어로-원하는-.gitignore를-빠르게-생성하기.html</link><guid isPermaLink="false">Tip/터미널 명령어로 원하는 .gitignore를 빠르게 생성하기.md</guid><pubDate>Fri, 24 Jan 2025 07:37:42 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/edQGEd/btr33x7VXuV/MXJKPqyXmKq7AhkjCfu5YK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/edQGEd/btr33x7VXuV/MXJKPqyXmKq7AhkjCfu5YK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slate Architecture]]></title><description><![CDATA[ Pros: Programmers like that UI description is "close" to the code; easy to get at the data.
Invalidation is usually a non-issue; just poll data directly.
Easy to procedurally build interfaces. Cons: Adding animation and styling is harder.
UI description is imperative code, so no chance to make it data-driven. Desired Slate Characteristics: Easy access to model's code and data 모델의 코드와 데이터에 쉽게 접근할 수 있습니다.
Support procedural UI generation. 절차적 UI 생성을 지원합니다.
UI description should be hard to screw up.
Must support animation and styling. 애니메이션과 스타일을 지원해야 합니다. 불투명한 캐시와 중복된 상태를 피하세요. 역사적으로 UI는 상태를 캐시하고 명시적인 무효화를 요구 (from preferred to least preferred) Polling
Transparent caches
Opaque caches with low-grain invalidation 노티피케이션보다 알림을 더 선호 When UI structure is changing, prefer polling to notification. (When notification is necessary, prefer low-grain notifications to fine-grain notifications.) 피드백 루프를 피하기. Ex: 모든 레이아웃은 프로그래머 설정에서 계산됩니다. 이전 레이아웃 상태에 의존하지 않기. Only exceptions are when UI state becomes the model; e.g. ScrollBars visualize UI state.
This is done for correctness and programmer sanity rather than performance. 일단 난잡하게 개발 -&gt; 후에 일반화하기. &nbsp;Slate uses delegates as a flexible conduit for widgets that need to read and write the Model's data. Slate widgets read the Model's data when they need to display it.
STextBlock 은 Text 라는 델리게이트를 사용.<img alt="SLATE_ARCITECTURE_1.png" src="images/slate_arcitecture_1.png" target="_self">이 예제에서 Framerate는 float, integer로 저장될 확률이 높습니다. Delegate를 사용하면 값을 읽을 때마다 변환을 수행할 수 있는 유연성이 제공됩니다.<br><img alt="SLATE_ARCITECTURE_2.png" src="images/slate_arcitecture_2.png" target="_self">SEditableText는 입력과 출력을 모두 담당하는 Slate 위젯입니다. STextBlock과 마찬가지로 데이터 시각화를 위해 Text 대리자를 사용합니다. 사용자가 편집 가능한 텍스트 필드에 일부 텍스트를 입력하고 Enter 키를 누르면 SEditableText가 OnTextChanged 대리자를 호출합니다. 프로그래머가 입력의 유효성을 검사하고 모델의 데이터를 OnTextChanged에 변경하는 데 적합한 기능을 연결했다고 가정합니다.다음 프레임 동안 SEditableText는 모델의 데이터에서 읽습니다. 위의 예에서 항목 이름은 OnTextChanged 대리자에 의해 변경되었으며 Text 대리자를 통해 시각화를 위해 읽혀집니다.Using a delegate is not always desirable. Depending on the use case, the arguments to Slate widgets may need to be constant values or functions. We encapsulate this notion via the&nbsp;TAttribute &lt; T &gt;&nbsp;class. An attribute can be set to a constant or to a delegate.<br>After reading the&nbsp;<a data-tooltip-position="top" aria-label="https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine#pollingdataflowanddelegates" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine#pollingdataflowanddelegates" target="_self">Polling Data Flow and Delegates</a>&nbsp;section, one might have serious concerns about performance.Consider the following observations:
UI complexity is bounded by the number of live widgets.
Scrolling content is virtualized whenever possible; this mostly avoids live widgets off-screen. Large numbers of off-screen widgets can easily tank Slate performance. Assumption: users with big screens have beefy machines to drive those screens; they can handle a large number of widgets.
Sometimes polling is either not performant or functionally incorrect. This is often the case with non-trivial values that cannot be expressed as a combination of simpler, trivial values. We usually invalidate in scenarios where the structure of the Model changes drastically. It is then reasonable to scrap an existing UI and recreate it. However, doing so assumes state loss, so we should not do it unless necessary.Invalidation is - as a rule - reserved for infrequent, low-granularity events.Consider the example of the Blueprint Editor, which displays nodes on a graph. When an update is requested, all the&nbsp;Graph&nbsp;Panel widgets are cleared and re-created. This is preferable to fine-grain invalidation because it is simpler and more maintainable.모델 구조가 크게 변경된다면 다 지우고 다시 그리는 게 낫다. (like 그래프)All Slate widgets store children in child slots. (As opposed to storing a plain array of child widgets.) Child slots always store a valid widget; by default they store the&nbsp;SNullWidget, which is a widget with no visualization or interaction. Each type of widget can declare its own type of child slot, which caters to its specific needs. Consider that&nbsp;SVerticalSlot&nbsp;arranges its children completely differently than an&nbsp;SCanvas, which is quite different from SUniformGridPanel. The Slots allow each type of panel to ask for a set of per-child settings that affect the arrangement of the children.모든 Slate 위젯은 하위 슬롯에 하위 항목을 저장합니다. (하위 위젯의 일반 배열을 저장하는 것과 반대입니다.) 하위 슬롯은 항상 유효한 위젯을 저장합니다. 기본적으로 시각화나 상호작용이 없는 위젯인 SNullWidget을 저장합니다. 각 위젯 유형은 특정 요구 사항을 충족하는 자체 하위 슬롯 유형을 선언할 수 있습니다. SVerticalSlot은 SUniformGridPanel과 상당히 다른 SCanvas와 완전히 다르게 자식을 배열한다는 점을 고려하세요. 슬롯을 사용하면 각 유형의 패널에서 하위 배열에 영향을 미치는 하위별 설정 세트를 요청할 수 있습니다.위젯은 세 가지 형태로 제공됩니다 Leaf Widgets&nbsp;- widgets with no child slots. e.g. STextBlock displays a piece of text. It has native knowledge of how to draw text. 하위 슬롯이 없는 위젯. 예를 들어 STextBlock은 텍스트 조각을 표시합니다. 텍스트를 그리는 방법에 대한 기본 지식이 있습니다. Panels&nbsp;- widgets with a dynamic number of child slots. e.g.&nbsp;SVerticalBox&nbsp;arranges any number of children vertically given some layout rules. 동적 개수의 하위 슬롯이 있는 위젯. 예를 들어 SVerticalBox는 일부 레이아웃 규칙에 따라 여러 자식을 수직으로 정렬합니다. Compound Widgets&nbsp;- widgets with a fixed number of explicitly named child slots. e.g.&nbsp;SButton&nbsp;has one slot called Content which contains any widgets inside the button. 동적 개수의 하위 슬롯이 있는 위젯. 예를 들어 SVerticalBox는 일부 레이아웃 규칙에 따라 여러 자식을 수직으로 정렬합니다. Slate layout is accomplished in two passes.
Pass 1:&nbsp;Cache Desired Size&nbsp;- the relevant functions are&nbsp;SWidget::CacheDesiredSize&nbsp;and&nbsp;SWidget::ComputeDesiredSize
Pass 2:&nbsp;ArrangeChildren&nbsp;- the relevant function is&nbsp;SWidget::ArrangeChildren
The goal of this pass is to figure out how much space each widget wants to occupy.&nbsp; Widgets with no children (i.e. leaf widgets) are asked to compute and cache their desired size based on their intrinsic properties.Leaf Widget은 자기 고유의 intrinsic 특성을 기준으로 사이즈가 계산되고 캐싱되도록 요청됨.Widgets that combine other widgets (i.e. compound widgets and panels) use special logic to determine their desired size as a function of the size of their children.
다른 위젯과 결합하는 위젯 (패널과 Compound 위젯)은 special logic을 통해 사이즈가 계산됩니다.Note that each type of widget is only required to implement&nbsp;ComputeDesiredSize();&nbsp;the caching and traversal logic are implemented by Slate.
각 위젯 유형은 ComputeDesiredSize()를 구현하는 데만 필요합니다. 캐싱 및 순회 논리는 Slate에 의해 구현됩니다.Slate guarantees that when ComputeDesiredSize() is called on a widget, its children have already computed and cached their desired size. Thus, this is a bottom-up pass.
Slate는 위젯에서 ComputeDesiredSize()가 호출될 때 해당 하위 항목이 이미 원하는 크기를 계산하고 캐시했음을 보장합니다. 따라서 이것은 상향식 패스입니다.다음의 예를 고려해보자.<br><img alt="SLATE_ARCITECTURE_3.png" src="images/slate_arcitecture_3.png" target="_self">An STextBlock widget would compute its desired size by measuring the string that it is displaying. The SImage widget would determine its size based on the image data it is showing. Assume that the text inside the textblock requires 14 slate units of space, and the image requires 8. The horizontal panel arranges widgets horizontally, and therefore requires 14 + 8 = 22 units of space.STextBlock의 Text를 고려하면 14사이즈 되어야하고, SImage의 Image가 들어가려면 8사이즈가 필요하다. 그래서 Horizontal Box는 14+8 = 22로 결정된다.ArrangeChildren is a top-down pass. Slate begin at the top-level windows and asks each window to arrange its children based on the constraints provided by the programmers. When the space allotted for each child is known, Slate can recur and arrange the children's children. The recursion continues until all the children are arranged.AlignChildren은 하향식 패스입니다. 슬레이트는 최상위 창에서 시작하여 프로그래머가 제공한 제약 조건에 따라 하위 창을 정렬하도록 각 창에 요청합니다. 각 자식에게 할당된 공간이 알려지면 Slate는 자식의 자식을 반복해서 배열할 수 있습니다. 모든 하위 항목이 정렬될 때까지 재귀가 계속됩니다.<br><img alt="SLATE_ARCITECTURE_4.png" src="images/slate_arcitecture_4.png" target="_self">먼저 Horizontal Box에 사이즈를 할당하고 그것에 맞춰 자식 컴포넌트의 사이즈가 결정된다.STextBlock은 Autosize이고 내부 Text는 14 사이즈를 필요로하기 때문에 14로 결정된다 SImage의 내부 이미지는 8의 사이즈를 필요로 하지만 Fill WIdth이기 때문에 11로 결정된다.Note that in the actual SHorizontalBox widget, the alignment of the SImage within its slot would be driven by the&nbsp;HAlign&nbsp;property, which can be Left, Center, Right, or Fill.In practice, Slate never performs a full ArrangeChildren pass. Instead, this functionality is used to implement other functionality. Key examples are hit detection and painting.
실제로 Slate는 전체 AlignChildren 패스를 수행하지 않습니다. 대신 이 기능은 다른 기능을 구현하는 데 사용됩니다. 주요 예로는 히트 감지 및 페인팅이 있습니다.During the paint pass, Slate iterates over all the visible widgets and produces a list of draw elements which will be consumed by the rendering system. This list is produced anew for every frame. 페인트 패스 중에 Slate는 표시되는 모든 위젯을 반복하고 렌더링 시스템에서 사용할 그리기 요소 목록을 생성합니다. 이 목록은 매 프레임마다 새로 생성됩니다.We begin at the top level windows and recur down the hierarchy, appending the draw elements of every widget to the draw list. 최상위 창에서 시작하여 계층 구조를 따라 반복하여 모든 위젯의 그리기 요소를 그리기 목록에 추가합니다.Widgets tend to do two things during paint: they output actual draw elements or figure out where a child widget should exist and ask the child widget to paint itself. 위젯은 페인트하는 동안 두 가지 작업을 수행하는 경향이 있습니다. 즉, 실제 그리기 요소를 출력하거나 하위 위젯이 어디에 있어야 하는지 파악하고 하위 위젯에게 자체적으로 페인트하도록 요청합니다.Thus, we can think of a simplified general-case&nbsp;OnPaint&nbsp;function as being 따라서 단순화된 일반적인 경우의 OnPaint 함수를 다음과 같이 생각할 수 있습니다. // An arranged child is a widget and its allotted geometry
struct ArrangedChild
{ Widget; Geometry;
}; OutputElements OnPaint( AllottedGeometry )
{ // Arrange all the children given our allotted geometry Array&lt;ArrangedChild&gt; ArrangedChildren = ArrangeChildrenGiven( AllottedGeometry ); // Paint the children for each ( Child in ArrangedChildren ) { OutputElements.Append( Child.Widget.OnPaint( Child.Geometry ) ); } // Paint a border OutputElements.Append( DrawBorder() );
}
The key functions that define an SWidget's behavior in Slate are: ComputeDesiredSize() - responsible for desired size. 원하는 사이즈를 책임집니다.| ArrangeChildren() - responsible for arrangement of children within the parent's allotted area. 부모에게 할당된 공간 내에서 자녀를 배치할 책임이 있습니다. OnPaint() - responsible for appearance. Event handlers - these are of the form OnSomething. These are functions that may be invoked on your widget by Slate at various times. 이는 OnSomething 형식입니다. 이는 Slate가 위젯에서 다양한 시간에 호출할 수 있는 함수입니다. Composition is the notion that any slot should be able to contain arbitrary widget content. This affords users of Slate a great deal of flexibility. Composition is used whenever possible in core Slate widgets. 구성은 모든 슬롯이 임의의 위젯 콘텐츠를 포함할 수 있어야 한다는 개념입니다. 이는 Slate 사용자에게 상당한 유연성을 제공합니다. 컴포지션은 핵심 슬레이트 위젯에서 가능할 때마다 사용됩니다.]]></description><link>ue/slate-architecture.html</link><guid isPermaLink="false">UE/Slate Architecture.md</guid><pubDate>Fri, 24 Jan 2025 07:33:13 GMT</pubDate><enclosure url="images/slate_arcitecture_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FGenricError]]></title><description><![CDATA[<a href=".?query=tag:unreal" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#unreal">#unreal</a> <a href=".?query=tag:error" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#error">#error</a> Crashed: Thread
0 libsystem_kernel.dylib 0xc2ec __pthread_kill + 8
1 libsystem_pthread.dylib 0x7c0c pthread_kill + 268
2 libsystem_c.dylib 0x75ba0 abort + 180
3 U2Client 0x2417084 auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()&lt;FLogCategoryLogGenericPlatformMisc, char16_t [31], bool&gt;(FLogCategoryLogGenericPlatformMisc const&amp;, char16_t const (&amp;) [31], bool const&amp;) const + 653 (GenericPlatformMisc.cpp:653)
4 U2Client 0x24d2e54 FIOSErrorOutputDevice::Serialize(char16_t const*, ELogVerbosity::Type, FName const&amp;) + 31 (IOSErrorOutputDevice.cpp:31)
5 U2Client 0x254cf6c FOutputDevice::LogfImpl(char16_t const*, ...) + 178 (UnrealMemory.h:178)
6 U2Client 0x250e55c FDebug::ProcessFatalError() + 482 (AssertionMacros.cpp:482)
7 U2Client 0x277e668 UObjectBase::~UObjectBase() + 212 (UObjectArray.h:212)
8 U2Client 0x26d9534 FAsyncPurge::TickDestroyGameThreadObjects(bool, float, double) + 366 (GarbageCollection.cpp:366)
9 U2Client 0x26d8f3c FAsyncPurge::TickPurge(bool, float, double) + 489 (GarbageCollection.cpp:489)
10 U2Client 0x26ce4b4 IncrementalPurgeGarbage(bool, float) + 1783 (GarbageCollection.cpp:1783)
11 U2Client 0x4626ef4 UEngine::ConditionalCollectGarbage() + 1378 (IConsoleManager.h:1378)
12 U2Client 0x421ca50 UWorld::Tick(ELevelTick, float) + 1691 (LevelTick.cpp:1691)
13 U2Client 0x41064a4 UGameEngine::Tick(float, bool) + 224 (CoreGlobals.h:224)
14 U2Client 0x106c3c4 FEngineLoop::Tick() + 4902 (LaunchEngineLoop.cpp:4902)
15 U2Client 0x27e4410 -[IOSAppDelegate MainAppThread:] + 429 (IOSAppDelegate.cpp:429)
16 Foundation 0xde428 __NSThread__start__ + 732
17 libsystem_pthread.dylib 0x606c _pthread_start + 136
18 libsystem_pthread.dylib 0x10d8 thread_start + 8 Crashed: Thread
0 libsystem_kernel.dylib 0x7674 __pthread_kill + 8
1 libsystem_pthread.dylib 0x71ac pthread_kill + 268
2 libsystem_c.dylib 0x20c8c abort + 180
3 U2Client 0x2417084 auto FGenericPlatformMisc::RequestExit(bool)::$_27::operator()&lt;FLogCategoryLogGenericPlatformMisc, char16_t [31], bool&gt;(FLogCategoryLogGenericPlatformMisc const&amp;, char16_t const (&amp;) [31], bool const&amp;) const + 653 (GenericPlatformMisc.cpp:653)
4 U2Client 0x24d2e54 FIOSErrorOutputDevice::Serialize(char16_t const*, ELogVerbosity::Type, FName const&amp;) + 31 (IOSErrorOutputDevice.cpp:31)
5 U2Client 0x254cf6c FOutputDevice::LogfImpl(char16_t const*, ...) + 178 (UnrealMemory.h:178)
6 U2Client 0x250e55c FDebug::ProcessFatalError() + 482 (AssertionMacros.cpp:482)
7 U2Client 0x2624598 FAsyncLoadingThread::FlushLoading(int) + 7003 (AsyncLoading.cpp:7003)
8 U2Client 0x2787174 LoadPackageInternal(UPackage*, char16_t const*, unsigned int, FLinkerLoad*, FArchive*, FLinkerInstancingContext const*) + 1147 (UObjectGlobals.cpp:1147)
9 U2Client 0x2785ddc LoadPackage(UPackage*, char16_t const*, unsigned int, FArchive*, FLinkerInstancingContext const*) + 1469 (UObjectGlobals.cpp:1469)
10 U2Client 0x2784960 ResolveName(UObject*&amp;, FString&amp;, bool, bool, unsigned int, FLinkerInstancingContext const*) + 791 (UObjectGlobals.cpp:791)
11 U2Client 0x2785fe4 StaticLoadObjectInternal(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*, bool, FLinkerInstancingContext const*) + 853 (UObjectGlobals.cpp:853)
12 U2Client 0x2774930 StaticLoadObject(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*, bool, FLinkerInstancingContext const*) + 928 (UObjectGlobals.cpp:928)
13 U2Client 0x278662c StaticLoadClass(UClass*, UObject*, char16_t const*, char16_t const*, unsigned int, UPackageMap*) + 1322 (UObjectGlobals.h:1322)
14 U2Client 0x1dc2248 UUIScreenController::CreatePopupUI(EU2UIScreenLayerType, FString, bool) + 1332 (UObjectGlobals.h:1332)
15 U2Client 0x1dc285c UUIScreenController::OpenPopupUI(FString, bool) + 294 (UIScreenController.cpp:294)
16 U2Client 0x1dc2950 UUIScreenController::OpenPopupUI(FString, FAnchors const&amp;, FVector2D const&amp;, bool) + 306 (UIScreenController.cpp:306)
17 U2Client 0x1bf67d8 UUIErrorPopup* UUIScreenController::OpenPopup&lt;UUIErrorPopup&gt;(EUIComponentPopup, bool) + 149 (UIScreenController.h:149)
18 U2Client 0x1dcea48 UU2NetworkManager::MessageManagerEnum(EU2MsgType, UMsgC_Base*) + 105 (U2NetworkManager.cpp:105)
19 U2Client 0x1e5f708 TBaseUObjectMethodDelegateInstance&lt;false, UManagerObject, void (EU2MsgType, UMsgC_Base*), FDefaultDelegateUserPolicy&gt;::ExecuteIfSafe(EU2MsgType, UMsgC_Base*) const + 598 (DelegateInstancesImpl.h:598)
20 U2Client 0x1e5f8a8 UE4Function_Private::TFunctionRefCaller&lt;UMessageManager::SendThreadSafeMsgManager(EU2MsgType, UMsgC_Base*)::$_49, void ()&gt;::Call(void*) + 955 (DelegateSignatureImpl.inl:955)
21 U2Client 0x1079fdc TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(TArray&lt;FBaseGraphTask*, TSizedDefaultAllocator&lt;32&gt;&gt;&amp;, ENamedThreads::Type) + 681 (Function.h:681)
22 U2Client 0x23f7be0 FNamedTaskThread::ProcessTasksUntilIdle(int) + 711 (TaskGraph.cpp:711)
23 U2Client 0x2bc2d9c FlushRenderingCommands(bool) + 1264 (RenderingThread.cpp:1264)
24 U2Client 0x27eb754 invocation function for block in FIOSApplication::OrientationChanged(UIInterfaceOrientation) + 465 (SharedPointerInternals.h:465)
25 U2Client 0x24d1fcc -[FIOSAsyncTask CheckForCompletion] + 69 (IOSAsyncTask.cpp:69)
26 U2Client 0x24d2044 +[FIOSAsyncTask ProcessAsyncTasks] + 107 (IOSAsyncTask.cpp:107)
27 U2Client 0x27e424c -[IOSAppDelegate MainAppThread:] + 297 (CoreGlobals.h:297)
28 Foundation 0x5b518 __NSThread__start__ + 716
29 libsystem_pthread.dylib 0x16cc _pthread_start + 148
30 libsystem_pthread.dylib 0xba4 thread_start + 8 FAsyncLoadingThread
0 libsystem_kernel.dylib 0x1268 __semwait_signal + 8
1 libsystem_c.dylib 0x57d8 nanosleep + 220
2 libsystem_c.dylib 0x64a4 usleep + 68
3 U2Client 0x261e12c FAsyncLoadingThread::Run() + 4772 (AsyncLoading.cpp:4772)
4 U2Client 0x2440214 FRunnableThreadPThread::Run() + 25 (PThreadRunnableThread.cpp:25)
5 U2Client 0x24236a8 FRunnableThreadPThread::_ThreadProc(void*) + 186 (PThreadRunnableThread.h:186)
6 libsystem_pthread.dylib 0x16cc _pthread_start + 148
7 libsystem_pthread.dylib 0xba4 thread_start + 8 FAsyncPurge
0 libsystem_kernel.dylib 0x167c __psynch_cvwait + 8
1 libsystem_pthread.dylib 0x806c _pthread_cond_wait + 1232
2 U2Client 0x2418fc4 FPThreadEvent::Wait(unsigned int, bool) + 443 (GenericPlatformProcess.cpp:443)
3 U2Client 0x26d9134 FAsyncPurge::Run() + 537 (GarbageCollection.cpp:537)
4 U2Client 0x2440214 FRunnableThreadPThread::Run() + 25 (PThreadRunnableThread.cpp:25)
5 U2Client 0x24236a8 FRunnableThreadPThread::_ThreadProc(void*) + 186 (PThreadRunnableThread.h:186)
6 libsystem_pthread.dylib 0x16cc _pthread_start + 148
7 libsystem_pthread.dylib 0xba4 thread_start + 8
Tip.FAsyncPurge는 언리얼엔진에서 가비지 컬렉션을 담당하는 비동기 스레드 -더 이상 사용되지 않는 객체들을 식별하고 정리(Purge)함
비동기 로딩 프로세스:
StaticLoadObject
-&gt; LoadPackage // 패키지 로딩 시작
-&gt; AsyncLoading 큐에 작업 등록
-&gt; FlushLoading // 로딩 완료 대기
-&gt; 로딩된 객체 반환 FlushLoading이 필요한 이유: LoadClass는 동기(Synchronous) 함수임 - 호출한 즉시 결과(UClass*)를 반환해야 함
하지만 실제 리소스 로딩은 비동기로 처리
따라서 비동기 로딩이 완료될 때까지 기다려야 함
이 "기다림"을 위해 FlushLoading 사용 FlushLoading의 역할:
void FAsyncLoadingThread::FlushLoading(int32 PackageId)
{ // 1. 현재 진행중인 비동기 로딩 작업들이 완료될 때까지 대기 // 2. 로딩된 객체들의 초기화/링킹 작업 // 3. 참조 관계 설정 // 4. 모든 작업이 완료되면 리턴
} 만약 FlushLoading이 없다면:
UClass* LoadedClass = LoadClass(...); // 비동기 로딩 시작
// 이 시점에서 실제 로딩이 안 된 상태로 반환될 수 있음
CreateWidget(LoadedClass); // 크래시! 아직 로딩 안 된 Class 사용 시도
UE의 FlushLoading은:큐에 있는 모든 비동기 로딩 작업을 처리할 때까지 대기
각 작업의 완료를 보장
모든 작업이 완료될 때까지 호출 스레드를 블록즉, "Flush"는 파이프라인이나 큐에 있는 모든 작업을 강제로 처리 완료시키는 동작을 의미
즉, FlushLoading은 비동기 로딩 시스템에서 동기적 결과가 필요할 때 사용되는 "동기화 포인트(Synchronization Point)"
이는 UE의 리소스 로딩 시스템에서 필수적인 메커니즘 크래쉬 발생 경로 UUIScreenController::CreatePopupUI()
-&gt; StaticLoadClass() -&gt; LoadPackage()
-&gt; FAsyncLoadingThread::FlushLoading()
-&gt; Fatal Error (Cannot Flush Async Loading while async loading is suspended) 상황:
1. ALT Status: Suspended (작업은 있지만 실행 못하는 상태)
[Task1] -&gt; [Task2] -&gt; [LoadClass Task] -&gt; [Task4]
하지만 실행 불가 (Suspended) 2. CreatePopupUI에서 LoadClass 호출
-&gt; StaticLoadObject -&gt; LoadPackage
-&gt; FlushLoading 호출 1. 교착 상태 발생:
FlushLoading: "모든 작업이 완료될 때까지 기다린다"
ALT: "Suspended 상태라 작업을 처리할 수 없다"
결과: ⚠️ 영원히 대기하게 됨 이유
AsyncLoadingThread가 suspend 상태일 때 LoadClass를 호출
LoadClass는 내부적으로 리소스 로딩을 위해 FlushLoading 호출
UE는 ALT가 Suspend 상태일 때 FlushLoading을 명시적으로 금지
UE_CLOG(IsAsyncLoadingSuspendedInternal(), LogStreaming, Fatal, TEXT("Cannot Flush Async Loading while async loading is suspended (%d)"), GetAsyncLoadingSuspendedCount()); UE가 이를 명시적으로 금지하는 이유
교착 상태 방지
리소스 로딩의 안전성 보장
명확한 에러 메시지로 개발자에게 문제 상황 전달 해결방안
ALT 상태를 먼저 체크하고 Suspend 상태일 때 지연 로딩을 하기 ]]></description><link>ue/fgenricerror.html</link><guid isPermaLink="false">UE/FGenricError.md</guid><pubDate>Fri, 24 Jan 2025 07:28:38 GMT</pubDate></item><item><title><![CDATA[언리얼 패키징 관련 Error]]></title><description><![CDATA[<a href=".?query=tag:unreal" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#unreal">#unreal</a> <a href=".?query=tag:error" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#error">#error</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted" target="_self">https://stackoverflow.com/questions/68387270/android-studio-error-installed-build-tools-revision-31-0-0-is-corrupted</a> 보고 적용-&gt; provisioning과 certificate matching을 다시 한번 확인하기
-&gt; 인증서와 모바일 프로비저닝 다시 임포트하기]]></description><link>ue/언리얼-패키징-관련-error.html</link><guid isPermaLink="false">UE/언리얼 패키징 관련 Error.md</guid><pubDate>Fri, 24 Jan 2025 07:28:26 GMT</pubDate></item><item><title><![CDATA[UE4.27 iOS Background 앱 크래쉬]]></title><description><![CDATA[<a href=".?query=tag:unreal" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#unreal">#unreal</a> <a href=".?query=tag:error" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#error">#error</a> 게임을 실행하고 플레이한다.
앱을 백그라운드로 전환한다.
일정 시간 지난 후에 (시간은 각각 다양합니다.) 앱을 켭니다.
앱 크래쉬 발생 렌더 스레드를 Flush 하고 suspend 하는 생성자
생성자 - 렌더링 스레드를 없애고 재생성할 지, 단순 일시정지인 지 결정
// 렌더링 스레드가 일시 중단되는 동안 렌더링 명령 대기열을 시작하지 않도록 비동기 로드 스레드를 일시 중단합니다.
if (IsAsyncLoadingMultithreaded())
{ SuspendAsyncLoading();
} Async Loading Thread는 렌더링에 필요한 리소스를 비동기적으로 로딩하고 사용하지 않는 리소스들을 언로드한다.앱이 백그라운드 전환시에 렌더링 스레드 일시 중지 -&gt; 비동기 로딩 중단 -&gt; 비동기 로딩 기다림 -&gt; 크래쉬앱이 Background 갈 때 FAppEntry::Suspend(true) -&gt; 스레드 중지
앱이 Foreground로 다시 돌아와서 팝업을 열어야 하는데 Async Loading Thread가 중지되어 있는 상태팝업을 여는 코드에서 Load Package를 하는 부분이 있는데 이때 ALT를 이용. 따라서 ALT가 돌지 않고 메인스레드는 ALT를 기다리고 있기 때문에 Stall 발생
프로젝트 세팅에서 비동기화 로딩 스레드 끔 -&gt; 앱 크래쉬는 나지 않으나, 게임스레드가 모든 Asset을 로딩해서 속도 이슈가 있을 수 있음 ApplicationHasEnteredForegroundDelegate를 사용하지 말기(?) IOSAppDelegate.cpp
applicationDidEnterBackground
applicationWillEnterForeground
applicationDidBecomeActive
가 존재합니다. 각각 백그라운드로 갔을 때, Foreground로 돌아올 때 그리고 화면이 완전히 Active 되었을 때 호출되고 이는 각자 순서대로 호출함
FIOSCoreDelegates::ApplicationWillEnterBackgroundDelegate
FIOSCoreDelegates::ApplicationHasEnteredForegroundDelegate
FIOSCoreDelegates.OnDidBecomeActive
ApplicationHasEnteredForegroundDelegate를 사용하지 말고 OnDidBecomeActive 하면됨.]]></description><link>ue/ue4.27-ios-background-앱-크래쉬.html</link><guid isPermaLink="false">UE/UE4.27 iOS Background 앱 크래쉬.md</guid><pubDate>Fri, 24 Jan 2025 07:28:15 GMT</pubDate></item><item><title><![CDATA[FIOSView insertText - objc_msgSend]]></title><description><![CDATA[<a href=".?query=tag:unreal" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#unreal">#unreal</a> <a href=".?query=tag:error" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#error">#error</a> Crashed: com.apple.main-thread
0 libobjc.A.dylib 0x3020 objc_msgSend + 32
1 U2Client 0x246e35c -[FIOSView insertText:] + 636 (IOSView.cpp:636)
2 U2Client 0x246eaac -[FIOSView unmarkText] + 811 (IOSView.cpp:811)
3 UIKitCore 0xdc95d0 -[UIResponder(UITextInput_Internal) _unmarkText] + 68
4 UIKitCore 0xa7d590 -[UIKBInputDelegateManager unmarkText] + 48
5 UIKitCore 0x4d3e18 -[UIKeyboardImpl _teardownExistingDelegate:forSetDelegate:force:delayEndInputSession:] + 2180
6 UIKitCore 0x4d2808 -[UIKeyboardImpl setDelegate:force:delayEndInputSession:] + 624
7 UIKitCore 0x2c4b68 -[UIKeyboardSceneDelegate _reloadInputViewsForKeyWindowSceneResponder:force:fromBecomeFirstResponder:] + 2584
8 UIKitCore 0x325d3c -[UIKeyboardSceneDelegate _reloadInputViewsForResponder:force:fromBecomeFirstResponder:] + 88
9 UIKitCore 0x364d8c -[UIResponder _finishResignFirstResponderFromBecomeFirstResponder:] + 328
10 UIKitCore 0x3643d0 -[UIResponder resignFirstResponder] + 352
11 U2Client 0x246e8fc -[FIOSView resignFirstResponder] + 740 (IOSView.cpp:740)
12 UIKitCore 0x52cfa8 -[UIView(UITextField) endEditing:] + 136
13 U2Client 0x246e7bc 30-[FIOSView DeactivateKeyboard]_block_invoke + 102 (IOSInputInterface.h:102)
14 libdispatch.dylib 0x213c _dispatch_call_block_and_release + 32
15 libdispatch.dylib 0x3dd4 _dispatch_client_callout + 20
16 libdispatch.dylib 0x125a4 _dispatch_main_queue_drain + 988
17 libdispatch.dylib 0x121b8 _dispatch_main_queue_callback_4CF + 44
18 CoreFoundation 0x56710 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE + 16
19 CoreFoundation 0x53914 CFRunLoopRun + 1996
20 CoreFoundation 0x52cd8 CFRunLoopRunSpecific + 608
21 GraphicsServices 0x11a8 GSEventRunModal + 164
22 UIKitCore 0x40a90c -[UIApplication _run] + 888
23 UIKitCore 0x4be9d0 UIApplicationMain + 340
24 U2Client 0xdb1650 main + 568 (LaunchIOS.cpp:568)
25 ??? 0x1ac721e4c (누락)- (void)insertText:(NSString*)theText
{ if (nil != CachedMarkedText) { [CachedMarkedText release] ; CachedMarkedText = nil; } // insert text one key at a time, as chars, not keydowns for (int32 CharIndex = 0; CharIndex &lt; [theText length]; CharIndex++) { int32 Char = [theText characterAtIndex : CharIndex]; // FPlatformMisc::LowLevelOutputDebugStringf(TEXT("sending key '%c' to game\n"), Char); if (Char == '\n') { // send the enter keypress FIOSInputInterface::QueueKeyInput(KEYCODE_ENTER, Char); // hide the keyboard [self resignFirstResponder] ; } else { FIOSInputInterface::QueueKeyInput(Char, Char); } }
} 원인 예상
이미 해제한 CachedMarkedText를 접근하려고 했기 때문에
theText에 nil 값이 들어오기 때문에
해결
iOS - UI 관련된 작업은 main - thread에서 실행
]]></description><link>ue/fiosview-inserttext-objc_msgsend.html</link><guid isPermaLink="false">UE/FIOSView insertText - objc_msgSend.md</guid><pubDate>Fri, 24 Jan 2025 07:22:56 GMT</pubDate></item><item><title><![CDATA[Golf Simulator using SFML]]></title><description><![CDATA[C++, SFML을 이용해서 간단한 2D 골프 시뮬레이터를 만든 과정을 공유할 것입니다.이 프로젝트는 C++ 코드로 골프공 움직임을 시뮬레이션하고, SFML 라이브러리를 이용해서 렌더링 하는 것이 목표입니다..
└── src ├── core │&nbsp;&nbsp; ├── GolfBall.cpp │&nbsp;&nbsp; ├── GolfBall.h │&nbsp;&nbsp; ├── Simulator.cpp │&nbsp;&nbsp; └── Simulator.h └── main.cpp
class GolfBall {
private: const double gravity = 9.81; // 중력가속도 const double airDensity = 1.225; // 공기밀도 const double mass = 0.0459; // 골프공 질량 const double radius = 0.0213; // 골프공 반지름 const double dragCoefficient; // 항력계수: 0.47 const double liftCoefficient; // 양력계수: 0.1 double x, y; // 골프공 위치 double vx, vy; // x축, y축 방향의 속도 double spin; // 회전속도 (rad/s) public: GolfBall(double initialVelocity, double launchAngle, double initialSpin); void update(double dt); bool isFlying() const; std::pair&lt;double, double&gt; getPosition() const;
}
골프공에 작용하는 주요 힘은 간단하게 아래 3가지만 고려했습니다.
중력
항력
양력
void GolfBall::update(double dt) { double velocity = sqrt(vx * vx + vy * vy); // 스칼라 double area = M_PI * radius * radius; // 골프공 단면적 // 공기저항력 계산 double dragForce = 0.5 * airDensity * dragCoefficient * area * velocity * velocity; // 양력 계산 double liftForce = 0.5 * airDensity * liftCoefficient * area * velocity * velocity; // F = ma -&gt; a = F/m을 이용. double ax = -(dragForce * vx / velocity) / mass; double ay = -gravity - (dragForce * vy / velocity) / mass + (liftForce/mass); x += vx * dt; y += vy * dt; vx += ax * dt; vy += ay * dt; }
update 함수에서 위치(x,y)를 업데이트 하고 속도 (vx, vy)를 업데이트 하기 위해
항력(dragForce), 양력(liftForce)를 계산한 다음 이를 이용해 가속도를 구했습니다.<a data-href="SFML" href="graphics/sfml.html#_0" class="internal-link" target="_self" rel="noopener nofollow">SFML</a>class Simulator {
private: sf::RenderWindow window; // SFML 윈도우 GolfBall golfBall; // 골프공 객체 sf::CircleShape ballShape; // 골프공 그래픽 sf::View camera; // 카메라 뷰 const float SCALE = 10.0f; // 물리적 거리를 픽셀로 변환하는 비율 (1m = 10px)
}
Simulator::Simulator(double initialVelocity, double launchAngle, double initialSpin) : window(sf::VideoMode(sf::Vector2u(800, 600)), "Golf Simulator") { camera.setSize(sf::Vector2f(1600.f, 1200.f)); // ...
}
window 사이즈를 800, 600으로 설정했고 camera size를 2배로 설정했다. 따라서 2배 넓은 시야를 가진다. (축소 모드)void Simulator::run() { while (window.isOpen()) { handleEvents(); // 이벤트 처리 update(); // 물리 시뮬레이션 업데이트 render(); // 화면 렌더링 }
}
void Simulator::render() { window.clear(sf::Color(50, 50, 50)); updateCamera(); window.draw(groundShape); auto position = golfBall.getPosition(); sf::Vector2f ballPosition(position.first * SCALE, 500.f - position.second * SCALE); ballShape.setPosition(ballPosition); window.draw(ballShape); window.display(); }
핵심이 되는 함수다. 이 함수는 매 프레임마다 호출된다. 그래서 clear가 반드시 필요하다. clear를 하지 않으면 이전 프레임의 그림이 남아있어 새로운 프레임이 계속 중첩되어서 그려질 것이다. updateCamera()를 호출해서 카메라 위치를 업데이트하고 window에 groundShape를 그린다. (ground는 위치가 고정이라 그려주기만 하면 됨.)그 다음으로는 ballShape를 그려야하므로 ball의 위치를 가져온다. 현재 ball의 위치를 ballPosition 을 생성할 때 y축의 값이 500.f - position.second * SCALE 인 이유는 SFML의 좌표계와 ball의 좌표계가 다르기 때문이다.
물리 시뮬레이션 좌표계 Y축이 위로 갈수록 양수 (+)
지면이 0
공이 위로 올라갈수록 y값이 증가 SFML 화면 좌표계 Y축이 아래로 갈수록 양수 (+)
화면 최상단이 0
아래로 갈수록 y값이 증가 500.0f는 지면의 y좌표고 - position.second * SCALE 는 물리 좌표계의 y값을 화면 좌표계로 변환한 값이다.물리 좌표계 화면 좌표계 ↑ +y 0 ───── │ │ ↓ +y │ │ 0 ───── 500 ─────
마지막으로 ball의 위치를 설정하고 window에 그린 다음에 display 하면 끝이다.void Simulator::updateCamera() { auto ballPos = golfBall.getPosition(); sf::Vector2f targetCenter(ballPos.first * SCALE, 300.f); // 부드러운 카메라 이동 cameraCenter.x = cameraCenter.x + (targetCenter.x - cameraCenter.x) * CAMERA_SPEED;
}
표준 STL을 이용해서 리팩토링 진행함.
Simulator에서 GolfBall을 참조할 때 raw pointer를 사용 했는데 unique_ptr로 변경
make_pair(x,y)를 이용해 Position을 정의 하는 것보다 Struct으로 정의하는 것이 확장에 유리
Event Handler를 visitor pattern으로 해결
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/golf_simulator" target="_self">https://github.com/psychehose/golf_simulator</a>]]></description><link>golf-simulator/golf-simulator-using-sfml.html</link><guid isPermaLink="false">Golf Simulator/Golf Simulator using SFML.md</guid><pubDate>Fri, 24 Jan 2025 07:15:59 GMT</pubDate></item><item><title><![CDATA[1. 참조와 포인터]]></title><description><![CDATA[
성능 같음
포인터는 원본 전달을 확실히 알려줌.
참조는 표현적으로 원본을 넘겨주는 지 아닌지 애매함예시: PrintInfo(&amp;info) - 포인터 vs PrintInfo(info) - 참조참조에서 마음대로 고치는 부분은 const를 사용하면 해서 읽기용으로 만들 수 있음.물론 포인터도 const 사용 가능*을 기준으로 앞뒤에 따라 의미가 달라짐. 변경앞인 경우
void (const PrintInfo StatInfo info) {} -&gt; 주소값을 타고 가는 데이터 변경 불가능
info-&gt;hp = 100; // 에러
뒤인 경우:
void (PrintInfo StatInfo* const info) { } -&gt; 주소값 자체 변경 불가능
info = other_info; // 불가능 참조 타입은 참조하는 대상이 없으면 안됨 nullptr 개념 없음, 포인터는 nullptr 가능
int age = 29;
const int* pt = &amp;age; *pt += 1; // 불가능 age += 1; // age는 const가 아니므로 가능 cout &lt;&lt; age &lt;&lt; endl; // 가능
const float g_earth = 9.80;
const float* pe = &amp;g_earth; // 불가능 - pm을 이용해 g_moon의 값을 변경한다면 const라는 것이 무의미해지기 때문에
// c++은 const 변수의 주소를 const가 아닌 일반 포인터에 대입하는 것을 금지함.
const float g_moon = 1.63;
float* pm = &amp;g_moon; 포인터를 지시하는 포인터를 사용할 때 복잡해짐
const가 아닌 포인터를 const 포인터에 대입하는 것은 간접 지시인 경우에만 가능(?)int age = 29;
int* pd = &amp;age;
// 간접지시? 왜 간접지시냐면 pt는 결국 age를 가리키는 거랑 마찬가지이기 뗴문ㅇㅇ
const int* pt = pd; //( 이거 가능?) // age++ 가능
// *pd +=1 가능
// *pt += 1는 불가능!
위의 예에서 보다시피 간접지시에서 const와 const가 아닌 것을 섞어쓰는 것은 매우 non - safe임.const int **pt2;
int* p1;
const int n = 13; pp2 = &amp;p1; // 사실 안됨, 근데 된다고 가정
*pp2 = &amp;n; // const끼리니까 간접지시로 p1이 n을 가리키게 한다. *p1 = 10; // const n을 변경하게 만든다.? const 무효 const가 아닌 포인터를 const 포인터에 대입하는 것은 한다리만 건너는 간접지시인 경우에만 가능. 노트는 무슨 말이야 젠장..Note. 데이터형 자체가 포인터가 아니라면 const 데이터의 주소이든, const가 아닌 데이터의 주소이든 const를 지시하는 포인터(한다리 건너는 간접지시?) 에 모두 대입할 수 있다.
int n = 1; const int* p1 = &amp;n;
int* p2 = &amp;n; const int* p3 = p2; // 이게 안됨.
int* n2 = 2;
const int* p4 = &amp;n2;
int* p5 = p4; // 여기서 안됨 // 이것도 안됨
const int x = 5;
int* ptr = &amp;x; ]]></description><link>cpp/basic/1.-참조와-포인터.html</link><guid isPermaLink="false">CPP/Basic/1. 참조와 포인터.md</guid><pubDate>Fri, 24 Jan 2025 07:12:15 GMT</pubDate></item><item><title><![CDATA[0. c, c++ 컴파일 과정]]></title><description><![CDATA[<img alt="build_process.png" src="images/build_process.png" target="_self">
전처리 과정
소스 코드 파일 (.c / .cpp)를 전처리된 파일 *.i로 변환한다. Header file Inclusion - #include를 actual content로 대체한 후에 소스코드에 삽입한다.
Macro Expansion - #define PI 3.14를 확인하고 PI를 3.14로 치환한다.
Comments Removal - 주석을 삭제한다. 컴파일 과정
컴파일러를 통해 전처리된 파일 *.i를 어셈블리어 파일 .*s로 변환한다. 이 과정에서 언어의 문법 검사를 수행하고 Static한 Section에 대한 메모리 할당을 이뤄진다. 그리고 코드 최적화를 수행하고 코드를 생성한다.
어셈블리어 과정
어셈블러를 통해 어셈블리어 파일(*.s)을 오브젝트 파일 (*.o)로 변환한다. 오브젝트 파일은 어셈블된 코드를 소스코드와 긱어 코드의 중간 형태로 저장하고 표현하는데 사용되는 파일 형식이다. 이러한 오브젝트 파일은 실행파일에 결합하는 링커에 대한 입력 역할을 한다.<br><img alt="object_file_header.png" src="images/object_file_header.png" target="_self">Object File Header: 일반적으로 아키텍처, 섹션의 크기, entry point에 대한 정보가 들어있다.Text Section: 변환된 기계어로 이뤄진 코드가 들어 있다.Data Section: 프로그램에서 사용되는 초기화된 / 되지 않은 데이터가 들어있다. (전역변수 / static 변수)Symbol Table Section: &nbsp;변수 및 함수 이름과 같이 코드에 사용된 기호에 대한 정보가 포함됩니다. 이 정보는 연결 및 디버깅에 필수적입니다.Relocation Information Section: 이 정보는 프로그램이 최종 실행 파일을 형성하기 위해 다른 개체 파일과 연결될 때 코드의 주소를 조정해야 하는 방법을 지정합니다. 이는 기호에 대한 참조가 올바르게 해석되도록 보장합니다. 링킹 전까지 심볼의 위치를 확정할 수 없으므로 심볼의 위치가 확정 나면 바꿔야 할 내용을 적어놓은 부분입니다.Debugging Information Section: 디버깅에 필요한 정보가 있는 부분입니다.심볼(Symbol)은&nbsp;함수나 변수를 식별할 때 사용하는 이름으로&nbsp;심볼 테이블(Symbol Table)&nbsp;안에는 오브젝트 파일에서 참조되고 있는 심볼 정보(이름과 데이터의 주소 등)를 가지고 있다.이때 오브젝트 파일의 심볼 테이블에는 해당 오브젝트 파일의 심볼 정보만 가지고 있어야 하기 때문에&nbsp;다른 파일에서 참조되고 있는 심볼 정보의 경우 심볼 테이블에 저장할 수 없다.<br><img alt="printf.png" src="images/printf.png" target="_self">이 소스 코드 파일을 컴파일하여 하나의 오브젝트 파일을 생성할 수 있다.
하지만, 이 오브젝트 파일은 독립적으로 실행할 수가 없다. 왜냐하면 이 소스코드에서 printf 함수를 구현한 내용이 없기 때문이다. 전처리 과정을 통해 include &lt;stdio.h&gt;로부터 printf()의 원형은 복사했지만 구현한 내용은 포함되어 있지 않다.
Symbol Table에는 자신의 심볼 정보만 가지고 있지 외부에서 참조하는 printf에 대한 심볼 정보는 가지고 있지 않다.이 오브젝트 파일을 실행하기 위해서 printf 함수를 구현한 libc.a와 연결시키는 작업이 필요하다. 이러한 연결 과정을 링킹이라고 한다. 링킹 이후에 심볼의 위치가 확정되고 이 위치들은 Relocation Information Section에 저장된다.참고: 개체 파일 형식은 플랫폼마다 다릅니다.
ELF(Executable and Linkable Format):&nbsp;Linux를 포함한 Unix 계열 시스템
Mach-O(Mach Object):&nbsp;macOS 및 iOS
COFF(Common Object File Format):&nbsp;이전 Windows PE(Portable Executable):&nbsp;최신 Windows 시스템 링킹
프로그램에서 사용되는 모든 Object 파일과 라이브러리를 실행파일로 결합하는 과정이다. 이 과정을 통해 다양한 소스파일에서 참조되는 모든 함수와 변수가 올바르게 링크된다.링커는 한 Object 파일에서 참조하는 Symbol을 다른 Object 파일의 Symbol 정의와 일치시켜 확인한다. 만약 Symbol을 찾을 수 없다면 Link Error가 발생한다. (Symbol Resolution)그리고 Object 파일의 데이터의 주소나 코드의 메모리 참조 주소를 조정하여 알맞게 배치한다.
각 오브젝트 파일에 있는 데이터의 주소나 코드의 메모리 참조 주소가 실행 파일에서의 주소와 다르므로 알맞게 수정한다. (오브젝트 파일의 Relocation Information Section의 존재 이유)
이 과정을 Relocation 이라고 한다.링킹을 하기 전 오브젝트 파일을&nbsp;재배치 가능한 오브젝트 파일(Relocatable Object File)이라 부르고 링킹을 통해 만들어지는 오브젝트 파일을&nbsp;실행 가능한 오브젝트 파일(Executable Object File)이라 부른다.]]></description><link>cpp/basic/0.-c,-c++-컴파일-과정.html</link><guid isPermaLink="false">CPP/Basic/0. c, c++ 컴파일 과정.md</guid><pubDate>Fri, 24 Jan 2025 07:09:39 GMT</pubDate><enclosure url="images/build_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/build_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[424. Longest Repeating Character Replacement]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> You are given a string&nbsp;s&nbsp;and an integer&nbsp;k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most&nbsp;k&nbsp;times.Return&nbsp;the length of the longest substring containing the same letter you can get after performing the above operations.Example 1:Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.Example 2:Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.Constraints:
1 &lt;= s.length &lt;= 105
s&nbsp;consists of only uppercase English letters.
0 &lt;= k &lt;= s.length
못풀었다. 문제를 봤을 때 슬라이딩 윈도우일 것 같긴 했는데 조건을 생각하지 못했다.window size - max_count &gt; k 를 생각했어야 했다. 이걸 떠올리지 못한 이유가 무엇일까라고 생각해봤을 때, 빈도수 관리를 떠올리지 못해서 그런가 싶다.max_count 최적화에 대한 문제가 있는데 이해하면 간단하지만 이해가 쉽지 않았다. 이해를 힘들게 했는데 댓글을 보니 저렇게 생각하면 더 쉽게 이해할 수 있었을 것 같다.For those who are struggling to understand the optimisation with maxf, here is how i understood it: For a substring to be valid, we need window_length - maxf &lt;= k. Here, maxf is the frequency of the most common character in the current window. The difference window_length - maxf tells us how many characters we'd need to change to make the whole window the same character. The biggest valid substring we can get is of size maxf + k. So, the larger maxf is, the better. If maxf doesn't change or goes down, our potential best answer doesn't change. We don't need to update maxf in this case. On the other hand, if maxf goes up, it means we've found a character in the current window that appears more often than in previous windows. This means we might be able to get a longer valid substring, so we update maxf. Hope this helps! And thank you neetcode for the wonderful video as always.
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std; class Solution {
public: int characterReplacement(string s, int k) { unordered_map&lt;char, int&gt; countmap; int res = 0; int l = 0; for (int r = 0; r &lt; s.size(); ++r) { countmap[s[r]] = 1 + countmap[s[r]]; while((r - l + 1) - most_frequent(countmap) &gt; k) { countmap[s[l]] = countmap[s[l]] - 1; l += 1; } res = max(res, r - l + 1); } } int characterReplacement_opt(string s, int k) { unordered_map&lt;char, int&gt; countmap; int l = 0; int max_len = 0; int max_count = 0; for (int r = 0; r &lt; s.size(); ++r) { countmap[s[r]] = countmap[s[r]] + 1; max_count = max(max_count, countmap[s[r]]); while((r - l + 1) - max_count &gt; k) { countmap[s[l]] = countmap[s[l]] - 1; l += 1; } max_len = max(max_len, r-l+1); } return max_len; } int most_frequent(unordered_map&lt;char, int&gt;&amp; m) { int frequent = 0; for (auto&amp; [k, v] : m) { frequent = max(frequent, v); } }
};
]]></description><link>algorithm/leetcode/424.-longest-repeating-character-replacement.html</link><guid isPermaLink="false">Algorithm/LeetCode/424. Longest Repeating Character Replacement.md</guid><pubDate>Fri, 24 Jan 2025 07:06:54 GMT</pubDate></item><item><title><![CDATA[271. Encode and Decode Strings]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.Please implement&nbsp;encode&nbsp;and&nbsp;decodeExample 1:Input: ["neet","code","love","you"] Output:["neet","code","love","you"]
Example 2:Input: ["we","say",":","yes"] Output: ["we","say",":","yes"]
Constraints:
0 &lt;= strs.length &lt; 100
0 &lt;= strs[i].length &lt; 200
strs[i]&nbsp;contains only UTF-8 characters.
이 문제는 인코딩과 디코딩을 디자인하는 문제다. 평소에 푸는 PS와 좀 다른 스타일의 문제였다. 특징은 시간 복잡도는 이여야 하고, 공간 복잡도는 이여야 한다. 그래서 저장하는 멤버변수를 사용할 수 없다. #include &lt;vector&gt;
using namespace std; class Solution {
public: string encode(vector&lt;string&gt;&amp; strs) { string res; for (const auto&amp; c : strs) { res += to_string(c.size()) + "#" + c; } return res; } vector&lt;string&gt; decode(string s) { vector&lt;string&gt; res; int i = 0; while(i &lt; s.size()) { int j = i; while(s[j] != '#') { ++j; } int len = stoi(s.substr(i, j-i)); string sub = s.substr(j+1, len); res.push_back(sub); i = j + len + 1; } return res; }
}; stoi(), substr 사용 방법을 숙지할 수 있었다.]]></description><link>algorithm/leetcode/271.-encode-and-decode-strings.html</link><guid isPermaLink="false">Algorithm/LeetCode/271. Encode and Decode Strings.md</guid><pubDate>Fri, 24 Jan 2025 07:06:51 GMT</pubDate></item><item><title><![CDATA[217. Contains Duplicate]]></title><description><![CDATA[<a href=".?query=tag:alog" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#alog">#alog</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> Given an integer array&nbsp;nums, return&nbsp;true&nbsp;if any value appears&nbsp;at least twice&nbsp;in the array, and return&nbsp;false&nbsp;if every element is distinct.Example 1:Input: nums = [1,2,3,1]
Output: trueExample 2:Input: nums = [1,2,3,4]
Output: falseExample 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: trueConstraints:
1 &lt;= nums.length &lt;= 105
-109&nbsp;&lt;= nums[i] &lt;= 109 class Solution {
public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { std::set&lt;int&gt; s(nums.begin(), nums.end()); return s.size() != nums.size(); }
}; ]]></description><link>algorithm/leetcode/217.-contains-duplicate.html</link><guid isPermaLink="false">Algorithm/LeetCode/217. Contains Duplicate.md</guid><pubDate>Fri, 24 Jan 2025 07:06:48 GMT</pubDate></item><item><title><![CDATA[200. Number of Islands]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> Given an&nbsp;m x n&nbsp;2D binary grid&nbsp;grid&nbsp;which represents a map of&nbsp;'1's (land) and&nbsp;'0's (water), return&nbsp;the number of islands.An&nbsp;island&nbsp;is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.Example 1:Input: grid = [
["1","1","1","1","0"],
["1","1","0","1","0"],
["1","1","0","0","0"],
["0","0","0","0","0"]
]
Output: 1Example 2:Input: grid = [
["1","1","0","0","0"],
["1","1","0","0","0"],
["0","0","1","0","0"],
["0","0","0","1","1"]
]
Output: 3Constraints:
m == grid.length
n == grid[i].length
1 &lt;= m, n &lt;= 300
grid[i][j]&nbsp;is&nbsp;'0'&nbsp;or&nbsp;'1'.
#include &lt;vector&gt;
#include &lt;queue&gt; using namespace std; class Solution {
public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { vector&lt;vector&lt;bool&gt;&gt; m(grid.size(), vector&lt;bool&gt;(grid[0].size(), false)); vector&lt;int&gt; dr = {-1, 1, 0, 0}; vector&lt;int&gt; dc = {0, 0 , -1, 1}; int result = 0; for (int i = 0; i &lt; grid.size(); ++i) { for (int j = 0; j &lt; grid[0].size(); ++j) { if (grid[i][j] == '1' &amp;&amp; m[i][j] == false) { queue&lt;pair&lt;int, int&gt;&gt; q; q.push({i,j}); m[i][j] = true; while (!q.empty()) { int r = q.front().first; int c = q.front().second; q.pop(); for (int k = 0; k &lt; 4; ++k) { int new_r = dr[k] + r; int new_c = dc[k] + c; if (new_r &gt;= 0 &amp;&amp; new_r &lt; grid.size() &amp;&amp; new_c &gt;= 0 &amp;&amp; new_c &lt; grid[0].size() &amp;&amp; m[new_r][new_c] == false) { m[new_r][new_c] = true; if (grid[new_r][new_c] == '1') { q.push({new_r, new_c}); } } } } ++result; } } } return result; }
};
class Solution {
public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { if (grid.empty() || grid[0].empty()) return 0; int rows = grid.size(); int cols = grid[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(cols, false)); static constexpr array&lt;pair&lt;int, int&gt;, 4&gt; d = { {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} }; auto bfs = [&amp;](int row, int col) { queue&lt;pair&lt;int, int&gt;&gt; q; q.push({row, col}); visited[row][col] = true; while (!q.empty()) { auto [r, c] = q.front(); q.pop(); for (const auto&amp; [dr, dc] : d) { int nr = r + dr; int nc = c+ dc; if (nr &gt;= 0 &amp;&amp; nr &lt; grid.size() &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; grid[0].size() &amp;&amp; !visited[nr][nc] &amp;&amp; grid[nr][nc] == '1') { visited[nr][nc] = true; q.push({nr, nc}); } } } }; int result = 0; for (int i = 0; i &lt; rows; ++i) { for (int j = 0; j &lt; cols; ++j) { if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) { bfs(i,j); ++result; } } } return result; }
};
]]></description><link>algorithm/leetcode/200.-number-of-islands.html</link><guid isPermaLink="false">Algorithm/LeetCode/200. Number of Islands.md</guid><pubDate>Fri, 24 Jan 2025 07:06:41 GMT</pubDate></item><item><title><![CDATA[198. House Robber]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and&nbsp;it will automatically contact the police if two adjacent houses were broken into on the same night.Given an integer array&nbsp;nums&nbsp;representing the amount of money of each house, return&nbsp;the maximum amount of money you can rob tonight&nbsp;without alerting the police.Example 1:Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.Example 2:Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.Constraints:
1 &lt;= nums.length &lt;= 100
0 &lt;= nums[i] &lt;= 400
순회를 할 때 이 원소를 더할 것이냐, 더하지 않을 것이냐로 결정 -&gt; 하위 문제로 분할할 수 있음.rob[n]은 n까지의 최대값으로 정의
rob[n] = max(rob[n-2] + arr[n], rob[n-1])
class Solution {
public: int rob(vector&lt;int&gt;&amp; nums) { int rob1 = 0; int rob2 = 0; for (int num : nums) { int temp = std::max(rob1 + num, rob2); rob1 = rob2; rob2 = temp; } return rob2; }
};
]]></description><link>algorithm/leetcode/198.-house-robber.html</link><guid isPermaLink="false">Algorithm/LeetCode/198. House Robber.md</guid><pubDate>Fri, 24 Jan 2025 07:06:32 GMT</pubDate></item><item><title><![CDATA[78. Subsets]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> Given an integer array&nbsp;nums&nbsp;of&nbsp;unique&nbsp;elements, return&nbsp;all possible&nbsp;subsets&nbsp;(the power set).The solution set&nbsp;must not&nbsp;contain duplicate subsets. Return the solution in&nbsp;any order.Constraints:
1 &lt;= nums.length &lt;= 10
-10 &lt;= nums[i] &lt;= 10
All the numbers of&nbsp;nums&nbsp;are&nbsp;unique.
<br><img alt="subset_graph.png" src="images/subset_graph.png" target="_self">class Solution {
public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; curr; vector&lt;vector&lt;int&gt;&gt; result; dfs(nums, 0, curr, result); return result; } private: void dfs( vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; curr, vector&lt;vector&lt;int&gt;&gt;&amp; result) { result.push_back(curr); for(int i = start; i &lt; nums.size(); i++) { curr.push_back(nums[i]); dfs(nums, i+1, curr, result); curr.pop_back(); } }
};
]]></description><link>algorithm/leetcode/78.-subsets.html</link><guid isPermaLink="false">Algorithm/LeetCode/78. Subsets.md</guid><pubDate>Fri, 24 Jan 2025 07:06:13 GMT</pubDate><enclosure url="images/subset_graph.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subset_graph.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[70. Climbing Stair]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a>You are climbing a staircase. It takes&nbsp;n&nbsp;steps to reach the top.Each time you can either climb&nbsp;1&nbsp;or&nbsp;2&nbsp;steps. In how many distinct ways can you climb to the top?Example 1:Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1 step + 1 step
2 steps
Example 2:Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1 step + 1 step + 1 step
1 step + 2 steps
2 steps + 1 step
Constraints:
1 &lt;= n &lt;= 45
점화식으로 해결class Solution {
public: int climbStairs(int n) { if (n == 1) return 1; std::vector&lt;int&gt; dp { 1, 2 }; dp.reserve(n); for (int i = 2; i &lt; n; ++i) { dp.push_back(dp[i-1] + dp[i-2]); } return *(dp.end() - 1); }
};
]]></description><link>algorithm/leetcode/70.-climbing-stair.html</link><guid isPermaLink="false">Algorithm/LeetCode/70. Climbing Stair.md</guid><pubDate>Fri, 24 Jan 2025 07:05:59 GMT</pubDate></item><item><title><![CDATA[62. Unique Paths]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> There is a robot on an&nbsp;m x n&nbsp;grid. The robot is initially located at the&nbsp;top-left corner&nbsp;(i.e.,&nbsp;grid[0][0]). The robot tries to move to the&nbsp;bottom-right corner&nbsp;(i.e.,&nbsp;grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers&nbsp;m&nbsp;and&nbsp;n, return&nbsp;the number of possible unique paths that the robot can take to reach the bottom-right corner.The test cases are generated so that the answer will be less than or equal to&nbsp;2 * 109.Example 1:<br><img alt="robot_maze.png" src="images/robot_maze.png" target="_self">Input: m = 3, n = 7
Output: 28Example 2:Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner 1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down#include &lt;vector&gt; class Solution {
public: int uniquePaths(int m, int n) { // dp 초기화 std::vector&lt;std::vector&lt;int&gt;&gt; dp(m, std::vector&lt;int&gt;(n,1)); for (std::vector&lt;std::vector&lt;int&gt;&gt;::size_type r = 1; r &lt; dp.size(); ++r) { for (std::vector&lt;int&gt;::size_type c = 1; c &lt; dp[r].size(); ++c) { dp[r][c] = dp[r-1][c] + dp[r][c-1]; } } return dp[m-1][n-1]; }
};
]]></description><link>algorithm/leetcode/62.-unique-paths.html</link><guid isPermaLink="false">Algorithm/LeetCode/62. Unique Paths.md</guid><pubDate>Fri, 24 Jan 2025 07:05:31 GMT</pubDate><enclosure url="images/robot_maze.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/robot_maze.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[55. Jump Game]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a> You are given an integer array&nbsp;nums. You are initially positioned at the array's&nbsp;first index, and each element in the array represents your maximum jump length at that position.Return&nbsp;true&nbsp;if you can reach the last index, or&nbsp;false&nbsp;otherwise.Example 1:Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.나는 visited 배열과 queue를 이용해서 bfs로 풀었다.핵심 로직은 순회하면서 pop할 아이템을 pair(최대 점프할 수 있는 수, 현재 인덱스)로 설정하고
현재 인덱스 == 마지막 인덱스 or 현재 인덱스 + 최대 점프할 수 있는 수 &gt;= 마지막 인덱스 인 경우
true를 리턴 했다.시간복잡도는 최대 ) 를 가질 수 있다.class Solution {
public: bool canJump(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) { return true; } vector&lt;bool&gt; visited(nums.size(), false); // max, cur size queue&lt;pair&lt;int, int&gt;&gt; q; q.push({nums[0], 0}); visited[0] = true; while (!q.empty()) { int max = q.front().first; int cur = q.front().second; q.pop(); if (max == 0) continue; if (cur == nums.size() - 1 || cur + max &gt;= nums.size() - 1) return true; for (int i = cur + 1; i &lt; cur + max + 1; ++i) { if (!visited[i]) { q.push({nums[i], i}); visited[i] = true; } } } return false; }
}; 이 문제는 그리디로 푸는 게 더 합리적이다.class Solution {
public: bool canJump(vector&lt;int&gt;&amp; nums) { int goal = nums.size() - 1; for (int i = nums.size() - 1; i &gt;= 0; --i) { if (i + nums[i] &gt;= goal) goal = i; } return goal == 0; }
};
순회를 반대로 하여 i + nums[i]와 goal을 비교하면 된다. i + nums[i]이 더 크다면 goal에 도달할 수 있다는 것이기 때문에 goal을 업데이트 할 수 있다. 순회가 다 끝났을 때 goal == 0인 경우 true이다.]]></description><link>algorithm/leetcode/55.-jump-game.html</link><guid isPermaLink="false">Algorithm/LeetCode/55. Jump Game.md</guid><pubDate>Fri, 24 Jan 2025 07:05:20 GMT</pubDate></item><item><title><![CDATA[3. Longest Substring Without Repeating Characters]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a> <a href=".?query=tag:blind75" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#blind75">#blind75</a> <a href=".?query=tag:medium" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#medium">#medium</a>Given a string&nbsp;s, find the length of the&nbsp;longest&nbsp;substring&nbsp;without repeating characters.Example 1:Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.Example 2:Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.Example 3:Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.Constraints:
0 &lt;= s.length &lt;= 5 * 104
s&nbsp;consists of English letters, digits, symbols and spaces.
내 답시간복잡도 - find, erase = 공간복잡도 class Solution {
public: int lengthOfLongestSubstring(string s) { size_t result = 0; string sub_s; for (size_t i = 0; i &lt; s.size(); ++i) { if (auto p = sub_s.find(s[i]); p != string::npos) { // find result = max(result, sub_s.size()); sub_s.erase(0,p + 1); } sub_s += s[i]; } return max(result, sub_s.size()); }
};
neetcode 답Sliding window using set시간복잡도 공간복잡도 class Solution {
public: int lengthOfLongestSubstring(string s) { unordered_set&lt;char&gt; charSet; int l = 0; int res = 0; for (int r = 0; r &lt; s.size(); r++) { while (charSet.find(s[r]) != charSet.end()) { charSet.erase(s[l]); l++; } charSet.insert(s[r]); res = max(res, r - l + 1); } return res; }
};
]]></description><link>algorithm/leetcode/3.-longest-substring-without-repeating-characters.html</link><guid isPermaLink="false">Algorithm/LeetCode/3. Longest Substring Without Repeating Characters.md</guid><pubDate>Fri, 24 Jan 2025 07:05:01 GMT</pubDate></item><item><title><![CDATA[그리디 알고리즘]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a>
현재 상황에서 지금 당장 좋은 것만 고르는 방법
문제 1.<br>
<img alt="greedy_1.png" src="images/greedy_1.png" target="_self">#include &lt;bits/stdc++.h&gt; using namespace std; int n = 1260;
int cnt; int coinTypes[4] = {500, 100, 50, 10}; int main()
{ for (int i = 0; i &lt; 4; ++i) { cnt += n / coinTypes[i]; n % = coinTypes[i]; } cout &lt;&lt; cnt &lt;&lt; '\n';
} 문제 2. <br><img alt="greedy_2.png" src="images/greedy_2.png" target="_self">2 이상의 수로 나누는 것이 1을 빼는 것보다 수를 더 많이 줄일 수 있음 -&gt; 그리디#include &lt;bits/stdc++.h&gt; using namespace std; int n,k;
int result; int main()
{ cin &gt;&gt; n &gt;&gt; k; while (true) { // n이 k로 나누어 떨어지는 수가 될 때까지 빼기 int target = (n/k) * k; result += (n - target); n = target; // n이 k보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출 if (n &lt; k) break; result++; n /= k; } // 마지막으로 남은 수에 대하여 1씩 빼기 result += (n-1); cout &lt;&lt; result &lt;&lt;'\n';
}
문제 3.<br><img alt="greedy_3.png" src="images/greedy_3.png" target="_self">Mine: 0이나 1을 만났을 때 더하기 나머지 곱하기#include &lt;bits/stdc++.h&gt; using namespace std; string str; int main()
{ cin &gt;&gt; str; long long result = str[0]-'0'; for (int i = 1; i &lt; str.size(); i++) { int num = str[i] - '0'; if (num &lt; = 1 || result &lt;= 1) result += num; else result *= num; } cout &lt;&lt; result &lt;&lt; '\n';
} 문제 4.<br><img alt="greedy_4.png" src="images/greedy_4.png" target="_self">예시: n = 5, 공포도 : 2 3 1 2 2오름차순 정렬하고 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면 그룹 결성 그룹1: 1, 2, 3
그룹2: 2 2#include &lt;bits/stdc++.h&gt; using namespace std; int n;
vector&lt;int&gt; arr; int main()
{ cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; arr.push_back(x); } sort(arr.begin(), arr.end()); int result = 0; int cnt = 0; for(int i =0; i &lt; n; i++) { cnt += 1; if( cnt &gt;= arr[i]) { result +=1; cnt = 0; } } cout &lt;&lt; result &lt;&lt; '\n';
} ]]></description><link>algorithm/lecture/그리디-알고리즘.html</link><guid isPermaLink="false">Algorithm/Lecture/그리디 알고리즘.md</guid><pubDate>Fri, 24 Jan 2025 07:04:54 GMT</pubDate><enclosure url="images/greedy_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DFS]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a>
스택 또는 재귀 이용
<br><img alt="DFS_1.png" src="images/dfs_1.png" target="_self"><br><img alt="DFS_2.png" src="images/dfs_2.png" target="_self">#include &lt;bits/stdc++.h&gt; using namespace std; bool visited[9];
vector&lt;int&gt; graph[9]; void dfs(int x) { visited[x] = true; cout &lt;&lt; x &lt;&lt; ' '; for(int i = 0; i &lt; graph[x].size(); i++) { int y = graph[x][i]; if (!visited[y] ) dfs(y); }
} int main(void) { graph[1].push_back(2); graph[1].push_back(3); graph[1].push_back(8); // 노드 2에 연결된 노드 정보 저장 graph[2].push_back(1); graph[2].push_back(7); // 노드 3에 연결된 노드 정보 저장 graph[3].push_back(1); graph[3].push_back(4); graph[3].push_back(5); // 노드 4에 연결된 노드 정보 저장 graph[4].push_back(3); graph[4].push_back(5); // 노드 5에 연결된 노드 정보 저장 graph[5].push_back(3); graph[5].push_back(4); // 노드 6에 연결된 노드 정보 저장 graph[6].push_back(7); // 노드 7에 연결된 노드 정보 저장 graph[7].push_back(2); graph[7].push_back(6); graph[7].push_back(8); // 노드 8에 연결된 노드 정보 저장 graph[8].push_back(1); graph[8].push_back(7); // dfs(1); return 0;
} ]]></description><link>algorithm/lecture/dfs.html</link><guid isPermaLink="false">Algorithm/Lecture/DFS.md</guid><pubDate>Fri, 24 Jan 2025 07:04:53 GMT</pubDate><enclosure url="images/dfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/dfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS]]></title><description><![CDATA[<a href=".?query=tag:algo" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#algo">#algo</a>
너비 우선 탐색
가까운 노드부터 우선적으로 탐색
큐 자료구조
<br><img alt="BFS_1.png" src="images/bfs_1.png" target="_self"><br><img alt="BFS_2.png" src="images/bfs_2.png" target="_self">
#include &lt;bits/stdc++.h&gt; using namespace std; bool visited[9];
vector&lt;int&gt; graph[9]; // BFS 함수 정의
void bfs(int start) { queue&lt;int&gt; q; q.push(start); // 현재 노드를 방문 처리 visited[start] = true; // 큐가 빌 때까지 반복 while(!q.empty()) { // 큐에서 하나의 원소를 뽑아 출력 int x = q.front(); q.pop(); cout &lt;&lt; x &lt;&lt; ' '; // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입 for(int i = 0; i &lt; graph[x].size(); i++) { int y = graph[x][i]; if(!visited[y]) { q.push(y); visited[y] = true; } } }
} int main(void) { // 노드 1에 연결된 노드 정보 저장 graph[1].push_back(2); graph[1].push_back(3); graph[1].push_back(8); // 노드 2에 연결된 노드 정보 저장 graph[2].push_back(1); graph[2].push_back(7); // 노드 3에 연결된 노드 정보 저장 graph[3].push_back(1); graph[3].push_back(4); graph[3].push_back(5); // 노드 4에 연결된 노드 정보 저장 graph[4].push_back(3); graph[4].push_back(5); // 노드 5에 연결된 노드 정보 저장 graph[5].push_back(3); graph[5].push_back(4); // 노드 6에 연결된 노드 정보 저장 graph[6].push_back(7); // 노드 7에 연결된 노드 정보 저장 graph[7].push_back(2); graph[7].push_back(6); graph[7].push_back(8); // 노드 8에 연결된 노드 정보 저장 graph[8].push_back(1); graph[8].push_back(7); bfs(1);
}
]]></description><link>algorithm/lecture/bfs.html</link><guid isPermaLink="false">Algorithm/Lecture/BFS.md</guid><pubDate>Fri, 24 Jan 2025 07:04:51 GMT</pubDate><enclosure url="images/bfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4. BLE 디바이스 연결]]></title><description><![CDATA[<a href=".?query=tag:bluetooth" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bluetooth">#bluetooth</a>GAP periphral로 동작하는 디바이스에서 advertising 함 Device Name, Mac Address, TxPower 등과 같은 간단한 정보를 GAP Central로 동작하는 근처 BLE 디바이스에 알리는 동작이다.PHY의 40개 채널 중 3개 (37 ~ 39)를 이용하고 각 채널은 2.4 GHz 대역 중에서도 Wifi 간섭이 가장 적을 것을 예상되는 주파수를 중심 주파수로 가짐<br><img alt="images/ble-conn-fig-1.png" src="images/ble-conn-fig-1.png" target="_self">GAP Central로 동작하는 디바이스는 BLE 무선 연결을 위해 근처에 연결 가능한 디바이스가 있는지 찾는다. 즉 근처에 Advertising 하고 있는 디바이스를 탐색하는 작업이다. Scanning도 advertising 채널(37 ~ 39) 에 대해 수행한다.<br><img alt="images/ble-conn-fig-2.png" src="images/ble-conn-fig-2.png" target="_self">peripheral 디바이스는 한 번에 3개의 채널을 advertising 하고 central 디바이스는 일정 간격으로 하나의 채널을 scanning 한다.주요 scanning parameter는 scan interval, scan window가 있다.
scan interval은 scanning 시작시간 사이의 간격을 정의한다.scan window는 한 채널에서 실제로 scanning 하는 구간을 정의한다.advertising 채널과 scanning 채널이 일치하는 경우에만&nbsp;Scanner&nbsp;에서 advertising 데이터를 수신할 수 있으며, advertising 시간은 수 ms 인 반면&nbsp;Scanner&nbsp;에서는 수십에서 수백 ms 동안 scanning 동작을 수행한다. 따라서,&nbsp;Scanner&nbsp;에서는 기본적으로&nbsp;Advertiser&nbsp;에 비해 보다 많은 양의 전류를 소비하게 된다.<br><img alt="images/ble-conn-fig-3.png" src="images/ble-conn-fig-3.png" target="_self">peripheral 디바이스에서 advertising 직후 해당 채널의 신호를 수신하는 시간을 갖는다. peripheral 디바이스에서 advertising 주기와 scanning 주기가 겹치는 시점에 채널을 통해서 central 디바이스의 연결 요청 신호 (CREQ: connection request)를 수신하게 되면 무선 연결이 시작된다. 무선 연결이 시작되고나서 먼저 본격적인 데이터 교환 전에 하드웨어 단에서 필요한 파라미터를 포함한 연결 파라미터를 주고 받는다. 또 이 시점에 연결 주기, 타임아웃 시간 등을 정보를 주고 받고 이 파라미터는 대부분 central 디바이스가 결정한다.
다만 peripheral 디바이스도 연결 파라미터를 제안할 수 있다. 제안할 수 있는 항목은 아래와 같다.
minimum connection interval
maximum connection interval
slave latency
connection supervision timeout
advertising 채널을 제외한 37개 채널을 이용해 FHSS 방식으로 데이터를 주고 받는다.연결파라미터에 대한 추가connection interval은 BLE 패킷을 주고 받는 시간 간격이다.
connection supervision timeout은 BLE 디바이스가 연결된 상태에서 얼마 동안 패킷을 교환하지 못할 때 연결을 끊을 것일지 판단하는 값이다.slave latency BLE 디바이스가 무선을 연결된 상태에서의 패킷 교환 주기는 최대 4초이다. 그런데 slava latency 파라미터를 사용하면 연결 주기를 늘릴 수 있다. 무선 연결을 유지하기 위해 교환하는 더미 패킷을 몇 번까지 무시할 것인지 결정하는 파라미터이다.예를 들면 Slave latency 를 이용하면&nbsp;GAP peripheral&nbsp;디바이스에 전송할 유효한 데이터가 없는 경우,&nbsp;GAP central&nbsp;디바이스에 더미 패킷을 전송하는 과정을 건너뛸 수 있고, 따라서 불필요한 전력 소모를 줄일 수 있게 된다. 만약 connection interval 값을 4 secs 로 설정하고, slave latency 를 2 로 설정하는 경우, 유효한 데이터가 없는 상황에서는&nbsp;GAP peripheral&nbsp;디바이스의 더미 패킷 전송을 두 번 스킵할 수 있으므로 연결 주기가 12 secs 정도가 되는 셈이다.]]></description><link>ble/4.-ble-디바이스-연결.html</link><guid isPermaLink="false">BLE/4. BLE 디바이스 연결.md</guid><pubDate>Fri, 24 Jan 2025 07:04:19 GMT</pubDate><enclosure url="images/ble-conn-fig-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. BLE ATT, GATT]]></title><description><![CDATA[<a href=".?query=tag:bluetooth" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bluetooth">#bluetooth</a>ATT는 서버와 클라이언트 사이의 데이터 교환에 대한 규칙이다. 데이터 교환은 ATT를 기반으로 이뤄지고 각각의 데이터 구조는 GATT에 의해 정의 된다.GATT에 의해 정의되는 데이터 구조는 Service와 Characteristic으로 표현된다.<br><img alt="images/ble-gatt-structure.png" src="images/ble-gatt-structure.png" target="_self">Service는 characteristic의 집합이고 데이터들은 Characteristic에 의해 정의된다.이러한 Service와 Characteristic은 attribute 라는 최소 데이터 유닛에 의해 정의된다. 이러한 attribute에 대한 것들은 attribute table 내에 저장된다.attribute는 type (uuid), handle, permission에 대한 정보를 포함<br><img alt="images/ble-attribute-table.png" src="images/ble-attribute-table.png" target="_self">각 행은 하나의 attribute를 나타냄handle은 attribute의 주소 값에 해당
permission에 service 또는 characteristic의 접근 권한에 대한 정보 저장
UUID는 고유 식별자<br><img alt="images/ble-data-exchange.png" src="images/ble-data-exchange.png" target="_self">데이터를 가지고 있는 디바이스가 GATT Server
요청하는 쪽이 GATT client]]></description><link>ble/3.-ble-att,-gatt.html</link><guid isPermaLink="false">BLE/3. BLE ATT, GATT.md</guid><pubDate>Fri, 24 Jan 2025 07:04:05 GMT</pubDate><enclosure url="images/ble-gatt-structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-gatt-structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. BLE 프로토콜 스택]]></title><description><![CDATA[<a href=".?query=tag:bluetooth" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bluetooth">#bluetooth</a>BLE stack은 BLE 디바이스의 구조를 나타냄.블루투스 표준에서 정의하고 있는 LE 모드로 동작하는 디바이스가 갖춰야 하는 기능들을 포함하고 있다.<br><img alt="ble_host_controller.png" src="images/ble_host_controller.png" target="_self">스택은 Host와 Controller로 구성 되어 있음 (Host는 아이폰, Controller는 애플워치, 에어팟 등등)
신호를 송수신하기 위한 하드웨어로 구성
2.4 GHZ ISM 주파수 대역에서 동작
GFSK, FHSS 방식으로 데이터 송수신
주파수 영역 일부를 40개의 구간으로 나누어 신호를 주고 받음 - 각 구간을 채널이라고 함 PHY와 직접적으로 상호 작용하는 레이어
하드웨어와 소프트웨어 사이에서 동작함
하드웨어와 연결되어 BLE 디바이스 간의 연결을 직접적으로 관리
암호, 연결 상태 및 채널 업데이트 등의 역할 수행
<br><img alt="images/ble-link-layer.png" src="images/ble-link-layer.png" target="_self">!BLE 디바이스는 LL에서 하나의 상태로 동작함
Standby
Advertising
Scanning
Initiating
Connected
<br><img alt="ble-connection 1.png" src="images/ble-connection-1.png" target="_self">두 개의 BLE 디바이스가 연결을 할 때의 동작 모습이러한 BLE 연결 과정은 GAP에 의해 관리됨
Host와 Controller가 분리되어 있는 경우 두 모듈 사이의 상호작용을 담당 상위 레이어 (GATT / GAP) 하위 레이어 사이의 상호작용 담당
BLE 패킷에 데이터를 포함하거나, 추출하는 역할
// 상위 레이어와 하위 레이어는 BLE 패킷으로 데이터를 송수신 함<br><img alt="images/ble-l2cap.png" src="images/ble-l2cap.png" target="_self">
Security Manager는 자주 연결하는 디바이스 (Peer) 사이의 보안 코드 (Key)를 관리 배포하는 역할 서버와 클라이언트 사이의 데이터 교환에 대한 규칙
데이터 교환의 주체
정보를 가지고 있는 Device를 GATT server
요청하는 디바이스를 GATT client 연결 및 Advertising 동작을 관리하는 최상위 레이어
각 디바이스의 LL 상태를 결정
서로 다른 BLE 디바이스 사이의 상호 작용을 관리하는 모듈
GAP는 동작 상태 중 하나를 가짐 Broadcaster
Observer
Peripheral
Central
Peripheral (주변기기 - 에어팟과 같은)로 동작하는 디바이스는 LL에서 Advertising 상태를 유지함 일반적으로 Advertising에서 디바이스 이름과 간단한 정보만을 송신한다. 그리고 이러한 Peripheral 디바이스를 Scanning 해서 연결까지 가능한 디바이스를 Central(중앙장치)로서 동작하는 디바이스라고 함.Peripheral 디바이스가 연결 과정 없이 Advertising 동작을 수행하는 경우 이러한 디바이스를 Broadcater라고 한다. 이 때 이름 이외에도 실질적인 데이터를 실어서 전송 이러한 장치를 비콘이라고 부름역시 Central 디바이스가 연결 과정 없이 Scanning 동작만을 수행할 때 Observer라고 일컫고 일반적으로 Advertising 패킷 내의 데이터를 타겟으로 하므로 비콘 신호를 수신할 때 사용한다.]]></description><link>ble/2.-ble-프로토콜-스택.html</link><guid isPermaLink="false">BLE/2. BLE 프로토콜 스택.md</guid><pubDate>Fri, 24 Jan 2025 07:04:04 GMT</pubDate><enclosure url="images/ble_host_controller.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_host_controller.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1. BLE 개요]]></title><description><![CDATA[<a href=".?query=tag:bluetooth" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#bluetooth">#bluetooth</a>Bluetooth Low Energy (BLE)
WPAN 기술의 일종
Bluetooth 4.0부터 저전력 프로토콜 지원
Bluetooth 5.0부터 확장 기능 제공
BD/EDR과의 차이점
BD/EDR은 데이터 전송 속도와 연속성에 초점 BLE는 전력 소모를 줄이는 것에 초점
BLE는 대량의 정보를 빠르게 전송하는 것보다 소량의 정보를 주기적으로 또는 간헐적으로 보내는 시스템에 적합한 기술응용 분야 - 헬스케어, 무선 센서 네트워크]]></description><link>ble/1.-ble-개요.html</link><guid isPermaLink="false">BLE/1. BLE 개요.md</guid><pubDate>Fri, 24 Jan 2025 07:04:01 GMT</pubDate></item><item><title><![CDATA[P4 extension, P4 Triggers]]></title><description><![CDATA[trigger와 extension을 사용하면 Helix core에서 발생하는 동작과 바인딩해서 유저가 작생한 로직을 실행할 수 있음.
특정 Perforce 명령어가 실행될 때 자동으로 실행되는 스크립트
주로 간단한 검증이나 알림을 위해 사용
shell, python, perl 등 사용
form - out을 이용해서 디폴트 description 변경 Perforce 서버의 기능을 확장하는 플러그인 형태의 프로그램
lua로 작성되며 Perforce API를 직접 사용할 수 있음
복잡한 로직에 적합함
swarm을 extension으로 사용했음.
둘은 동시 사용 가능예시는 form-out 이벤트가 발생할 때 default description를 변경하는 것이다.
p4 trigger와 바인딩할 파일(shell, python 등등 가능) 을 p4 서버 내에 만든다.
#!/bin/bash formfile="$1" sed -i '/\&lt;enter description\&gt;/c\r [기능출시예정일자][이름][커밋내용]' "$formfile" p4 서버 내에서 trigger와 바인딩 한다.
$ p4 triggers
# Triggers 아래에
# $ {Trigger 이름} {Trigger 이벤트 종류} "{file path}" Triggers: form_template form-out change "/opt/perforce/triggers/form_template.sh %formfile%" 앞으로는 form-out change가 이벤트가 발생하면 자동으로 해당 스크립트가 실행된다.Extname을 가진 스켈레톤 폴더를 만든다.$ cd $P4ROOT/server.extension.dir
$ p4 extension --sample Extname
manifest.json, main.lua 을 수정한다.manifest.json에 들어 가야할 필수 요소들이 있기 때문에 문서를 참고[Server Extension JSON manifest fields][https://help.perforce.com/helix-core/server-apps/extensions/current/Content/Extensions/extensionjson.html]main.lua 파일에 우리가 원하는 로직을 작성 해야한다. 어떤 Event Callback을 받아서 처리할건지는 문서를 참고{ "manifest_version": 1, "api_version": 20191, "script_runtime": { "language": "lua", "version": "5.3" }, "key": "여기에_새로_생성한_UUID_입력", "name": "My Extension name", "namespace": "MyCompany", "version": "1.0", "version_name": "", "description": "My descrip", "compatible_products": [ "p4d" ], "default_locale": "en", "supported_local" : ["en"], "developer": { "name": "Your Company", "url": "https://your-company.com/" }, "license": "MIT", "license_body": "Copyright 2024, Your Company Name"
} [Server extension callbacks][https://help.perforce.com/helix-core/server-apps/extensions/current/Content/Extensions/extensioncallbacks.html#Server_extension_callbacks]<img alt="compared_ext_trigger.png" src="images/compared_ext_trigger.png" target="_self">InstanceConfigEvent()에서 어떤 이벤트 callback을 정의하고, 그에 해당하는 함수를 작성 해야한다. function GlobalConfigFields() return {}
end function GlobalConfigEvents() return {}
end function InstanceConfigFields() return {}
end function InstanceConfigEvents() return { ["form-out"] = "change", ["form-in"] = "change" }
end function FormOut() return true
end function FormIn() return true
end
# change-desc-template 폴더 안에 main.lua,manifest.json 존재
sudo -u perforce p4 extension --package change-desc-template # sign없이 install
sudo -u perforce p4 extension --install change-desc-template.p4-extension -y --allow-unsigned # Extuser를 super 권한이 있는 user로 변경, 전역설정
sudo -u perforce p4 extension --configure Perforce::Change-Description-Template # Extuser를 super 권한이 있는 user로 변경, 전역설정 # super 권한이 있는 user로 변경, 인스턴스 설정
sudo -u perforce p4 extension \ --configure Perforce::Change-Description-Template \ --name "ChangeDescInstance" \ -y
# 현재 돌고 있는 익스텐션 확인
sudo -u perforce p4 extension --list --type=extensions # To list all instance configurations:
sudo -u perforce p4 extension --list --type configs #configs (all), global, instance # extension 모두 지우기
sudo -u perforce p4 extension --delete Perforce::Change-Description-Template -y # extension name 기반 instance 지우기
sudo -u perforce p4 extension --delete Perforce::Change-Description-Template --name instance name -y ]]></description><link>infra/p4-extension,-p4-triggers.html</link><guid isPermaLink="false">Infra/P4 extension, P4 Triggers.md</guid><pubDate>Tue, 21 Jan 2025 11:24:19 GMT</pubDate><enclosure url="images/compared_ext_trigger.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/compared_ext_trigger.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Swarm Teams]]></title><description><![CDATA[Swarm에 커스텀 모듈을 만들어야 한다.$SWARM_ROOT config
└──custom.modules.config.php module
└── Teams ├── Module.php ├── config │ └── module.config.php └── src └── Listener └── TeamsActivityListener.php custom.modules.config.php 클래스를 자동 로드하고 어떤 사용자 정의 모듈을 실행해야 하는지 확인 module.config.php Swarm이 모듈을 인식하도록 하는 설정 파일
PHP 배열 형태로 이벤트 리스너 바인딩, 서비스 등록 Module.php module.config.php를 불러오는 파일.
namespace 설정해야함
getConfig()를 구현해야함 // custom.modules.config.php
&lt;?php
\Laminas\Loader\AutoloaderFactory::factory( array( 'Laminas\Loader\StandardAutoloader' =&gt; array( 'namespaces' =&gt; array( 'Teams' =&gt; BASE_PATH . '/module/Teams/src', ) ) )
);
return [ 'Teams'
];
// Module.php
&lt;?php
/** * Perforce Swarm Teams Module * * @author psyche95 */ namespace Teams; class Module
{ public function getConfig() { return include __DIR__ . '/config/module.config.php'; }
} // module.config.php
&lt;?php
/** * Perforce Swarm Teams Module * * @author psyche95 */ $listeners = [Teams\Listener\TeamsActivityListener::class]; return [ 'listeners' =&gt; $listeners, 'service_manager' =&gt;[ 'factories' =&gt; array_fill_keys( $listeners, Events\Listener\ListenerFactory::class ) ], Events\Listener\ListenerFactory::EVENT_LISTENER_CONFIG =&gt; [ Events\Listener\ListenerFactory::ALL =&gt; [ Teams\Listener\TeamsActivityListener::class =&gt; [ [ Events\Listener\ListenerFactory::PRIORITY =&gt; Events\Listener\ListenerFactory::HANDLE_MAIL_PRIORITY + 1, Events\Listener\ListenerFactory::CALLBACK =&gt; 'handleEvent', // callback 함수 등록 Events\Listener\ListenerFactory::MANAGER_CONTEXT =&gt; 'queue' // custom module 사용 ] ] ], ], 'teams' =&gt; [ 'swarm_host' =&gt; '', 'teams_webhook' =&gt; '', 'email' =&gt; '', 'id' =&gt; '', ]
]; Events\Listener\ListenerFactory::CALLBACK =&gt; 'handleEvent' : callback 함수 등록 Events\Listener\ListenerFactory::MANAGER_CONTEXT =&gt; 'queue': custom module 사용 'teams' =&gt; [] : src에서 멤버 변수로 사용할 hashmap custom.module.config.php에서 지정한 BASE_PATH에 로직을 작성할 소스파일을 생성하고 구현한다.
// src/Listener/TeamsActivityLister.php
&lt;?php
/** * Perforce Swarm Teams Module * * @author psyche95
*/ namespace Teams\Listener; use Events\Listener\AbstractEventListener;
use Reviews\Model\Review;
use Comments\Model\Comment;
use Laminas\EventManager\Event;
use Laminas\Http\Client;
use Laminas\Http\Request; class TeamsActivityListener extends AbstractEventListener
{ public function handleEvent(Event $event) { $activity = $event-&gt;getParam('activity'); if (!$activity) { return; } $logger = $this-&gt;services-&gt;get('logger'); $config = $this-&gt;services-&gt;get('config'); $p4Admin = $this-&gt;services-&gt;get('p4_admin'); // Host address of Swarm for link back URLs $host = $this-&gt;services-&gt;get('ViewHelperManager')-&gt;get('qualifiedUrl'); $logger-&gt;info("Teams: event / id =&gt; " . $event-&gt;getName() . " / " . $event-&gt;getParam('id')); // taken from mail module, this doesn't seem to work $data = (array) $event-&gt;getParam('data') + array('quiet' =&gt; null); $quiet = $event-&gt;getParam('quiet', $data['quiet']); if ($quiet === true) { $logger-&gt;info("Teams: event is silent(notifications are being batched), returning."); return; } // it's better not to tag user involved in activity, only review author //$user = $this-&gt;tagUser($config, $activity-&gt;get('user')); $user = $activity-&gt;get('user'); $action = $activity-&gt;get('action'); $target = $activity-&gt;get('target'); $link = $activity-&gt;get('link'); $projects = $activity-&gt;get('projects'); $logger-&gt;err("Projects =&gt; " . json_encode($projects)); if (count($link) &gt; 0) { if (count($link) &gt; 1) { $link = $host($link[0], $link[1]); } else { $link = $host($link[0]); } } $eventString = $user . " " . $action . " " . $target; $linkMessage = $link; $linkMessage = str_replace('localhost', $config['teams']['swarm_host'], $linkMessage); $reviewId = -1; switch($event-&gt;getName()) { case "task.comment.batch": if (preg_match('/^reviews\/(\d+)$/', $event-&gt;getParam('id'), $matches)) { $reviewId = $matches[1]; $eventString = "Comments have been made on review " . $reviewId . " =&gt; " . $host('review', array('review' =&gt; $reviewId)); } break; case "task.review": $reviewId = $event-&gt;getParam('id'); $eventData = $event-&gt;getParam('data'); if (isset($eventData['isAdd']) &amp;&amp; $eventData['isAdd']) { //new review $reviewId = 0; } $logger-&gt;info("Teams: event data =&gt; " . json_encode($eventData)); break; case "task.comment": try { $comment = Comment::fetch($event-&gt;getParam('id'), $p4Admin); $topic = $comment-&gt;get('topic'); if (preg_match('/^reviews\/(\d+)$/', $topic, $matches)) { $reviewId = $matches[1]; } } catch (\Exception $e) { $logger-&gt;err("Teams: error when fetching comment : " . $e-&gt;getMessage()); } //don't treat single comments, wait for the comment.batch return; break; default: $logger-&gt;info("Teams: event not treated " . $eventString); return; } $notify = ""; if ($reviewId &gt; 0) { try { $review = Review::fetch($reviewId, $p4Admin); $reviewAuthor = $review-&gt;get('author'); } catch (\Exception $e) { $logger-&gt;err("Teams: error when fetching review : " . $e-&gt;getMessage()); } } else if ($reviewId == 0) { //notify everybody $notify = '@everyone '; } $eventString = "Hey " . $notify . "! " . $eventString; $logger-&gt;info("Teams: " . $eventString); $leadid = ""; $leadname = ""; $projname = ""; if (!empty($projects)) { foreach ($projects as $key =&gt; $projectArray) { switch ($key) { case "": break 2; case "": break 2; } } } // URL to POST messages to Teams $teamsUrl = $config['teams']['teams_webhook']; $this-&gt;postTeams($teamsUrl, $eventString, $leadid, $leadname, $projname, $linkMessage); $logger-&gt;info("Teams: handleEvent end."); } private function postTeams($url, $msg, $leadid, $leadname, $projname, $linkMessage) { $logger = $this-&gt;services-&gt;get('logger'); $config = $this-&gt;services-&gt;get('config'); $team_leader_id = $config['teams']['']; $team_leader_name = $config['teams']['']; try { $messageData = [ 'type' =&gt; 'message', 'attachments' =&gt; [ [ 'contentType' =&gt; 'application/vnd.microsoft.card.adaptive', 'content' =&gt; [ 'width' =&gt; 'Full', 'type' =&gt; 'AdaptiveCard', 'body' =&gt; [ [ 'type' =&gt; 'TextBlock', 'size' =&gt; 'Medium', 'weight' =&gt; 'Bolder', 'text' =&gt; $projname . ' Perforce Swarm Notification' ], [ 'type' =&gt; 'TextBlock', 'text' =&gt; '&lt;at&gt;' . $team_leader_name . '&lt;/at&gt; &lt;at&gt;' . $leadname . '&lt;/at&gt;' ], [ 'type' =&gt; 'TextBlock', 'text' =&gt; $msg ], [ 'type' =&gt; 'ActionSet', 'actions' =&gt; [ [ 'type' =&gt; 'Action.OpenUrl', 'title' =&gt; 'Go to Swarm', 'url' =&gt; $linkMessage ] ] ] ], '$schema' =&gt; 'http://adaptivecards.io/schemas/adaptive-card.json', 'version' =&gt; '1.0', 'msteams' =&gt; [ 'entities' =&gt; [ [ 'type' =&gt; 'mention', 'text' =&gt; '&lt;at&gt;' . $team_leader_name . '&lt;/at&gt;', 'mentioned' =&gt; [ 'id' =&gt; $team_leader_id, 'name' =&gt; $team_leader_name ] ], [ 'type' =&gt; 'mention', 'text' =&gt; '&lt;at&gt;' . $leadname . '&lt;/at&gt;', 'mentioned' =&gt; [ 'id' =&gt; $leadid, 'name' =&gt; $leadname ] ] ] ] ] ] ] ]; $client = new Client(); $client-&gt;setUri($url); $client-&gt;setMethod(Request::METHOD_POST); $client-&gt;setRawBody(json_encode($messageData)); $client-&gt;setHeaders(['Content-Type' =&gt; 'application/json']); $response = $client-&gt;send(); if (!$response-&gt;isSuccess()) { $logger-&gt;err("Teams: Failed to send message. Status: " . $response-&gt;getStatusCode()); } } catch (\Exception $e) { $logger-&gt;err("Teams: Error sending message: " . $e-&gt;getMessage()); } }
}
]]></description><link>infra/swarm-teams.html</link><guid isPermaLink="false">Infra/Swarm Teams.md</guid><pubDate>Tue, 21 Jan 2025 11:24:19 GMT</pubDate></item><item><title><![CDATA[Git]]></title><description><![CDATA[리모트 저장소에서 히스토리 지우기$ git rm -r --cached {path}
$ git commit -m "deleted" # 현재 해시에서 삭제함.
$ git filter-branch --force --index-filter \
"git rm -r --cached --ignore-unmatch {path}" \
--prune-empty --tag-name-filter cat -- --all # 리모트 저장소 히스토리에서 삭제
reset 커밋 복구git reflog
git reset --hard 복구하려는커밋해시 git reset --hard 현재 작업 중인 변경사항을 모두 삭제하므로 주의하기 작업 중인 변경사항을 보존: --soft 사용하기
]]></description><link>tip/git.html</link><guid isPermaLink="false">Tip/Git.md</guid><pubDate>Sun, 19 Jan 2025 12:29:32 GMT</pubDate></item><item><title><![CDATA[Jenkins 설치 및 구성]]></title><description><![CDATA[자동화 시스템 구축
젠킨스에서 Java 11은 2024.07.31까지 지원 Deprecated 될 예정
OpenJDK 17로 구성 완료 sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:148) at java.base/sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:129) at java.base/java.security.cert.CertPathBuilder.build(CertPathBuilder.java:297) at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:383)
Caused: sun.security.validator.ValidatorException: PKIX path building failed at java.base/sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:388) at java.base/sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:271) at java.base/sun.security.validator.Validator.validate(Validator.java:256) at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:230) at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:132) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1302)
Caused: javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:130) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:378) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:321) at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:316) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.checkServerCerts(CertificateMessage.java:1318) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.onConsumeCertificate(CertificateMessage.java:1195) at java.base/sun.security.ssl.CertificateMessage$T13CertificateConsumer.consume(CertificateMessage.java:1138) at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:393) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:476) at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:447) at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:201) at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:172) at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1506) at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1421) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:455) at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:426) at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:586) at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:187) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect0(HttpURLConnection.java:2909) at java.base/sun.net.www.protocol.http.HttpURLConnection.followRedirect(HttpURLConnection.java:2818) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1929) at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1599) at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:223) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1321)
Caused: java.io.IOException: Failed to load https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi to C:\ProgramData\Jenkins\.jenkins\plugins\mailer.jpi.tmp at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1332)
Caused: java.io.IOException: Failed to download from https://updates.jenkins.io/download/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi (redirected to: https://get.jenkins.io/plugins/mailer/470.vc91f60c5d8e2/mailer.hpi) at hudson.model.UpdateCenter$UpdateCenterConfiguration.download(UpdateCenter.java:1366) at hudson.model.UpdateCenter$DownloadJob._run(UpdateCenter.java:1923) at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:2235) at hudson.model.UpdateCenter$DownloadJob.run(UpdateCenter.java:1897) at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317) at hudson.remoting.AtmostOneThreadExecutor$Worker.run(AtmostOneThreadExecutor.java:121) at java.base/java.lang.Thread.run(Thread.java:1583)
suncertpathbuilderexception unable to find valid certification path to requested target를 인터넷에 검색했을 때 -Https를 사용하는 웹사이트에 연결을 시도할 때 Java에서 신뢰하는 인증서 목록에 해당 웹사이트의 인증서가 존재하지 않아서 발생하는 문제라고 한다.그래서 예전에 전달받은 인증서를 jdk(jre)/lib/securites/cacert에 keytool 명령어를 이용해 현재 사용하는 자바인증서에 인증서를 넣었음.keytool -importcert -alias {alias name} -keystore "C:\Program Files\Java\jdk-21.0.2\lib\security\cacerts" -storepass changeit -file C:\Users\psyche95\Desktop\CERT\{.cer}
suncertpathbuilderexception unable to find valid certification path to requested target는 해결 되었으나 아래의 문제가 발생java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
검색하니, openjdk에서 발생할 수 있다고 함 -&gt; oracle jdk의 cacert로 교체하면 된다고 해서 교체 -&gt; 같은 에러 반복 cacert 문제가 아님을 확인환경변수 JAVA_HOME 확인-&gt; java8 사용하고 있었음.
JAVA_HOME java21로 변경이로써 플러그인 업데이트 가능하게 됨. + 배치파일 작성 후 빌드 가능그래도 계속 안된다면, java cacert에서 회사 사내 인증서 없애고 JAVA_HOME 설정 다시 할 것java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty at java.base/java.security.cert.PKIXParameters.setTrustAnchors(PKIXParameters.java:200) at java.base/java.security.cert.PKIXParameters.&lt;init&gt;(PKIXParameters.java:120) at java.base/java.security.cert.PKIXBuilderParameters.&lt;init&gt;(PKIXBuilderParameters.java:104) at java.base/sun.security.validator.PKIXValidator.&lt;init&gt;(PKIXValidator.java:94) Caused: java.lang.RuntimeException: Unexpected error
해결한 줄 알았는데, 다시 발생해서 재설치 진행함.jdk 21은 젠킨스에 도입된 지 얼마 되지 않아서 jdk 17로 교체.sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target그냥 check certificate 하지 않는 게 정신건강에 이로울 거 같아서 skip-certificate-check 플러그인을 hpi로 받음. 그러고나서 C:\ProgramData\Jenkins.jenkins\plugins에 직접 hpi를 넣고 설치 젠킨스 재시작이로써 해결 완료되었고 현재까지는 잘 작동함.Unreal Engine4로 작업을 하고 있는데, ugs를 사용하지 않아 개발자가 주기적으로 binary를 depot에 올려줘야 하는 상황 (perforce helix core 사용)아래 batch 파일을 통해 일정 시간에 컴파일하고 만들어진 binary를 submit 함.@echo off
setlocal enabledelayedexpansion set ENGINE_PATH=C:\Users\owner\Perforce\psyche95_GZ-PSYCHE9503_8014\GolfzonMEngine
set PROJECT_PATH=C:\Users\owner\Perforce\psyche95_GZ-PSYCHE9503_8014\WaveM\U2Client_Wave :: 접근 권한 설정
icacls "%ENGINE_PATH%" /grant Everyone:(F)
icacls "%PROJECT_PATH%" /grant Everyone:(F) :: 필요한 폴더와 파일 삭제
echo Deleting unnecessary files and folders...
if exist "%PROJECT_PATH%\.vs" rmdir /s /q "%PROJECT_PATH%\.vs"
if exist "%PROJECT_PATH%\DerivedDataCache" rmdir /s /q "%PROJECT_PATH%\DerivedDataCache"
if exist "%PROJECT_PATH%\Intermediate" rmdir /s /q "%PROJECT_PATH%\Intermediate"
if exist "%PROJECT_PATH%\Saved" rmdir /s /q "%PROJECT_PATH%\Saved"
if exist "%PROJECT_PATH%\U2Client.sln" del /f /q "%PROJECT_PATH%\U2Client.sln" :: Unreal Engine을 이용해 비주얼 스튜디오 프로젝트 파일 생성
echo Generating Visual Studio project files...
"%ENGINE_PATH%\Engine\Binaries\DotNET\UnrealBuildTool.exe" -projectfiles -project="%PROJECT_PATH%\U2Client.uproject" -game -progress
if %errorlevel% neq 0 ( echo Failed to generate Visual Studio project files. curl -X POST -H "Content-type: application/json" --data "{\"text\":\"Failed to generate Visual Studio project files\", \"channel\":\"#dev_build\"}" "https://hooks.slack.com/services/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" exit /b %errorlevel%
) :: 비주얼 스튜디오를 이용해 U2Client.sln 빌드
echo Building the U2Client.sln...
"C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\Common7\IDE\devenv.com" "%PROJECT_PATH%\U2Client.sln" /Build "Development Editor|Win64" /Project "U2Client"
echo Errorlevel after build: %errorlevel%
if %errorlevel% neq 0 ( echo Build process failed, checking log... curl -X POST -H "Content-type: application/json" --data "{\"text\":\"Build process failed\", \"channel\":\"#dev_build\"}" "https://hooks.slack.com/services/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" exit /b %errorlevel%
) :: 변경된 PDB 및 DLL 파일 검사 및 Perforce로 체크아웃
pushd "%PROJECT_PATH%\Binaries\Win64"
set CHANGES_EXIST=
for %%f in (*.pdb *.dll) do ( :: 파일 접미사 체크 및 변경 검사 echo %%f | findstr /R /C:".*-[0-9][0-9][0-9][0-9]\." &gt; nul if errorlevel 1 ( :: 파일이 마지막으로 변경된 시간 가져오기 for /f "tokens=2 delims==" %%t in ('wmic datafile where name^="%%f" get lastmodified /value') do set LASTMOD=%%t :: Perforce에 저장된 파일의 수정 시간 비교 p4 -u psyche95 fstat -T headTime %%f | findstr /C:"headTime" set HEADTIME=!headTime! if "!LASTMOD:~0,14!" neq "!HEADTIME!" ( set CHANGES_EXIST=true p4 -u psyche95 edit %%f ) )
)
popd :: 변경점이 있으면 제출하고, 없으면 되돌리기
if defined CHANGES_EXIST ( echo Changes detected. Submitting to Perforce... p4 -u psyche95 submit -d "automate submit"
) else ( echo No changes detected. Reverting changes... pushd "%PROJECT_PATH%\Binaries\Win64" for %%f in (*.pdb *.dll) do ( p4 -u psyche95 revert %%f ) popd
) echo Finished: SUCCESS ]]></description><link>infra/jenkins-설치-및-구성.html</link><guid isPermaLink="false">Infra/Jenkins 설치 및 구성.md</guid><pubDate>Wed, 15 Jan 2025 12:54:31 GMT</pubDate></item><item><title><![CDATA[Jenkins 안드로이드 패키징]]></title><description><![CDATA[
Jenkins는 JAVA 11 지원 X -&gt; JDK 17
@echo off
setlocal enabledelayedexpansion :: Java 11 Setting -
set JAVA_HOME=C:\Program Files\Android\Android Studio\jre
set PATH=%JAVA_HOME%\bin;%PATH%
set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
:: Gradle 설정
set GRADLE_USER_HOME=%USERPROFILE%\.gradle_java11
:: Java 옵션 설정
set _JAVA_OPTIONS=-Djava.specification.version=11 :: 기본 경로 설정
set ENGINE_PATH=D:\Develop\GolfzonMEngine
set PROJECT_PATH=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client
set PROJECT_NAME=U2Client
set OUTPUT_DIR=C:\Users\psyche95\Desktop\Golfzon\M_Packaging :: Android SDK 및 NDK 설정
set ANDROID_HOME=C:\Users\psyche95\AppData\Local\Android\Sdk
set ANDROID_NDK_PATH=%ANDROID_HOME%\ndk\25.2.9519653
set NDKROOT=%ANDROID_NDK_PATH% :: 출력 폴더 설정
for /f "tokens=2 delims==" %%I in ('wmic os get localdatetime /value') do set TIMESTAMP=%%I
set NEW_OUTPUT_DIR=%OUTPUT_DIR%\Build_Android_%TIMESTAMP:~0,8%_%TIMESTAMP:~8,6% :: 필요한 디렉토리 생성
if not exist "%NEW_OUTPUT_DIR%" mkdir "%NEW_OUTPUT_DIR%" :: 프로젝트 파일 확인
if not exist "%PROJECT_PATH%\%PROJECT_NAME%.uproject" ( echo Error: Project file not found! exit /b 1
) echo Starting Android packaging for %PROJECT_NAME%... :: Project Build
call "%ENGINE_PATH%\Engine\Build\BatchFiles\RunUAT.bat" ^
BuildCookRun ^
-nocompileeditor ^
-installed -nop4 ^
-project=%PROJECT_PATH%\%PROJECT_NAME%.uproject ^
-cook -stage -archive -archivedirectory="%NEW_OUTPUT_DIR%" ^
-package ^
-ue4exe="%ENGINE_PATH%\Engine\Binaries\Win64\UE4Editor-Cmd.exe" ^
-compressed ^
-ddc=InstalledDerivedDataBackendGraph ^
-pak ^
-prereqs ^
-targetplatform=Android -cookflavor=ASTC ^
-build ^
-CrashReporter ^
-target=%PROJECT_NAME% ^
-clientconfig=Development ^
-utf8output ^
-AndroidSDK="%ANDROID_HOME%" ^
-AndroidNDK="%NDKROOT%" if %ERRORLEVEL% neq 0 ( echo Error: Build failed with exit code %ERRORLEVEL% exit /b %ERRORLEVEL%
) echo Android packaging completed successfully.
echo Output directory: %NEW_OUTPUT_DIR%
exit /b 0 -nocompileeditor: 에디터 컴파일을 건너뜀 -installed: 엔진 바이너리로 빌드 -nop4: Perforce 연동을 비활성화 -project: 프로젝트 파일의 경로를 지정 -cook: 콘텐츠 쿠킹을 수행 -stage: 패키징된 게임을 스테이징 디렉토리로 복사 -archive: 패키지된 게임을 아카이브 -archivedirectory: 아카이브 디렉토리를 지정 -package: 게임을 패키징 -ue4exe: 사용할 UE4 Editor 실행 파일의 경로를 지정 -compressed: 패키지를 압축 -ddc: 사용할 파생 데이터 캐시(DDC) 설정을 지정 DDC는 파생 데이터 캐시를 의미합니다. 이는 에셋 처리 결과를 저장하는 캐시 시스템입니다. 예를 들어, 텍스처의 압축 버전이나 머티리얼의 컴파일된 버전 등이 여기에 저장됩니다. DDC를 사용하면 에셋 처리 시간을 줄이고, 여러 사용자 간에 처리된 데이터를 공유할 수 있습니다. -pak: 콘텐츠를 PAK 파일로 패키징 -prereqs: 필요한 선행 요구사항을 포함 -targetplatform: 대상 플랫폼을 Android로 설정 -cookflavor: 쿠킹 설정을 ASTC(텍스처 압축 형식)로 지정 -build: 코드를 빌드 -CrashReporter: 크래시 리포터를 포함 -target: 빌드할 프로젝트 이름을 지정 -clientconfig: 클라이언트 구성을 Development or Shipping -utf8output: 출력을 UTF-8로 인코딩 -AndroidSDK: Android SDK 경로를 지정 -AndroidNDK: Android NDK 경로를 지정 Execution of commandlet took: 123.49 seconds LogShaderCompilers: Display: === FShaderJobCache stats === LogShaderCompilers: Display: Total job queries 0, among them cache hits 0 (0.00%) LogShaderCompilers: Display: Tracking 0 distinct input hashes that result in 0 distinct outputs (0.00%) LogShaderCompilers: Display: RAM used: 0.00 MB (0.00 GB) of 1638.40 MB (1.60 GB) budget. Usage: 0.00% LogShaderCompilers: Display: ================================================ LogShaderCompilers: Display: Shaders left to compile 0 LogShaderCompilers: Display: Shaders left to compile 0 OptickLog: Display: OptickPlugin UnLoaded! LogHttp: Display: cleaning up 0 outstanding Http requests. LogContentStreaming: Display: There are 1 unreleased StreamingManagers
Took 140.1294547s to run UE4Editor-Cmd.exe, ExitCode=0
********** COOK COMMAND COMPLETED **********
********** BUILD COMMAND STARTED **********
Running: D:\Develop\GolfzonMEngine\Engine\Binaries\DotNET\UnrealBuildTool.exe U2Client Android Development -Project=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject -Manifest=C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Manifest.xml -nobuilduht -NoHotReload -xgeexport C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject -NoUBTMakefiles -remoteini="C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client" -skipdeploy -log="C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UBT-U2Client-Android-Development.txt" Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client Adjust SDK found in C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Plugins\Adjust\Source\Adjust\../ThirdParty/Android Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client Engine Directory:D:\Develop\GolfzonMEngine\Engine Project Directory:C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client D:\Develop\GolfzonMEngine\Engine\Source\Runtime\Engine\Engine.Build.cs: warning: Referenced directory 'D:\Develop\GolfzonMEngine\Engine\Source\Launch\Public' does not exist. PLATFORM_ANDROID_NDK_VERSION = 250300 NDK toolchain: r25c, NDK version: 33, GccVersion: 4.9, ClangVersion: 14.0.7 Parsing headers for U2Client Running UnrealHeaderTool "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\U2Client.uproject" "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Android\U2Client\Development\U2Client.uhtmanifest" -LogCmds="loginit warning, logexit warning, logdatabase error" -Unattended -WarningsAsErrors -abslog="C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UHT-U2Client-Android-Development.txt" -installed LogInit: Display: Loading text-based GConfig.... Reflection code generated for U2Client in 3.4027725 seconds Compiling Native 64-bit code with NDK API 'android-33' Writing manifest to C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Build\Manifest.xml XGEEXPORT: Exported 'D:\Develop\GolfzonMEngine\Engine\Intermediate\Build\UBTExport.000.xge.xml' Total execution time: 6.14 seconds
Took 6.2589684s to run UnrealBuildTool.exe, ExitCode=0
Running: C:\Program Files (x86)\Incredibuild\xgConsole.exe "C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread Fatal Error: File not found: C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml
Took 0.0520074s to run xgConsole.exe, ExitCode=3
BUILD FAILED: Command failed (Result:3): C:\Program Files (x86)\Incredibuild\xgConsole.exe "C:\Windows\system32\config\systemprofile\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\UAT_XGE.xml" /Rebuild /NoLogo /ShowAgent /ShowTime /no_watchdog_thread. See logfile for details: 'xgConsole-2024.07.31-10.14.49.txt'
AutomationTool exiting with ExitCode=1 (Error_Unknown)
Error: AutomationTool execution failed. Check log: C:\Windows\system32\config\systemprofile\UnrealEngine\BuildTemp\UAT_Log.txt
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE
인크레디빌드 사용시에 패키징 에러가 발생함.
로그에서 실패한 이유가 File Not found인데 실제 경로에 가보니 해당 파일이 있었다.
그래서 권한을 주는 등 다양한 방법을 적용해봤으나 계속해서 같은 이유로 실패했다.인크레디빌드 Agent를 끄고 패키징을 하면 Incredibuild 관련 부분을 통과할 수 있었다. 또는 RunUAT 실행 인자에 -noxge를 추가해도 Incredibuild가 꺼져서 관련 부분을 통과할 수 있었다. 이를 통해, Incredibuild 관련 이슈라 판단하고 incredibuild support에 질문함.<img alt="inc_support.png" src="images/inc_support.png" target="_self">윈도우 젠킨스 설치시에 Windows Service에 등록된다.젠킨스를 이용해서 빌드를 할 때 Window Service에 등록된 사용자로 빌드를 하는데 기본 값이 SYSTEM 사용자다. 그래서 이를 바꿔줘야한다.WIN + R를 누르고 services.msc를 입력해서 서비스를 연다.Jenkins Service를 돌릴 윈도우 계정이 필요한데 회사 도메인을 이용한 사내아이디를 사용 해야했다.Jenkins - 속성 - 로그온 - 찾아보기
아이디 검색 - 비밀번호 입력하고 젠킨스 중지C:\Program Files\Jenkins 로 이동해서 jenkins.xml을 수정한다. xml을 열어서 &lt;arguments&gt; 있는 곳에 다음 값을 추가한다. (젠킨스 서비스가 시작할 때 domain 아이디로 로그인 하겠다고 알려줘야함)&lt;arguments&gt;-Xrs -Xmx256m -Dhudson.lifecycle=hudson.lifecycle.WindowsServiceLifecycle -jar "C:\Program Files\Jenkins\jenkins.war" --httpPort=12000 --webroot="%ProgramData%\Jenkins\war --serviceLogonAccount={yourdomain\yourid} --serviceLogonPassword={your_passward}"&lt;/arguments&gt;
domain과 id를 하는 법은 cmd를 열고 whoami 입력<br><img alt="whoami.png" src="images/whoami.png" target="_self">젠킨스 다시 시작하고 젠킨스 빌드시에 Incredibuild에서 에러나는 부분을 넘어갈 수 있다. ====2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so.
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png.
[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)
Making .apk with Gradle...
To honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).
Daemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:
Build file 'Z:\build.gradle' line: 14 * What went wrong:
A problem occurred evaluating root project 'app'.
&gt; Could not open dsl generic class cache for script 'Z:\buildscriptAdditions.gradle' (C:\Users\psyche95\.gradle\caches\7.5\scripts\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:
&gt; Run with --stacktrace option to get the stack trace.
&gt; Run with --info or --debug option to get more log output.
&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)
* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s
ERROR: cmd.exe failed with args /c "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\rungradle.bat" :app:assembleDebug (see C:\Users\psyche95\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\Log.txt for full exception trace)
AutomationTool exiting with ExitCode=1 (Error_Unknown)
BUILD FAILED
Error: Build failed with exit code 1
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE
Dataview (inline field '===2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64===========================================
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so.
Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png.
[FirebaseGoodies] Crashlytics debug symbols upload enabled. Adding native libraries... Creating rungradle.bat to work around commandline length limit (using unused drive letter Z:)
Making .apk with Gradle...
To honour the JVM settings for this build a single-use Daemon process will be forked. See [https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon](https://docs.gradle.org/7.5/userguide/gradle_daemon.html#sec:disabling_the_daemon).
Daemon will be stopped at the end of the build FAILURE: Build failed with an exception. * Where:
Build file 'Z:\build.gradle' line: 14 * What went wrong:
A problem occurred evaluating root project 'app'.
&gt; Could not open dsl generic class cache for script 'Z:\buildscriptAdditions.gradle' (C:\Users\psyche95\.gradle\caches\7.5\scripts\cp2i11tnu00nybyfrpbih872t). &gt; BUG! exception in phase 'semantic analysis' in source unit '_BuildScript_' Unsupported class file major version 65 * Try:
&gt; Run with --stacktrace option to get the stack trace.
&gt; Run with --info or --debug option to get more log output.
&gt; Run with --scan to get full insights. Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0. You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins. See [https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings](https://docs.gradle.org/7.5/userguide/command_line_interface.html#sec:command_line_warnings)
* Get more help at [https://help.gradle.org](https://help.gradle.org/) BUILD FAILED in 4s
ERROR: cmd.exe failed with args /c "C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\rungradle.bat" :app:assembleDebug (see C:\Users\psyche95\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Develop+GolfzonMEngine\Log.txt for full exception trace)
AutomationTool exiting with ExitCode=1 (Error_Unknown)
BUILD FAILED
Error: Build failed with exit code 1
Build step 'Execute Windows batch command' marked build as failure
Finished: FAILURE'): Error: -- PARSING FAILED -------------------------------------------------- &gt; 1 | ===2024-07-31 오후 2:17:26====PERFORMING FINAL APK PACKAGE OPERATION=====-arm64=========================================== | ^ 2 | Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\jniLibs\arm64-v8a\libUE4.so. 3 | Copied file C:\Users\psyche95\Desktop\jenkins_build\GolfzonM\U2Client\Intermediate\Android\arm64\gradle\app\src\main\assets\main.obb.png. Expected one of the following: '(', 'null', boolean, date, duration, file link, list ('[1, 2, 3]'), negated field, number, object ('{ a: 1, b: 2 }'), string, variable
젠킨스 설정시에 java 버전을 21로 올렸기 때문에 발생하는 에러다. 현재 gradle 7.5를 사용하고 있는데 gradle 7.5가 지원하는 상방은 java 18이다. 그래서 패키징시에 명시적으로 java 11 path를 넣고 패키징을 했다.
:: batch 파일 상단 :: Java 11 Setting -
set JAVA_HOME=C:\Program Files\Android\Android Studio\jre
set PATH=%JAVA_HOME%\bin;%PATH%
set JAVA_EXE="%JAVA_HOME%\bin\java.exe"
:: Gradle 설정
set GRADLE_USER_HOME=%USERPROFILE%\.gradle_java11
:: Java 옵션 설정
set _JAVA_OPTIONS=-Djava.specification.version=11 ]]></description><link>infra/jenkins-안드로이드-패키징.html</link><guid isPermaLink="false">Infra/Jenkins 안드로이드 패키징.md</guid><pubDate>Wed, 15 Jan 2025 12:54:13 GMT</pubDate><enclosure url="images/inc_support.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/inc_support.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[compared_ext_trigger]]></title><description><![CDATA[<img src="images/compared_ext_trigger.png" target="_self">]]></description><link>images/compared_ext_trigger.html</link><guid isPermaLink="false">images/compared_ext_trigger.png</guid><pubDate>Sun, 12 Jan 2025 15:55:55 GMT</pubDate><enclosure url="images/compared_ext_trigger.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/compared_ext_trigger.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Missing required module 'RxCocoaRuntime'에 대한 고찰 - SPM과 UnitTest에서의 오류]]></title><description><![CDATA[SPM으로 RxSwift를 가져오고 Unit Test를 작성한 후 테스트를 실행했을 때 다음과 같은 에러를 만난 적이 있습니다. Missing required module 'RxCocoaRuntime'
프로젝트를 만들고 Swift Package Manager로 RxSwift를 추가하고 RxSwift, RxCocoa, RxRelay 라이브러리만을 앱 타겟에 추가합니다. 그리고 테스트 타겟은 Target Dependencies로 앱 타겟을 가지고 있고, 어떠한 라이브러리도 링킹하고 있지 않습니다.&nbsp;<img src="https://blog.kakaocdn.net/dn/RdgNd/btr8uTeqxjZ/YOZ0YRoqBNvxqE6hKVB9gK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cwsx5k/btr8vHqZp1v/ZgdvWLkIyayepWxb2MLli1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그리고 AppDelegate에서 RxSwift를 import하고 RxSwift 코드를 작성합니다. 이제 애플리케이션을 빌드하면 빌드가 성공합니다. import RxSwift
import UIKit @main
class AppDelegate: UIResponder, UIApplicationDelegate { func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? ) -&gt; Bool { Observable.just(1).subscribe(onNext: { print($0) }) .dispose() return true }
이제 UnitTest 클래스로 가서, Command + U를 눌러 테스트를 실행해보도록 할까요? 문제없이 테스트가 성공할 것입니다.
그러면 import RxCocoa를 시도해보면 어떨까요? 그 순간 아래와 같이 에러가 발생할 거예요.&nbsp;<br><img src="https://blog.kakaocdn.net/dn/wKYQe/btr8u3BgSJE/9mYuSIp7sq7TNKCKlZscKK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">우리가 설정한 걸로는 아직 테스트 타겟에서 RxCocoa를 import 하지 못합니다. 그렇기 때문에 테스트 클래스에서 RxCocoa를 지우겠습니다. 그러면 위의 에러는 당연히 사라질 거예요. 다시 AppDelegate로 돌아가서 RxCocoa를 import 하고 AppDelegate에서 RxCocoa가 가지고 있는 Trait인 BehaviorRelay를 작성하도록 할게요.import RxCocoa
import RxSwift
import UIKit @main
class AppDelegate: UIResponder, UIApplicationDelegate { func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? ) -&gt; Bool { Observable.just(1).subscribe(onNext: { print($0) }) .dispose() BehaviorRelay(value: 2) .subscribe(onNext: { print($0) }) .dispose() return true }
애플리케이션을 빌드하면 실행이 되고 print도 잘 찍힙니다. 이걸로 봐서 앱 타겟에는 문제가 없습니다. 다시 테스트 클래스로 돌아가서 테스트를 실행해 볼까요?&nbsp;<br><img src="https://blog.kakaocdn.net/dn/C9D03/btr8lmBPXiT/efZVLhCFNcoQjVsYeSoTp0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">테스트 클래스에서 RxCocoa를 import 하지 않았는데도 RxCocoaRuntime Error가 발생했습니다.테스트 타겟에서 Target Dependency로 앱 타겟을 가지고 있기 때문입니다. 그런데 앱 타겟에서 RxCocoa를 사용하고 있어요. 문제점은 여기에서 발생하는 것 같습니다. 테스트를 실행하면, 테스트 타겟에 RxCocoaRuntime의 코드가 링킹 되지 않는 것 같아요. (근본적인 문제는 아직 잘 모르겠습니다. RxCommunity에서도 오랫동안 제기 되어온 문제이고 SPM 이슈라고 합니다) 그래서 위의 에러가 발생하는 것 같습니다. 그렇다면 테스트 타겟에 RxCocoaRuntime를 링킹 하면 문제가 해결될 것 같아요.&nbsp;
Project -&gt; Test Target 클릭 -&gt; Build Phrase -&gt; Link Binary with Libraries -&gt; RxCocoa 넣기.
<br><img src="https://blog.kakaocdn.net/dn/pox84/btr8uRnuyqS/qFYBbQf8c5W7blnOoAclsK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/snY2F/btr8uSs8KUd/XwFDicPwSOwQn663zZTHA0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">예상대로 에러는 사라지고 테스트는 성공했습니다. 다만 엄청나게 많은 경고들이 생성되었는데 코드가 중복으로 올라갔다는 경고입니다. 테스트 타겟에서 RxCocoa 코드가 올라오고 테스트 타겟이 Target Dependency로 가지고 있는 앱 타겟에서 RxCocoa 코드가 다시 한번 올라오기 때문입니다. 이제는 이 중복 경고를 지우려고 노력해 보겠습니다.RxCocoa 구현 코드에 보면, Runtime이라는 폴더가 존재합니다. 우리가 필요한 것은 Runtime에 있는 것들이니까 Link Binary with Libraries에 저것들을 넣어주면 될 것 같습니다. 이 폴더는 그대로 RxTest에 존재합니다. 그러면 테스트 타겟에 RxTest와, RxBlocking을 넣어주면 에러가 사라지지 않을까요? <br><img src="https://blog.kakaocdn.net/dn/LhJkD/btr8lN7y6mF/2ENFkbrfG0lRyqMtvlL611/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/cKdACd/btr8vtNoZgD/qf6HkEldHPDPwmjwXLK12K/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/kSoQd/btr8wR770kI/kHzTCf6oRbxGoNvMPhVTD1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">아쉽게도 에러가 사라지지 않았습니다. 논리적으로 사라질 거라고 생각했는데 그러지 않네요. 이러한 이슈는 위에 언급한 것처럼 오래전부터 있어 왔습니다. 물론 해결 방법은 있습니다. 해결 방법도 꽤나 다양합니다. 무튼 해결 방법은 있는데 근본적으로 어떤 문제가 있는지는 언급되지는 않네요. SPM 이슈일 것이라고만 나와있습니다. 그 말에 충분히 신빙성이 있는 게 같은 환경에서 .xcframework로 링킹 하면 해당 에러는 발생하지가 않습니다. 예상 가능한 건 RxCocoaRuntime이 중요 포인트다 라는 것 정도인 것 같습니다. 구현된 RxCocoa를 살펴보면 SPM인 경우에 import RxCocoaRuntime을 하는 걸 볼 수 있기 때문입니다.&nbsp;<br><img src="https://blog.kakaocdn.net/dn/89GV2/btr8LLUimFH/rjYwZmkK4zW57rakC1hXG0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">RxSwift Issue와 구글 검색을 통해서 몇 가지 해결 방법을 찾았습니다. 근데 다수의 해결 방법들은 코드가 중복 적재되어서 경고가 뜹니다.참고해 주세요. &nbsp;1. 테스트 타겟에 Link Binary with Libraries에 RxCocoa를 추가한다. 중복 적재 경고(O)
위에서 사용했던 방법입니다.
Project -&gt; Test Target 클릭 -&gt; Build Phrase -&gt; Link Binary with Libraries -&gt; RxCocoa 넣기
2.&nbsp;&nbsp;TEST_HOST를 바꿔주는 방법입니다. 중복 적재 (X)&nbsp;# Test Target -&gt; Build Setting -&gt; TEST_HOST 검색 -&gt; '$(BUNDLE_EXECUTABLE_FOLDER_PATH)/' 지우기 $(BUILT_PRODUCTS_DIR)/&lt;YOUR APPNAME&gt;.app/&lt;YOUR APPNAME&gt;
이걸로 추측하는 건데, Bundle Loader 부분이 조금 다르게 처리되어 있는 듯합니다. 이상하게 앱 타겟에서는 Bundle Loader 부분이 설정이 안되어 있고, 테스트 타겟에서는 Bundle Loader 값이 $(TEST_HOST) 입니다. 그래서 TEST_HOST 값을 설정해 주면 RxCocoaRuntime을 가지고 올 수 있는 것이 아닐지 예상합니다.<br><img src="https://blog.kakaocdn.net/dn/b1epQr/btr8Ima3ymS/GGWPfB0bGI15LIqGfmld2k/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
전처리 사용해서 해결 - 중복적재 (O)
Other Swift Flags는 Swift 컴파일러에게 pass 하라고 명령하는 것입니다. 이걸 입력하지 않을 경우 SPM에 구현되어 있는 RxCocoa에서 import RxCocoaRuntime 할 때 import를 못했으나, Other Swift Flags를 설정하면 컴파일하기 전에 코드를 올리기 때문에 에러가 발생하지 않는 것 같습니다. 테스트 타겟에 RxTest와 RxBlocking을 추가하면 코드 중복 적재 경고가 뜨는데요. 위의 이유 때문입니다. C언어에서 #include와 똑같은 것입니다.
Test Target -&gt; Build Setting -&gt; Other Swift Flags 검색 -&gt; -Xcc -fmodule-map-file=(PLATFORM_NAME)/RxCocoaRuntime.modulemap
<br><img src="https://blog.kakaocdn.net/dn/rK1Pi/btr8Jo621JB/5cfUXLTnju2vW2zbnLgZK0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">4.&nbsp; 앱 타겟과 테스트 타겟에서 RxCocoa 대신에 RxCocoa-Dynamic을 사용한다- 중복 적재 (X)&nbsp;문제로 돌아가서 단순하게 그냥 해결하겠습니다. 우리가 달성하고 싶은 건 다음과 같습니다.
&nbsp;테스트 타겟은 RxCocoaRuntime이 필요함 (-&gt; RxCocoa를 Link Binary wtih Libraries에 넣음)
그러면 코드가 중복 적재되는데 이를 해결하고 싶음 (-&gt; dynamic을 사용하면 됨)
보통 SPM은 static library(.o type)으로 코드를 가져오는데, 코드 자체를 Heap 영역에 때려 넣습니다. 따라서 코드 자체 말고 Dynamic library reference를 Heap 영역에 넣어 필요할 때마다 Stack 영역에서 가져오는 dynamic으로 변경 시에 중복 적재 경고가 뜨지 않습니다. <br><img src="https://blog.kakaocdn.net/dn/bLcSx2/btr8IJcErfK/n0F7LhRlFUIgfNsgVCDK1K/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/CWUS5/btr8KHkMfIj/g3AxUDBhU3MycwdBI2B2Jk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Local SPM을 만들어서 ThirdPartyLibrary를 관리하는 ThirdPartyManager를 만드는 것입니다. - 중복적재 (X)
<br><img src="https://blog.kakaocdn.net/dn/caj5Qa/btr8J4m6q6o/qhgCquDO1aqVGYm1Jkw3Ok/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그래프를 그리면 다음과 같이 되겠습니다. Local SPM 코드를 다음과 같이 작성할 수 있어요.// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package. // Package.swift import PackageDescription let package = Package( name: "ThirdPartyManager", platforms: [.iOS(.v14)], products: [ .library( name: "ThirdPartyManager", type: .dynamic, targets: ["ThirdPartyManager"] ), .library( name: "TestResolver", targets: ["TestResolver"] ) ], dependencies: [ .package(url: "https://github.com/ReactiveX/RxSwift.git", exact: "6.5.0") ], targets: [ .target( name: "ThirdPartyManager", dependencies: [ .product(name: "RxSwift", package: "Rxswift"), .product(name: "RxCocoa", package: "Rxswift") ] ), .target( name: "TestResolver", dependencies: [ .product(name: "RxTest", package: "Rxswift"), .product(name: "RxBlocking", package: "Rxswift") ] ), .testTarget( name: "ThirdPartyManagerTests", dependencies: ["ThirdPartyManager"]), ]
)
Local SPM으로 RxSwift를 가져온 후에, target을 만들어줍니다. 이것을 library로 외부에 노출하면 되겠습니다. 이때, ThirdPartyManager(library)는 dynamic library로 지정하겠습니다. 그리고 앱을 실행해 보고, 테스트를 실행하면 무사히 통과하고 중복 적재 경고도 없음을 알 수 있습니다. 코드 중복은 dynamic을 적절히 사용하면 해결할 수 있겠네요. Local SPM을 사용해서 에러를 해결하는 코드는 아래 GitHub을 참고해 주세요.<br><img src="https://blog.kakaocdn.net/dn/btgkkT/btr8MpRhc9s/xN9BkJxxkyCrB2DMc75m21/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/NA8tG/btr8I1qNiyC/CCn3uUazzNLgSmfSnStWOk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">SPM 사용 시에 RxCocoaRuntime 모듈을 찾을 수 없는 에러에 대해서 이제 다양한 방법으로 해결할 수 있게 되었습니다. 처음에 왜 뜨는지 조차 이유를 몰랐었는데, 어느 정도 감을 잡은 후에는 즐겁게 해결할 수 있었어요. 라이브러리에 이슈에 대해서 공부할 때마다 Mach -O Type의 중요성을 깨닫는 것 같습니다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/SPMRxCocoaRuntimeError" target="_self">https://github.com/psychehose/SPMRxCocoaRuntimeError</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/apple/swift-package-manager/issues/4581" target="_self">https://github.com/apple/swift-package-manager/issues/4581</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/ReactiveX/RxSwift/issues/2127" target="_self">https://github.com/ReactiveX/RxSwift/issues/2127</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/58125428/missing-required-module-xyz-on-unit-tests-when-using-swift-package-manager" target="_self">https://stackoverflow.com/questions/58125428/missing-required-module-xyz-on-unit-tests-when-using-swift-package-manager</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://forums.swift.org/t/missing-required-modules-when-importing-an-spm-framework/24856" target="_self">https://forums.swift.org/t/missing-required-modules-when-importing-an-spm-framework/24856</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/ReactiveX/RxSwift/issues/2057" target="_self">https://github.com/ReactiveX/RxSwift/issues/2057</a>]]></description><link>ios/missing-required-module-&apos;rxcocoaruntime&apos;에-대한-고찰-spm과-unittest에서의-오류.html</link><guid isPermaLink="false">iOS/Missing required module &apos;RxCocoaRuntime&apos;에 대한 고찰 - SPM과 UnitTest에서의 오류.md</guid><pubDate>Mon, 06 Jan 2025 15:10:33 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/RdgNd/btr8uTeqxjZ/YOZ0YRoqBNvxqE6hKVB9gK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/RdgNd/btr8uTeqxjZ/YOZ0YRoqBNvxqE6hKVB9gK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[robot_maze]]></title><description><![CDATA[<img src="images/robot_maze.png" target="_self">]]></description><link>images/robot_maze.html</link><guid isPermaLink="false">images/robot_maze.png</guid><pubDate>Sun, 05 Jan 2025 08:12:34 GMT</pubDate><enclosure url="images/robot_maze.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/robot_maze.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Visitor Pattern]]></title><description><![CDATA[기존의 SFML에서는 멤버 변수 sf::Event::EventType을 확인해서 각 이벤트를 처리 했었다. 내가 사용하는 3.0 버전에서는 이벤트를 visitor를 이용해서 처리 한다. Visitor 패턴은 객체 구조와 처리를 분리하는 디자인 패턴. 즉 '다른 클래스에 있는 알고리즘을 가져와서 실행할 수 있게 해주는 패턴'임 // 기존 방식 (이제 지원하지 않음)
if (event.type == sf::Event::Closed) { window.close();
} // Visitor 패턴 사용 (새로운 방식)
event.visit([&amp;window](const sf::Event::Closed&amp;) { window.close();
}); 컴파일 타임 검사: 잘못된 이벤트 타임에 접근하는 것을 방지하고 타입 불일치 오류를 컴파일 단계에서 발견할 수 있다. 기존의 방식을 사용하면 아래처럼 런타임에서 에러를 잡을 수 있다.
// 기존
if (event.type == sf::Event::MouseMoved) { // 실수로 KeyPressed의 데이터를 사용하려고 하면... bool isShiftPressed = event.key.shift; // 잘못된 메모리 접근
} // visitor
event.visit([](const sf::Event::MouseMoved&amp; mouse) { // mouse.position만 사용할 수 있음 // 다른 이벤트의 멤버는 접근 불가능
}); 코드 가독성: 중첩 if문, switch문 없음. 각 이벤트 타입별 처리가 원활
유지보수 좋음: 기존 코드 수정하지 않고 새로운 핸들러 추가가 쉬움
sf:Event 클래스를 확인하면 클래스 내에 struct으로 각 이벤트가 정의 되어 있다. 그리고 내부 변수에 private로 m_data를 가지고 있다.
이 m_data의 타입은 std::variant&lt;Closed, Resized, FocusLost, /*...*/ &gt; 이다.std::variant는 여러 타입 중 하나를 저장할 수 있는 type-safe union이다. 그렇다면 어떻게 SFML에서 m_data와 visit을 통해서 이벤트를 처리할까?이를 이해하기 위해 먼저 std::variant와 std::visit의 관계와 사용법에 대해 알아야만 한다.// 기본구조 // Variant: 여러 타입 중 하나를 저장할 수 있는 컨테이너
std::variant&lt;A, B, C&gt; data;
// Visitor: variant에 저장된 데이터를 처리하는 방법
auto visitor = [](const auto&amp; value) { /* 처리 로직 */ }; // 동작 방식
// 1. variant가 데이터 저장
std::variant&lt;int, std::string&gt; data = 42;
// 2. visitor가 데이터 처리
std::visit([](const auto&amp; value) { using T = std::decay_t&lt;decltype(value)&gt;; if constexpr (std::is_same_v&lt;T, int&gt;) { std::cout &lt;&lt; "정수 처리: " &lt;&lt; value &lt;&lt; std::endl; } else if constexpr (std::is_same_v&lt;T, std::string&gt;) { std::cout &lt;&lt; "문자열 처리: " &lt;&lt; value &lt;&lt; std::endl; }
}, data);
using T = std::decay_t&lt;decltype(value)&gt; 에서 decltype(value)는 value의 정확한 타입을 추론하고 std::decay_t는 참조와 const를 제거한 순수한 타입을 얻는다. 위 코드에서 const int&amp;는 int로 변환된다.이렇게 얻은 타입 T로 컴파일 타임에 타입 체크를 수행한다.if constexpr (std::is_same_v&lt;T, int&gt;) { // int 타입일 때의 처리
}
else if constexpr (std::is_same_v&lt;T, std::string&gt;) { // string 타입일 때의 처리
}
위의 예시와 같이std::variant 과 std::visit를 이용하면 컴파일 타임에서 안전하게 타입을 추론할 수 있고 각 타입마다 처리를 하기 용이 해진다는 장점을 알 수 있다.Window::pollEvnet() 를 호출하면 m_data가 변경된다.//SFML Event 내부 구현
template &lt;typename TEventSubtype&gt; Event::Event(const TEventSubtype&amp; eventSubtype)
{ static_assert(isEventSubtype&lt;TEventSubtype&gt;, "TEventSubtype must be a subtype of sf::Event"); if constexpr (isEventSubtype&lt;TEventSubtype&gt;) m_data = eventSubtype;
}
// SFML Event 내부 구현
class Event {
public: // visitor 패턴을 이용한 이벤트 처리 template &lt;typename T&gt; auto visit(T&amp;&amp; visitor) const { // visitor는 람다함수 or 함수 객체 return std::visit(std::forward&lt;T&gt;(visitor), m_data); }
};
여기에서 Visitor 패턴의 핵심 동작이 일어난다. Event::visit 함수는 std::visit의 단순 래퍼다.
std::forward&lt;T&gt;를 통해 visitor (람다나 함수 객체) 를 perfect 전달한다. 따라서 m_data와 visitor를 통해서 각 이벤트에 대해서 처리를 할 수 있게 된다.void Simulator::handleEvents() {
if (auto event = window.pollEvent()) { event-&gt;visit([this](const auto&amp; e) { using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }); }
}
이 코드가 실행될 때 내부적으로 아래와 같은 과정이 일어난다.
람다 함수가 Event::visit에 전달
Event::visit은 람다 함수를 std::visit으로 전달
std::visit은 m_data에 저장된 실제 타입을 확인하고 람다를 호출 한다.
이걸 좀 풀어서 설명하면 아래처럼 코드가 실행되는 것이다.std::visit( [this](const auto&amp; e) { // 여기서 e는 variant에 저장된 실제 타입의 참조 using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }, m_data // variant 객체 전달
);
struct EventVisitor { Simulator&amp; simulator; // 참조를 저장 // 특정 이벤트용 처리기 void operator()(const sf::Event::Closed&amp; event) { simulator.window.close(); } void operator()(const sf::Event::KeyPressed&amp; event) { ... } // 다른 모든 이벤트를 처리하는 템플릿 template&lt;typename T&gt; void operator()(const T&amp; event) {}
};
void Simulator::handleEvents() { if (auto event = window.pollEvent()) { event-&gt;visit(EventVisitor{*this}); }
} 객체를 만들고 operator()를 구현하면 객체를 함수처럼 사용할 수 있다.EventVisitor visitor; visitor(something);
내부적으로는 위의 람다 함수의 경우와 사실 거의 같다. 람다 함수 대신에 함수 객체를 넘겨주는 것이 차이점이다. 그리고 기본적으로 std::visit은 variant에 저장된 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다
event-&gt;visit(EventVisitor{*this}); 호출 한다.
Event::visit은 std::visit에 함수 객체와, m_data를 전달한다.
std::visit은 m_data(variant)를 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다.
]]></description><link>golf-simulator/visitor-pattern.html</link><guid isPermaLink="false">Golf Simulator/Visitor Pattern.md</guid><pubDate>Fri, 03 Jan 2025 15:33:44 GMT</pubDate></item><item><title><![CDATA[SFML]]></title><description><![CDATA[크로스 플랫폼 Golf Simulator를 만들면서 빠른 그래픽 렌더링을 위해 사용해봤다.
SFML은 C++로 작성된 멀티미디어 라이브러리다. 게임 개발이나 그래픽 애플리케이션을 만들 때 사용되는 크로스 플랫폼 프레임워크다. 주로 2D 엔진일 때 사용하는듯?SFML은 다양한 모듈을 지원하는데 내가 사용한 모듈은 Graphics, System, Window다. Window: 어플리케이션의 창과 입력을 관리하는 핵심 모듈 sf::RenderWindow - 윈도우
sf::VideoMode - 해상도
sf::Event - 입력 이벤트 처리 System: 유틸 모듈 (Thread, Clock 등등 지원함) sf::Vector - 벡터 연산 Graphics: 렌더링 sf::CircleShape: 골프공
sf::RectangleShape: 그라운드
sf::View - 카메라 cmake를 이용하고 있어서 CMakeLists.txt에서 라이브러리를 링크하는 형태로 적용했다.
SFML 예제를 보면 CMake의 FetchContent 모듈을 통해서 SFML을 다운로드하고 의존성을 관리한다.FetchContent_Declare(SFML GIT_REPOSITORY https://github.com/SFML/SFML.git GIT_TAG 3.0.0 GIT_SHALLOW ON EXCLUDE_FROM_ALL SYSTEM
)
FetchContent_MakeAvailable(SFML) # ... target_link_libraries(${PROJECT_NAME} PRIVATE SFML::Graphics SFML::Window SFML::System
) ]]></description><link>graphics/sfml.html</link><guid isPermaLink="false">graphics/SFML.md</guid><pubDate>Tue, 31 Dec 2024 17:31:23 GMT</pubDate></item><item><title><![CDATA[Modeling]]></title><description><![CDATA[수학을 배운 경험이 있다면 x^2&nbsp; + y^2 = 1 형태의 식을 본 적이 있을 것이다. 이러한 형태를 음함수라고 하는데 GPU는 음함수를 잘 처리하지 못한다. 그러면 어떻게 하느냐? 평면의 점을 샘플링해서 Polygon Mesh로 만든다. (샘플링을 한다는 것은 정점과, 법선 벡터를 잘 뽑는 것을 의미한다.)어떤 물체가 있고 이를 잘 샘플링해서 폴리곤 메쉬로 만들었다. 이렇게 만들어진 메쉬를 컴퓨터(?)는 어떻게 저장을 하는 지 알아보자.<img src="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">t1, t2, t3라는 삼각형 메쉬가 존재한다. 이를 메모리에 저장을 하는 방법은 간단하다. 좌표를 그냥 배열에 때려넣으면 된다. 때려 넣고 나니 문제점이 있는 것 같다.&nbsp; vertex array를 보면 중복되는 것이 많다는 것을 알 수 있다. 낭비가 심하다. 그래서 위와 같이 저장하지 않는다. 문제를 해결하기 위해 인덱스를 추가해 보자.<br><img src="https://blog.kakaocdn.net/dn/bB6wFv/btstk41D2xI/WHrJSexTiosKNTGHhMQe40/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">각 정점들에 index를 줘서 해결하면 더 빠르게 처리할 수 있다.3ds Max와 같은 모델링 프로그램을 이용해서 export를 하면 .obj 파일을 얻을 수 있다. 간단한 구를 모델링해서 export를 해서 열면 어떤 데이터가 들어 있을까?구는 26개의 정점과 48개의 삼각형으로 이뤄져 있다.<br><img src="https://blog.kakaocdn.net/dn/d3DpsC/btstkTy9Ufk/3TFup6zSfeHakZy5345wc1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">v는 Vertex를 의미하고, 숫자는 순서대로 x, y, z이다.vn는 Vertex Noraml을 의미하고 숫자는 순서대로 x, y, z이다.f는 face를 의미하고 v // vn 을 의미한다. (구는 v와 vn이 1:1로 대응하지만, 직육면체와 같은 입체에서는 vn이 중복될 수 있다.)<br><img src="https://blog.kakaocdn.net/dn/1Vyde/btsth6yLCPq/GbVkDxpfn73pFLdUo44HZ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">.obj를 Import 하게 되면 메모리는 위와 같이 저장된다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.kocw.net/home/search/kemView.do?kemId=1349173" target="_self">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>]]></description><link>graphics/modeling.html</link><guid isPermaLink="false">graphics/Modeling.md</guid><pubDate>Tue, 31 Dec 2024 06:02:33 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[컴퓨터 그래픽스 기초와 수학]]></title><description><![CDATA[컴퓨터 그래픽스는 3D 인풋을 받아 2D 공간에 표현하는 것에 대한 학문이다.컴퓨터 그래픽스의 Production는 5단계로 나눌 수 있다.<img src="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Modeling은 Polygon Mesh로 형태를 만드는 작업과 질감 처리 같은 Texture를 만드는 작업을 말한다.Rigging은 뼈대를 만들고 Polygon Mesh와 관계를 만드는 작업을 말한다.Animation은 Rigging를 통해 만들어진 관계들을 시퀀스로 만들어 실제로 움직이는 것처럼 보이게 만드는 작업이다.Rendering은 3차원에 있는 Scene을 2차원 Scene으로 나타내는 과정이다. 여기에서 중요한 이슈는 텍스쳐와 빛을 처리하는 것이다.Post-Processing는 후처리를 해서 좀 더 사실적으로 보이게 하는 작업이다. 필수 작업은 아니다.1번 ~ 3번의 작업은 그래픽 아티스트가 작업하고 4번 ~ 5번은 컴퓨터 프로그램이 처리한다.<br><img src="https://blog.kakaocdn.net/dn/mFeAO/btstpF7SkJM/2hgcK3ZnsHKFQ7ORXIcLN1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">일반적으로 게임의 하단에 Unity와 Unreal과 같은 게임엔진이 있고 게임 엔진에서 Graphics API를 사용한다. Graphics API에는 DirectX, Vulkan, OpenGL, Metal 등이 있다. Graphics API는 GPU를 구동하기 위한 추상화 되어 있는 인터페이스다.그래픽스 분야에서는 기본적으로 선형대 수학을 정말 많이 사용하는 것 같다.&nbsp;Line, Ray, and Linear Interpolation<br><img src="https://blog.kakaocdn.net/dn/QVQu5/btstqsArCYv/IB9YYR1LMmXpo37iJ5BsY0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">t의 범위에 따라서 p(t)를 부르는 이름이 달라진다.t의 범위가 -inf &lt; t &lt; inf 인 경우 Infinite linet의 범위가 0 &lt;= t &lt; inf 인 경우 Rayt의 범위가 0 &lt;= t &lt;= 1 인 경우 Line segmentp(t)에 대한 식을 풀어쓰면 Line segment는 p0과 p1의 Line interpolation과 대응한다는 것을 알 수 있다.<br><img src="https://blog.kakaocdn.net/dn/bTDV50/btstpCQPsfu/XuWI7yGFk88ChA1GK782NK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이것이 의미하는 바는 p0와 p1 사이에 위치하는 값을 양 끝점의 값으로 추정할 수 있다는 것이다.(선형보간법)<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.kocw.net/home/search/kemView.do?kemId=1349173" target="_self">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>]]></description><link>graphics/컴퓨터-그래픽스-기초와-수학.html</link><guid isPermaLink="false">graphics/컴퓨터 그래픽스 기초와 수학.md</guid><pubDate>Tue, 31 Dec 2024 06:01:51 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LINQ]]></title><description><![CDATA[Swift에서&nbsp; map(), filter() 같은&nbsp;고차함수를 많이 사용했었어요. C#으로 처음 PS를 풀 때 map을 사용하고 싶어서 c# map function으로 구글링 했을 때&nbsp; LINQ의 Select() 메서드를 사용하라고 하더군요. 'Select이 뭐지?' 했는데 데이터베이스 시간에 SQL로 열심히 실습할 때 나오는 그 select가 동일합니다. 그럼 LINQ가 뭘까요?LINQ는 Language-Integrated Query의 준말로 C#에서 직접 쿼리 기능을 통합하는 방식을 기반으로 하는 기술 이름이에요. 일반적으로 쿼리는 특수화된 쿼리 언어로 표현되어요. 예를 들면 관계형 데이터베이스에서는 SQL, XML에서는 XQuery가 사용됩니다. 그래서 하나의 형식을 사용할 때마다 하나의 쿼리 언어를 학습할 필요가 생기는 거죠. 그래서 LINQ가 등장하게 되었어요. LINQ는 다양한 데이터 소스 및 다양한 형식에 사용할 수 있는 일관된 모델을 제공합니다. 모든 형식에서 같은 방식으로 데이터를 쿼리하고 변환할 수 있게 됩니다.&nbsp;LINQ는 쿼리군요.&nbsp; 그럼 쿼리는 무엇일까요?&nbsp;
쿼리는 데이터 소스에서 검색할 데이터 및 반환된 데이터에 필요한 모양과 구성을 설명하는 지침 집합이다.
쉽게 풀면 쿼리는 데이터 소스에서 데이터를 검색(추출)하는 식입니다. (쿼리를 통해 검색된 결과가 아님을 주의)C#에서 쿼리(LINQ)를 어떻게 이용할 수 있을까요?&nbsp; LINQ는 세가지 작업으로 구성됩니다!1.&nbsp; 데이터 소스 가져오기 쿼리 만들기 쿼리 실행 데이터 소스는 말 그대로 우리가 쿼리하고 싶은 데이터 모음입니다. 단 쿼리 변수의 타입이&nbsp;IEumerable 또는 IQueryable이므로 이것을 두 타입 중 하나를 컨펌해야만 합니다.&nbsp;List와 Array와 같은 컬렉션 타입은 IEnumerable을 컨펌하고 있기 때문에 데이터 소스로 사용할 수 있어요. 또 관계형 데이터 베이스나, XML과 같은 것들을 IEumerable 또는 IQueryable로 로드를 하거나 맵핑을 해서 데이터 소스로 사용할 수 있습니다.// Array int[] numbers = new int[7] { 0,1,2,3,4,5,6 }; IEumerable&lt;int&gt; numQuery = from number in numbers where (number % 2) == 0 select number;
// LINQ to XML
// Create a data source from an XML document.
// using System.Xml.Linq;
XElement contacts = XElement.Load(@"c:\myContactList.xml"); IQueryable&lt;Contract&gt; contractQuery = from contract in contracts where ... select ...
// LINQ to SQL Mapping Northwnd db = new Northwnd(@"c:\northwnd.mdf"); // Query for customers in London.
IQueryable&lt;Customer&gt; custQuery = from cust in db.Customers where cust.City == "London" select cust;
이제 쿼리 변수를 만들겠습니다.쿼리 변수를 만드는 방법은 두가지가 있습니다. 쿼리 구문을 이용해서! 메서드 구문을 이용해서! 그럼 1번 2번을 두개 다 연습을 해볼게요. 연습을 하기 전에 데이터 소스를 먼저 만들어줍시다.// Teacher.cs public class Teacher
{ public string Name { get; set; } public int ID { get; set; } public decimal Salary { get; set; } public Teacher(string name, int id, decimal salary) { Name = name; ID = id; Salary = salary; }
} // Student.cs public class Student
{ public string Name { get; set; } public int ID { get; set; } public List&lt;int&gt; scroes { get; set; } public Student(string name, int id, List&lt;int&gt; scroes) { Name = name; ID = id; this.scroes = scroes; }
} // Program.cs namespace TestLINQ
{ class Program { static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); } public static void SeedData(List&lt;Student&gt; students, List&lt;Teacher&gt; teachers) { List&lt;Student&gt; _students = new List&lt;Student&gt;() { new Student("김수로", 0, new() { 90, 95,70,50, 87}), new Student("박혁거세", 1, new() { 80, 45,95,80, 75}), new Student("이은혜", 2, new() { 83, 63,89,93, 63}), new Student("이근왕", 3, new() { 55, 77,77,31, 90}), new Student("선우현", 4, new() { 100, 15,25,36, 57}), }; foreach (var s in _students) { students.Add(s); } List&lt;Teacher&gt; _teachers = new List&lt;Teacher&gt;() { new Teacher("김철수", 5, 10000), new Teacher("이진혜", 6, 20000), new Teacher("김왕심", 7, 30000), new Teacher("박수빈", 8, 40000), new Teacher("손을왕", 9, 50000), }; foreach (var t in _teachers) { teachers.Add(t); } } }
}
혹시 SQL을 사용한 경험이 있으신가요?SQL처럼 select where from을 이용해서 쿼리 하는 방식이 쿼리 구문을 이용하는 방법입니다. SQL과 차이점이라면 순서가 반대라는 것!쿼리 구문은 아래와 같은 형식을 가집니다.
쿼리 구문은 반드시 from절로 시작해야 함
쿼리 구문은 반드시 select절 또는 group절로 끝나야 함.
첫 번째 from절과 마지막 select절 또는 group절 사이에 where, orderby, join, let절과 추가 from절들이 하나 이상 들어갈 수 있음.
첫 번째 예시는 첫번째 시험에서 90점 이상을 맞은 학생들을 검색하는 쿼리 변수를 만들게요. static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); IEnumerable&lt;Student&gt; notLessThan90 = from student in students where (student.scroes[0] &gt;= 90) select student; Console.WriteLine("첫번째 시험에서 90점 이상 맞은 학생들"); foreach (Student student in notLessThan90) { Console.WriteLine("{0}, {1}", student.Name, student.scroes[0]); }
쿼리 구문을 이용하면 상당히 직관적으로 데이터를 추출할 수 있네요. 기본적인 구조는 이해하는데 문제가 없을 것 같아요.추가로 정렬을 의미하는 orderby도 한번 사용해 볼게요. Student에서 성이 이씨인 사람들을 뽑을건데 ID를 내림차순으로 정렬해보도록 하겠습니다. IEnumerable&lt;Student&gt; descendingByID = from student in students where (student.Name[0].ToString() == "이") orderby student.ID descending select student; Console.WriteLine("학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬"); foreach (Student student in descendingByID) { Console.WriteLine("{0}, {1}", student.Name, student.ID); }
되게 간단하네요.&nbsp; 마지막으로 select 대신에 group을 한번 사용해볼게요.Student 리스트에서 성으로 그룹핑을 하겠습니다. Console.WriteLine("학생들의 성으로 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstName= from student in students group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstName) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } Console.WriteLine("학생들의 성으로 내림차순으로 정렬 및 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescending= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescending) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } }
보시다시피 group을 사용하면 IGrouping을 반환해서 네스트 타입이 되네요. 일일이 타입을 적어주는 게 불편한 경우도 있죠. 그런 경우에는 암묵적 형식인 var 키워드를 사용해도 됩니다. var groupByFirstNameDescending2= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (var group in groupByFirstNameDescending2) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } }
위에서 쿼리를 쿼리 구문을 이용해서 작성해 봤어요.&nbsp;쿼리 구문은 코드를 컴파일할 때 .NET CLR(공용 언어 런타임)에 대한 메서드 호출로 변환해야 합니다. 이러한 메서드 호출은&nbsp;Where,&nbsp;Select,&nbsp;GroupBy,&nbsp;Join,&nbsp;Max,&nbsp;Average&nbsp;등과 같은 표준 쿼리 연산자를 호출한다고 하네요. 따라서 우리는 쿼리 구문 대신 메서드 구문을 사용하여 연산자를 직접 호출할 수도 있어요.쿼리 구문과 메서드 구문은 의미상 동일하지만, 쿼리 구문이 더 간단하고 읽기 쉽다고 생각하는 사람이 많다고 합니다. 저도 쿼리 구문이 더 읽기가 쉬웠어요. 그러나 일부 쿼리는 메서드 호출로 표현해야 합니다. 예를 들어 필터를 하는 쿼리에서 요소 개수 또는 최댓값등을 얻으려면 메서드 호출을 사용해야 해요. 따라서 LINQ 쿼리를 작성하기 시작한 경우에도 쿼리 및 쿼리 식 자체에서 메서드 구문을 사용하는 방법을 잘 알고 있으면 유용합니다.위에서 쿼리 구문으로 작성한 쿼리를 메서드 문법으로 작성해 볼게요. // 메서드 구문 이용 Console.WriteLine("메서드 구문 이용해서"); IEnumerable&lt;Student&gt; notLessThan90Method = students.Where(student =&gt; student.scroes[0] &gt;= 90); Console.WriteLine("첫번째 시험에서 90점 이상 맞은 학생들"); foreach (Student student in notLessThan90Method) { Console.WriteLine("{0}, {1}", student.Name, student.scroes[0]); } IEnumerable&lt;Student&gt; descendingByIDMethod = students.Where(student =&gt; student.Name[0].ToString() == "이").OrderByDescending(student =&gt; student.ID); // from student in students // where (student.Name[0].ToString() == "이") // orderby student.ID descending // select student; Console.WriteLine("학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬"); foreach (Student student in descendingByIDMethod) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } Console.WriteLine("학생들의 성으로 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameMethod = students.GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } Console.WriteLine("학생들의 성으로 내림차순으로 정렬 및 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescendingMethod = students.OrderByDescending(student =&gt; student.Name[0].ToString()) .GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescendingMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } }
마지막으로 Concat() 메서드를 이용해서 학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID를 추출하겠습니다. Console.WriteLine("학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID"); var oddIDInTeacherAndStudent = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)); foreach (var id in oddIDInTeacherAndStudent) { Console.WriteLine(id); }
위에서 쿼리 변수를 열심히 만들어서 출력해 봤는데요. 항상 맨 밑에 foreach가 존재합니다. 쿼리 변수는 사실 결과 데이터를 가지고 있지 않아요. 그저 명령만을 가지고 있습니다.&nbsp; 실제로 데이터를 얻기 위해서는 쿼리 실행을 해줘야 합니다. 쿼리 실행 하는 법은 foreach를 사용해서 루프를 돌게 하면 되겠습니다.즉시 실행을 하기 위해서는 Count(), Average(), Max() 등 결과를 얻기 위해 foreach를 암묵적으로 사용하는 메서드 문법을 사용하거나, ToList, ToArray 같은 것을 사용해서 결과를 바로 캐시 하는 방법을 사용하면 됩니다. var oddIDCount = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).Count(); Console.WriteLine(oddIDCount); var oddIDList = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).ToList(); Console.WriteLine(String.Join(" ", oddIDList));
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/LINQ_Practice" target="_self">https://github.com/psychehose/LINQ_Practice</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/" target="_self">https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/</a>]]></description><link>csharp/linq.html</link><guid isPermaLink="false">csharp/LINQ.md</guid><pubDate>Tue, 31 Dec 2024 06:01:06 GMT</pubDate></item><item><title><![CDATA[28. Plate Pick up Objects]]></title><description><![CDATA[Player가 그릇에 KitchenObject를 두는 로직을 구현하도록 하겠습니다.제약사항은 다음과 같습니다.
같은 KitchenObject가 들어가면 안됨
Valid한 KitchenObject만 들어가야함
가능한 경우는 두 가지입니다. 첫 번째는 ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직입니다. 두 번째는 ClearCounter에 KitchenObject(그릇 제외)가 놓여져 있고, Player가 들고 있는 그릇에 놓는 로직입니다.ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직부터 구현 하겠습니다.PlateKitchenObject 스크립트를 생성합니다. 이는 KitchenObject를 상속합니다. Plate Prefab에 스크립트를 넣고 레퍼런스로 Scriptable Object를 넣습니다.<img src="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// ClearCouter.cs public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject() is PlateKitchenObject) { // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter plateKitchenObject.AddIngredient(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
여기에서 제약조건을 추가해야 합니다. - 이미 가지고 있는 타입인 경우에 어떠한 액션도 일어나지 않게 하겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlateKitchenObject : KitchenObject
{ private List&lt;KitchenObjectSO&gt; kitchenObjectSOArray; private void Awake() { kitchenObjectSOArray = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (kitchenObjectSOArray.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOArray.Add(kitchenObjectSO); return true; } } }
ClearCounter에 있는 함수 AddIngredienet를 TryAddIngredent로 리팩토링 하겠습니당// ClearCouter.cs if (player.GetKitchenObject() is PlateKitchenObject)
{ // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter if(plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); }
}
제약조건 추가하기 - 유효한 KitchenObject만 넣을 수 있게 할게요
토마토슬라이스
치즈슬라이스
빵
양배추 슬라이스
익힌 고기패티
탄 고기패티
public class PlateKitchenObject : KitchenObject { [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOList; }
<br><img src="https://blog.kakaocdn.net/dn/cj2Xuj/btssACqprSj/ONuQLp1IF5IhnmfiTsAgDk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlateKitchenObject : KitchenObject
{ [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOListy; private List&lt;KitchenObjectSO&gt; kitchenObjectSOList; private void Awake() { kitchenObjectSOList = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (!validKitchenObjectSOListy.Contains(kitchenObjectSO)) { return false; } if (kitchenObjectSOList.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOList.Add(kitchenObjectSO); return true; } } }
코드 리팩토링을 진행할게요. KitchenObject에&nbsp; TryGetPlate 메서드를 만들어서 이것을 사용하도록 할게요. plateKitchenObject를 얻기 위해서 GetKitchenObject를 호출하고 as를 이용해서 타입캐스팅을 하는데 이것을 더 안전하게 하기 위해서 out parameter를 이용하도록 하겠습니다.// KitchenObject.cs
public bool TryGetPlate(out PlateKitchenObject plateKitchenObject) { if (this is PlateKitchenObject) { plateKitchenObject = this as PlateKitchenObject; return true; } else { plateKitchenObject = null; return false; } }
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
ClearCounter에서 열심히 만든 부분을 StoveCounter, CuttingCounter에도 똑같이 적용하도록 하겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter, IHasProgress
{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } // State Machine 초기화 state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter, IHasProgress
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler OnCut; private int cuttingProgress; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgress = 0; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgress++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnCut?.Invoke(this, EventArgs.Empty); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgress) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }
}
이제는 ClearCounter에 그릇이 놓여져 있고 그릇에 KitchenObject를 위치시키는 로직을 짜도록 하겠습니다.ClearCounter가 HasKitchenObject가 true인 경우에서 Player가 KitchenObject를 가지고 있지만 그릇이 아닌 경우에서 ClearCounter가 그릇을 가지고 있는 경우를 생각하면 됩니다. 말로 전달하니 조금 복잡한 것 같네요.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } else { // Player is not holding plate but something else if (GetKitchenObject().TryGetPlate(out plateKitchenObject)) { // There is Plate in Clear Counter if (plateKitchenObject.TryAddIngredient(player.GetKitchenObject().GetKitchenObjectSO())) { player.GetKitchenObject().DestroySelf(); } } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
&nbsp;끝!]]></description><link>unity/28.-plate-pick-up-objects.html</link><guid isPermaLink="false">Unity/28. Plate Pick up Objects.md</guid><pubDate>Tue, 31 Dec 2024 06:00:03 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[27. Plates Counter]]></title><description><![CDATA[접시가 생성되는 PlatesCounter를 만들어봅시다. Prefab을 만들어줍시다.스크립트를 생성합니다. PlatesCounter는 일정 시간이 흐르면 접시가 하나씩 생성되고 이미 존재한다면 그 위에 쌓아야 합니다.Plates Scriptable Object (기존에 만든 KitchenObjectSO로), Plate Object를 생성합니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; } } }
}
Visual을 담당하는 스크립트도 만듭시다. 왜냐하면 그릇을 쌓아야 하기 때문입니다. 따라서, Visual에는 TopPoint와 그릇 Visual Prefab을 알고 있어야겠죠?using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab;
}
<img src="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 PlatesCounter에서 이벤트 핸들러를 만들고 Invoke를 해줍시다. 그런 다음에 Visual에서 리슨 해주면 되겠네요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); }
}
근데 뭔가 잘못된 거 같아요. 그릇들을 쌓으려면 그릇 List를 가지고 있어야하고 Vector를 높이는 코드가 없어요. 처리 ㄱㄱusing System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }
}
여기까지 하면 그릇을 추가하면 슉슉하고 올라갑니다. 이제 플레이어가 그릇을 가져가는 코드를 작성합시다. PlatesCounter에서 Remove 이벤트 핸들러를 만들어주고&nbsp;Interact가 발생하면&nbsp;&nbsp;이를 Invoke하면 되겠죠?using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; public event EventHandler OnPlateRemoved; private float spawnPlateTimer; private float spawnPlateTimerMax = 4f; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } } public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player is empty Handed if (platesSpawnedAmount &gt; 0) { // There is at least one plate here platesSpawnedAmount--; KitchenObject.SpawnKitchenObject(plateKitchenObjectSO, player); // Update Visual OnPlateRemoved?.Invoke(this, EventArgs.Empty); } } }
}
비쥬얼에서 그릇 가져가는 이벤트를 리스닝 합시다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; platesCounter.OnPlateRemoved += PlatesCounter_OnPlateRemoved; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }
}
]]></description><link>unity/27.-plates-counter.html</link><guid isPermaLink="false">Unity/27. Plates Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:59:01 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[26. Stove Counter]]></title><description><![CDATA[고기를 굽는 StoveCounter를 만들어봅시다. 역시 Prefab을 먼저 만들어야 합니다. StoveCounter는 익히기 전 익힌 후의 오브젝트 input, output이 있기 때문에 Scriptable Object Script를 만들겠습니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class FryingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public float fryingTimerMax;
}
이제 고기 상태에 따라 Meet Uncooked, Cooked, Burned의 Scriptable Object와 Prefab을 만듭시다.<img src="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bagZDK/btssAHL3PhM/rXjdwUtJkw8eAJT6pyGOr0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cx1MPZ/btssk1SBRSJ/VBwrujauNrjjP9KSciFCPk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cSdtLN/btssBZyGhGf/JruIsm7eW6zkIP6BxFqlzK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">StoveCounter 스크립트를 만들고 SerializedField를 만들어줍시다. 그런 다음에 유니티로 돌아가서 레퍼런스를 넣어줍시다.public class StoveCounter : BaseCounter
{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray;
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; private float fryingTimer; private FryingRecipeSO fryingRecipeSO; private void Update() { if (HasKitchenObject()) { fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { Debug.Log("Fried"); fryingTimer = 0f; GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); } Debug.Log(fryingTimer); } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; }
}
위 코드는 문제가 발생 합니다. 시간은 계속 흐르기 때문에 오브젝트(고기)가 사라지고 output 오브젝트가 계속 새로 생깁니다. 이 문제를 해결하기 위해서 State Machine 개념을 도입해야 합니다. 처리하기 쉽게 Enum을 사용하도록 합시다. 그리고 State에 Burned도 있기 때문에 유사하게 Burning SO도 만듭시다.[CreateAssetMenu()]
public class BurningRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public float burningTimerMax;
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ private enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
StoveCounter에 Animation을 넣읍시다. StoveCounterVisual 스크립트를 생성할게요using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounterVisual : MonoBehaviour
{ [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; [SerializeField] private StoveCounter stoveCounter;
}
StoveCounter에서 EventHandler를 만들고 Invoke 할게요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
StoveCounterVisual에서 이벤트를 리슨 하는 코드를 작성!using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounterVisual : MonoBehaviour
{ [SerializeField] private StoveCounter stoveCounter; [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; private void Start() { stoveCounter.OnStateChanged += StoveCounter_OnOnStateChanged; } private void StoveCounter_OnOnStateChanged(object sender, StoveCounter.OnStateChangedEventArgs e) { bool showVisual = e.state == StoveCounter.State.Frying || e.state == StoveCounter.State.Fried; stoveOnGameObject.SetActive(showVisual); particlesGameObject.SetActive(showVisual); }
}
ProgressBar를 만듭시다. 전에 CuttingCounter에서 만든 거와 동일해요 그래서 재사용 가능using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public interface IHasProgress
{ public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged; public class OnProgressChangedEventArgs: EventArgs { public float progressNormalized; }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private GameObject hasProgressGameObject; [SerializeField] private Image barImage; private IHasProgress hasProgress; private void Start() { hasProgress = hasProgressGameObject.GetComponent&lt;IHasProgress&gt;(); if (hasProgress == null) { Debug.LogError("GameObject " + hasProgressGameObject + " does not have a component that implements IHasProgress"); } hasProgress.OnProgressChanged += HasProgress_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void HasProgress_OnProgressChanged(object sender, IHasProgress.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }
}
StoveCounter에서 Confirm 합시다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter, IHasProgress
{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
끝!]]></description><link>unity/26.-stove-counter.html</link><guid isPermaLink="false">Unity/26. Stove Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:58:13 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[25. Trash Counter]]></title><description><![CDATA[어떤 오브젝트도 버릴 수 있는 TrashCounter를 만듭시다.TrashCounter Prefab을 먼저 만들기_BaseCounter -&gt; Create Prefab Variant -&gt; TrashCounter로 네이밍프리팹에 들어가서 TrashCounter_Visual 넣고 복사해서 Selected로 네이밍 합니다.&nbsp; 그런 다음에 Selected에 SelectedCounter 스크립트를 넣어주기 그리고 Mesh 설정, Scale 1.01배 설정 등 귀찮은 작업들을 해줍시다.<img src="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Script를 생성합니다. 로직은 매우 단순해요. 인터렉트가 발생하면 플레이어가 가지고 있는 오브젝트를 없애면 되겠습니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class TrashCounter : BaseCounter { public override void Interact(Player player) { if (player.HasKitchenObject()) { player.GetKitchenObject().DestroySelf(); } }
}
<br><img src="https://blog.kakaocdn.net/dn/cwFk56/btsshrj0wKp/CjAEbaE6rG0AbuggrFQKGk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/25.-trash-counter.html</link><guid isPermaLink="false">Unity/25. Trash Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:57:18 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[24. Look At Camera]]></title><description><![CDATA[오브젝트마다 사용자에게 어떻게 보여줘야 할지 다른 경우가 있습니다. 이것을 일일이 설정하면 코드가 복잡해질 거예요. 이를 스크립트로 만들어서 필요한 경우 스크립트를 넣어서 핸들링하는 방법을 알아볼게요.LookAtCamera 스크립트를 생성할게요.using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine; public class LookAtCamera : MonoBehaviour
{ [SerializeField] private Mode mode; private enum Mode { LookAt, LookAtInverted, CameraForward, CameraForwardInverted } private void LateUpdate() { switch (mode) { case Mode.LookAt: // 예전에는 Camera.main이 캐시되지 않아서 배드 퍼포먼스여서 사용하지 않았으나 지금은 디폴트로 캐시되어서 사용 transform.LookAt(Camera.main.transform); break; case Mode.LookAtInverted: Vector3 dirFromCamera = transform.position - Camera.main.transform.position; transform.LookAt(transform.position + dirFromCamera); break; case Mode.CameraForward: transform.forward = Camera.main.transform.forward; break; case Mode.CameraForwardInverted: transform.forward = -Camera.main.transform.forward; break; } }
}
위처럼 enum으로 상태를 관리해줄게요. LookAt은 오브젝트가 카메라를 바라봅니다. (메인 카메라가 중앙에 있다면, 중앙을 향해서)LookAtInverted는 카메라를 바라보는 것은 같은데 좌우가 뒤집힙니다. CamerarForward는 메인 카메라 방향을 바라보지만, 기울어지지 않습니다. 역시 CameraForwardInverted는 좌우가 반전됩니다.유니티에서 오브젝트에 스크립트를 추가한 후에 설정해서 사용하면 됩니다.<img src="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/24.-look-at-camera.html</link><guid isPermaLink="false">Unity/24. Look At Camera.md</guid><pubDate>Tue, 31 Dec 2024 05:56:59 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[23. Cutting Progress, World Canvas]]></title><description><![CDATA[이번에는 재료들을 컷할 때 몇 번 액션을 줘야 하는지 정하고 Cutting Counter 위에 프로그레스바를 넣을 거예요.토마토는 3번, 치즈는 3번, 양배추는 5번 F키를 눌러서 잘라줘야 합니다.원재료가 있고 이를 컷팅했을 때 Sliced 재료가 되어야 하니까 Scriptable Object를 만들어서 관리하는 게 좋아요.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class CuttingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public int cuttingProgressMax;
}
<img src="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Cutting Counter에 가서 로직을 작성해 볼까요? cuttingProgress라는 이름으로 int인 프로퍼티를 만들고 Player가 CuttingCounter에 원재료를 올려놓으면 0으로 초기화해줍니다. 그리고 F키를 눌러 InteractAlternate를 하게 되면 cuttingProgress를 높이면 되겠습니다.그 외 코드들은, CuttingRecipeSO의 input인 토마토, 치즈, 양배추만 컷팅 카운터에 올릴 수 있게 하는 코드입니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; private int cuttingProgess; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgess = 0; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgess++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgess) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }
}
그리고 [SerializedField]로 설정했기 때문에 유니티에서 꼭 레퍼런스를 지정해 주세요.<br><img src="https://blog.kakaocdn.net/dn/EHheN/btsrNBG5Htz/5kSMlkvN7e2r0aa6DSXp41/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CuttingCounter 하위에 Empty Object를 만들고, Render Mode를 World Space로 바꿔줍시다. Rect Transform에서 Position과 width, height를 다 0으로 설정합시다. 그리고 프로그레스 바를 어디에다가 띄울지 위치를 대충 결정해 주면 됩니다. 그런 다음에 하위에 Image를 만들게요.Image를 눌러서 Color를 정해주고 Source 이미지에 White 1x1을 넣어주세요.<br><img src="https://blog.kakaocdn.net/dn/u82GH/btsrSKXRW5u/LN0bud5Z4lOEzRdYJkIYFK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Image type을 정해줍시다.Image Type에는 아래 4종류가 있습니다.
Simple
Tiled
Sliced
Filled
저는 Filled를 선택할게요. Fill Amount를 조정하면 아까 위에서 설정한 Source Image(하얀색)에서 우리가 설정한 색깔(노란색)로 변합니다. 1이면 전체가 노란색으로 채워집니다. 노란색으로 채우는 방법도 여러 가지입니다. Fill Method에서 Horizontal로 설정하면 왼쪽에서부터 가로로 채워집니다.<br><img src="https://blog.kakaocdn.net/dn/sqVRe/btsrSM2rv0c/rM2KN55cTnmJ1whSzup6Lk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/GCYaK/btsrYVRyRXh/qsaIsO3P6wNKrV18kv5Atk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위처럼 백그라운드 설정하기 위해서 먼저 Bar를 복사하고 이름을 Background로 짓습니다. 그런 다음에 Simple로 바꾸고 색깔을 검은색으로 하면 됩니다. 여기에서 중요한 것이 Bar보다 위에 위치시켜야 한다는 점입니다. 순서대로 그리기 때문입니다.Background에 아웃라인을 좀 더 주고 명확하게 하고 싶어서 컴포넌트를 추가하겠습니다.<br><img src="https://blog.kakaocdn.net/dn/AIGG7/btsrIb9Pm3Z/4S8qXoMIqZOHhTziVLSPQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CuttingCounter에서 ProgressUI를 분리하는 것이 더 깔끔하기 때문에 스크립트를 생성하고 ProgressBarUI로 이름 짓겠습니다. 스크립트를 ProgressBarUI에 어태치 해주세요.SerializedField로 CuttingCounter, Image를 선언하고 유니티에서 레퍼런스를 지정해 줍시다.public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image image;
}
CuttingCounter에서 이벤트로 ProgressBarUI에 이벤트를 넘겨줘야 하기 때문에 CuttingCounter에서 EventHandler를 만들고, 명확하게 몇 번 컷팅했는 지를 보내야 하기 때문에, EventArgus도 만들어줘야 합니다. 그런 다음에 InteractAlternate에서 Invoke 해주면 되겠죠?CuttingCounter.cs
// ...
public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged;
public class OnProgressChangedEventArgs: EventArgs
{ public float progressNormalized;
} //... // CuttingCounter.cs (InteractAlternate 메서드 안) CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new OnProgressChangedEventArgs
{ progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax
});
이벤트를 Invoke 하는 코드를 만들었으니, ProgressBarUI에서 이벤트를 리스닝하는 코드를 작성하면 되겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image barImage; private void Start() { cuttingCounter.OnProgressChanged += CuttingCounter_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void CuttingCounter_OnProgressChanged(object sender, CuttingCounter.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }
}
이제 마지막으로 Cutting 애니메이션을 넣도록 하겠습니다.CuttingCounter에서 OnCut이라는 이벤트 핸들러를 만들고 역시 InteracteAlternate()에서 Invoke 해줍시다.public event EventHandler OnCut; OnCut?.Invoke(this, EventArgs.Empty);
CuttingCounterVisual 스크립트를 만들어줄게요.public class CuttingCounterVisual : MonoBehaviour { [SerializeField] private CuttingCounter cuttingCounter; private Animator animator; private const string CUT = "Cut"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { cuttingCounter.OnCut += CuttingCounter_OnCut; } private void CuttingCounter_OnCut(object sedner, System.EventArgs e) { animator.SetTrigger(CUT); } }
SerializedField를 선언했으면? 당연히 레퍼런스를 넣어줘야겠죠? 끝!<br><img src="https://blog.kakaocdn.net/dn/lpEMX/btsrSNNNpx1/JXtASI1Rj7lKfM41TlNWJK/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/23.-cutting-progress,-world-canvas.html</link><guid isPermaLink="false">Unity/23. Cutting Progress, World Canvas.md</guid><pubDate>Tue, 31 Dec 2024 05:56:38 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[22. Cutting Recipe SO]]></title><description><![CDATA[지난번에 언급했던 문제점!하드코딩 되어있기 때문에 어떤 재료든 컷팅하며 슬라이스 토마토가 되어있는 이슈를 해결하도록 하겠습니다.각각 종류에 맞는 슬라이스로 만드는 것이 목표입니다.Scriptable Object를 이용해서 해결해봅시다. 고고대력 흐름은 CuttingRecipeSO를 만들어서 Input과 outpt으로 원재료 -&gt; 슬라이스로 다루는 것입니다.Input - 토마토, 치즈, 양배추Output - 토마토 슬라이스, 치즈 슬라이스, 양배추 슬라이스제약조건도 추가해줘야 합니다. 이미 잘린 것은 또 자를 수 없기 때문에요먼저 CuttingRecipeSO 스크립트를 만듭시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class CuttingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output;
}
유니티에서 노가다를 통해서 프리팹과 SO를 만듭시다. 처음엔 드래그 앤 드랍 싫고 그랬는데 익숙해지면 소소한 재미가 있더라고요.KitchenObjectSO - 치즈슬라이스랑, 캐비지 슬라이스 만들기KitchenObject - 치즈 슬라이스, 캐비지 슬라이스 만들기CuttingRecipeSO - 토마토,치즈,캐비지 만들기<img src="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 CuttingCounter에서 로직 구현을 할 차례예요.시리얼라이즈드 필드로 CuttingRecipeSO를 배열로 들고 있어야하고, KitchenObjectSO를 리턴하는 메서드가 필요하겠네요.그리고 이미 잘린 것은 또 못자르게 로직을 구현합시다.&nbsp;간단하게 CuttingCounter가 가지고 있는 KitchenObject가 루프를 돌아서 이게 Recipe의 Input과 같으면, 잘라주면 됩니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(kitchenObject.GetKitchenObjectSO()); kitchenObject.DestroySelf(); // Cutting KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return true; } } return false; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO.output; } } return null; }
}
마지막으로 유니티로 돌아가서 시리얼라이즈드 필드에 아래처럼 SOArray 레퍼런스를 잘 넣어주면 끝!<br><img src="https://blog.kakaocdn.net/dn/MeJop/btsqYqfsKQm/cI5DI71dFiLKeLt6TObc11/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/22.-cutting-recipe-so.html</link><guid isPermaLink="false">Unity/22. Cutting Recipe SO.md</guid><pubDate>Tue, 31 Dec 2024 05:55:48 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[21. Cutting Counter, Interact Alternate]]></title><description><![CDATA[이번에는 CuttingCounter를 만들게요!플레이어는 Cutting Counter에서 치즈, 토마토, 양배추를 놓고 자를 수 있어요. 그래서 놓고 드는 인터렉트 말고 다른 인터렉트가 필요할 거예요!프리팹을 먼저 만들게요. _BaseCounter를 선택하고 Prefab Variant를 클릭해서 만들어줍시다. 그리고 비주얼 넣고, 선택되었을 때 처리를 하면 되겠죠? 스크립트도 만들어서 어태치 하고 BaseCounter를 상속하게 합니다.그리고 유니티로 돌아와서 레퍼런스를 넣어줍시다. 처음에 할 때 이 과정이 복잡했는데, 이제는 조금 익숙해져서 다행이네요. 역시 반복이 답이제 자르는 인터렉트 키를 만들어봅시다.Input System에서 열고 InteractAlternate 추가하고 F로 설정! Save Asset 누르는 거 잊지 말기<img src="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input System에서 액션을 만들어줬기 때문에 이것을 등록하고 구현해야겠죠? 이미 구현한 Interact처럼 하면 됩니다.
GameInput.cs에 등록
Player가 Interact를 하기 때문에 Player.cs에서 등록 및 구현
BaseCounter에서 구현
코드를 작성해 봅시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.InputSystem; public class GameInput : MonoBehaviour { public EventHandler OnInteractAction; // 새로 구현한 곳 public EventHandler OnInteractAlternateAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Subscribe 코드 playerInputActions.Player.Interact.performed += Interact_performed; playerInputActions.Player.InteractAlternate.performed += InteractAlternateOnperformed; }
// 새로 구현한 곳 private void InteractAlternateOnperformed(InputAction.CallbackContext obj) { OnInteractAlternateAction?.Invoke(this, EventArgs.Empty); } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }
}
Player.cs에 추가합시다.private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction;
// 새로 추가됨 gameInput.OnInteractAlternateAction += OnInteractAlternateAction; }
// 새로 추가됨 private void OnInteractAlternateAction(object sender, EventArgs e) { if (selectedCounter != null) { selectedCounter.InteractAlternate(this); } }
BaseCounter에 구현을 하러 갑시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void InteractAlternate(Player player) { Debug.LogError("InteractAlternate.Interact();"); } public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
이제 CuttingCounter에서 overriding을 구현해야 해요. 그전에 Cutting을 했을 때 원래 있던 KitchenObject가 새로운 KitchenObject(Ex: 토마토 -&gt; 잘린 토마토)로 변해야므로 새로운 KitchenObjectSO와 KitchenObject를 만들겠습니다.일단 바로 추가할 수 있는 Destory()를 먼저 구현할게요(토마토 -&gt; 잘린 토마토인 경우 토마토 객체를 먼저 없애줘야 하므로)using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError("IKitchenObjectParent already has kitchen object"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; } // 새로 추가된 부분 public void DestroySelf() { kitchenObjectParent.ClearKitchenObject(); Destroy(gameObject); }
}
잘린 토마토 슬라이스 Scriptable Object와 프리팹을 유니티에서 만듭시다.<br><img src="https://blog.kakaocdn.net/dn/0QIKK/btsqYZ9QisQ/e0ETQgs7TAA2kRdfLderD0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">다 만든 다음에, CuttingCounter 코드를 작성 ㄱㄱusing System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO cuttingKitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Player is carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject()) { // There is Kitchen Object here kitchenObject.DestroySelf(); // Cutting Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); } }
}
코드에서, 다음 두 라인이 CuttingCounter.cs와 ContainerCounter.cs에서 공통적으로 사용됩니다. 따라서 리펙토링 대상이겠죠? 고고Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab);
kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player);
KitchenObject.cs에서 static 메서드로 만들어줍시다.public static KitchenObject SpawnKitchenObject(KitchenObjectSO kitchenObjectSO, IKitchenObjectParent kitchenObjectParent) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); KitchenObject kitchenObject = kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;(); kitchenObject.SetKitchenObjectParent(kitchenObjectParent); return kitchenObject; }
// ContainerCounter.cs
public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 KitchenObject.SpawnKitchenObject(kitchenObjectSO, player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }
마지막으로 Cutting Counter에 시리얼라이즈드 필드를 사용했으니 유니티에서 레퍼런스(만들어 놓은 Tomato Slice SO)를 넣어주면 끝!여기까지 하면, 토마토를 자르면 잘린 토마토가 되는 걸 확인할 수 있어요. 근데 치즈를 잘라도 잘린 토마토가 나오기 때문에 다음에 이 문제를 해결하도록 하겠습니다!]]></description><link>unity/21.-cutting-counter,-interact-alternate.html</link><guid isPermaLink="false">Unity/21. Cutting Counter, Interact Alternate.md</guid><pubDate>Tue, 31 Dec 2024 05:55:05 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20. Player Pick Up & Drop Object]]></title><description><![CDATA[이번에는 Player가 ContainerCounter에서 Object를 꺼내서 ClearCounter에 놓았다 들었다 하는 것을 구현할게요.public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { if (player.HasKitchenObject()) { // Player가 가지고 있으면 아무것도 해선 안됨 } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } }
}
컨터이너에서 오브젝트를 꺼내고, 바로 컨테이너에서 인터렉트를 할 시에 에러가 발생해야 해요. 왜냐하면 플레이어가 오브젝트를 들고 있지 않을 때만 인터렉트를 해야 하기 하기 때문이에요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }
}
현재는 KitchenObject가 Tomato, CheeseBlock만 존재합니다. Bread와, Cabbage를 추가하고 이것들을 담는 Prefab들을 유니티에만 들게요.각각 KitchenObjectSO와, KitchenObject, ContainerPrefab을 만들고 씬에 배치하면 끝!<img src="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/20.-player-pick-up-&amp;-drop-object.html</link><guid isPermaLink="false">Unity/20. Player Pick Up &amp; Drop Object.md</guid><pubDate>Tue, 31 Dec 2024 05:54:14 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[19. Container Counter와 상속]]></title><description><![CDATA[이번에는 물건을 꺼내오는 Container Counter를 구현할 거예요.이 게임에는 다양한 종류의 Counter가 존재합니다. 그래서 BaseCounter를 만들고 구체적인 카운터가 Base를 상속받게 하는 것이 좋습니다.프리팹도 베이스를 만들어 놓으면 프리팹을 정말 빠르게 만들 수 있습니다. 그래서 프리팹부터 만들어보도록 하겠습니다._BaseCounter로 이름 짓고 프리팹을 열어 CounterTopPoint를 넣어줍니다.<img src="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">_BaseCounter을 이용해서 ClearCounter 프리팹을 만들어볼게요.우클릭하고 Prefab Variant를 클릭합시다.<br><img src="https://blog.kakaocdn.net/dn/bjcUyF/btsqZvNH1vT/kKOpjwB2mkbPMhWrqC1pUK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러고나서 기존의 ClearCounter에 들어있는 Selected, ClearCounter_Visual을 복붙하고 스크립트를 잘 넣으면 됩니다.기존의 ClearCounter는 지워주면 되겠죠?<br><img src="https://blog.kakaocdn.net/dn/bMMeIK/btsqYP0df5o/et5dTWLLgxjIwzdMF1F2Bk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 _BaseCounter를 이용해서 ContainerCounter 프리팹을 만들게요.프리팹을 만들 때 설정해줘야 하는 건 다음과 같아요.
Visual Prefab(Asset) 끌당하기
복사해서 Selected 만들기
선택되었을 때, 하위 MeshRender 설정하기
Rendering 버그가 안 나게 선택되었을 때, Scale 전체 1.01로 수정하기
SelectedCounter에 스크립트 넣어주기
다 적용하면 아래처럼 사진처럼 됩니다.<br><img src="https://blog.kakaocdn.net/dn/dfUG6B/btsqXSQNHDr/d8M2SSux89DATZXuCm9KZK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 ContainerCounter 스크립트를 만든 다음 어태치 하고 코드를 작성할게요.public class ContainerCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool hasKitchenObject() { return kitchenObject != null; }
}
시리얼라이즈드필드 변수를 썼으니 어떻게 해야 된다? 유니티에서 레퍼런스를 추가해야 한다!&nbsp;추가 ㄱㄱ<br><img src="https://blog.kakaocdn.net/dn/biz7BP/btsqYZolSGD/qL5RsQqPyqQej5xaKm1AKK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 BaseCounter 스크립트를 만들어서 구체적인 Counter들의 부모로 사용할 거예요.public class BaseCounter : MonoBehaviour { public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); }
} 그런 다음에 Player.cs에서 ClearCounter를 BaseCounter로 변경
Container의 SelectedCounter를 설정해 볼까요. 현재는 SelectedCounterVisual이 시리얼라이즈 필드로 ClearCounter를 가지고 있는데 BaseCounter로 변경하고 그리고 GameObject는 Array로 바꿉시다.public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private BaseCounter baseCounter; [SerializeField] private GameObject[] visualGameObjectArray; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == baseCounter) { Show(); } else { Hide(); } } private void Show() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(true); } } private void Hide() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(false); } }
}
시리얼라이즈드 필드를 바꿨으니 각각 프리팹의 Selected로 가서 레퍼런스를 다시 넣어줍시다.<br><img src="https://blog.kakaocdn.net/dn/bDYQ2I/btsqZgwz8EM/N0rgbcuxLhfrPAlFeWOu61/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/dWVoRR/btsqYpOi57P/vrQg3yTGe27xekzOSR59bK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드 겹치는 부분인 IKitchenObjectParent도 Base로 뺄게요.public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
public class ContainerCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); }
}
public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { }
}
상속을 하니까 코드 라인이 눈에 띄게 줄어들었네요.이제 ContainerCounter에 Animation을 넣어볼게요. Animator를 이용하면 되겠죠?먼저 ContainerCounter에서 인터렉트가 발생했을 때 ContainerCounterVisual에 이벤트를 넘겨주게 코드를 작성합시다.public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); }
}
CountainerCounterVisual 스크립트를 생성하고 이벤트를 리스닝하는 코드를 작성하면 됩니다.public class CountainerCounterVisual : MonoBehaviour { [SerializeField] private ContainerCounter containerCounter; private Animator animator; private const string OPEN_CLOSE = "OpenClose"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { containerCounter.OnPlayerGrabbedObject += ContainerCounter_OnPlayerGrabbedObject; } private void ContainerCounter_OnPlayerGrabbedObject(object sedner, System.EventArgs e) { animator.SetTrigger(OPEN_CLOSE); } }
시리얼라이즈드 필드를 사용했으니 아래처럼 CotainerCounter_Visual에 레퍼런스를 넣고 구현을 마무리하면 되겠습니다! 끝<br><img src="https://blog.kakaocdn.net/dn/xiUU3/btsqYUHgX9Z/AKB4OKNI7LX6LecrI2CqgK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/19.-container-counter와-상속.html</link><guid isPermaLink="false">Unity/19. Container Counter와 상속.md</guid><pubDate>Tue, 31 Dec 2024 05:53:57 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[18. Player Pick up, CSharp Interfaces]]></title><description><![CDATA[카운터들이 키친 오브젝트를 가지고 있는 경우도 있지만, 플레이어가 키친 오브젝트를 가지고 있는 경우도 있겠죠? 이를 Interface를 이용해서 리팩토링 하면 됩니다!인터페이스 스크립트를 만들게요.public interface IKitchenObjectParent { public Transform GetKitchenObjectFollowTransform(); public KitchenObject GetKitchenObject(); public void SetKitchenObject(KitchenObject kitchenObject); public void ClearKitchenObject(); public bool HasKitchenObject(); }
이렇게 만들면, KitchenObject가 ClearCounter를 가지고 있는 것 아니라 IKitchenObjectParent를 프로퍼티로 가지게 합니다. 수정을 해볼까요?public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError("IKitchenObjectParent already has kitchen object"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }
}
부모가 될 수 있는 ClearCounter로 가서 IKitchenObjectParent를 컨펌할게요. 그리고 인터렉트를 할 때, Clear Counter가 들고 있는 Kitchen Object의 부모를 Player로 바꿔줘야 하기 때문에 Interact의 파라미터에 Player가 필요해요.&nbsp;public class ClearCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
Player도 IKitchenObjectParent를 컨펌합시다! 아직 플레이어는 ClearCounter가 가지고 있는 counterTopPoint (물건을 놓는 위치) 같은 것이 없어요. 이것을 SerializedField로 Transform kitchenObjectHoldPoint로 이름 짓고 Player 하위에 빈 객체를 하나 만들고 아래처럼 위치를 잡아줄게요. 그리고 Player Scirpt의 kitchenObjectHoldPoint에 레퍼런스로 넣어주면 되겠죠?<img src="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public class Player : MonoBehaviour, IKitchenObjectParent { public static Player Instance { get; set; } public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } private bool isWalking; private Vector3 lastInteractDir; private ClearCounter selectedCounter; private KitchenObject kitchenObject; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; [SerializeField] private LayerMask counterLayerMask; [SerializeField] private Transform kitchenObjectHoldPoint; private void Awake() { if (Instance != null) { Debug.LogError("Player가 한명보다 많습니다."); } Instance = this; } private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { if (selectedCounter != null) { selectedCounter.Interact(this); } } private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; // 회전을 부드럽게 하는 lerp, slerp transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return kitchenObjectHoldPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; } }
Interface를 이용한 리팩토링을 완료했어요. 이제 플레이어가 카운터에 있는 키친 오브젝트를 들 수 있게 되었습니다.]]></description><link>unity/18.-player-pick-up,-csharp-interfaces.html</link><guid isPermaLink="false">Unity/18. Player Pick up, CSharp Interfaces.md</guid><pubDate>Tue, 31 Dec 2024 05:53:02 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[13. Clear Counter - RayCast로 객체와 인터렉트하기]]></title><description><![CDATA[Empty Object(ClearCounter)를 생성하고 Prefab Asset(ClearCounter_Visual)을 만든 오브젝트에 끌어당겨 넣습니다.비주얼과 로직을 분리해야 하기 때문에 ClearCounter에 로직을 넣고 _Visual에는 UI 관련된 것을 넣습니다.따라서 ClearCounter에 ClearCounter.cs를 추가하고 Box Colider를 설정하고 크기는 Visual과 맞춥니다.그런 다음에 Player.cs를 작성할 것입니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class Player : MonoBehaviour { private bool isWalking; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float interactDistance = 2f; if (Physics.Raycast(transform.position, moveDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log("-"); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); }
}
Parameter에 out이 들어가는 경우는 일종의 콜백으로 생각하면 될 것 같습니다.위의 코드를 실행하면, 멈춰있을 때 이벤트가 발생하지 않아 인터렉션을 할 수가 없는 이슈가 있습니다. 그 이유는 HandleInteractions()에서 멈춰있을 때 moveDir이 0이기 때문입니다. 이것을 클래스 프로퍼티로 가지고 있으면 이슈를 해결할 수 있습니다.
// Player.cs // 클래스 프로퍼티로 가지고 있기
private Vector3 lastInteractDir; // ... /// private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log("-"); } }
그리고 만든 Object Instance를 다음에 다른 인스턴스를 빠르게 생성하기 위해서 파일창으로 드래그 앤 드롭을 해서 Object Prefab으로 만듭니다.<img src="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Interact를 하기 위해서는 플레이어가 객체를 Identifying 할 수 있어야 합니다. 이때 유니티에서 제공하는 tag를 사용할 수 있으나, 코드에서 컴포넌트를 얻어서 처리하는 것이 더욱 효과적인 방법인 것 같습니다. Try-를 이용하면 null 체크까지 진행할 수 있습니다. 이제 HandleInteractions()을 수정하겠습니다.// Player.cs // ... // private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }
RayCast를 사용할 때 매개변수에 layerMask를 쓸 수 있습니다. 이것을 설정하면 Player의 rayCast가 반응하는 Layer들을 설정할 수 있게 됩니다.&nbsp; Counter layer를 Counters라고 만들고 Counter의 Layer를 Counters로 설정하겠습니다.<br><img src="https://blog.kakaocdn.net/dn/XC2Hp/btso8z4Fejb/nHJTV998t8IKb312TzGJQ0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/ct99it/btso09muO2Z/GdpNRfT1HIXmhhynng9EUk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그런 다음에 Player.cs에서 SerializeField를 설정합시다.// Player.cs [SerializeField] private LayerMask counterLayerMask;
그러고나서 유니티로 돌아와 Player 인스턴스를 클릭하고 Inspector에서 SerializeField를 설정하면 끝입니다.<br><img src="https://blog.kakaocdn.net/dn/RaakV/btso12gk3LK/UQmJClmkttamek63c4N8F0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 Player는 아래처럼 Layer가 Counters로 설정된 오브젝트에만 인터렉트를 하게 됩니다!<br><img src="https://blog.kakaocdn.net/dn/D96LV/btso7R5xiII/WZahA3bPsoVxmdF6R2L0K1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html</link><guid isPermaLink="false">Unity/13. Clear Counter - RayCast로 객체와 인터렉트하기.md</guid><pubDate>Tue, 31 Dec 2024 05:52:25 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[14. Interact Action Events]]></title><description><![CDATA[Player가 Object에 갔을 때 Interact를 하는 것을 개발하겠습니다.&nbsp;Input System 열어서 Actions에 Interact를 생성하고 'E'를 바인딩합시다.<img src="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이벤트의 흐름은 아래와 같아요.
GameInput -&gt; Player -&gt; ClearCounter
먼저 GameInput.cs를 열어 코드를 작성해 볼까요? 어떻게 구현하면 될까요?Input System에서 Interact가 발생했을 때 알아채기 위해서 우리는 이 이벤트를 리스닝하고 있어야 합니다. 그러고 나서 이 이벤트가 발생했다는 사실을&nbsp; Player에게 보내야 해요. 따라서 EventHandler를 프로퍼티로 가지고 있어야 하고, Input System에서 오는 Interact를 리스닝하고 액션이 들어왔을 때 EventHandler를 통해 이벤트를 보내주는 함수를 구현하면 됩니다.&nbsp;public class GameInput : MonoBehaviour { // Event를 넘겨주는 객체 public EventHandler OnInteractAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Listening playerInputActions.Player.Interact.performed += Interact_performed; } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { //OnInteractAction이 Null일 수 있기 때문에 Invoke를 사용한다. OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }
}
Player.cs에서 OnInteractAction을 리스닝하면 됩니다.// Player.cs // GameInput.cs에서 발생하는 OnInteractAction을 리스닝 하기 private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }
유니티에서 이런 비동기 처리는 Event라는 것을 처리하는 것 같습니다. Swift는 클로저를 통해 제어권을 넘겨주는 방식이랑 상당히 유사한 것 같네요. 끝!]]></description><link>unity/14.-interact-action-events.html</link><guid isPermaLink="false">Unity/14. Interact Action Events.md</guid><pubDate>Tue, 31 Dec 2024 05:52:16 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[15. Selected Counter Visual & Singleton Pattern]]></title><description><![CDATA[이번에는 오브젝트에 다가갈 때 UI를 업데이트하는 것을 구현했어요. UI 로직과 게임 로직은 분리하는 게 좋아요.SelectedCounterVisual 스크립트를 생성하고 공통적으로 적용해야 하기 때문에 ClearCounter Prefab을 열어줍니다. 그리고 ClearCounter_Visual을 복사해서 Selected로 이름을 바꿉시다. 그런 다음 Inspector에서 세 가지 과정을 완료하면 되어요.
CounterSelected로 Meterial 변경 (Selected 하위에 있는 컴포넌트들)
사이즈 변경 (사이즈가 같으면 발생하는 렌더링 버그가 있음)
SelectedCounterVisual 넣기
<img src="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/dNulJo/btspE3SQKsU/H3PrGoAKCMIhBuYF9d6Tgk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/XdXso/btspNP0efBe/UfjgVYsPfcUiLcY4MY1QCK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 코드를 작성하고, SerializeField를 만들어서 레퍼런스를 넣어줍시다!흐름은 Player가 Object에 다가간다. -&gt; Selected Counter Visual을 업데이트해준다. 그러면 Player.cs에 다음과 같은 코드를 작성하면 되어요. 그리고 아직은 1인용 게임이기 때문에 Player는 인스턴스는 무조건 하나일 수밖에 없어서 싱글톤으로 만들면 됩니다.// Player.cs
public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } // Single 톤으로 만들어야하니까 public static Player Instance { get; private set; } private void Awake() { if (Instance != null) { Debug.LogError("Player가 한명보다 많습니다."); } Instance = this; } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // 수정
private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } }
이제 Visual을 업데이트를 하는 코드를 작성합시다!// SelectedCounterVisual.cs public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private ClearCounter clearCounter; [SerializeField] private GameObject visualGameObject; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == clearCounter) { Show(); } else { Hide(); } } private void Show() { gameObject.SetActive(true); } private void Hide() { gameObject.SetActive(false); }
}
이때 좀 주의할 점이 있는데 이벤트 등록을 Start()에서 하는 것입니다. Awake()에서 등록을 하게 되면 에러가 발생할 수 있습니다.왜냐하면 Player.cs에서 Instance를 Awake()에서 만들기 때문에 순서가 보장되지 않을 수 있기 때문입니다.따라서! 반드시 Start()에서 이벤트 등록을 해줍시다.이제 다시 유니티로 돌아가 [SerializeField]에 알맞는 레퍼런스를 넣어줄까요?<br><img src="https://blog.kakaocdn.net/dn/cveG34/btspOyYfvgw/91xl8AZvUZ4XgWtzWGXch0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bfZ78Q/btspCnqqB3Z/sYY06RxUirfT2CRaSdoMQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/d2OVRZ/btspGLxv4Oz/1AVqaYIqCEan1owh9eTlt1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bUh0Ao/btspRinhPFO/4mvrstPKOfYh7zouWBcz10/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/lF40S/btspFM4lwGY/uYgrQlWSSg8EzynxPNt201/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/15.-selected-counter-visual-&amp;-singleton-pattern.html</link><guid isPermaLink="false">Unity/15. Selected Counter Visual &amp; Singleton Pattern.md</guid><pubDate>Tue, 31 Dec 2024 05:52:04 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[16. Kitchen Object, Scriptable Object]]></title><description><![CDATA[Clear Counter에는 음식을 올려놓을 수 있어요. Clear Counter에 객체를 올려놓는 것을 개발하겠습니다.먼저 올려놓을 객체들을 Prefab으로 만듭니다. KitchenObjects 폴더에 만들어줄게요. 그런 다음에, ClearCounter 스크립트를 열고다음 코드를 작성합니다.public class ClearCounter : MonoBehaviour { [SerializeField] private Transform tomatoPrefab; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform tomatoTransform = Instantiate(tomatoPrefab, counterTopPoint); tomatoTransform.localPosition = Vector3.zero; }
}
Interact()가 호출되면 Log를 띄우고 토마토를 Clear Counter 위에 올려놓을 거예요. 이제 유니티로 돌아가서 설정한 SerializeField에 레퍼런스를 넣겠습니다.<img src="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 인터렉트를 하게 되면 토마토가 슉하고 올라갈 거예요. 근데 Clear Counter 위에는 토마토도 올라갈 수 있지만 다양한 것들도 올라갈 수 있어요. 그래서 이것을 Scriptable Object로 감싸고, 안에 멤버 변수로 Prefab을 가지고 있다면 코드를 공통화할 수 있어요.Scriptable Object를 만듭시다.[CreateAssetMenu()]
public class KitchenObjectSO : ScriptableObject { public Transform prefab; public Sprite sprite; public string objectName;
}
유니티로 돌아가서 확인해 보면 Create Kitchen Object SO라는 것이 생겼을 거예요. Tomato와, CheeseBlock을 만듭니다.<br><img src="https://blog.kakaocdn.net/dn/Bgna7/btspCllNj6o/lrnpl70tqht3IeX3Ev4Ptk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">ClearCounter.cs를 수정해 볼까요?public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; }
}
이렇게 하면 끝입니다.근데 kitchenObjectTransform에서 해당하는 KitchenObjectSO를 얻을 수 있을까요? 바로 얻을 수 없습니다. 이것 역시 스크립트를 이용해야 하는데 Scriptable Object에는 Script를 드래그 앤 드롭할 수 없습니다. 그래서 KitchenObject 스크립트를 만들어서 Prefab에 넣어야 합니다. 뭔가 쓰고 보니 말이 좀 헷갈리네요.<br><img src="https://blog.kakaocdn.net/dn/pp8fj/btspRh2ZVw7/OflwT6hlZfzIauDyiRsKDK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; }
}
즉 여러 KitchenObject&nbsp;(Tomato, Cheese etc..)를&nbsp;사용하는 곳 일종의 Type Erasing을 하는 곳에서는 Scriptable Object를 사용해서 관리하고 유니티에서 프리팹으로 KitchenObject에 Scriptable Object 레퍼런스를 넣어주면 되겠습니다.public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; // KitchenObject로 Scriptable Object를 얻을 수 있음! Debug.Log(kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().GetKitchenObjectSO().objectName); }
}
]]></description><link>unity/16.-kitchen-object,-scriptable-object.html</link><guid isPermaLink="false">Unity/16. Kitchen Object, Scriptable Object.md</guid><pubDate>Tue, 31 Dec 2024 05:51:53 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[17. Kitchen Object Parent]]></title><description><![CDATA[플레이어나 Counter들은 Kitchen Object를 가지고 있을 수 있어요.(플레이어는 Kitchen Object를 들 수 있고, Counter는 위에 Kitchen Object를 올릴 수 있습니다.) 이것을 Parent라고 할게요. 나중에 Interface를 이용해서 바꾸겠지만 지금은 Kitchen Object의 부모는 Clear Counter라고 가정하고 코드를 작성할게요.플레이어가 키친 오브젝트를 들고 있고 ClearCounter에 가서 ClearCounter의 Interact() 코드를 호출할 거예요. 이때 Clear Counter가 자식을 가지고 있으면 (즉 키친 오브젝트가 올려져 있으면) 아무것도 처리하지 않고, 자식을 가지고 있지 않으면 Kitchen Object를 자식으로 만들면 되겠네요.그리고 KitchenObject에서 부모를&nbsp; SetClearCounter로 설정하면 되어요. 그리고 키친오브젝트의 부모를 Set할 때 부모의 UI를 업데이트를 하면 됩니다. 비주얼 업데이틀 어떻게 하면 될까요? 부모의 Top인 CounterTopPoint에 올려놓으면 됩니다. 그리고 여기에서 부모의 메서드인 SetKitchenObject를 해주면 될 거예요. (부모의 자식은 나다.)public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; private void Update() { } public void Interact() { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetClearCounter(this); } else { Debug.Log(kitchenObject.GetClearCounter()); } } public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
이제 KitchenObject로 가서 SetClearCounter()를 구현합시다.public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private ClearCounter clearCounter; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public ClearCounter GetClearCounter() { return clearCounter; } public void SetClearCounter(ClearCounter clearCounter) { if (this.clearCounter != null) { this.clearCounter.ClearKitchenObject(); } this.clearCounter = clearCounter; if (clearCounter.hasKitchenObject()) { Debug.LogError("clear counter already has kitchen object"); } clearCounter.SetKitchenObject(this); transform.parent = clearCounter.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }
}
]]></description><link>unity/17.-kitchen-object-parent.html</link><guid isPermaLink="false">Unity/17. Kitchen Object Parent.md</guid><pubDate>Tue, 31 Dec 2024 05:51:36 GMT</pubDate></item><item><title><![CDATA[캐릭터 움직임과 Time.deltaTime]]></title><description><![CDATA[이번에는 유니티를 이용해 WASD로 움직이는 캐릭터를 만들어봅시다.Unity Project 3D URP로 생성해요.<img src="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">공허한 화면을 뒤로한 채 Hierarchy에서 오른쪽 클릭 후 3D Object -&gt; Plane을 눌러서 생성합시다. 이름을 Floor로 해줄게요그런 다음에, Inspector 창에서, Scale을 5, 5, 5로 Position과 Rotation을 0, 0, 0으로 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/bgttrZ/btsn6GSp3Nd/jRc4YxJMqApLlhmuq8I6O0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하이어러키 창에서 메인 카메라를 클릭한 다음 인스펙터창에서 Position, Rotation, Scale을 아래처럼 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/AjHWa/btsn9Tizkle/7XvsKtRoy95S7IjBmF8cd1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하이어러키 창에서 Create Empty를 만들고 이름을 Player로 합시다. 그리고 만든 Player 하위에 3D Object - Capsule을 생성합니다. 이렇게 하는 이유는 뷰 로직과 동작 로직을 분리하기 위해서예요.Player 오브젝트의 Position과 Rotation은 0,0,0 Scale은 1,1,1으로 설정하고 PlayerVisual(하위에 만든 캡슐)은 Postion (0,1,0) Rotation은 0,0,0, Scale은 1,1,1로 설정해 주세요.<br><img src="https://blog.kakaocdn.net/dn/RqMrq/btsn8pI3tFB/SnaoJYXV9i7IINUlK9jrO1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/cBgb5p/btsn7trHo5k/ibnoMMkaaZStsV2b9Jpaek/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Project 창에서 Asset 폴더 아래에 Script 폴더를 만들고 그곳에 C# Script를 만들고 파일을 Player 오브젝트에 드래그 앤 드롭합니다.그런 다음에 Asset - Open C# Project를 클릭합니다.<br><img src="https://blog.kakaocdn.net/dn/TaZwr/btsn8pI31yr/M7jSrnckR44FD7Tkg4yU70/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class Player : MonoBehaviour { [SerializeField] private float moveSpeed = 7f; private void Update() { Vector2 inputVector = new Vector2(0, 0); if (Input.GetKey(KeyCode.W)) { inputVector.y += 1; } if (Input.GetKey(KeyCode.A)) { inputVector.x -= 1; } if (Input.GetKey(KeyCode.S)) { inputVector.y -= 1; } if (Input.GetKey(KeyCode.D)) { inputVector.x += 1; } inputVector = inputVector.normalized; Vector3 moveDir = new Vector3(inputVector.x, 0, inputVector.y); transform.position += moveDir * moveSpeed * Time.deltaTime; }
}
좌표 시스템이 평소 학교에서 배웠던 거랑 일치하지 않을 수 있어요. 그리고 게임 엔진마다 축이 조금씩 상이하더라고요.&nbsp; 제가 공부할 때는 Right Handed를 많이 사용했는데, 유니티는 Left Handed라고 합니다. 아래 그림 참고 하시면 될 것 같아요.<br><img src="https://blog.kakaocdn.net/dn/TIRvR/btsn8lfDOKD/RL0AI3d1kyNgGDFcfsrZSk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드 자체는 별 게 없는 것 같아요. 조금 특징적인 것에 대해서만 알면 될 것 같습니다.inputVector = inputVector.normalized;
왜 inputVector를 정규화를 할까요? 왜냐하면, Vector는 속력이 아닌 속도를 나타내기 때문입니다. 만약 정규화를 하지 않았을 때, 대각선으로 이동한다면 inputVector의 값은 (1,1)이 될 거예요. 그러면 벡터의 길이 (스칼라) 값은 1.414...이 되기 때문에 대각선으로 이동할 때 더 빠른 속도로 이동하게 됩니다. 즉 동일한 속도가 보장이 되지 않게 됩니다. 이러한 이유로 정규화를 통해서 방향만을 얻고, 이동 속도는 변수로 곱해서 처리하는 것이 일반적인 것 같습니다.transform.position += moveDir * moveSpeed * Time.deltaTime;
위 코드에서 속력과 방향에 Time.deltaTime를 곱하고 있습니다. 왜 그럴까요? 이것을 알기 위해서는 Frame(프레임)과 FPS에 대해 먼저 알아야 합니다.동영상은 정지된 여러 장의 사진으로 구성되어 있고, 우리는 이 사진이 빠르게 변하는 것을 움직이는 것으로 보게 됩니다. 여기에서 이 정지된 사진을 프레임이라고 합니다. FPS는 Frame Per seconds의 준말로 1초당 몇 장의 사진이 변하는가입니다. 60 FPS면 1초당 연속하는 60장의 사진을 보는 것이라고 이해하면 될 것 같아요. 그래서 FPS는 성능에 비례합니다. (고사양 컴퓨터면 더 높고, 더 낮은 사양이면 더 낮습니다.)유니티에서 Update() 메서드는 1 프레임을 주기로 호출됩니다. 만약 위의 코드에서 Time.deltaTime이 없다면, 어떻게 될까요? 고사양의 컴퓨터를 가진 사람은 더 빨리 이동할 것입니다. 저사양의 컴퓨터를 가진 사람은 더 느리게 이동할 테고요. 이러한 차이를 보정하기 위해서 바로 Time.deltaTime을 곱하는 것입니다.&nbsp;유니티에서 Time.deltaTime의 정의는&nbsp;The interval in seconds from the last frame to the current one입니다.&nbsp;즉 현재 프레임과 이전 프레임의 시간 간격을 의미하게 되는 거예요. 따라서 고사양의 컴퓨터는 deltaTime의 값은 작을 테고, 저사양의 컴퓨터의 값은 더 높게 됩니다.&nbsp;고사양 컴퓨터는 60 fps가 나오고, 저사양의 게임은 30fps가 나온다고 가정하면, 아래와 같이 1 프레임당 시간 간격, 즉 deltaTime을 구할 수 있습니다.30fps = 1 / 30 = 0.03333333360fps = 1 / 60 = 0.01666666이때 Update 코드를 생각해봅시다. Update 코드는 1 프레임에 한번 호출된다고 했으니까,&nbsp;저사양 컴퓨터: (moveDir moveSpeed 0.3333333) * 30 만큼 이동 (30프레임)고사양 컴퓨터: (moveDir moveSpeed 0.016666666) * 60 만큼 이동 (60프레임)의 값은 같게 됩니다.그래서, Time.deltaTime로 컴퓨터 사양에 따른 이동을 보정할 수 있게 됩니다.캐릭터 이동을 구현할 때, GetKey를 이용해 구현하는 것보다, Input System이라는 package를 이용해서 구현하는 것이 확장하기 더 좋아요. 절대 Input System Package를 이용하세요!<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/Ex_Collision_Detection" target="_self">https://github.com/psychehose/Ex_Collision_Detection</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/destiny9720/221411002215?view=img_1" target="_self">https://m.blog.naver.com/destiny9720/221411002215?view=img_1</a>&nbsp;<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization" target="_self">https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://windeva.tistory.com/840" target="_self">https://windeva.tistory.com/840</a>]]></description><link>unity/캐릭터-움직임과-time.deltatime.html</link><guid isPermaLink="false">Unity/캐릭터 움직임과 Time.deltaTime.md</guid><pubDate>Tue, 31 Dec 2024 05:49:28 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Glow Effect 만들기]]></title><description><![CDATA[게임을 만들어보고 싶어서, 요즘 유니티를 공부하고 있어요.게임을 하다 보면 반짝거리는 물체들이 많이 있는데, 이 반짝거리는 효과를 어떻게 만드는지 공부해 보고 정리해 봤습니다.&nbsp;Glow Effect를 만들기 위해서 4가지가 성립해야 합니다.
Shader - Emission에서 Color가 검은색이 아니고, Intensity &gt; 0 이어야 합니다.
Post Processing Bloom (Intensity와 Threshold 세팅)
Render Pipeline Asset에서 HDR 체크
Camera에서 Rendering - Post Processing 체크
먼저 3D Object 구를 만든 다음에 이 구에 적용한 Material을 만듭시다.<img src="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/digjIe/btsnTEeToHv/SEV8Xa8MbugddHdz7EcIT0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">만든 Material을 구에 드래그 앤 드랍 해줍시다. 구 오브젝트를 선택하고 오른쪽 Inspector에서 Surface Inputs - Emission을 체크하고 색깔(검은색 X)을 지정하고 intensity를 0보다 높게 설정하면 1번 과정은 끝입니다. 그러면 구에 색깔이 있을 거예요.intensity를 엄청 높여도 Render Pipeline Asset이 HDR 옵션이 해제되어 있다면 Glow Effect는 나타나지 않을 거예요. 만약 나타난다면 HDR 옵션이 체크되어 있는 겁니다.<br><img src="https://blog.kakaocdn.net/dn/rYlDe/btsnTDfYB5N/KTQwg2cdfH6vEaKk9GTnR0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 Post Processing 옵션을 가지고 있는 Object를 만들 거예요. Create Empty 하고 이름을 변경합시다. 그런 다음에 아래처럼 Add Componet를 눌러서 Volume을 추가합시다.<br><img src="https://blog.kakaocdn.net/dn/cAcJUG/btsnSXFAZ5U/Uirq8dXFSglHSBkO8vArnK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/ME19w/btsnFK8UrKr/uTAOWh6GYcHtVmySaBjv61/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/EykhQ/btsnEXAV6i8/qMLIiOvafOxKXXFoe67ye1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Volume에서 Profile 칸이 아마 비워져 있을 텐데, New를 클릭해서 새로 생성한 뒤에, Add Override를 눌러서 Post Processing - Bloom을 클릭합니다. 그리고 Threshold를 설정하고 Intensity를 설정하면 됩니다. 이때 Threshold는 최솟값이에요. Intensity보다 작아야 작동합니다. Intensity는 Glow Effect의 강함입니다. 저는 Intensity를 1로 설정하겠습니다. 아직도 역시 효과가 없을 거예요!이제 URP에서 HDR 옵션을 체크해 주면 Glow Effect가 적용됩니다.<br><img src="https://blog.kakaocdn.net/dn/yWAiA/btsnF6Ya6uR/KmEDRHvcznviMUYwbWb2fK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">근데 한 가지 문제점이 있는데 씬 뷰에서는 적용되는데 게임 뷰에서 적용이 안될 수도 있습니다. (아래사진 왼쪽). Camera를 클릭해서 Rendering - Post Processing을 체크하면 게임 뷰에서도 적용(아래사진 오른쪽)됩니다.<br><img src="https://blog.kakaocdn.net/dn/bFAcJS/btsnLvJE7ic/KLNSIRJlE4hBxymlgALJVK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/bg7pfi/btsnHRsEeVi/k0CzMQSMCyd2nV873aYKqK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">단순 Glow Effect 뿐만 아니라 더 다양한 Effect를 적용하고 싶을 때 (예를 들면 캐릭터를 클릭했을 때 외곽선 하이라이팅 하고 싶은 경우)는 Unity에서 제공하는 Shader Graph를 사용하면 된다고 하네요. 다음에 기회가 되면 다뤄보도록 하겠습니다~<br>&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=bkPe1hxOmbI" target="_self">https://www.youtube.com/watch?v=bkPe1hxOmbI</a>]]></description><link>unity/glow-effect-만들기.html</link><guid isPermaLink="false">Unity/Glow Effect 만들기.md</guid><pubDate>Tue, 31 Dec 2024 05:48:39 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵)]]></title><description><![CDATA[컬렉션은 내장된 배열과 튜플 타입과는 다르게 힙에 저장됩니다. 이것은 데이터량이 런타임에서 변경될 수 있다는 뜻입니다. 러스트 표준 라이브러리가 제공하는 컬렉션은 다음과 같습니다.
sequence 타입: Vec, VecDeque, LinkedList
map 타입: HashMap, BTreeMap
Sets 타입: HashSet, BTreeSet
Misc 타입: BinaryHeap
그중에서 자주 사용되는 세 가지 컬렉션을 알아보겠습니다.
Vec는 여러 개의 값을 서로 붙어 있게 저장합니다.
String은 문자의 모음입니다.
HashMap은 키-값으로 저장합니다.
let v: Vec&lt;i32&gt; = Vec::new();
벡터는 제네릭을 이용해서 구현되어있습니다. 그래서 어떠한 종류의 값도 저장할 수 있습니다.let v = vec![1,2,3];
let v = Vec::from([1,2,3,4]);
let v = vec![0; 5]; // [0,0,0,0,0]
초기값이 있는 벡터를 생성하는 것은 흔한 일이기 때문에 러스트에서는 vec! 매크로를 제공하고 있습니다. Vec의 static method인 from을 이용해서도 배열을 생성할 수 있습니다. 길이가 n인 배열을 생성하고 0으로 초기화할 수 있습니다.let mut v = Vec:new();
v.push(5);
v.push(6);
v.push(7);
v.pop();
v.pop(); // insert(index, value)
// remove(index)
v.insert(1,4)
v.remove(1) // let mut vec = vec![1, 2, 3];
let mut vec2 = vec![4, 5, 6];
vec.append(&amp;mut vec2);
assert_eq!(vec, [1, 2, 3, 4, 5, 6]);
assert_eq!(vec2, []);
컬렉션 변수에 대해서 그 변수가 담고 있는 값이 변경되게 하려면 mut 키워드를 사용합니다. push &amp; pop을 사용해서 벡터 값을 자료구조 스택처럼 사용할 수 있습니다.특정한 인덱스에 값을 넣고 빼기 위해서는 insert &amp; remove를 사용하면 됩니다. Insert &amp; remove는 인덱스를 직접 사용하기 때문에 인덱스 범위를 넘어가면 패닉을 일으키게 됩니다.배열과 배열의 연산에는 append를 이용합니다. 특이한 점이 append를 하게 되면 추가 하는 항목들이 있는 배열에서 요소들이 사라집니다.let v = vec![1, 2, 3, 4, 5]; let third: i32 = v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
벡터 요소를 읽기 위해서는 []과 get 함수를 이용하는 방법입니다. []를 이용하는 경우 존재하지 않는 요소를 참조하게 되면 패닉을 일으키게 되겠죠?get 함수를 사용하면 벡터 범위를 벗어난 인덱스를 사용하면 퍄닉 없이 None이 반환됩니다.let v = vec![100, 32, 57];
for i in &amp;v { println!("{}", i);
} /// let mut v = vec![100, 32, 57];
for i in &amp;mut v { *i += 50;
}
인덱스를 명시하지 않아도, Swift나 Python처럼 반복문을 돌면서 요소에 접근할 수 있습니다. 요소들을 변경시키길 원한다면 역참조연산자(*)를 사용하면 됩니다.String은 문자들의 모음입니다. 러스트에서 스트링은 세 가지 특징적인 개념을 가집니다.
에러를 꼭 명시해줘야 합니다.
복잡한 데이터 구조를 가지고 있습니다.&nbsp;
UTF-8이라는 점입니다.
let mut s = String::new();
// let data = "initial contents";
let s = data.to_string(); // the method also works on a literal directly:
let s = "initial contents".to_string(); let s = String::from("initial contents");
스트링 생성은 String 타입의 new() 정적 메소드를 이용해서 할 수 있습니다. 그리고 스트링 리터럴(&amp;str)을 생성하고. to_string() 메서드를 이용해서 생성할 수도 있습니다.let mut s = String::from("foo");
s.push_str("bar"); let mut s1 = String::from("foo");
let s2 = "bar"; // 참조자를 사용하기 때문에 소유권을 넘기지 않음.
s1.push_str(&amp;s2);
println!("s2 is {}", s2);
스트링에 스트링을 추가하기 위해서 push_str 메소드를 사용할 수 있습니다.&nbsp; 문자 한 개를 추가하길 원하면 push() 메서드를 사용할 수 있습니다.&nbsp;let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &amp;s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요 연산자를 이용해서 문자열끼리 접합할 수 있습니다. 위의 코드를 보면 let s3 = s1 + &amp;s2; 입니다. s1에는 참조자가 붙지 않고 s2에 참조자가 붙어 있는 것을 볼 수 있는데요. 이것은 스트링에서 + 연산자는 add 메서드를 이용하기 때문입니다.
fn add(self, s: &amp;str) -&gt; String {
add()를 자세하게 보고 s3의 코드를 보면 조금 당황할 수도 있습니다. 왜냐하면, add의 파라미터는 &amp;str 타입인데 &amp;s2의 타입은 &amp;String이기 때문입니다. 하지만 컴파일러는 이를 컴파일 할 수 있습니다. 왜 그럴까요? &amp;String인자는 &amp;str로 강제될 수 있기 때문입니다. 이를 러스트에서는 역참조 강제(deref coercion)라고 합니다.위에서 보듯 +의 동작은 다루기가 불편한 것처럼 보입니다. 어떤 것은 String이고, 붙여지는 건 &amp;str인 것처럼요. 왜냐하면 이는 소유권에 대해서 더 신경을 써야한다는 것을 의미하니까요. 그래서 러스트는 format! 매크로를 제공합니다. 이를 이용하면 어떠한 파라미터의 소유권도 가져오지 않고 보기 쉽게 스트링을 합칠 수 있습니다.&nbsp;let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe"); let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
// let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe"); let s = format!("{}-{}-{}", s1, s2, s3);
let s1 = String::from("hello");
let h = s1[0];
다른 언어처럼 스트링에 인덱스로 접근하고 싶습니다. 위의코드는 컴파일이 될까요? 접근하면 어떻게 될까요? 러스트에서 스트링 인덱스 접근은 지원하지 않습니다. 이것을 이해하기 위해서 스트링이 어떻게 메모리에 저장되는지 확인해봐야 합니다.String은 Vec을 감싼 것입니다.&nbsp;let len = String::from("Hola").len(); // 1 let len = String::from("Здравствуйте").len(); len은 4입니다. 이건 4byte 길이라는 뜻입니다.
len은 24입니다. 글자는 12개지만, 이 문자 각각의 유니코드 스칼라 값이 2입니다. 12* 2 = 24
이 말은 스트링의 바이트들 안의 인덱스는 유니코드 스칼라 값과 항상 대응되지 않는다는 것을 의미합니다.그리고 인덱스 연산은 언제나 상수 시간에 실행될 것으로 기대를 받는데, String으로 그러한 성능을 보장하는 것은 불가능입니다. 왜냐하면 스트링 내에 얼마나 많은 문자가 있는지 알아내기 위해 시작지점부터 인덱스로 지정된 곳까지 살펴봐야 하기 때문입니다.만약 스트링 슬라이스를 만들기 위하고 인덱스를 사용하길 원한다면 구체적으로 지정해야 합니다.let hello = "Здравствуйте"; let s = &amp;hello[0..4]; // Зд
// let s = &amp;hello[0..1]; // 패닉 발생!
반복문을 돌면서 바이트에 관계 없이 유니코드 스칼라 값(글자)에 대한 연산을 하길 원하면 chars를 사용하면 됩니다.for c in "नमस्ते".chars() { println!("{}", c);
} for b in "नमस्ते".bytes() { println!("{}", b);
}
즉 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 확실히 기억해야만 합니다.''use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); // let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50]; let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
추가적으로 튜플의 벡터에 대해 collect 메서드를 사용해서 생성할 수 있습니다collect 메소드는 데이터를 모아서 컬렉션 타입으로 만들어줍니다.let field_name = String::from("Favorite color");
let field_value = String::from("Blue"); let mut map = HashMap::new();
map.insert(field_name, field_value);
insert 할 때, field_name과 field_value의 소유권은 map으로 이동합니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); let team_name = String::from("Blue");
let score = scores.get(&amp;team_name);
..use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); for (key, value) in &amp;scores { println!("{}: {}", key, value);
}
반목문 접근은 다른 컬렉션과 마찬가지로 &amp;를 이용해서 접근할 수 있습니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25); println!("{:?}", scores);
위의 코드는 키에 대한 값이 있어도 덮었어 집니다.&nbsp;만약 키에 할당된 값이 없을 경우에만 삽입하고 싶으면 다음 entry API를 이용하면 됩니다.entry의 리턴 값은 Enum 타입 Entry인데 있는지 없는 지를 반환합니다.Entry의 or_insert 메소드는 해당 키가 존재하는 경우는 Entry 키에 대한 값을 반환하고 아닌 경우에는 새 값을 삽입하고 수정된 Entry에 대한 값을 반환합니다.se std::collections::HashMap; let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10); scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50); println!("{:?}", scores);
이걸로 러스트의 콜렉션 타입 중 가장 자주 쓰이는 Vec, String, HashMap에 대해 알아보았습니다.]]></description><link>rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html</link><guid isPermaLink="false">rust/Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵).md</guid><pubDate>Tue, 31 Dec 2024 05:47:06 GMT</pubDate></item><item><title><![CDATA[비트 다루기]]></title><description><![CDATA[LeetCode에서 Bit Manipulation(231, 191, 190, 136)을 풀면서, 잊어버렸던 내용을 복습하게 되었다.컴퓨터가 정수를 표현하는 방법은 위의 문제와 직접적인 연관은 없습니다. 문제에 대한 코드는 Swift로 작성합니다.
부호비트와 절댓값
1의 보수
2의 보수
최상위 1비트로 부호를 표시한다. 최상위 비트가 0인 경우에 양수, 1인 경우에 음수를 나타낸다.&nbsp;
0000 0000 → +0
0000 0001 → +1
...
0111 1111 → +127 1000 0000 → -0
1000 0001 → -1
…
1111 1111 → -127 이 방법을 사용할 경우에 -0과 +0이 존재하게 된다. 그리고 컴퓨터로 처리할 때 연산이 불편하다. 왜냐하면 8비트를 다룰 때 최상위 비트와 절댓값 부분을 따로 다뤄야 하기 때문이다. 불편함은 1의 보수를 사용하면 해소된다.1의 보수법은 해당 양수의 모든 비트를 반전하여 음수를 표현하는 방법이다. 음수를 NOT 연산으로 표현할 수 있기 때문에 간단하다. 그러나 부호비트와 절댓값을 이용한 방법과 마찬가지로 +0, -0이 존재하게 된다.&nbsp;2의 보수법은 해당 양수의 모든 비트를 반전한&nbsp;1의 보수에 1을 더하여&nbsp;음수를 표현하는 방법이다. 0에 1의 보수를 취하고 1을 더하면, 오버플로가 발생하기 때문에 맨 앞의 값은 버려져서 0이 된다. 즉 2의 보수는 +0과 -0을 가지는 문제점이 발생하지 않는다.231. Power of Twoclass Solution { func isPowerOfTwo(_ n: Int) -&gt; Bool { if n &lt;= 0 { return false } var int32number = Int32(n) var valueCount = int32number.nonzeroBitCount return valueCount == 1 }
}
n이 주어질 때, n이 2의 거듭제곱이면 true 아니면 false이다. 0은 거듭제곱으로 나타낼 수 없고 2의 음수 거듭제곱은 정수가 아니다.값이 2의 거듭제곱이려면, 2진수 표현방식에서 1이 한 번만 있어야 한다.0000 0001 -&gt; 2^00000 0010 -&gt; 2^1&nbsp;0000 0100 -&gt; 2^2191.&nbsp;Number of 1 Bitsclass Solution { func hammingWeight(_ n: Int) -&gt; Int { var unsignedNumber = UInt32(n) return unsignedNumber.nonzeroBitCount }
}
위의 문제와 같다.190. Reverse Bitsclass Solution { func reverseBits(_ n: Int) -&gt; Int { var int32number = UInt32(n) var bitInt32Number = String(int32number, radix: 2) var zerolen = 32 - bitInt32Number.count var zeroArray: [String] = Array(repeating: "0", count: zerolen) var zeros = zeroArray.joined() var bits = zeros + bitInt32Number var newBits = String(bits.reversed()) var result = Int(newBits, radix: 2) return result ?? 0 }
}
입력받은 값을 String으로 변화시킨다. (예를 들면 32bit 이므로 10 -&gt; 0000 0000 0000 0000 0000 0000&nbsp; 0000 1010)Swift에서는 1010만 출력하기 때문에 앞에 0들을 붙여줘야 한다. 그리고 뒤집어 준 후에, Int로 변환시킨다.136.&nbsp;Single Numberclass Solution { func singleNumber(_ nums: [Int]) -&gt; Int { var result = 0 for num in nums { result ^= num } return result }
}
위의 코드를 이해하기 위해서는 XOR 연산을 알고, XOR의 특징을 알아야 한다.
자기 자신과 XOR 연산을 하면 0(False)이다.
XOR 연산은 교환법칙과 결합법칙이 성립한다
XOR은 Exclusive OR 연산이다. 수리 논리학에서 주어진 2개의 명제 가운데 1개만 참일 경우를 판단하는 논리 연산이다. 비트연산에서의 XOR 연산은 비트끼리 연산을 해서 같으면 0(=False), 다르면 1(= True)이다.&nbsp; 예를 들어 10과 12 XOR 연산을 해보자.10 = 1010(b)12 = 1100(b)1010(b)^1100(b) = 0110(b)우리는 어떤 정수 x가 주어질 때, 자기 자신과 XOR 연산을 하게 되면 0이 나온다.XOR 연산은 교환법칙과 결합법칙이 성립한다.<img src="https://blog.kakaocdn.net/dn/Duemc/btsdefZuIKt/KQl30T41JOe2akmKqEBaqK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9" target="_self">https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9</a>]]></description><link>tip/비트-다루기.html</link><guid isPermaLink="false">Tip/비트 다루기.md</guid><pubDate>Tue, 31 Dec 2024 05:46:24 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/Duemc/btsdefZuIKt/KQl30T41JOe2akmKqEBaqK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/Duemc/btsdefZuIKt/KQl30T41JOe2akmKqEBaqK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Rust 기초 - Control, 연습 문제]]></title><description><![CDATA[&nbsp;조건의 상태가 참인지에 따라 어떤 코드의 실행 여부를 결정하거나 조건이 만족되는 동안 반복 수행을 하는 것은 대부분의 프로그래밍 언어의 기초 문법입니다. 대다수의 언어처럼 if, for, while을 러스트에서도 사용합니다.fn main() { let number = 6; if number % 4 == 0 { println!("number is divisible by 4"); } else if number % 3 == 0 { println!("number is divisible by 3"); } else if number % 2 == 0 { println!("number is divisible by 2"); } else { println!("number is not divisible by 4, 3, or 2"); }
}
if 뒤에 오는 코드의 조건은 반드시 boolean 타입이어야 합니다. 러스트에서 많은 else if가 많으면 ‘match’를 이용하길 권합니다. match 키워드는 나중에! 포스팅하겠습니다.또 let 구문을 if, else를 이용해서 사용할 수 있습니다. 만약 다음과 같이 let 구문에서 if 블록을 사용하려면, if 블록과 else 블록은 같은 타입을 반환해야 합니다.fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!("The value of number is: {}", number);
}
아래의 코드는 에러를 발생시킵니다. 이유는 변수가 가질 수 있는 타입이 오직 하나이기 때문이에요. 러스트는 컴파일 시에 변수의 타입이 뭔지 확실하게 정의해야 합니다. 그래야 number가 사용되는 모든 곳에서 유효한지 검증할 수 있으니까요. 즉, number의 타입을 런타임에 정의할 수 없습니다. 이는 컴파일러가 보증할 수 있는 것을 많이 가져가고 복잡해지는 것을 방지하기 위함입니다.fn main() { let condition = true; let number = if condition { 5 } else { "six" }; println!("The value of number is: {}", number);
}
&nbsp;러스트가 제공하는 반복문은 loop, while, for가 있습니다.loop&nbsp;loop는 무한루프를 생성합니다. loop를 탈출하기 위해서는 if break와 같이 탈출 코드를 작성하면 됩니다.fn main() { loop { println!("again!"); }
}
while&nbsp;while은 대다수의 언어에 존재하는 while과 같습니다. 조건이 true인 동안 코드가 실행되고, 그렇지 않으면 루프에서 탈출합니다. while을 사용하게 되면 loop, if, else와 break를 사용할 때 발생하는 {&nbsp; }를 줄일 수 있기 때문에, 더 깔끔해요.&nbsp;for&nbsp;역시 while과 마찬가지로 많이 익숙한 for입니다. for문은 while과 다르게, 조건 검사를 수행하는 코드가 없기 때문에 while보다 더 빠르고 안전합니다. for in 문법을 사용합니다.fn main() { let a = [10, 20, 30, 40, 50]; //	그냥 for element in a { } 도 가능 for element in a.iter() { println!("the value is: {}", element); }
}
for 반복문이 안전하고 간결하기 때문에 러스트에서 가장 보편적으로 사용한다고 하네요. 정확히 몇 번 반복을 해야 하는 경우에도, 기본 라이브러리로 제공하는 Range를 사용합니다. Range는 한 숫자에서 다른 숫자 전까지 모든 숫자를 차례로 생성합니다.fn main() { for number in (1..4).rev() { println!("{}!", number); } println!("LIFTOFF!!!");
}
연습 문제를 한번 풀어보도록 하겠습니다.
화씨와 섭씨를 상호 변환.
n번째 피보나치수열 생성.
크리스마스 캐롤 “The Twelve Days of Christmas”의 가사를 반복문을 활용해 출력.
fn main() { println!("섭씨: {} -&gt; 화씨: {}", 0, c_to_f(0.0)); println!("화씨: {} -&gt; 섭씨: {}", 32.0, f_to_c(32.0)); let n = 7; println!("{}번째 피보나칠 수열의 값 = {}", n, fibo(n)); let string = "The Twelve Days of Christmas"; for c in string.chars() { print!("{}", c); } println!(); for i in string.char_indices() { print!("{}", string.chars().nth(i.0).unwrap()); } println!(); for i in string.char_indices() { print!("{}", i.1); } } fn c_to_f(c: f64) -&gt; f64 { (9.0/5.0) * c + 32.0
} fn f_to_c(f: f64) -&gt; f64 { (f - 32.0) * (5.0/9.0)
} fn fibo(n: i32) -&gt; i32 { if n &lt;= 2 { 1 } else { fibo(n-1) + fibo(n-2) }
} /* 1. 화씨와 섭씨를 상호 변환. -&gt; // 배운것: f64로 타입 맞춰줄 것 f to c -&gt; (x°F − 32) × 5/9 c = (f - 32) (5/9) c to f -&gt; f = (9/5)c + 32 2. n번째 피보나치 수열 생성. 3. 크리스마스 캐롤 “The Twelve Days of Christmas”의 가사를 반복문을 활용해 출력. // 배운것: nth(x), .chars() string 인스턴스 함수
.chars() -&gt; 요소 값
.char_indices() -&gt; index랑 요소
.nth() -&gt; n번째 요소 출력(에러 가능성이 있으므로, unwrap()을 사용하거나, expect를 이용해서 에러 핸들 해야함) */
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/rust_basic_problem" target="_self">https://github.com/psychehose/rust_basic_problem</a>]]></description><link>rust/rust-기초-control,-연습-문제.html</link><guid isPermaLink="false">rust/Rust 기초 - Control, 연습 문제.md</guid><pubDate>Tue, 31 Dec 2024 05:45:17 GMT</pubDate></item><item><title><![CDATA[Rust 기초 - Function]]></title><description><![CDATA[러스트에서 함수 선언은 fn 키워드를 이용합니다.fn main() { another_function(5);
} fn another_function(x: i32) { println!("The value of x is: {}", x);
}
&nbsp;위처럼 같은 파일 내에서, 함수의 위치는 중요하지 않습니다. 역시 다른 언어와 마찬가지로 매개변수를 갖는 형식으로 상수를 전달 인자로 제공합니다. 이때 매개변수의 타입을 꼭 명시해줘야 합니다.&nbsp;다른 함수와 다르게 함수 본문은&nbsp;구문과&nbsp;표현식으로 구성될 수 있어요. 구문은 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행을 합니다.표현식은 결과 값을 산출해 냅니다.&nbsp;표현식은 구문의 부분일 수 있습니다. 함수를 호출하는 것은 표현식, 매크로를 호출하는 것도 표현식, 새로운 범위를 생성하는 데 사용하는 { } 도 표현식입니다.&nbsp;쉽게 생각하면 값을 반환하면 ;을 안붙여야합니다. 뭔가 좀 헷갈립니다. 예를 보고 한번 뜯어볼게요.fn main() { let x = 5; let y = { let x = 3; x + 1 }; // 표현식 // { // let x = 3 // x+1 //	} println!("The value of y is: {}", y); let y = five();
} fn five() -&gt; i32 { 5
}
'let x = 5;' 이 부분이&nbsp;표현식은 구문의 부분이 될 수 있다의 예입니다.&nbsp; 전체적으로 봤을 때 let x = 3은 어떠한 값을 리턴하지 않기 때문에 구문입니다. 그러나, '3'인 부분은 어떠한 값을 반환하기 때문에 표현식입니다. 그래서 전체적으로 봤을 때 ;이 붙어 있어야 합니다. 이제 같은 맥락에서 주석처리한 {&nbsp; } 블록이 왜 표현식인지, 그리고 블록이 끝난 후에 세미콜론을 붙는지 이해할 수 있을 것 같아요.반환값 설정은 five()와 같이 매개변수 오른쪽에 ‘ → i32 ‘ 처럼 작성하면 됩니다. '→(반환타입)'five() 함수를 보면 조금 특징적인 것이 있습니다. 값을 반환할 때, return 키워드가 없습니다. return을 사용해서 함수로부터 값을 일찍 반환 할 수 있지만 대부분의 함수들은 암묵적으로 마지막 값을 반환합니다. 사실 Swift도 return을 생략할 수 있어요. 근데 가독성 때문에 잘 안 하는 것 같은데, 러스트에서는 return을 생략하나 봐요. 다음으로 함수의 반환 값에 ; 세미콜론이 붙지 않습니다. 위에서 언급한 것처럼 5라는 값을 반환하기 때문에 표현식이기 때문이에요. 따라서 ;이 없어야 합니다. 만약 반환값에 ;을 붙이면 아래와 같은 에러를 출력합니다.
error[E0308]: mismatched types
함수 선언에서 i32 값을 반환한다고 했는데, 구문은 값을 반환하지 않기 때문에 ()라는 비어 있는 튜플을 반환하기 때문에&nbsp;mismatched 에러가 발생하게 됩니다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://rinthel.github.io/rust-lang-book-ko/ch03-03-how-functions-work.html" target="_self">https://rinthel.github.io/rust-lang-book-ko/ch03-03-how-functions-work.html</a>]]></description><link>rust/rust-기초-function.html</link><guid isPermaLink="false">rust/Rust 기초 - Function.md</guid><pubDate>Tue, 31 Dec 2024 05:44:52 GMT</pubDate></item><item><title><![CDATA[Rust 기초 - Data Type]]></title><description><![CDATA[true와 false를 다루는 값입니다.fn main() { let t = true; let f: bool = false; // with explicit type annotation
}
&nbsp;char는 string과 다르게 ‘ ‘ 를 사용합니다. 그리고 러스트에서는 Unicode 스칼라를 표현하는 값입니다. Unicode는 ASCII 보다 많은 표현이 가능합니다. 예를 들면 이모티콘, 한글을 표현할 수 있습니다.fn main() { let c = 'z'; let z = 'ℤ'; let heart_eyed_cat = '😻';
}
컴파운드 타입은 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있습니다. Rust는 기본적으로 튜플과 배열이 있습니다.&nbsp;튜플은 일반적으로 다양한 타입의 숫자를 집합시켜서 컴파운드 타입으로 만듭니다. 괄호 안에 콤마로 구분되는 값들의 목록을 작성하면 됩니다. 각 값의 타입이 동일한 필요가 없습니다. 저는 보통 좌표를 표현할 때 사용하는 것 같아요.fn main() { let tup = (500, 6.4, 1); let five_hundred = tup.1 let (x, y, z) = tup; println!("The value of y is: {}", y);
}
위의 코드에서 let (x, y, z) = tup 처럼 값을 분리해서 할당할 수 있습니다. 이를 구조 해체 (destructurize)라고 합니다. 다른 언어들도 많이 가지고 있는 특징입니다. (Swift, JavaScript 등등)또는 let five_hundred = tup.1처럼 tup에서 마침표(.)를 이용해서 튜플의 요소에 직접 접근할 수 있습니다.튜플과 다르게 배열의 모든 요소는 같은 타입이여야 합니다.다른 언어랑 구별되는 특징이 있습니다. Rust에서 배열은 고정된 길이를 가진다는 것입니다. 한번 선언되면 크기는 변할 수 없습니다. c처럼 동적 할당하는 것이 아니라, 아예 길이가 정해져야만 합니다.fn main() { let a = [1, 2, 3, 4, 5]; let index = 3 // let index = 10; let element = a[index]; println!("The value of element is: {}", element);
}
배열의 끝을 넘어선 요소에 접근하려고 하면 컴파일시에 에러를 발생시키진 않지만, 런타임 때 에러가 발생합니다. 이때 런타임에러가 발생하면서 프로그램이 종료될 때 패닉(panic) 한다고 합니다. 그렇기 때문에 배열은 heap 보다 stack에 할당될 때 즉, 고정된 길이를 보장해야 할 때 사용됩니다. 만약 길이가 가변적이라면 표준 라이브러리에서 제공하는 Vector 타입을 사용해야 한다고 합니다.
스칼라 - 하나의 값으로 표현되는 타입 정수형
- u:&nbsp; 양수
- i: 음수, 양수
- isize, usize:&nbsp; 프로그램 동작하는 환경에 따라 64bit, 32bit
- 기본 타입: i32 부동소수점 - 기본타입 f64 boolean 문자 - 유니코드, 작은 따옴표로 표현 컴파운드 튜플 - 집합, 구조 해체 배열 - 고정된 길이 ]]></description><link>rust/rust-기초-data-type.html</link><guid isPermaLink="false">rust/Rust 기초 - Data Type.md</guid><pubDate>Tue, 31 Dec 2024 05:44:26 GMT</pubDate></item><item><title><![CDATA[Rust 기초 - Variable]]></title><description><![CDATA[&nbsp;러스트는 다른 언어와 다르게 기본적으로 Immutable(불변)입니다. 이것은 안전성과 동시성이라는 장점을 얻을 수 있도록 코드를 강제하는 요소 중 하나라고 합니다.&nbsp;fn main() { let x = 5; println!("The value of x is: {}", x); x = 6; println!("The value of x is: {}", x);
}
위처럼 작성하게 되면 immutable variable에 값을 재할당할 수 없다는 에러메시지를 출력합니다.
error[E0384]: re-assignment of immutable variable x
만약 mutable 하게 사용하고 싶으면 ‘mut’ keyword를 사용하면 됩니다.fn main() { let mut x = 5; println!("The value of x is: {}", x); x = 6; println!("The value of x is: {}", x);
}
&nbsp;Rust에서 이런 정책을 채택한 이유는 컴파일러가 변경되지 않은 값에 대해서 보증을 하기 때문에, 버그 예방에 효율적입니다.하지만 mut 키워드를 사용하는 것이 효율적인 경우가 있습니다. 예를 들면 대규모 데이터 구조체를 다루는 경우입니다. 기존의 인스턴스를 변경하는 것이 새로 인스턴스를 만들고 값을 사용하는 것보다 더 효율적이기 때문입니다. trade - off를 잘 고려해서 코드를 작성하면 될 것 같습니다.상수는 mut을 사용하는 것이 허용되지 않고 불변 그 자체입니다. 상수 선언할 때는 타입을 무조건 지정해줘야 합니다.const MAX_POINTS: u32 = 100_000;
&nbsp;러스트는 shadowing을 허용합니다. 같은 이름의 변수를 선언하면 기존의 값은 가려지게 됩니다.fn main() { let x = 5; let x = x + 1; let x = x * 2; println!("The value of x is: {}", x);
}
mut과 차이점은 새 변수를 선언하고, 값의 유형을 변경하면서도 같은 이름을 사용할 수 있다는 것이 장점입니다.let spaces = " ";
let spaces = spaces.len(); // mut 사용시에 이것은 타입을 변경했기 때문에
// 에러를 발생시킵니다. let mut spaces = " ";
spaces = spaces.len();
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://rinthel.github.io/rust-lang-book-ko/ch03-01-variables-and-mutability.html" target="_self">https://rinthel.github.io/rust-lang-book-ko/ch03-01-variables-and-mutability.html</a>]]></description><link>rust/rust-기초-variable.html</link><guid isPermaLink="false">rust/Rust 기초 - Variable.md</guid><pubDate>Tue, 31 Dec 2024 05:44:01 GMT</pubDate></item><item><title><![CDATA[Cargo]]></title><description><![CDATA[Cargo는 러스트 프로젝트에서 아주 중요한 것 같습니다. 러스트를 시작한 지 며칠 안되었기 때문에 Cargo에 대해 아는 게 몇 개 없습니다. 러스트 기본 공부가 끝나는 대로 러스트를 사용해서 작은 사이드 프로젝트를 할 예정입니다. 아마 그때 Cargo에 대해서 공부할 것 같아요. 그때 내용 보충을 더 해서 업데이트하겠습니다.Cargo는&nbsp; 러스트의 빌드 시스템 및 패키지 매니저로 프로젝트를 관리합니다. 좀 더 상세하게 풀어서 이야기하면 Cargo가 코드를 우리가 작성한 코드를 빌드하면서, 코드가 의존하고 있는 라이브러리들도 다운로드하고 빌드합니다. Cargo의 버전확인은 아래 명령어를 터미널에 입력하면 확인할 수 있습니다.$ cargo --version
Cargo의 환경 설정은 Cargo.toml을 확인하면 알 수 있어요.&nbsp;# Cargo.toml [package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name &lt;you@example.com&gt;"] [dependencies]
[package]는 패키지 환경 설정이라는 섹션의 시작지점입니다. 여기에 정보를 추가할 수 있고, 수정할 수 있습니다.[dependency]는 프로젝트의 의존성들의 리스트를 적을 수 있는 섹션의 시작점입니다. 러스트에서는 코드의 패키지를 크레이트(crate)라고 부르는데, 여기에 크레이트를 추가하면 해당 코드를 사용할 수 있게 됩니다.]]></description><link>rust/cargo.html</link><guid isPermaLink="false">rust/Cargo.md</guid><pubDate>Tue, 31 Dec 2024 05:43:42 GMT</pubDate></item><item><title><![CDATA[asdf를 이용한 Rust 설치와 IntelliJ가 Path를 못 찾는 이슈 및 해결]]></title><description><![CDATA[Rust를 공부하기 위해서는 Rust를 설치해야 합니다. 저는 개발도구나, 환경은 asdf를 이용합니다. asdf는 도구 버전 관리자입니다. 플러그인을 통해서 정말 많은 것들을 가상환경으로 구성할 수 있게 도와줘요 python, node, jdk 등 우리가 사용하는 거의 대부분을 지원하고 있습니다. Rust 역시 지원하기 때문에 asdf를 사용해서 설치하도록 하겠습니다.asdf가 더 알고 싶으신 분은 공식 홈페이지를 참고해주세요.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://asdf-vm.com/guide/introduction.html" target="_self">https://asdf-vm.com/guide/introduction.html</a># 러스트 플러그인을 먼저 설치합니다.
$ asdf plugin add rust # 설치 가능한 러스트 버전을 확인합니다.
$ asdf list all rust # 자기에게 알맞은 버전을 설치해주세요.
# 러스트 공홈 release 버전을 확인해서 받으셔도 될 것 같습니다.
# https://www.rust-lang.org/
$ asdf install rust 1.67.1 # 설치된 러스트 버전을 확인합니다.
$ asdf list rust # global 또는 local을 이용해서 환경을 적용합니다.
$ asdf global rust 1.67.1
그러고 나서 버전을 확인합니다.$ rustc --version
$ cargo --version
cargo는 러스트 프로젝트를 관리하는 빌드시스템 및 패키지 매니지입니다. 여기까지 하면 러스트 설치가 끝났습니다.저는 개발을 좀 더 편하게 하기 위해서 IDE를 사용하는데요. IntelliJ를 사용하고 있습니다. IntelliJ에 러스트 플러그인을 설치만 하면 바로 사용할 수 있습니다. (CLion도 같은 방식으로 플러그인을 추가할 수 있습니다.) 그런데, asdf를 사용해서 그런가 IntelliJ가 프로젝트를 생성할 때, rust를 찾지 못하는 것 같아요. 이를 어떻게 해결했는지 쓰겠습니다.&nbsp;1. Plugins에서 Rust 검색 후 다운로드<br><img src="https://blog.kakaocdn.net/dn/l1BXk/btsbQRluIcE/gKu7klUAuMUvwEKUzNyiIk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">&nbsp;2.&nbsp; Toolchain location을 바로 찾을 수 없음.
asdf로 설정한 러스트 경로를 찾지 못해서, 아래 스크린샷 왼쪽처럼, 프로젝트를 만들 수 없습니다. 이 경로를 직접 설정하면 되지 않을까 해서, bin이 있는 곳을 찾아서, 경로를 넣었습니다. 그러면 아래 스크린샷 오른쪽처럼, 정상적으로 작동합니다. 하지만 매번 프로젝트마다, 직접 경로를 찾아서 넣어주는 것은 불편합니다. 이것은 어떻게 해결할 수 있을까요?$ cd ~/.asdf/installs/rust/1.67.1/toolchains/1.67.1-aarch64-apple-darwin/bin
pwd # pwd에 나온 결과를 붙여 넣기
# 예시
#/Users/psychehose/.asdf/installs/rust/1.67.1/toolchains/1.67.1-aarch64-apple-darwin/bin
<br><img src="https://blog.kakaocdn.net/dn/b7tjcf/btsbSK6Uj6N/tk3lzlsDrgkaXmrPl5F0n0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/uvzmo/btsbSfGaREc/vKJt2xgIqDD7eyDMiV0WlK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">&nbsp;3. Tool-chain location 디폴트 설정 바꾸기저는 이것을 asdf-shims와 IntelliJ 기본 설정을 바꿔서 해결했습니다.&nbsp;
(IntelliJ의) Preference -&gt; Languages &amp; Frameworks -&gt; Rust
<br><img src="https://blog.kakaocdn.net/dn/bkUIU0/btsbSgd77OO/oiBzpVLOCvck39evdMPYe0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">&nbsp;그러면 항상 새로운 프로젝트에 들어갔을 때,&nbsp; 기본설정으로 들어가 있게 됩니다. 이제 IntelliJ로 러스트 프로젝트를 시작할 수 있게 되었어요.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/intellij-rust/intellij-rust/issues/5315" target="_self">https://github.com/intellij-rust/intellij-rust/issues/5315</a>]]></description><link>rust/asdf를-이용한-rust-설치와-intellij가-path를-못-찾는-이슈-및-해결.html</link><guid isPermaLink="false">rust/asdf를 이용한 Rust 설치와 IntelliJ가 Path를 못 찾는 이슈 및 해결.md</guid><pubDate>Tue, 31 Dec 2024 05:43:18 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/l1BXk/btsbQRluIcE/gKu7klUAuMUvwEKUzNyiIk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/l1BXk/btsbQRluIcE/gKu7klUAuMUvwEKUzNyiIk/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[단위테스트와 PRODUCT_MODULE_NAME]]></title><description><![CDATA[작년부터 진행했던 사이드 프로젝트가 있습니다. 최근에 버전 2를 만들기 위해서 기획 &amp; 디자이너 친구들이 앱 업데이트 요청을 했어요. 그래서 과거에 짰던 코드를 보면서 Dev 설정으로 애플리케이션을 살펴보고 있었습니다. 근데 카카오톡으로 로그인하기를 눌렀는데 권한요청 alert 떴어요. 여기에 타겟이름이 그대로 있다는 것을 발견했습니다.<img src="https://blog.kakaocdn.net/dn/dpQuzW/btslZ5NKkqr/n9zrpFvuy6sENHXX9QE0UK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 문제를 해결하는 방법은&nbsp;빌드 환경을 단일 타겟과 스킴으로 나누지 않았다면&nbsp;PRODUCT_NAME을 수정하면 됩니다.근데 저희 팀이 작업했던 빌드 환경은 달라서 언급을 먼저 하겠습니다.애플리케이션의&nbsp;Configuration은 Debug(Development), Debug(Staging), Debug(Production), Release(Development), Release(Staging), Release(Production)로 구성되어 있어요.그리고&nbsp;단일 Target에,&nbsp;세가지 Scheme(Dev, Staging, Prod)로 구성되어 있고 xcconfig 파일을 이용해 Build Setting 값을 넣었습니다. xcconfig 파일에서 CFBundleDisplayName를 설정했기 때문에 단일 타겟으로 다른 이름으로 세 가지 앱을 빌드할 수 있었어요. (각각 Hous-, Hous-Dev, Hous-Staging)그래서, 앱을 처음 실행하자마자 나오는 푸시알림 권한요청 팝업, 그리고 애플로 로그인하기 팝업은 CFBundleDisplayName을 CFBundleDisplayName을 바라보기 때문에 해당 값이 잘 뜹니다.<br><img src="https://blog.kakaocdn.net/dn/bhUESq/btsl0jrs0xY/rUbDYOsHMKawDmWPiW8AgK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러나, 카카오톡으로 로그인하기는 CFBundleDisplayName을 바라보는 것이 아니었고, PRODUCT_NAME(=CFBundleName)이 뜨는 상태였습니다. 처음에 이걸 봤을 때, 마음 편하게 Build Setting 값을 확인했고 ProductName = $(TARGET_NAME)이었기 때문에 각 xcconfig에서 TARGET_NAME을 환경에 맞게 수정했었어요. 결과는 성공적이었고 이렇게 해결된 줄 알았습니다.문제는 단위테스트에서 발생했어요. Command + U를 눌렀는데 세상에서 가장 보기 싫은 에러가 떴습니다.<br><img src="https://blog.kakaocdn.net/dn/c8zoME/btsl1WPOda7/0raQoWTD67KqOF4HVsgnOk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">stackoverflow에 나오는 여러가지 해결 방법을 시도해 봤는데 대부분 안되었지만, 어떤 글에서 지나가듯이 import 하는 모듈의 이름이 PRODUCT_MODULE_NAME이라는 것을 알게 되었습니다. 그래서, PRODUCT_MODULE_NAME을 플래그 봤는데 ($PROUDCT_NAME:c99extidentifier)였습니다. 이것을 보고, 테스트 클래스로 가서 자동완성은 안되지만, PRODUCT_MODULE_NAME을 그대로 @testable import를 했습니다. 그리고 Command + U를 눌렀는데<br><img src="https://blog.kakaocdn.net/dn/TjEGd/btsl0Xn8JPf/JuuQyn8AT9LNWnXkMwIzJ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">놀랍게도 No such module 에러는 계속 떴지만, 테스트는 진행 되었어요.ㅋㅋ 하지만 자동완성은 안되었어요. 근데 여기서 조금 더 발전해서 PRODUCT_MODULE_NAME을 xcconfig로 다루면 해결할 수 있지 않을까 싶어서 시도해 봤습니다. 그전에 문제점을 다시 정리하고 가겠습니다.
빌드환경 구성을 단일타겟과 세 가지 스킴, xcconfig로 했다.
카카오톡 로그인 Alert에 뜨는 앱이름을 바꾸기 위해서는 PRODUCT_NAME을 고쳐야 한다.
따라서 PRODUCT_MODULE_NAME(이 플래그는 PRODUCT_NAME을 참조하고 있음)이 변경되어서 기존의 Target NAME을 import 할 수 없다.
xcconfig에서 PRODUCT_MODULE_NAME_FIX 라는 플래그를 선언하고 적당한 값(이게 모듈 이름이 될 거예요)을 넣었어요. 그리고 Build Setting으로 가서 PRODUCT_MODULE_NAME에 PRODUCT_MODULE_NAME_FIX를 넣었습니다.<br><img src="https://blog.kakaocdn.net/dn/bAaFdy/btslZF9Womg/mkM2xJM0tHL3ICyazbzWQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그리고 위에서 적당한 값을 넣었잖아요? @testable import를 해줍시다. 그리고 Command + U를 누르면 테스트가 진행되네요.&nbsp;<br><img src="https://blog.kakaocdn.net/dn/ET2As/btslZSOHOL6/XlcRMxk0xt7DTw0TuAjFDk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">왜 카카오 로그인의 Alert는 CFBundleDisplay가 아닌 CFBundleName을 보고 있을까? 혹시 카카오SDK에서 이것을 다루는 프로퍼티가 있을까 싶어서 카카오 SDK 코드 구경을 했었습니다.&nbsp;public func presentationAnchor(for session: ASWebAuthenticationSession) -&gt; ASPresentationAnchor
사용자가 카카오로 로그인을 누를 때 위의 함수를 호출(애플도 같은 함수를 호출하지만 파라미터가 다름) 하게 되는데 파라미터가 ASWebAuthenticationSession입니다. 이 부분에서 버그가 있다고 다른 레포에서 이슈가 올라왔었습니다.&nbsp;&nbsp;사실 문제는 아닌 거 같고 그냥 업데이트를 안 하고 있는 것 같아요.아무튼 끝. 읽어주셔서 감사합니다.]]></description><link>ios/단위테스트와-product_module_name.html</link><guid isPermaLink="false">iOS/단위테스트와 PRODUCT_MODULE_NAME.md</guid><pubDate>Tue, 31 Dec 2024 05:41:07 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/dpQuzW/btslZ5NKkqr/n9zrpFvuy6sENHXX9QE0UK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dpQuzW/btslZ5NKkqr/n9zrpFvuy6sENHXX9QE0UK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[WWDC 2023 Parameter pack]]></title><description><![CDATA[WWDC 2023 Generalize APIs with parameter pack을 보고 알게된 것을 정리하기 위해 포스팅 하게 되었습니다. 모바일 애플리케이션을 만들 때 Swift로 Variadic Function을 사용하는 경우가 많이는 있을 것 같지 않지만, Swift 언어 자체 관점에서 보면 참 매력적인 피쳐라고 생각해요. 얼른 실험이 끝나고 swift 메인에 병합되었으면 좋겠네요.Generalize APIs with parameter pack을 보기 위해서는 제네릭에 대한 이해를 어느 정도 요구하고 이 포스팅도 마찬가지로 영상을 따라가기 때문에 제네릭에 대한 선수적인 지식이 조금 필요할 것 같아요. 하지만 쉽게 풀어쓰도록 최선을 다하겠습니다.파라미터 팩에 대한 영상을 볼 때 계속 나오는 단어가 있습니다.&nbsp;Variadic argument&nbsp;한글로 뜻 풀이하면 가변 전달인자입니다. 우리가 흔히 함수를 작성할 때 파라미터 영역과 리턴타입을 선언부에 작성하고 body에 함수 내용을 작성합니다.// 선언부
func sum(_ operand1: Int, _ operand2: Int) -&gt; Int { // Body return operand1 + operand2
} // main.swift sum(3, 4)
위 코드에서 3, 4가 바로 argument(전달인자)입니다. 지금처럼 함수 파라미터 개수가 2개인 경우도 있지만, 상황이 바뀌어 세 수를 더하고 싶습니다. 그러면 어떻게 하면 될까요? 배열을 만들어 루프를 돌아 처리 하는 방법이 있겠지만 저장할 필요가 없기 때문에 배열을 사용하고 싶지 않습니다. 그렇다면 함수 오버로딩을 통해서 구현하면 됩니다.// 함수 오버로딩 func sum(_ operand1: Int, _ operand2: Int, _ operand3: Int) -&gt; Int { // Body return operand1 + operand2 + operand3
} // main.swift sum(3, 4, 5)
또 상황이 바뀌어 6개의 수를 더하고 싶습니다… 함수 오버로딩을 이용하게 되면 반복적인 패턴이 나타나게 되고 로직이 바뀌면 유지보수가 쉽지 않습니다. 그럴 때 가변 인수개수를 허용하는 것입니다. 이것이 바로&nbsp;Variadic&nbsp;function 입니다.func sum(_ operands: Int...) -&gt; Int { var sum = 0 for op in operands { sum += op } return sum
} print(sum(1,2,3,4,5,6,7,8)) // 36
이런 Variadic function은 확실히 유용합니다. 하지만 한계점이 명확합니다.
여러개의 인자를 받고 이걸 tuple로 만들어서 return 하는 함수를 만든다고 가정합시다. 그렇다면 어떤 타입을 리턴 해야할까요?
func tuplify(_ numbers: Int...) -&gt; ??? { } Variadic parameter는 다양한 타입을 사용할 수 없습니다. 여러 타입을 사용하려면 type erasure를 고려해야합니다. 하지만 이 방법을 사용하게 된다면 전달인자의 specific한 타입에 대한 정보를 사용할 수 없습니다. 이 말은 캐스팅을 해서 사용해야 하기 때문에 런타임에러가 발생할 확률이 높습니다. (디버깅 비용을 낮추기 위해서는 컴파일러를 최대한 이용해야 합니다.)&nbsp;
func testFunc(objects: Any...) { // 컴파일러는 일을 안한다. // object들은 type information을 이용할 수 없음 -&gt; 캐스팅 해야함 -&gt; 런타임에러
}
&nbsp;즉 현재까지의 Swift로는 제네릭과 Variadic parameter로 type information을 보존할 수가 없고 여러개의 전달인자를 사용할 수 없었습니다. 이것을 하는 방법은 overloading 밖에 없었습니다. 하지만 Swift 5.9에서 Parameter Pack이 도입되었고 제네릭과 함께 전달인자 길이에 대해 추상화가 가능해졌습니다.파라미터 팩은 영단어 그대로 해석하면 됩니다. 파라미터를 담는 팩입니다. 타입 또는 값을 가지고 있고 (holds) 그것을 싸서 (packs) 전달인자로 넘겨줄 수 있습니다.
Bool, Int, String 이 세가지 individual type을 한꺼번에 묶어서 처리함 → type pack
true, 10, “” 위의 type pack에 대응하는 value pack
파라미터 팩은 생각보다 친숙한 개념입니다. 데이터를 담는 바구니 같은 것이기 때문에요. 마치 컬렉션처럼요. 다만 컬렉션은 동일한 타입만을 다룰 수 있는데 반해 파라미터 팩은 각각의 아이템들이 different 타입일 수 있다는 점입니다. 즉 파라미터 팩을 이용하면 type - level에서 작동할 수 있으며 이는 각각의 유형을 쉽게 처리할 수 있다는 뜻입니다.좋아요. 파라미터 팩이 뭔지 어느정도 알 거 같죠? 그러면 코드를 통해서 어떻게 작동하는 지 살펴보도록 할게요.오버로딩 패턴으로 이뤄진 기존의 코드를 파라미터 팩을 이용해서 리팩토링 하겠습니다. item들을 받아서 이것을 튜플로 리턴하는 함수입니다.// Query // 아래 코드를 리팩토링 할 것입니다
func query&lt;Payload&gt;( _ item: Request&lt;Payload&gt;
) -&gt; Payload func query&lt;Payload1, Payload2&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;
) -&gt; (Payload1, Payload2) func query&lt;Payload1, Payload2, Payload3&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;, _ item3: Request&lt;Payload3&gt;
) -&gt; (Payload1, Payload2, Payload3) func query&lt;Payload1, Payload2, Payload3, Payload4&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;, _ item3: Request&lt;Payload3&gt;, _ item4: Request&lt;Payload4&gt;
) -&gt; (Payload1, Payload2, Payload3, Payload4)
실제 코드로 살펴봐야하니 약간 구현을 하도록 하겠습니다.struct Request&lt;Payload&gt; { var payload: Payload init(payload: Payload) { self.payload = payload }
} func query&lt;Payload1, Payload2, Payload3&gt;( _ item1: Request&lt;Payload1&gt;, _ item2: Request&lt;Payload2&gt;, _ item3: Request&lt;Payload3&gt;
) -&gt; (Payload1, Payload2, Payload3) { return (item1.payload, item2.payload, item3.payload)
} print(query(Request(payload: true), Request(payload: 10), Request(payload: "")))
// Print: (true, 10, "")
파라미터 팩을 이용한 코드는 each 키워드를 사용해 작성되고 repeat 키워드를 사용해 repetition 패턴을 이용합니다.repeat (Requset&lt;each Payload&gt;)
위 코드의 뜻은 패턴이 반복되고, each Payload 자리가 각 반복동안 concrete 타입으로 대체된다는 것을 의미 합니다. 우리가 만든 예시는 Request&lt;Bool&gt;, Request&lt;Int&gt;, Request&lt;String&gt;, Request&lt;Bool&gt;, Request&lt;Int&gt;가 될 거에요.(Request&lt;Bool&gt;, Request&lt;Int&gt;, Request&lt;String&gt;) == (repeat Reqeust&lt;each Payload&gt;)
그러면 아래처럼 함수를 바꿀 수 있게 됩니다.func query&lt;each Payload&gt;( _ item: repeat (Request&lt;each Payload&gt;)
) -&gt; (repeat (each Payload)) { return (repeat (each item).payload)
} let result = query( Request(payload: true), Request(payload: 10), Request(payload: "")
) print(result) // Print: (true, 10, "")
제네릭 Payload에 Equatable 프로토콜을 컨펌하는 타입만 허용하게 하고 싶어요. 그러면 평소 제네릭을 쓰는 것처럼&nbsp;제네릭 &lt;&gt;에 제약조건을 추가하거나,&nbsp;where&nbsp;을 이용하면 됩니다.// MARK: - 제네릭에 제약 조건 추가 // 1. 제네릭 선언부에 제약조건 func query&lt;each Payload: Equatable&gt;( _ item: repeat (Request&lt;each Payload&gt;)
) -&gt; (repeat (each Payload)) { return (repeat (each item).payload)
} // 2. where Clause 제약조건 func query&lt;each Payload&gt;( _ item: repeat (Request&lt;each Payload&gt;)
) -&gt; (repeat (each Payload)) where repeat (each Payload): Equatable { return (repeat (each item).payload)
} let result = query( Request(payload: true), Request(payload: 10), Request(payload: "")
) print(result) class TestClass { } // Complie Error: 클래스는 Equatable 만족안함. Equatable 직접 구현하면 컴파일 성공!!
let result2 = query( Request(payload: true), Request(payload: 10), Request(payload: ""), Request(payload: TestClass())
)
func query&lt;each Payload&gt;( _ item: repeat (Request&lt;each Payload&gt;)
) -&gt; (repeat (each Payload)) where repeat (each Payload): Equatable { return (repeat (each item).payload)
} var test: () = query() // 컴파일 성공!
경우에 따라, 최소한 한개의 길이 보장을 하고 싶어요. 함수 body에 분기코드를 작성해 구현할 수 있으나, 그렇게 되면 런타임 에러에 좀 취약해질 수 있겠죠? 별 차이는 없겠지만 속도가 더 느릴테고요. 이 경우에는 제네릭 선언부에 한개를 더 선언함으로써 쉽게 구현할 수 있습니다. 항상 컴파일러에게 일을 할당해주는 게 좋다고 생각해요.func query&lt;FirstPayload, each Payload&gt;( _ first: Request&lt;FirstPayload&gt;, _ item: repeat Request&lt;each Payload&gt;
) -&gt; (FirstPayload, repeat each Payload) where FirstPayload: Equatable, repeat each Payload: Equatable { return (first.payload, repeat (each item).payload)
}
<img src="https://blog.kakaocdn.net/dn/S1EJQ/btslw8Cx1gx/cD5Zal2xo39GRSuZpgNau1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">&nbsp;파라미터 팩의 마지막 부분은 Generic에 파라미터 팩을 사용하는 방법입니다. WWDC 영상에서는 이 부분까지 다루긴 합니다. 그런데 아직은 사용하는 것은 시기상조인 것 같습니다. Generic에 파라미터 팩을 사용하는 것은 아직 swift main에 병합되지 않았기 때문입니다. 그래서 코드를 작성하게 되면 아직 실험 단계에 있다고 경고메세지가 뜹니다.
현재기준: 2023년 6월 25일 10:00 PM
Xcode version: Xcode-15.0.0-Beta.2, Swift Complier version: 5.9
$ /Applications/Xcode-15.0.0-Beta.2.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift --version #swift-driver version: 1.82.2 Apple Swift version 5.9 (swiftlang-5.9.0.114.10 clang-1500.0.29.1) Target: arm64-apple-macosx13.0
<br><img src="https://blog.kakaocdn.net/dn/bXQUgQ/btsljhIAoYC/m1T6ErQISBbTPPIZJKJBRk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">실험 Swift를 사용하려면, Swift Setting을 변경해줘야 합니다. 가장 간단하게 할 수 있는 방법은 SPM을 만들어서 package.swift을 수정하는 거에요!// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( name: "VariadicGenerics", products: [ // Products define the executables and libraries a package produces, making them visible to other packages. .library( name: "VariadicGenerics", targets: ["VariadicGenerics"]), ], targets: [ // Targets are the basic building blocks of a package, defining a module or a test suite. // Targets can depend on other targets in this package and products from dependencies. .target( name: "VariadicGenerics", swiftSettings: [.enableExperimentalFeature("VariadicGenerics")] ), .testTarget( name: "VariadicGenericsTests", dependencies: ["VariadicGenerics"]), ]
)
그러면 Package 내에서 파일을 생성하고 코드를 작성하면 Generic types with parameter packs are experimental 에러는 나오지 않게 됩니다.추가로 확장하고 싶은 기능은 다음과 같아요.
상태를 저장하는 프로퍼티를 추가하는 것
전달인자로 넘겨주는 타입과 리턴 타입을 다르게 하고 싶음 (differ input type and output type)
manage control flow during parameter pack iteration - 파라미터 팩을 사용하는 것은 반복이기 때문에 반복을 조기에 종료했을 때 처리하는 방법
따라서 완성 코드 (애플 제공)는 다음과 같습니다!rotocol RequestProtocol {
// 2번 요구사항 충족 associatedtype Input associatedtype Output func evaluate(_ input: Input) -&gt; throws Output
} struct Evaluator&lt;each Request: RequestProtocol&gt; { var item: (repeat each Request) // 1번 요구사항 충족 func query(_ input: repeat (each Request).Input) -&gt; (repeat (each Request).Output)? {
// 3번 요구사항 충족 do { return (repeat try (each item).evaluate(each input)) } catch { return nil } }
}
그러나, 현재도 Generic Parameter pack에 대한 많은 논의가 이뤄지고 있습니다. 애플이 제공하는 코드도 현재는 에러가 나와서 빌드가 되지 않습니다. 이 부분은 추후 Swift에 이 기능이 정식으로 릴리즈 되면 다시 다뤄봐야 할 것 같습니다.읽어주셔서 감사합니다!]]></description><link>ios/wwdc-2023-parameter-pack.html</link><guid isPermaLink="false">iOS/WWDC 2023 Parameter pack.md</guid><pubDate>Tue, 31 Dec 2024 05:39:59 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/S1EJQ/btslw8Cx1gx/cD5Zal2xo39GRSuZpgNau1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/S1EJQ/btslw8Cx1gx/cD5Zal2xo39GRSuZpgNau1/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Swift에서 다형성을 달성하는 방법]]></title><description><![CDATA[이번 글은 WWDC 2022 Embrace Swift generics와 같은 년도인 Design Protocol interfaces in Swift를 보고 포스팅하게 되었습니다.이 포스팅에서 다음과 같은 내용을 다룹니다. Ad - Hoc 다형성과 Subtype 다형성을 설명하고 코드 구현, 그리고 이 구조들에서 발생하는 문제점 제네릭을 이용한 파라미터릭 다형성을 달성하는 법. 이 부분에서 some 키워드와 any 키워드를 설명하고 interface를 설계하고 코드를 작성하는 방법 다형성(多形性,&nbsp;polymorphism; 폴리모피즘)은 그 프로그래밍 언어의&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C%ED%98%95_%EC%B2%B4%EA%B3%84" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C%ED%98%95_%EC%B2%B4%EA%B3%84" target="_self">자료형 체계</a>의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%83%81%EC%88%98" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EC%83%81%EC%88%98" target="_self">상수</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EB%B3%80%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)" target="_self">변수</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%8B%9D" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EC%8B%9D" target="_self">식</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8" target="_self">오브젝트</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98" target="_self">함수</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EB%A9%94%EC%86%8C%EB%93%9C" target="_self">메소드</a>&nbsp;등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다.
즉 하나의 코드로 여러 행동을 하게 해주는 것이 다형성이라고 생각하면 될 것 같아요. 다형성은 다양한 방식으로 달성할 수 있는데요.&nbsp;WWDC 2022에서는 3가지로 설명하고 있습니다. ad-hoc 다형성 - 오버로딩 Subtype 다형성 - 오버라이딩 파라미터릭 다형성 using Generic 그러면 하나씩 살펴보도록 하겠습니다.설명하기에 앞서 코딩을 해야 하기 때문에, 요구사항을 먼저 정하겠습니다. 다음과 같은 프로그램을 개발해야 합니다.
농장 시뮬레이팅 만들기!
Farm (농장)에는&nbsp;Cow(소),Horse(말),Chicken(닭)이 있습니다.
소는&nbsp;Hay(건초), 말은&nbsp;Carrot(당근), 닭은 Grain(사료)을 먹습니다.
농장은 동물들에게 밥을 줘야 하기 때문에, Hay, Carrot, Grain을 수확해야 함. Alfalfa가 자라서 Hay가 되고, Root는 Carrot,&nbsp;Wheat가 자라서 Grain이 됩니다.
// Animal.swift struct Cow { func eat(_ food: Hay) { print("\(Self.self) eat \(food)") }
} struct Horse { func eat(_ food: Carrot) { print("\(Self.self) eat \(food)") }
} struct Chicken { func eat(_ food: Grain) { print("\(Self.self) eat \(food)") }
}
// AnimalFeed.swift // 재료 -&gt; 음식
// 소는 Alfalfa가 자라서 수확된 Hay를 먹음
// 말은 Root가 자라서 수확된 Carrot을 먹음
// 닭은 Wheat가 자라서 수확된 Grain을 먹음 struct Hay { static func grow() -&gt; Alfalfa { return Alfalfa() }
} struct Alfalfa { func harvest() -&gt; Hay { return Hay() }
} struct Carrot { static func grow() -&gt; Root { return Root() }
} struct Root { func harvest() -&gt; Carrot { return Carrot() }
} struct Grain { static func grow() -&gt; Wheat { return Wheat() }
} struct Wheat { func harvest() -&gt; Grain { return Grain() }
}
// Farm.swift struct Farm { func feed(_ animal: Cow) { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food) } func feed(_ animal: Horse) { let root = Carrot.grow() let food = root.harvest() animal.eat(food) } func feed(_ animal: Chicken) { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food) }
}
// FarmSimulator.playgroud import Foundation let farm = Farm() let cow = Cow()
let horse = Horse()
let chicken = Chicken() farm.feed(cow) // Print: Cow eat Hay()
farm.feed(horse) // Print: Horse eat Carrot()
farm.feed(chicken) // Print: Chicken eat Grain()
Ad-Hoc 다형성을 이용해서 요구사항을 만족하는 코드를 작성했습니다. 코드를 보면 유형에 따라 구체적인 feed() 함수가 결정되고 실행되는 것을 볼 수 있습니다. 이것은 함수 오버로딩 (Function overloading)을 통해서 작동하고 있어요(파라미터의 타입을 다르게 동일한 함수를 작성하는 것)<br><img src="https://blog.kakaocdn.net/dn/bad809/btskUMGVFT1/3Wfq3cbT9hTwOGWwsvBIk0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이 방식의 문제점은 무엇일까요? 오버로딩은 반복적인 구현, 즉 보일러 플레이트를 유발합니다. 코드를 너무 많이 작성해야 한다는 것이죠. 그리고 요구사항 변경에 매우 취약합니다. 한 가지 예를 들어보도록 할게요.요구사항 변경
농장에 새로운 동물 돼지가 들어왔어요. 돼지는 GrainForPig를 먹습니다. 그리고 돼지가 먹는 GrainForPig는 옥수수 Corn으로 만들어집니다.
// Animal.swift 에 추가해야함
struct Pig { func eat(_ food: GrainForPig) { print("\(Self.self) eat \(food)") }
} // AnimalFeed.swift
struct GrainForPig { static func grow() -&gt; GrainForPig { return GrainForPig() }
} struct Corn { func harvest() -&gt; GrainForPig { return GrainForPig() }
} // Farm.swift func feed(_ animal: Pig) { let corn = GrainForPig.grow() let food = corn.harvest() animal.eat(food)
} // FarmSimulator.playgroud let pig = Pig()
farm.feed(pig) // Print: Chicken eat Grain()
변경된 요구사항을 만족하기 위해서 위의 코드를 추가로 작성해야 합니다. 새로운 기능이 추가된 것도 아닌데 작성할 코드가 너무 많아 보입니다. 그리고 더 중요한 건&nbsp;컴파일러는 이러한 요구사항에 일절 관여하지 않기 때문에&nbsp;코딩할 때 feed 함수를 오버로딩 해야 한다는 것을 깜빡해도 경고를 하지 않는다는 것입니다. 디버깅 비용이 높아지고 있어요. 딱 봐도 안 좋은 방식인 것 같습니다.Subtype 다형성이 작동하는 메커니즘은&nbsp;class를 이용한 상속입니다. 한 Super Class가 있고 이를&nbsp;상속해서&nbsp;관련 함수를&nbsp;오버라이딩(overriding)&nbsp;합니다. 여기에서는 Animal이라는 Super Class를 만들고, Cow, Horse, Chicken은 Animal을 상속하게 합니다.import Foundation // Animal.swift class Animal { func eat(_ food: Any) { fatalError(" Subclass implements 'eat' ") }
} class Cow: Animal { override func eat(_ food: Any) { guard let food = food as? Hay else { fatalError("소는 \(food) 를 먹을 수 없습니다.") } print("\(Self.self) eat \(food)") }
} class Horse: Animal { override func eat(_ food: Any) { guard let food = food as? Carrot else { fatalError("말은 \(food) 를 먹을 수 없습니다.") } print("\(Self.self) eat \(food)") } } class Chicken: Animal { override func eat(_ food: Any) { guard let food = food as? Grain else { fatalError("닭은 \(food) 를 먹을 수 없습니다.") } print("\(Self.self) eat \(food)") }
} // Farm.swift
struct Farm { func feed(_ animal: Animal) { if animal is Cow { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food) return } if animal is Horse { let root = Carrot.grow() let food = root.harvest() animal.eat(food) return } if animal is Chicken { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food) return } fatalError("올바른 동물 타입이 아닙니다.") }
} // AnimalFeed.swift는 변경 안함
// FarmSimulator.playground도 변경 안함
소, 닭, 말은 다른 먹이 타입을 먹기 때문에 eat()의 파라미터 food가 구체적일 수가 없습니다. 따라서 Animal 클래스에서의 eat의 파라미터인 food의 타입을 구체적인 타입이 아니라&nbsp;유연한 Any 타입으로 변경해야 합니다.이제 각각의 구체적인 동물 클래스(소, 닭, 말)에서 eat 메서드를 구현합시다. 이때 주의할 점이 있습니다. eat()을 구현할 때 guard let을 이용해서 타입 검사를 해야 합니다. 왜냐하면 eat의 파라미터가 Any이기 때문에 모든 타입이 전달인자(argument)로 들어올 수 있기 때문이에요.(예를 들면 Cow의 eat에 Hay 말고 다른 것이 들어오면 안 됨!)다음으로 Farm을 보면 feed() 구현현도 조금 바뀌었죠? 함수 오버로딩을 사용하지 않고 진정한 의미의 함수 하나가 되었습니다.동물에게 밥을 주기 위해서 인자로 받은 동물의 타입 검사를 하고 동물 타입에 맞게 밥을 주는 코드가 완성되었습니다.이제 실행을 해볼까요? FarmSimulator.playground 파일을 수정하지 않고도 잘 실행되는 것을 확인할 수 있습니다.<br><img src="https://blog.kakaocdn.net/dn/bTBLKV/btskSn2eIaz/N9VlHTbYzVAiKOu4p4qXVk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/vdJ0q/btskRekEX7G/RC4a2SzXov76lkcMoEtv9k/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 하나의 코드로 여러 행동을 할 수 있게 되었습니다. 짝짝 😀좋습니다. 하지만 이 코드도 확실히 문제점이 존재합니다. 위처럼 새로운 동물 Pig가 추가될 때, Pig 내부에 eat을 구현하지 않으면 컴파일 타임에 에러 검출을 하지 못합니다. 앱이 실행되고 나서 런타임에 Pig가 eat을 구현하지 않았다는 에러를 발견할 수 있습니다.마찬가지로, eat 메서드에서 전달인자로 올바른 타입이 왔는지 검사하는 것도 모두 다 런타임에서 일어납니다.즉, 이 코드 역시 보일러플레이트를 생성할 뿐만 아니라, 에러 검출이 런타임에서 이뤄지기 때문에 디버깅 난이도가 올라갑니다. 그리고 Any 타입을 사용하기 때문에 코드 파악이 어려운 단점도 존재합니다.문제점을 정리해 볼게요.
런타임시에 에러 검출
구체적인 동물 타입 구현시에 파라미터 타입이 Any → 코드 파악 어려움
여기서 새로운 개념을 하나만 더 도입하면 문제점 2번은 해결할 수 있을 것 같아요. 조금 더 나아가보도록 할게요.타입파라미터를 도입할게요!class Animal&lt;Food&gt; { func eat(_ food: Food) { fatalError(" Subclass implements 'eat' ") }
} class Cow: Animal&lt;Hay&gt; { override func eat(_ food: Hay) { print("\(Self.self) eat \(food)") }
} class Horse: Animal&lt;Carrot&gt; { override func eat(_ food: Carrot) { print("\(Self.self) eat \(food)") } } class Chicken: Animal&lt;Grain&gt; { override func eat(_ food: Grain) { print("\(Self.self) eat \(food)") }
} // Farm.swift
struct Farm { func feed&lt;T&gt;(_ animal: Animal&lt;T&gt;) where T: Any { if animal is Cow { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food as! T) return } if animal is Horse { let root = Carrot.grow() let food = root.harvest() animal.eat(food as! T) return } if animal is Chicken { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food as! T) return } fatalError("올바른 동물 타입이 아닙니다.") }
}
이 방법으로 2번의 문제를 조금 해결할 수 있네요. 하지만 근본적인 문제는 해결되지 않았습니다. Farm의 feed()에서, 각 동물들의 eat을 실행하기 위해서 역시 유연한 Any 타입을 사용해야 합니다. 그리고 실제 eat 코드를 실행할 때, T로 캐스팅을 해줘야 한다는 점이 불편해 보여요.즉, 코드 누락 시에 컴파일러는 알려주지 않고, 런타임 시에 에러가 검출되겠네요. 역시 1번 문제는 해결하지 못했습니다.문제가 이것뿐만이 아닙니다. 이 밖에도 다음과 같은 문제가 발생합니다!!동물의 주요 행위가 꼭 먹는 것이라고 할 수 없는데, class에 타입 파라미터를 지정해줘야 한다는 것입니다. 동물의 행위에는 여러 가지가 있고 eat은 그중 하나일 뿐인데요! (예를 들면 동물 메서드에 run(), sleep() 등등이 있는데 이것은 AnimalFeed와 무관합니다.)그리고 만약 Food 같이 다른 파라미터도 다형성을 구현하기 위해서 아래 코드처럼 보일러 플레이트를 생성하게 될 것입니다.class Animal&lt;Food, Habitat, Commodity&gt; { func eat(_ food: Food) { fatalError(" Subclass implements 'eat' ") }
} class Cow: Animal&lt;Hay, Barn, Milk&gt; { override func eat(_ food: Hay) { }
} // 말 같은 경우에 얻을 Commodity가 없는데, 상위 클래스인 Animal에 타입파라미터로
// Commodity가 있기 때문에 Never 같은 보일러 플레이트가 발생함
class Horse: Animal&lt;Carrot, Stable, Never&gt; { override func eat(_ food: Carrot) { } } class Chicken: Animal&lt;Grain, Coop, Egg&gt; { override func eat(_ food: Grain) { }
}
Subtype 다형성에서 가장 큰 문제점은 바로 Super Type이 Data Type이라는 겁니다.지금까지 다형성을 달성하는 방법 2가지를 찾아봤는데 단점이 너무 명백해 보입니다. 이제 우리가 원하는 것을 생각해 보고 새로운 단계로 나아가봅시다!!우리가 원하는 것은 다음과 같아요.
기능이 작동하는 방식에 대한 세부 정보 없이 유형의 기능을 나타내길 원함
컴파일러가 좀 더 엄격하게 버그를 찾아줬으면 좋겠음(누락된 코드나 잘못 작성하면 컴파일 타임에 알려줘!)
이때 우리에게 한 줄기의 빛이 되는 것이 바로 interface입니다. 현대 언어에서는 위에서 살펴본 문제들을 interface를 통해 해결하고 있어요. swift에서는 protocol로 선언할 수 있습니다.// 구현체 Animal.swift
// Interface
protocol Animal { func eat(_ food: AnimalFeed)
} struct Cow: Animal { func eat(_ food: AnimalFeed) { print("\(Self.self) eats \(food)") }
} struct Horse: Animal { func eat(_ food: AnimalFeed) { print("\(Self.self) eats \(food)") }
} struct Chicken: Animal { func eat(_ food: AnimalFeed) { print("\(Self.self) eats \(food)") }
} // AnimalFeed.swift
// interface
protocol AnimalFeed { }
struct Hay: AnimalFeed { static func grow() -&gt; Alfalfa { return Alfalfa() }
} struct Alfalfa { func harvest() -&gt; Hay { return Hay() }
} struct Carrot: AnimalFeed { static func grow() -&gt; Root { return Root() }
} struct Root { func harvest() -&gt; Carrot { return Carrot() }
} struct Grain: AnimalFeed { static func grow() -&gt; Wheat { return Wheat() }
} struct Wheat { func harvest() -&gt; Grain { return Grain() }
} // Farm.swift
struct Farm { func feed(_ animal: Animal) { if animal is Cow { let alfalfa = Hay.grow() let food = alfalfa.harvest() animal.eat(food) return } if animal is Horse { let root = Carrot.grow() let food = root.harvest() animal.eat(food) return } if animal is Chicken { let wheat = Grain.grow() let food = wheat.harvest() animal.eat(food) return } }
}
만약 여기에서 Pig가 추가되었다는 기획의 요청을 받으면, Pig 구현체를 만들 때 Animal을 컨펌하면 되겠습니다. 그러면 eat 메서드를 누락하면 컴파일러가 이를 알아채고 고치라고 합니다!&nbsp;아무래도 컴파일러가 알려주니 좀 뇌를 빼고 개발해도 되겠죠?좋습니다. 좋아요. 하지만 위의 코드에도 문제점을 그만 찾고 싶은데 당연히 문제점이 있습니다. Cow, Horse, Chicken과 같은 구현체에서 eat 메서드의 파라미터를 보니 AnimalFeed입니다. 타입이 인터페이스죠? 말은 Hay를 먹고, Horse는 Carrot, Chicken은 Grain을 먹는다는 사실은 자명합니다. 이 구현체에서 매개변수를&nbsp;인터페이스로 은닉할 필요가 없다는 뜻입니다! 이때&nbsp;associatedtype&nbsp;(연관타입)을 사용하면 됩니다. Animal에&nbsp;&nbsp;associatedtype을&nbsp;추가합시다.protocol Animal { associatedtype Feed: AnimalFeed func eat(_ food: Feed)
}
<br><img src="https://blog.kakaocdn.net/dn/ldB46/btskRomUwNB/4Kays19TdOCR4Qcgd1cgnk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 위처럼 각 동물을 구현할 때 Animal을 컨펌하라고 컴파일러가 알려줍니다. 이제 _ food: AnimalFeed를 구체적인 타입으로 변경합시다.struct Cow: Animal { func eat(_ food: Hay) { print("\(Self.self) eats \(food)") }
} struct Horse: Animal { func eat(_ food: Carrot) { print("\(Self.self) eats \(food)") }
} struct Chicken: Animal { func eat(_ food: Grain) { print("\(Self.self) eats \(food)") }
}
Farm의 feed() 메서드를 봤을 때, 조금 복잡해 보입니다. if 문으로 분기처리를 하지 않고, 조금 명료한 하나의 동작을 코드로 작성하고 싶습니다. 타입 파라미터를 이용해 제네릭 코드를 작성해 봅시다. feed 메서드를 작성할 때, animal의 타입을 지정해줘야 합니다. 매개변수의 타입은 Concrete 타입이어야 합니다. (소, 닭, 말 같은 구현체) 그렇기 때문에 매개변수는 직접적인 protocol이 아니라 아래처럼 제네릭을 이용해서 작성해야 합니다.(두 함수는 표현만 다를 뿐 같은 함수입니다.)struct Farm { func feed&lt;A: Animal&gt;(_ animal: A) { } func feed&lt;A&gt;(_ animal: A) where A: animal { }
}
이 제네릭 코드를 이해해 볼까요?A에는 특정한 Concrete 타입이 들어가고, 이 Concrete 타입은 Animal Protocol을 컨펌한다는 뜻입니다.위의 두 메서드와 같은 함수를 하나 더 작성해 보겠습니다. 바로&nbsp;some&nbsp;키워드를 이용하는 것입니다. some 이용하면 좀 더 의미 있게 표현이 되는 것 같습니다. some 키워드에 대해 알아봅시다.struct Farm { func feed(_ animal: some Animal) { }
}
some 키워드를 이해하기 전에 약간의 개념 정립과 용어 정리가 필요한 것 같습니다.메서드의 매개변수에 specific concrete 타입이 와야 한다고 말했습니다. some 키워드가 붙은 것도 역시 specific concrete 타입일 것입니다. 하지만 정말 명료한 concrete 타입은 아닐 겁니다. 왜냐하면 프로토콜을 컨펌하는 어떤 구현체가 들어가도 되니깐요. 맞나요? 맞습니다. 하나가 딱 정확히 정해져있지 않다는 뜻입니다. 이러한 것을&nbsp;opaque&nbsp;타입이라고 합니다.(some 단어로 유추할 수 있죠) 즉 특정한 concrete 타입에 대한 추상적인 placeholder를 opaque 타입이라고 부르는 것입니다. 그래서 애플 문서나 WWDC에서 some 키워드가 붙으면 opaque 타입이라고 부릅니다. 좋아요. 이 opaque 타입은 컴파일 타임에 실제 완전 명료한 concrete type으로 대체가 될 것입니다. 이것을 기저에 깔려있는 즉 underlying 타입이라고 합니다. 이제 의미에 대해 생각해 볼게요. 제네릭 코드를 이용하거나 파라미터 변수에 some을 붙인 것은 어떤 의미가 있을까요? 이러한 코드들이 의미하는 바는 컴파일러에게 이 메서드는&nbsp;‘specific concrete 타입으로&nbsp;작업할 거야’라고 알리는 것과 마찬가지입니다. 즉 컴파일 시점에 이 opaque 타입의 underlying 타입은 고정되어야만 한다는 것을 의미합니다. 그렇기 때문에 재할당도 불가능합니다. 코드를 보면 알 수 있습니다.// 컴파일 성공
let animals: [some Animal] = [ Cow(), Cow(), Cow(),
] // Print: Compile error: Cannot convert value of type 'Horse' to expected element type 'Cow'
let vehicles: [some Animal] = [ Cow(), Cow(), Horse(),
] // 컴파일 성공
func createCow() -&gt; some Animal { return Cow()
} // Print: Compile error: Function declares an opaque return type 'some Animal', but the return statements in its body do not have matching underlying types
func createSomeAnimal(number: Int) -&gt; some Animal { if number == 0 { return Cow() } else if number == 1{ return Horse() } else { return Chicken() }
} var animal: some Animal = Cow()
animal = Horse() // 불가능
animal = Cow() // 이것도 불가능
이제 다시 돌아와서 Farm의 feed 메서드를 작성해 볼까요? some 키워드에 대해 알아보느라 우리의 목표를 잠깐 까먹었을 수도 있기 때문에 리마인드 하겠습니다.feed 메서드를 여러 유형에게 공통으로 작동하는 코드로 작성하는 것어떻게 작성하면 될까요? 설계를 해봅시다.protocol Animal { associatedtype Feed: AnimalFeed func eat(_ food: Feed)
}
Animal은 연관타입으로 Feed (AnimalFeed)을 가지고 있습니다. 자동완성으로 확인해 볼게요.<br><img src="https://blog.kakaocdn.net/dn/m1JBl/btsk4N6CzrV/s9MFR67PU2a2lF9B77xs11/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">AnimalFeed는 프로토콜이고, concrete 타입으로는 동물들이 먹는 Hay, Carrot, Grain입니다.위에서 이것을 만들기 위해서 어떻게 했나요? Hay 안에 static 메서드 grow()를 사용했습니다.간단하게 리뷰를 하면 아래와 같습니다. (소를 예로 들게요.)let crop = Hay.grow() (crop의 타입은 Alfalfa) → let food = crop.harvest() (food의 타입은 Hay)opaque 타입은 concrete한 타입이기 때문에, type 메서드를 사용할 수 있어요. type을 이용해 코드를 작성해 볼게요. 그러면, 위의 코드를 type(of: animal). Feed.grow()라고 하면 될 것 같아요.<br><img src="https://blog.kakaocdn.net/dn/bbkEzr/btsk1clWC60/jg1GIMpA2zttu9aXmggnh0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">당연히 뜨지 않겠죠. 왜냐하면 grow() 메서드는 concrete 타입(Hay, Carrot, Grain)에 직접 구현했으니깐요. 따라서 자연스럽게 AnimalFeed 프로토콜에 에 static grow()가 추가되어야 합니다. grow()는 Alfalfa, Root, Wheat 같은 작물을 리턴해야 하기 때문에 이와 관련된 인터페이스(Crop)를 만들고 연관타입으로 가지고 있어야 합니다. 그리고 Crop 프로토콜에는 당연히 harvest()가 있어야 하겠죠? 이 메서드의 리턴은 역시 연관 타입으로 AnimalFeed를 가지고 있어야 할 겁니다.코드 작성을 해볼게요.protocol AnimalFeed { associatedtype CropType: Crop static func grow() -&gt; CropType
} protocol Crop { associatedtype Feed: AnimalFeed func harvest() -&gt; Feed
} struct Hay: AnimalFeed { static func grow() -&gt; Alfalfa { return Alfalfa() }
} struct Alfalfa: Crop { func harvest() -&gt; Hay { return Hay() }
} struct Carrot: AnimalFeed { static func grow() -&gt; Root { return Root() }
} struct Root: Crop { func harvest() -&gt; Carrot { return Carrot() }
} struct Grain: AnimalFeed { static func grow() -&gt; Wheat { return Wheat() }
} struct Wheat: Crop { func harvest() -&gt; Grain { return Grain() }
}
struct Farm { func feed(_ animal: some Animal) { let crop = type(of: animal).Feed.grow() let food = crop.harvest() animal.eat(food) }
}
정말 깔끔한 코드가 작성되었습니다. 다형성을 구현했습니다. 하지만 이 코드는 아래처럼 빌드에 실패할 거예요ㅠ<br><img src="https://blog.kakaocdn.net/dn/ds9HYU/btsk1Bsk9Wf/lL1qYwrMh7YhkKAwAETPL1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">왜냐하면 프로토콜 관계에&nbsp;꼬리에 꼬리를 무는 관계가 있기 때문이에요. (back - and - forth) AnimalFeed 프로토콜을 한번 봐볼까요.모든 프로토콜은 Self 타입을 가지고 있습니다.AnimalFeed는 concrete conforming type인 CropType을 가지고 있습니다.Crop 역시 concrete conforming type인 FeedType을 가지고 있습니다.Self: AnimalFeed → Self.CropType: Crop → Self.CropType.FeedType: AnimalFeed → …위와 같이 무한반복이 될 거예요.Crop 프로토콜도 이와 마찬가지고요. 따라서 이 (back - and - forth)를 끊어주면 되겠습니다. AnimalFeed 프로토콜에서 CropType이 가지고 있는 Feed는 바로 자신이라고 알려주고, 마찬가지로 Crop 프로토콜에서 FeedType이 가지고 있는 Crop은 자기 자신이라는 것을 알려주면 됩니다. 어떻게? where을 이용해서!protocol AnimalFeed { associatedtype CropType: Crop where CropType.Feed == Self static func grow() -&gt; CropType
} protocol Crop { associatedtype Feed: AnimalFeed where Feed.CropType == Self func harvest() -&gt; Feed
}
여기까지 작성하면, feed에서 나는 에러가 사라지게 됩니다. FarmSimulating.playground로 돌아가서 실행을 하면 잘 작동합니다.지금까지 .playground을 단 한 번도 수정한 적이 없습니다. 그럼에도 불구하고 같은 결과를 보여주는 게 정말 멋지네요.FarmSimulating.playground에서 각 동물 인스턴스와 농장 인스턴스를 만들어서 작업을 하고 있어요. 여기에 요구사항을 약간 변경해 보도록 할게요. 그리고 요구사항에 맞게 코드를 변경해 봅시다.
농장은 배고픈 동물들에게 밥을 줄 책임이 있습니다. 배고픈 동물들에게 밥을 주는 기능을 추가하세요.
요구사항을 읽었을 때, 바뀌거나 추가되어야 할 부분들은 다음과 같습니다.
동물은 자기가 배고픈지 아닌지를 알 수 있어야 합니다. → 동물은 배고픔을 나타내는 프로퍼티를 가지고 있어야 함
농장은 배고픈 동물들을 판별할 수 있어야 함 → Farm 구현체에 프로퍼티로 동물들을 가지고 있어야 함
// 1번 요구사항 충족
// Animal 인터페이스에 isHungry를 프로퍼티를 추가하고
// 동물 인터페이스를 컨펌하는 concrete 객체에 isHungry를 추가함.
protocol Animal { associatedtype Feed: AnimalFeed func eat(_ food: Feed) var isHungry: Bool { get }
} struct Cow: Animal { var isHungry: Bool func eat(_ food: Hay) { print("\(Self.self) eats \(food)") }
} // ...
1번 요구사항을 충족시키는 것은 매우 쉽습니다! 2번도 만족시켜볼까요?struct Farm { var animals: [some Animal] func feed(_ animal: some Animal) { let crop = type(of: animal).Feed.grow() let food = crop.harvest() animal.eat(food) }
}
<br><img src="https://blog.kakaocdn.net/dn/kxFNx/btskZsJ6zyL/xKuqodcdpKxuO4oxPn3P60/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">빌드할 수가 없습니다. 왜 그럴까요? some에서 봤듯이, 컴파일 타임에 opaque type의 underlying type을 유추할 수 있어야 하기 때문입니다. 그러면 다음 코드들은 어떨까요?// case 1 (성공) // underlying type이 고정되어 있음
var animals: [some Animal] = [Cow(isHungry: false), Cow(isHungry: false)] //case 2 (실패) - underlying type이 고정되어 있지 않음
var animals: [some Animal] = [Horse(isHungry: false), Cow(isHungry: false)]
농장에는 다른 유형의 동물들이 있어야 합니다. 우리가 원하는 건 case 2입니다. 컴파일러는 고정된 underlying type을 요구합니다. 우리는 이걸 좀 유연하게 가져가고 싶어요. [Cow(), Horse(), Chicken() … ] 이런 식으로요어떻게 타입을 지우는 법이 없을까요? 이때 필요한 키워드가 바로&nbsp;any입니다.any 키워드는&nbsp;existential type를&nbsp;생성하기 위해 도입되었어요. 사실 existential type는 새로운 게 아닙니다. 그냥 프로토콜을 타입으로 사용할 때, 존재 유형으로 부릅니다.var cow: Animal = Cow() // 이 코드에서 Animal이 존재 유형임.
// Swift 5.7에서는 위 코드는 var cow: any Animal = Cow() 가 되어야만 함.
any 키워드를 사용한다는 것은 Apple은 concrete 타입을 박스로 싸는 것에 비유합니다. ㅎ<br><img src="https://blog.kakaocdn.net/dn/1tIyb/btsk2fP5Zek/tlhdodbWyyLohnGMOAQkHk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">즉 박스에 특정한 프로토콜을 준수하는 concrete 타입을 넣는 겁니다. 그렇다면 concrete 타입( Cow, Chicken, Horse)은 숨겨집니다. 그래서 이것을 type erasure라고 합니다! 즉 upper bound로 퉁치는 거입니다. (수학 공부할 때 정말 많이 나오는 그 upper bound 맞아요) 그래서 any를 사용하게 되면 heterogeneous한 컬렉션([Cow(), Horse()] 같은 컬렉션들)을 만들 수 있게 되는 것입니다. 이해하고 나니까 별로 어려운 것이 아니네요.^^<br>any 키워드에 주의점을 마지막으로 any에 대한 설명을 끝내겠습니다. ‘Donny Wals라는 개발자는&nbsp;<a data-tooltip-position="top" aria-label="https://www.donnywals.com/what-is-the-any-keyword-in-swift/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.donnywals.com/what-is-the-any-keyword-in-swift/" target="_self">‘*<strong></strong></a>*What is the “any” keyword in Swift?**’라는 아티클에서 any 키워드는 some보다 덜 효율적이고 비용을 더 많이 초래하기 때문에 기본적으로 some을 사용하고 필요할 때, any 키워드를 사용하라고 권고합니다. 그리고 역시 WWDC 2022에서도 some을 디폴트로 사용하라고 언급해요.이제 any에 대한 이해가 끝났으니 코드 작성을 해봅시다.struct Farm { var animals: [any Animal] func feedAnimals() { animals.filter(\.isHungry).map { animal in animal.eat(???) } }
} // FarmSimulating.playground import Foundation let farm = Farm(animals: [ Cow(isHungry: true), Cow(isHungry: false), Chicken(isHungry: true), Horse(isHungry: true)
]) farm.feedAnimals()
위의 코드는 작동하지 않을 것입니다. 왜일까요? 답은 간단합니다. 닭은 Grain을 먹어야 하고, 소는 Hay를 먹어야 합니다. 이때 animal.eat()에서 어떠한 방식으로 Parameter를 넘겨야 할지 문제가 생깁니다. Animal 프로토콜과 관련된 FeedTye의 upper bound는 'any AnimalFeed'입니다. any AnimalFeed가 닭인 경우에 Grain, 소인 경우에 Hay를 정적으로 보장할 방법이 없습니다. 따라서 위 코드처럼 Type erasure를 허용해서는 안됩니다. 즉 정적으로 보장하기 위해서 existential 타입을 언박싱해야 합니다. 언박싱하는 방법은 opaque 타입인 some 키워드를 매개변수로 하는 함수를 호출하면 됩니다. 바로 아래처럼요!struct Farm { var animals: [any Animal] private func feed(_ animal: some Animal) { let crop = type(of: animal).Feed.grow() let food = crop.harvest() animal.eat(food) } func feedAnimals() { animals.filter(\.isHungry).map { animal in feed(animal) } }
} // FarmSimulating.playground import Foundation let farm = Farm(animals: [ Cow(isHungry: true), Cow(isHungry: false), Chicken(isHungry: true), Horse(isHungry: true)
]) farm.feedAnimals()
드디어 모든 코드 구현이 완료되었습니다. some과 any 키워드를 사용하고 인터페이스를 잘 설계함으로써 제네릭을 이용한 파라미터릭 다형성을 달성했습니다.&nbsp;제가 이해한 것을 바탕으로 최대한 이해하기 쉽게 풀어쓰려고 노력했는데 잘 와닿을까 모르겠네요. 제네릭은 참 어려운 것 같습니다.상당히 긴 호흡의 글을 읽어주셔서 감사합니다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/FarmSimulating" target="_self">https://github.com/psychehose/FarmSimulating</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://swiftsenpai.com/swift/understanding-some-and-any/" target="_self">https://swiftsenpai.com/swift/understanding-some-and-any/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.donnywals.com/what-is-the-any-keyword-in-swift/" target="_self">https://www.donnywals.com/what-is-the-any-keyword-in-swift/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.apple.com/videos/play/wwdc2022/110352/" target="_self">https://developer.apple.com/videos/play/wwdc2022/110352/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.apple.com/videos/play/wwdc2022/110353/" target="_self">https://developer.apple.com/videos/play/wwdc2022/110353/</a>]]></description><link>ios/swift에서-다형성을-달성하는-방법.html</link><guid isPermaLink="false">iOS/Swift에서 다형성을 달성하는 방법.md</guid><pubDate>Tue, 31 Dec 2024 05:35:15 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bad809/btskUMGVFT1/3Wfq3cbT9hTwOGWwsvBIk0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/bad809/btskUMGVFT1/3Wfq3cbT9hTwOGWwsvBIk0/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Lazy Sequence]]></title><description><![CDATA[간만의 iOS 포스팅입니다.WWDC 2023에서&nbsp;**Generalize APIs with parameter packs**&nbsp;를 보고 있습니다.연관 영상으로 타고 내려가다가 WWDC 2022 Design Protocol Interfaces in Swift를 보게 되었습니다.영상에서, lazy squence를 이용한 예시가 나왔는데, 평소에 제가 쓰지 않는 Collection이라서 포스팅하게 되었습니다.
A Sequence containing the same elements as a&nbsp;Base&nbsp;collection, but on which some operations such as&nbsp;map&nbsp;and&nbsp;filter&nbsp;&nbsp;are implemented&nbsp;lazily.
protocol LazySequenceProtocol : Sequence @frozen
struct LazySequence&lt;Base&gt; where Base : Sequence
typealias LazyCollection&lt;T&gt; = LazySequence&lt;T&gt; where T : Collection /** protocol LazySequenceProtocol : Sequence의 Instance Method compactMap()
drop()
filter()
flatMap()
joined()
map()
prefix() **/
lazy 키워드는 sequence가 처리되는 방식을 변경합니다. 예를 들면 lazy 키워드를 사용하지 않은 경우, 전체 Sequence를 처리하고 새로운 Sequence가 저장됩니다.lazy가 사용된 경우에 sequence의 값은 downstream 함수에서 요청 시에 생성됩니다. 값은 저장되지 않고 필요할 때 생성됩니다.코드로 비교를 하면서 확인해 보겠습니다.양의 정수를 요소로 가지는 배열이 있을 때 짝수로 필터링하고 2배를 하는 코드를 작성할게요.&nbsp;// lazy keyword를 사용하지 않은 경우 var numbers: [Int] = [1, 2, 3, 6, 9] let modifiedNumbers = numbers .filter { number in print("Even number filter") return number % 2 == 0 }.map { number -&gt; Int in print("Doubling the number") return number * 2 } print(modifiedNumbers) // 출력결과: /**
Even number filter
Even number filter
Even number filter
Even number filter
Even number filter
Doubling the number
Doubling the number
[4, 12]
**/
modifiedNumbers에서 filter() 코드 블록이 upstream 함수이고, map() 코드 블록이 downstream 함수입니다. 출력된 결과를 확인하면 upstream 함수인 filter를 다 돌고 os에서 임시로 storage에 [2,6]을 할당하고 map 함수를 통과하고 있습니다.이제 lazy가 사용된 경우를 볼게요.&nbsp;// lazy keyword 사용 var numbers: [Int] = [1, 2, 3, 6, 9] let modifiedLazyNumbers = numbers.lazy .filter { number in print("Lazy Even number filter") return number % 2 == 0 }.map { number -&gt; Int in print("Lazy Doubling the number") return number * 2 } print(modifiedLazyNumbers) // 출력결과: /**
LazyMapSequence&lt;LazyFilterSequence&lt;Array&lt;Int&gt;&gt;, Int&gt;(_base: Swift.LazyFilterSequence&lt;Swift.Array&lt;Swift.Int&gt;&gt;(_base: [1, 2, 3, 6, 9], _predicate: (Function)), _transform: (Function))
**/
출력 결과를 확인했을 때, 어떤 구체적인 값을 나타내지 않습니다. 그렇다면, 다음 코드를 추가하고 다시 실행해 보도록 하겠습니다.print(modifiedLazyNumbers.first!) // 출력결과: /**
LazyMapSequence&lt;LazyFilterSequence&lt;Array&lt;Int&gt;&gt;, Int&gt;(_base: Swift.LazyFilterSequence&lt;Swift.Array&lt;Swift.Int&gt;&gt;(_base: [1, 2, 3, 6, 9], _predicate: (Function)), _transform: (Function))
Lazy Even number filter
Lazy Even number filter
Lazy Doubling the number
4
**/
결과가 실제적인 값인 4가 나왔네요. 이렇듯,&nbsp;lazy는 필요할 때 계산한다.라는&nbsp;특징을 확인할 수 있습니다. 좋습니다.우리는 이러한 맥락에서, lazy 키워드가 붙은 경우에 sequence가 처리되는 방식을 이해할 수 있습니다. lazy를 사용하지 않을 때 모든 filter문을 돌고 map 함수를 도는 반면에, lazy를 사용할 때&nbsp; 각각의 element가 순서대로 함수를 통과하는 모습을 확인할 수 있어요.그러면 다음 코드의 실행 결과는 무엇일까요?let modifiedLazyNumbers = numbers.lazy .filter { number in print("Lazy Even number filter") return number % 2 == 0 }.map { number -&gt; Int in print("Lazy Doubling the number") return number * 2 } .reduce(0) { partialResult, ele in return partialResult + 1 }
// 출력결과: /**
Lazy Even number filter
Lazy Even number filter
Lazy Doubling the number
Lazy Even number filter
Lazy Even number filter
Lazy Doubling the number
Lazy Even number filter
**/
.reduce 블록에서 값을 계산해서 처리할 필요가 있기 때문에 위와 같은 결과를 확인할 수 있습니다.lazy sequence에 대해 알아봤는데요. 어떨 때 사용하면 될까요?
intermediate operation이 storage 할당하는 것을 막을 때
불필요한 계산을 피하기 위해서 → 최종 컬렉션의 일부만 필요한 경우
downstream process를 더 빨리 시작하고, upstream process가 다 수행될 때까지 기다릴 필요가 없는 경우
예시를 하나 들면, 1부터 10000까지 소수를 찾아서 어떤 작업을 하는 프로그램이 있다고 가정합시다.(의사코드로 작성)var 양의정수배열 = [1 ... 10000] 양의정수배열
.filter { 요소가 소수입니까?
}
.map { 어떤 작업
} 양의정수배열.lazy
.filter { 요소가 소수입니까?
}
.map { 어떤 작업
}
lazy를 사용하지 않은 경우에는 전체 배열을 필터링하고&nbsp;결과인 배열의 요소에 대해 어떤 작업을 하는 반면에lazy를 사용한 경우에는 배열을 돌 때 요소가&nbsp;소수인 경우 바로 어떤 작업을 하게 됩니다.끝!import Foundation var numbers: [Int] = [1, 2, 3, 6, 9] let modifiedNumbers = numbers .filter { number in print("Even number filter") return number % 2 == 0 }.map { number -&gt; Int in print("Doubling the number") return number * 2 }
//
print(modifiedNumbers) let modifiedLazyNumbers = numbers.lazy .filter { number in print("Lazy Even number filter") return number % 2 == 0 }.map { number -&gt; Int in print("Lazy Doubling the number") return number * 2 }
// .reduce(0) { partialResult, ele in
// return partialResult + 1
// } print(modifiedLazyNumbers)
//print(modifiedLazyNumbers.first!)
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.apple.com/documentation/swift/lazysequenceprotocol" target="_self">https://developer.apple.com/documentation/swift/lazysequenceprotocol</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.avanderlee.com/swift/lazy-collections-arrays/" target="_self">https://www.avanderlee.com/swift/lazy-collections-arrays/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/51917054/why-and-when-to-use-lazy-with-array-in-swift" target="_self">https://stackoverflow.com/questions/51917054/why-and-when-to-use-lazy-with-array-in-swift</a>]]></description><link>ios/lazy-sequence.html</link><guid isPermaLink="false">iOS/Lazy Sequence.md</guid><pubDate>Tue, 31 Dec 2024 05:33:35 GMT</pubDate></item><item><title><![CDATA[Scalable Application 설계부터 구현까지 - (0) 대략의 설계]]></title><description><![CDATA[퇴사를 하고 졸업을 위해 학교에 복학하게 되었는데, 왜인지 모르게 개인 프로젝트를 진행해야 할 것 같은 느낌이 듭니다. 그래서 확장 가능한 어플리케이션을 만들어보겠습니다. 꽤나 장기 프로젝트, 포스팅이 될 것 같은데 꾸준히 이어나가도록 할게요. 사실 어떤 어플리케이션을 만들지는 아직 생각하지는 않았습니다. 정해지지 않았어요. 하지만 아직 아이디어가 없어도 어떤 방식으로 개발을 할 수 있을지는 충분히 가능하기 때문에 선 블로그 포스팅을 먼저 하도록 하겠습니다.요즘 어플리케이션 개발에 대한 생각이 바뀌었습니다. 예전에는 화려한 기술 스택, 어려운 프레임워크 사용하는 것을 선망했고 도입하기 위해 정말 애썼는데 정작 중요한 것을 많이 놓쳤다는 느낌을 받았습니다. 그래서 이번에는 기준을 잡고 천천히 기초를 다지면서 어플리케이션을 개발하려고 합니다.&nbsp;(하지만 쓰고 싶은 라이브러리는 쓰겠습니다.)처음부터 완벽할 수는 없다고 생각합니다. 특히나 저에게는요. 그래서 먼저 얼개를 draw.io를 통해서 그릴 것입니다.그리고 아이디어가 확정이 되면 어떤 기능들 필요한 지 생각해보고 이에 맞게 의존성을 수정하려고 합니다. 한번 그려볼게요.<img src="https://blog.kakaocdn.net/dn/coJPBI/btr7d9RpZ60/80trKYFfJ6fjchcRMwKmoK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Application: App 전체에 관한 Project 입니다. UIKit인 경우에 AppDelegate, SceneDelegate가 존재합니다. 최상단 모듈이기 때문에 아래에 있는 모듈을 import 해서 접근할 수 있습니다. 따라서 이 모듈에서 우리의 어플리케이션이 작동하게 될 것입니다.
기능: 문자 말그대로 기능이 있는 모듈입니다. 예를 들면 검색이 될 수 있고, 채팅이 될 수 있습니다. 이 기능들은 UI를 가질 수도 있고 가지지 않을 수도 있습니다. Dependency: 모든 기능들은 이 Base를 가져야 합니다. 모듈 간의 결합을 도와주는 모듈로도 사용할 수 있습니다.&nbsp; Network: 서버 통신을 위한 모듈입니다. 이 모듈에 Network Layer가 존재합니다. Design: DesignSystem에 대한 모듈입니다. 이곳에 각종 Asset과 UIComponent를 넣도록 하겠습니다. Util: 개발 효율을 높여주는 모듈입니다. 각종 Extension에 대한 소스를 가지고 있습니다. 사실 글의 첫 시작은 Tuist로 시작하려고 했는데 Tuist에 대해서 글을 쓰려면 대략적으로 제가 어떤 방식으로 설계를 했는지 알아야 될 것 같아서 짧은 글이지만 0번으로 작성하게 되었습니다.
]]></description><link>ios/scalable-application-설계부터-구현까지-(0)-대략의-설계.html</link><guid isPermaLink="false">iOS/Scalable Application 설계부터 구현까지 - (0) 대략의 설계.md</guid><pubDate>Tue, 31 Dec 2024 05:32:08 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/coJPBI/btr7d9RpZ60/80trKYFfJ6fjchcRMwKmoK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/coJPBI/btr7d9RpZ60/80trKYFfJ6fjchcRMwKmoK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[@testable import와  빌드 환경 구성 (Build Environment Configuration) 그리고 에러]]></title><description><![CDATA[출시할 어플리케이션을 개발할 때 빌드 환경을 구성하는 것이 좋다고 생각합니다. 왜냐하면 추후에 개발 서버를 바라보고 있는 어플리케이션, 실제 서버를 바라보고 있는 어플리케이션을 파일 하나로 관리할 수 있어서요. .xcconfig file에 샥샥샥 하면 손쉽게 관리 가능합니다.&nbsp;요즘 저는 테스팅을 공부하고 있습니다. 제가 진행하고 있는 사이드 프로젝트에서도 테스트를 도입하고 싶어서 기존에 있는 기능에 테스트 코드를 작성하려고 했습니다. 유닛테스트 케이스를 생성하고 테스트를 하려고 하는데 예제에서 많이 보던 @testable import 'myProject'를 했는데 다음과 같은 에러가 발생했습니다.<img src="https://blog.kakaocdn.net/dn/mbkn5/btr6tX3qHqO/aCEgvC9kkSEfKcWce61a6K/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">먼저 @testable은 뭘까요? 우리가 기본적으로 Unit Test를 하기 위해서는 Unit Test Target을 만들어서 진행하게 됩니다.우리가 테스트 코드를 작성할 Unit Test Class에서 우리의 App Target에 바로 접근할 수 없어요. 왜냐하면 Target들은 별도의 모듈로 처리 되기 때문입니다. 그래서 import를 해야 합니다. 따라서 역시&nbsp;internal(아무것도 안 붙이면 자동으로 internal로 선언됨)에 접근할 수가 없어요.import UIKit // TestableImport 타겟임! // ViewController.swift class ViewController: UIViewController { private let text: String init(text: String) { self.text = text super.init(nibName: nil, bundle: nil) } required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") } override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .red guard let bundleID = Bundle.main.bundleIdentifier else { return } }
<br><img src="https://blog.kakaocdn.net/dn/o3sgZ/btr6qNNFQGh/4MYA16uMOU3f1hxsTM7xJ0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하지만 우리는 소프트웨어 공학적으로, 모든 것을 open과 public으로 선언하지 않잖아요? 그래서 @testable이 필요한 겁니다.@testable import TestableImport
이렇게 선언하면 우리의 Main Target에 있는 internal에 접근할 수 있어요.이제 위에서 언급한 제 프로젝트에서 에러가 발생하는 상황을 설명할게요.
Project Configuration 설정 총 환경 3개를 사용 - Development, Staging, Production 각각 하나의 앱을 구성할 수 있기에 앱마다 Debug, Release가 있기 때문에 총 3 * 2 = 6개의 Configuration이 구성됨 Debug(Development), Release(Development), etc.. 3개의 환경 (Development, Staging, Production)은 xcconfig file로 관리
Unit Test Target 생성
@testable import 'MainTarget'
internal 코드들 자동 완성 가능
테스트 코드 작성 가능 테스트 성공
그런데 위처럼 빨간 줄
테스트 코드 작성은 잘 되고, 테스트도 잘됩니다. 그런데 저렇게 계속 빨갛게 버그처럼 사라지지 않고 있습니다. 혹시 클린빌드를 하면 될까 Xcode를 껐다 켜면 없어질까 싶어서 해봤는데 되지 않았습니다. 그래서, Sample App을 만들어서 버그를 재현해 보도록 할게요.먼저 App을 만들고 Build 환경을 구성합니다. 여기에서는 Staging을 안 쓰고 4개만 만들도록 할게요.먼저 xcconfig 파일 두 개(Development, Production)를 만들고 Configuration을 펼쳐서 아래에 있는 +를 클릭하고 Duplicate Debug 한번, Duplicate Release 한번 눌러줍니다. 그리고 이름을 바꿔주세요.<br><img src="https://blog.kakaocdn.net/dn/mbhAV/btr6g8Z4biV/FHgER9ZDkMrAwf9C3oyFIK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">빌드 설정이 잘 되어 있는 것을 신뢰하기 위해서, xcconfig에 코드를 작성하겠습니다. Bundle Identifier를 설정하는 코드입니다.//
// Development.xcconfig
// TestableImport PRODUCT_BUNDLE_IDENTIFIER = com.dev.hose.TestableImport.Development
//
// Production.xcconfig
// TestableImport PRODUCT_BUNDLE_IDENTIFIER = com.dev.hose.TestableImport
그러고 나서 Project -&gt; Target -&gt; Signing &amp; Capabilities에 가면 우리가 설정한 Configuration 총 4개가 있을 거예요.&nbsp;Bundle Identifier를 $(PRODUCT_BUNDLE_IDENTIFIER)로 입력합니다. 그러면 다음과 같이 될 거예요.<br><img src="https://blog.kakaocdn.net/dn/cllnVE/btr6tXClClI/Ur4edaiK4nhLgId8jx1ktK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 빌드 환경 설정은 거의 다 끝났어요. 이제 하나의 코드로 2개의 앱을 만들 수 있게 할 거예요. Scheme을 이용하면 됩니다.Scheme 바꾸는 곳 ( 시뮬레이터 바꾸는 위치 왼쪽)을 누르고 Edit Scheme을 클릭하면 아래 왼쪽과 같이 뜰 겁니다.그러면 왼쪽에 있는 것들 (Run, Test, Profile, Analyze, Archive) 눌러서 아래처럼 빌드 환경에 맞게 설정합니다.&nbsp;그런 다음에 Duplicate Sceme을 눌러서 'TargetName'(Development)으로 바꿔주고 이것 역시 빌드 환경을 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/bHVHdV/btr6pGBf201/hUMrxOmcc0nJQjkkcR2JrK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/D3yW9/btr6pGgYbXJ/UfMLbc3Zhk0NqBlJu8jcBk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이렇게 하면 빌드 환경 설정은 끝이 납니다. 아래에서 확인할 수 있듯이 문제없이 잘 돌아가고 있어요.<br><img src="https://blog.kakaocdn.net/dn/buPbNv/btr53IudVAb/BF60BOxkxUvdZ2iquHV0yK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/BNH8K/btr6eWlb2H4/JZx5R7wt54DPrDeK5ek97K/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 테스트 코드를 작성하는 곳으로 돌아가겠습니다. Unit Test Target라서, 별도의 타깃이기 때문에 @testable 어노테이션을 붙여주겠습니다. 테스트를 하기 위해서 위해서 ViewController에서 private으로 선언한 text를 internal로 선언하겠습니다. 그리고 테스트를 작성할게요. 테스트를 작성하고 테스트 (Command + U)를 하면 성공적으로 테스트할 수 있습니다. 당연하게 internal로 선언된 것들도 모두 접근할 수 있고요. 하지만 아래처럼 빨간 줄은 역시 사라지지 않습니다.<br><img src="https://blog.kakaocdn.net/dn/DApwt/btr6oe6tR1U/Lp4FEw9Z7rw6tVdORcYCWk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이상합니다.TestableImport(Development)의 Test는 아까 Debug(Development)로 설정했고TestableImprot의 Test도 역시 Debug(Production)으로 설정했습니다. 따라서 저 빨간 줄도 사라져야 된다고 생각합니다. 이 이슈에 대해서 'Module '' was not compiled for testing'으로 많은 시간을 검색해 봤는데 대부분 Enable Testability = YES로 설정하라는 답변이 대부분이었습니다.<br><img src="https://blog.kakaocdn.net/dn/QX71d/btr6oXQMWqL/0qIq3atf7rNJUvPdg97hK0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Debug는 디폴트로 Enable Testability가 Yes이기 때문에 의미가 없었습니다.stackoverflow, apple developer forum에서 제시한 해결책들을 시도했으나 다 실패했습니다.그런데 이것저것 시도해 보다가 두 가지 방법을 찾았습니다.첫 번째 방법은 Productuon에서도 Enable Testability = YES로 설정을 하는 것입니다. 그랬을 때 빨간 줄이 사라졌습니다.<br><img src="https://blog.kakaocdn.net/dn/edVyIB/btr6qOTnJsH/ykkmDtmQ5FK6NhWlED3qjK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bkzvTy/btr6qrjEZSn/WP35oviZ1jvNi1lKM7UYm1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Productuon에서도 Enable Testability를 지워주면 다시 빨간 줄이 생깁니다.두 번째 방법은 Project Configuration에서 Debug를 하나 더 만드는 것입니다.<br><img src="https://blog.kakaocdn.net/dn/cqrFvR/btr53ESUgpQ/2ifuQUTKT7ZSPQRMCqqRp0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그리고 끝입니다? 테스트를 진행하면, 빨간 줄이 사라집니다. 그냥 Configuration을 만드는 것만으로 빨간 줄이 사라집니다.
이 문단은 상상의 나래입니다. 틀릴 확률이 매우 높습니다.
왜 위의 두 가지 방법이 빨간 줄을 없앤 걸까요?첫 번째 방법은 모든 설정을 Testability가 가능하게 했으니, 컴파일러가 @testable에 대해서 신경 쓰지 않는 것 같습니다.두 번째 방법은 Debug Configuration이 있는 것만으로 빨간 줄이 사라졌는데 Unit Test Target의 configuration가 debug로 설정되어 있는 것 같습니다. 그래서 컴파일러가 Debug Configuration이 없으면 Testable을 사용할 수 없다고 에러를 띄우는 것 같아요.Swift Package Manager도 custom configuration을 적용할 수 없는 이슈가 있는데 이와 비슷한 이유이지 않을까 싶습니다.&nbsp;혹시 이것에 대해서 해결한 적이 있으시거나 이유를 아시는 분이면 알려주시면 감사하겠습니다. 쓰고 보니까 빌드 환경 구성 글 같아 보이네요.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/TestableImport" target="_self">https://github.com/psychehose/TestableImport</a>]]></description><link>ios/@testable-import와-빌드-환경-구성-(build-environment-configuration)-그리고-에러.html</link><guid isPermaLink="false">iOS/@testable import와  빌드 환경 구성 (Build Environment Configuration) 그리고 에러.md</guid><pubDate>Tue, 31 Dec 2024 05:26:02 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/mbkn5/btr6tX3qHqO/aCEgvC9kkSEfKcWce61a6K/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/mbkn5/btr6tX3qHqO/aCEgvC9kkSEfKcWce61a6K/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unit Test와 TDD - 근데 이게 async await를 곁들인]]></title><description><![CDATA[유닛 테스트는 테스트 케이스를 작성하는 절차로써 특정 모듈이 정확히 작동하는지 검증하는 절차입니다.
문제점을 발견하기 쉽다
-&gt; 프로그램을 독립적인 작은 단위로 쪼개서 검사하기 때문에 잘못된 점을 빠르게 발견할 수 있다. → 디버깅 시간의 단축
변경이 쉽다.
-&gt; 코드 리팩토링시에 유용하다. 리팩토링 후에도 의도대로 작동하고 있음을 유닛 테스트를 통해 확신할 수 있다.
통합이 쉽다.
-&gt; 유닛 테스트는 유닛 자체의 불확실성을 제거해 준다. 그렇기 때문에 유닛들의 통합들을 검증하는 Integration Test에서 유용하다.
Testing 할 때, 가장 좋은 관행(Practice)은 FIRST이다.
Fast:&nbsp;테스트들은 빠르게 실행되어야만 한다.
Independent / Isolated:&nbsp;테스트들은 서로 state를 공유해서는 안된다. (독립적)
Repeatable:&nbsp;검사를 할 때마다 동일한 결과를 얻어야 한다.
Self-validating:&nbsp;테스트들은 automated 여야 한다. 결과는 "Pass or Fail" 이여야 한다.
Timely:&nbsp;이상적으로 Production Code를 만들기 전에, Test Code부터 작성해야 한다.(TDD)
TDD는 테스트 주도 개발이라는 뜻으로, 테스트를 먼저 작성하고 그것이 통과하는 코드를 작성하는 개발 방법론입니다. TDD는 다음과 같은 기본적인 원칙에 따라 개발됩니다.<img src="https://blog.kakaocdn.net/dn/SLAXa/btr3XzeOz6m/jHDqIOdvfH0lcWCpgrOKBK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
자동화된 테스트 케이스를 작성한다.
&lt; RED &gt;: 테스트를 실행하면 실패하는 것을 확인한 후 코드를 작성한다.
&lt; GREEN &gt;: 작성한 코드를 테스트를 통과시킨다.
&lt; REFATOR&gt;: 리팩토링을 통해 중복 코드를 제거하고 더 나은 코드를 만든다.
장점
코드의 품질을 높일 수 있고, 버그를 줄일 수 있다
기능 추가나 수정을 할 때 기존 코드에 영향을 미치지 않도록 하며 코드의 유지보수가 용이해진다.
단점
초기에 작성하는 테스트 케이스와 코드의 품질이 좋지 않을 경우, 전체적인 개발 프로세스가 더욱 지연될 수 있다.
프로그램 개발 전에, 테스트 코드부터 작성하므로 전체적인 생산성이 저하할 수 있다
아이디 유효성 검증을 하는 Validator를 구현해야 한다고 합시다. 먼저&nbsp;요구사항을 살펴보고 Validator를 구현하도록 합시다.
요구사항: 아이디는 반드시 알파벳 소문자로 시작해야 하며, 알파벳 소문자와 숫자를 포함하여 5자 이상 12자 이하로 한다.
Validator를 쉽게 테스트하기 위해서 객체로 만듭니다. 그리고 유효성 검증 패턴을 정규 표현식으로 작성해 주고 이에 어긋날 시 false, 만족하면 true를 리턴하는 함수를 만듭니다. 우리는 이 Validator 객체를 신뢰하기 위해서 함수를 테스트하면 됩니다.// Validator.swift import Foundation public struct Validator { public init() { } private let idValidationPattern: String = "^[a-z]{1}[a-z0-9]{4,11}$"
} public extension Validator { func idValidateByClient(_ input: String) -&gt; Bool { guard let regex = try? NSRegularExpression( pattern: idValidationPattern, options: [] ) else { assertionFailure("Regex not valid") return false } let regexFirstMatch = regex .firstMatch( in: input, options: [], range: NSRange(location: 0, length: input.count) ) return regexFirstMatch != nil }
}
Project에서 command + 6을 누르고 왼쪽 하단에 + 버튼을 클릭해서 유닛 테스트를 추가합니다.테스트하고 싶은 모듈을 @testable Import 하고 setUpWithError에서 테스트하고 싶은 객체를 선언해 줍니다.import XCTest
@testable import Validator final class ValidatorTests: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() sut = Validator() } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() }
}
TDD 방법론에 따라서 먼저 실패하는 케이스를 적용해 보면 되겠습니다. 어떤 케이스가 실패를 할까요? TDD의 핵심은 바로 이런 테스트 시나리오를 짜는 것이라고 생각합니다.테스트 시나리오를 쉽게 생각하기 위해서는&nbsp;Given,&nbsp;When,&nbsp;Then으로 나눠서 생각하는 것이 좋다고 합니다.다음과 같은 테스트 케이스(Given)는 테스트시에(When) 실패(Then)해야만 합니다.
1psychehose → 숫자로 시작함
_psychehose → 특수문자로 시작함
Psychehose → 대문자로 시작함
김psychehose → 한글로 시작함
psychehose! → 특수문자 포함
a → 1글자
abcd → 4글자
abcde12345678 → 13글자
테스트 함수 코드는&nbsp;무조건 앞에 test가 붙어야 합니다. 그리고 테스트 결과를 알기 위해&nbsp;XCTAssertEqual&nbsp;함수를 이용할 건데, 사용하기 정말 쉽습니다. 매개변수 1과 매개변수 2를 비교해서 같으면 성공, 다르면 실패합니다. 따라서 실패 케이스를 작성할 때&nbsp;XCTAssertEqual(result, true)는 실패해야 합니다. 그러면 위의 실패하는 테스트 케이스를 바탕으로 코드를 작성해 보겠습니다.import XCTest
@testable import Validator final class ValidatorTests: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() sut = Validator() } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func testFailFirstNumberID() throws { // Given let id = "1psychese" // When let result = sut.idValidateByClient(id) // Then XCTAssertEqual(result, true) } func testFailFirstSpecialSymbolID() throws { let id = "_psychehose" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailFirstCaptialID() throws { let id = "Psychehose" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailFirstKoreanID() throws { let id = "김psychehose" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailOneLetterID() throws { let id = "p" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailFourLetterLetterID() { let id = "abcd" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailThirteenLetterID() throws { let id = "abcde12345678" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testFailIDWithSymbol() throws { let id = "ab!cdef" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) }
}
<br><img src="https://blog.kakaocdn.net/dn/8lEPE/btr3WaTHqhQ/P30kT6HEIA3m5KweKrzusk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">원하는 대로 실패하는 결과값이 잘 나온 것 같습니다. 만약 여기에서, 원하는 결과값이 나오지 않는다면 코드 리팩토링을 진행하면 되겠습니다. 그러면 이제 통과하는 케이스를 바탕으로 코드를 작성하겠습니다.다음과 같은 테스트 케이스(Given)는 테스트시에(When) 성공(Then)해야만 합니다.
abcde
psychehose
abcdeabcdeab
abcd1234
a1b2c3d4
import XCTest
@testable import Validator final class ValidatorTests: XCTestCase { // ... // ... func testSuccessFiveLetterID() throws { let id = "abcde" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessID() throws { let id = "psychehose" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessTwelveLetterID() throws { let id = "abcdeabcdeab" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessIDWithNumber1() throws { let id = "abcd1234" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) } func testSuccessIDWithNumber2() throws { let id = "a1b2c3d4" let result = sut.idValidateByClient(id) XCTAssertEqual(result, true) }
}
<br><img src="https://blog.kakaocdn.net/dn/bqktVJ/btr35EePQWY/sOPslnmvnaKImxBXk1xLv0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이번에도 원하는 대로 성공하는 결괏값이 잘 나온 것 같습니다. 만약 여기에서 실패한다면 코드 리팩토링을 해야만 합니다. 그리고 다시 실패 케이스 단계로 돌아가야만 합니다. 이 과정을 반복하면서 개발을 완료하도록 합니다.
주의) 이 단락은 저의 생각을 많이 담고 있습니다. 정답이 아니고 제 개인적인 생각이니 주의해서 읽어주세요. 틀린 점이 있거나 자신의 생각과 다른 점이 있으면 알려주시면 감사하겠습니다.
비동기처리의 대표적인 예는 서버 통신이 있습니다. 사용자가 회원가입을 하는 상황을 생각해 봅시다. 아이디란에 아이디를 입력하고 위에서 작성한 아이디 유효성 검사를 무사히 통과했습니다. 이게 끝이 아닌 걸 압니다. 앱은 이 아이디를 서버에 보내고 서버는 데이터베이스에서 조회해 아이디 중복 검사를 합니다. 우리가 중복검사를 하고자 하는 아이디를 서버에 보내고 그 결과가 올 때까지 우리는 기다려야 합니다. 즉 우리는 비동기 함수를 작성해야 합니다. 그러면 비동기 함수는 어떻게 테스트하면 될까요?&nbsp;사실 이 부분을 넣을까 고민했었습니다. 'Validator의 역할(책임)을 어디까지로 잡을 것인가' 대해 생각해 봤을 때 의문이 들었습니다.
위의 상황처럼 Validator에서 서버 통신을 하고 백엔드에서 최종적으로 유효성 검사(아이디 중복여부, 아이디 형식)를 해서 회원가입 여부를 Response 값으로 던져준다. 즉 Validator는&nbsp;네트워크 의존성을 가지고 서버 통신 테스트를 작성해야 함
Validator는 로컬에서 아이디 형식에 대한 유효성 검사만 한다. - 이 경우에 위의 상황 테스트는 Validator와 Network를 같이 알고 있는 상위 모듈이나 ViewModel, Interactor 같은 곳에서 테스트하게 됨.
<br><img src="https://blog.kakaocdn.net/dn/boF5CY/btr5AAwdUlO/sfnmCVkgUo1ZVbZCHjKaG0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/cVpKcQ/btr5AOHJmHa/wNgkM1gMHkOhEugnQKpJ80/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">왼쪽: 1번 경우, 오른쪽: 2번 경우따라서 어떤 '구조'를 가지고 있느냐가 어떤&nbsp;테스트 코드를 작성할지&nbsp;결정하는&nbsp;것 같습니다.저는 네트워크 모듈을 따로 만들어서 사용하고 Validator는 어떠한 의존성도 가지지 않게 개발했습니다. 그렇기에 Validator에서 비동기를 처리하는 함수를 만들지 않았습니다.&nbsp;다만 이 포스팅은 유닛테스트 전반적인 것에 대해서 쓰고 싶기 때문에, 1번 경우로 가정(회원가입 여부: Boolean을 받음)을 하고 테스트 코드를 작성하겠습니다.서버 통신 테스트 방법은 두 가지가 있어요.&nbsp;
앱에서 만든 가짜 서버와 통신하는 것 - Mock Test
실제 서버와 통신하는 것 - Slow Test
실제 작업을 할 때,&nbsp; 프로젝트 시작 단계에서 기획 문서 하나만 있는 경우가 있을 수도 있습니다. 이때 Mock을 만들어서 서버 통신을 테스트할 수 있습니다. 먼저 Validator에 코드 추가를 하겠습니다.Response 결과는 [Bool] type으로 받겠습니다.&nbsp;(key 이름 짓기 귀찮아서)// Validator.swift
import Foundation public struct Validator { public init(configuration: URLSessionConfiguration = .default) { self.configuration = configuration } private let configuration: URLSessionConfiguration private let idValidationPattern: String = "^[a-z]{1}[a-z0-9]{4,11}$" private var session: URLSession { return URLSession(configuration: self.configuration) }
} public extension Validator { func isValidationFromServer(_ url: URL) async throws -&gt; Bool { let url = url let urlRequest = URLRequest(url: url) let (data, _) = try await session.data(for: urlRequest) guard let isValidate = try JSONDecoder().decode([Bool].self, from: data).first else { throw NSError(domain: "No Data", code: -1) } return isValidate }
}
Validator에서 서버 통신을 할 것이기 때문에, Validator가 URLSession을 가지고 있어야 해요. 이 때 Session Configuration을 주입받을 수 있게 해 주세요.이제&nbsp;isValidationFromServer&nbsp;함수를 한번 살펴볼게요. 다른 함수와 다르게 async 키워드가 매개변수 오른쪽에 붙어있는 것을 확인할 수 있습니다. 이것은 비동기 함수라는 뜻입니다.let (data, _) = try&nbsp;await&nbsp;session.data()를 보면 await 키워드를 확인할 수 있어요. await는 무엇일까요?&nbsp; 애플이 구현해놓은 session.data() 함수를 한번 확인하면 알 수 있습니다. public func data( for request: URLRequest, delegate: URLSessionTaskDelegate? = nil ) async throws -&gt; (Data, URLResponse) /// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally. /// /// - Parameter url: The URL for which to load data. /// - Parameter delegate: Task-specific delegate. /// - Returns: Data and response.
awai는 문자 그대로&nbsp; '기다린다'라는 뜻입니다. 그러면 무엇을 기다릴까요? 애플이 구현해놓은 .data(for:)에서&nbsp;async&nbsp;키워드가 보이시나요? await는 async를 기다린다고 할 수 있겠네요.Mock으로 Test를 진행해야 하는데요. 이것은 Validator를 생성할 때 주입하는&nbsp;URLSessionConfiguration의 property인&nbsp;protocolClasses&nbsp;값을 설정하면 값을 하이재킹 할 수 있습니다. MockURLProtocol을 구현하도록 하겠습니다.&nbsp;// MockURLProtocol.swift import Foundation
typealias CustomResponse = Result&lt;Data, Error&gt; class MockURLProtocol: URLProtocol { static var responseHandler: ((URLRequest) throws -&gt; (response: HTTPURLResponse, data: CustomResponse))? override class func canInit(with request: URLRequest) -&gt; Bool { return true } override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest { return request } override func startLoading() { guard let handler = MockURLProtocol.responseHandler else { return } do { let result = try handler(request) let httpResponse = result.response let customResponse = result.data switch customResponse { case .success(let data): client?.urlProtocol(self, didReceive: httpResponse, cacheStoragePolicy: .notAllowed) client?.urlProtocol(self, didLoad: data) client?.urlProtocolDidFinishLoading(self) case .failure(let error): client?.urlProtocol(self, didFailWithError: error) } } catch { client?.urlProtocol(self, didFailWithError: error) } } override func stopLoading() { debugPrint("Stop Loading") }
}
여기까지 구현하면 드디어 Mock으로 Unit Test를 할 수 있게 됩니다.유닛테스트 파일을 생성하고 테스트 코드를 작성하면 되겠습니다. 저는 ValidatorMockTest.swift로 파일을 만들게요.import Foundation
import XCTest
@testable import Validator final class ValidatorMockTest: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() let config = URLSessionConfiguration.ephemeral config.protocolClasses = [MockURLProtocol.self] sut = Validator(configuration: config) } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func test_available_from_mock() async throws { // Mock을 생성 -&gt; 이것이 우리가 받을 결과임 MockURLProtocol.responseHandler = { request in let response = HTTPURLResponse( url: request.url!, statusCode: 200, httpVersion: nil, headerFields: nil )! let mockResult: [Bool] = [true] let mockResponseData = try! JSONEncoder().encode(mockResult) let responseData = CustomResponse.success(mockResponseData) return (response, responseData) }
// URL에 "https://" 이런식으로 말이 되는 URL 넣으면 됩니다. scheme host 다 있어야함 let testTargetValue = try await sut.isValidationFromServer(URL(string: "https://www.test11111.com")!) XCTAssertEqual(testTargetValue, true) } func test_no_available_from_mock() async throws { MockURLProtocol.responseHandler = { request in let response = HTTPURLResponse( url: request.url!, statusCode: 200, httpVersion: nil, headerFields: nil )! let mockResult: [Bool] = [false] let mockResponseData = try! JSONEncoder().encode(mockResult) let responseData = CustomResponse.success(mockResponseData) return (response, responseData) } let testTargetValue = try await sut.isValidationFromServer(URL(string: "https://www.test11111.com")!) XCTAssertEqual(testTargetValue, false) } func test_empty_error_from_mock() async throws { MockURLProtocol.responseHandler = { request in let response = HTTPURLResponse( url: request.url!, statusCode: 404, httpVersion: nil, headerFields: nil )! let mockResult: [Bool] = [] let mockResponseData = try! JSONEncoder().encode(mockResult) let responseData = CustomResponse.failure(NSError(domain: "No data. Empty", code: -10)) return (response, responseData) } let testTargetValue = try await sut.isValidationFromServer(URL(string: "https://www.test11111.com")!) XCTAssertEqual(testTargetValue, false) }
}
이제 코드 보시면 완전히 이해가 갈 것에요. 주의할 점은 setupWithError에서 Validator를 생성할 때 Configuration의 protocolClassese에&nbsp;[MockURLProtocol.self]를 꼭 넣어줘야 합니다. 그래야 값을 Mock Response 값을 받을 수 있어요.<br><img src="https://blog.kakaocdn.net/dn/dY99TU/btr5N3StqIK/mklb1GFX0duc6c1T3qR9Ek/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">마지막으로 실제 서버로 하는 테스트 코드를 작성해 볼게요. 자신이 가지고 있는 실제 서버가 없으면 Postman을 통해서 Mock Server를 손쉽게 만들 수 있습니다. 'postman mock server'로 검색하면 다양한 포스팅을 확인할 수 있을 거예요.<br><img src="https://blog.kakaocdn.net/dn/6BdrF/btr5N3LLvql/fXd4uG18FlgqUnRlOOSXK1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">저는 총 세 가지 경우를 테스트할 거예요.(실제 API 테스트이기 때문에 config의 protocolClassess 넣는 코드를 주석처리 하거나 삭제해야 합니다. 그리고 아래 코드에서 url에 자신의 서버 URL을 입력하시면 됩니다.)
&nbsp;회원가입 가능: endpoint - available, 결과 - [true]
&nbsp;회원가입 불가능: endpoint - noavailable, 결과 - [false]
&nbsp;에러: endpoint - empty, 결과 - []
import Foundation
import XCTest
@testable import Validator final class ValidatorSlowTest: XCTestCase { var sut: Validator! override func setUpWithError() throws { try super.setUpWithError() let config = URLSessionConfiguration.ephemeral sut = Validator(configuration: config) } override func tearDownWithError() throws { sut = nil try super.tearDownWithError() } func test_available_api_test() async throws{ guard let url = URL( string: "" ) else { return } let result = try await sut.isValidationFromServer(url) XCTAssertEqual(result, true) } func test_no_available_api_test() async throws{ guard let url = URL( string: "" ) else { return } let result = try await sut.isValidationFromServer(url) XCTAssertEqual(result, false) } func test_empty_api_test() async throws{ guard let url = URL( string: "" ) else { return } let result = try await sut.isValidationFromServer(url) XCTAssertEqual(result, true) }
}
<br><img src="https://blog.kakaocdn.net/dn/b7vDo2/btr5PbWC4Zu/3igzX1RKFfgQUyGKAjRgxk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">&nbsp;Unit Test에 대해 전반적으로 알아봤습니다. GitHub을 구경하거나, 회사 공고를 보면 대부분 MVVM, VIPER(RIBs) 패턴을 사용하고 있는 것 같습니다. 그렇기 때문에 저것들을 공부했었는데요. 왜 사용하냐고 물어보면 로직이 분리되어 있어서 코드 관리가 용이하다, 테스트가 용이하다 같은 말들을 하곤 했습니다. 그러다가 실제로 테스트 코드를 작성해야 할 일이 생겼는데 '테스트 코드를 대체 어떻게 작성해야 하지?' 같은 생각이 들어 멘탈이 나간 적이 있어요. 그때 중요한 걸 놓쳤다는 생각이 들었습니다. 이번 포스팅을 통해서, 테스트 코드와 조금 친해진 거 같아서 꽤나 뿌듯합니다. 테스트와 베스트 프렌드가 되고 싶기 때문에 조만간 MVVM 테스트에 대해 공부하고 포스팅해보고 싶습니다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/UnitTestForValidator" target="_self">https://github.com/psychehose/UnitTestForValidator</a>Reference<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.apple.com/videos/play/wwdc2018/417/" target="_self">https://developer.apple.com/videos/play/wwdc2018/417/</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://swiftsenpai.com/swift/async-await-network-requests/" target="_self">https://swiftsenpai.com/swift/async-await-network-requests/</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.swiftbysundell.com/articles/unit-testing-code-that-uses-async-await/" target="_self">https://www.swiftbysundell.com/articles/unit-testing-code-that-uses-async-await/</a><br><a data-tooltip-position="top" aria-label="https://xtring-dev.tistory.com/entry/Postman-Postman-Mock-Server%EB%A5%BC-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-Front-end-%EC%84%A0%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0%ED%98%91%EC%97%85" rel="noopener nofollow" class="external-link is-unresolved" href="https://xtring-dev.tistory.com/entry/Postman-Postman-Mock-Server%EB%A5%BC-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-Front-end-%EC%84%A0%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0%ED%98%91%EC%97%85" target="_self">https://xtring-dev.tistory.com/entry/Postman-Postman-Mock-Server를-구축하기-Front-end-선개발하기협업</a><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kodeco.com/21020457-ios-unit-testing-and-ui-testing-tutorial" target="_self">https://www.kodeco.com/21020457-ios-unit-testing-and-ui-testing-tutorial</a>]]></description><link>ios/unit-test와-tdd-근데-이게-async-await를-곁들인.html</link><guid isPermaLink="false">iOS/Unit Test와 TDD - 근데 이게 async await를 곁들인.md</guid><pubDate>Tue, 31 Dec 2024 05:25:25 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/SLAXa/btr3XzeOz6m/jHDqIOdvfH0lcWCpgrOKBK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/SLAXa/btr3XzeOz6m/jHDqIOdvfH0lcWCpgrOKBK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[드래그가 가능한 BottomSheet를 만들어보자(DraggableBottomSheet )]]></title><description><![CDATA[&nbsp;Ounce를 개발할 때, 버튼을 누르면 밑에서 present modal 방식으로 올라오는 뷰를 만든 적이 있습니다. 다만 그때 시간이 촉박해서 애플이 기본적으로 제공하는 방식으로 구현했습니다.잠깐 코드를 가져와보겠습니다.let targetVC = ViewController()
targetVC.modalPresentationStyle = .popover
self.present(targetVC, animated: true, completion: nil)
이제는 좀 더 나아가서 드래그가 가능하고 이전의 뷰가 백그라운드 처리가 되어 있는 뷰를 만들어보겠습니다.&nbsp;뷰의 전환은 ViewController → BottomCardViewController입니다.먼저 구현에 필요한 extension을 추가하겠습니다. 화면 전환을 할 때 현재 화면(ViewController)의 스냅샷을 찍어서 화면 전환한 후 (BottomSheetViewController)의 배경화면으로 사용할 겁니다. 그리고 ViewController에서 사용할 화면전환 함수를 만들 것인데 저는 tapGestureRecognizer를 이용하도록 할게요.// UIView+Snapshot.swift extension UIView { // render the view within the view's bounds, then capture it as image func asImage() -&gt; UIImage { let renderer = UIGraphicsImageRenderer(bounds: bounds) return renderer.image(actions: { rendererContext in layer.render(in: rendererContext.cgContext) }) }
}
//UIViewController.swift let tapGesture = UITapGestureRecognizer(target: self, action: #selector(self.tapImageView(_:))) @objc func tapImageView(_ sender:UITapGestureRecognizer) { let bottomCardViewController = BottomCardViewController() bottomCardViewController.modalPresentationStyle = .fullScreen bottomCardViewController.backgroundImage = view.asImage() self.present(bottomCardViewController, animated: false, completion: nil) }
여기까지 작성하면 ViewController에서 해야 할 일은 끝났습니다.이제 BottomCardViewController를 만들겠습니다. BottomCardViewController는 다음과 같은 UIComponet와 Property들이 필요하다.
배경을 투명하게 만들어 주는&nbsp;dimmerView: UIView
cardView: UIView
backgroundImage: UIImage - 스냅샷 이미지
스냅샷으로 넘겨받은 이미지를 담는 UIImageView
cardViewTopConstraints: NSLayoutConstraint - 드래그를 할 때 이 값의 변화에 따라 실제로 뷰가 움직입니다.
처음에 화면 전환을 할 때, 아래에서부터 cardView가 올라와야 하기 때문에 viewDidLoad에 다음과 같이 레이아웃을 잡았습니다. cardView의 Top Constraint를 잡은 것을 보면 카드뷰의 Top이 우리가 화면에서 보는 뷰 바로 아래에 위치하는 것을 알 수 있습니다.func setupViews() { if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint = cardView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: safeAreaHeight + bottomPadding) } cardView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true cardView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true cardView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true NSLayoutConstraint.activate([cardViewTopConstraint])
}
그러고 나서 viewDidAppear에서&nbsp;카드뷰를 올라오게 하는 함수를 사용하면 되겠네요.카드뷰를 올라오게 하는 함수 showCard()를 어떻게 구현하면 될까요?
dimmerView의 alpha 값을 조절
cardView의 topConstraint의 값을 조절
private func showCard() { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication .shared .windows.first? .safeAreaLayoutGuide .layoutFrame .size .height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2 } let showCard = UIViewPropertyAnimator(duration: 1, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) showCard.addAnimations({ self.dimmerView.alpha = 0.7 }) showCard.startAnimation() }
cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2를 통해서&nbsp; 카드뷰의 위치를 중간쯤으로 위치시켰습니다. 이렇게 딱 끝나면 좋을 것 같은데 끝이 아닙니다. topConstraint의 값은 변했지만 UI 변화는 실시간으로 반영되지 않습니다. 저는 애니메이션을 주고 싶기 때문에 카드 뷰의 위치를 실시간으로 업데이트해주고 싶어요. 뷰의 위치를 업데이트하는 방법은 layoutIfNeeded()를 이용하는 것입니다. 저는 애니메이션을 실행시키는 여러 방법 중 하나인 UIViewPropertyAnimator를 사용해서 카드뷰 위치를 업데이트하겠습니다. 그리고 화면 Dim 처리 역시 UIViewPropertyAnimator에게 넘겨주겠습니다.이제는 바텀시트를 닫아주는 함수를 만들게요. showCard()를 이해했다면, 쉽게 알 수 있어요. 거의 똑같은 함수라서요. 차이점은 카드뷰가 내려갔을 때 BottomSheetViewControll를 dismiss 해주면 됩니다.private func hideAndDismiss() { self.view.layoutIfNeeded() if let window = UIApplication.shared.windows.first { let safeAreaHeight = window.safeAreaLayoutGuide.layoutFrame.size.height let bottomPadding = window.safeAreaInsets.bottom cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) } let hideAndDismiss = UIViewPropertyAnimator(duration: 1, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) hideAndDismiss.addAnimations({ self.dimmerView.alpha = 0.0 }) hideAndDismiss.addCompletion({ position in if position == .end { if(self.presentingViewController != nil) { self.dismiss(animated: false, completion: nil) } } }) hideAndDismiss.startAnimation()
}
여기까지 완료 했으면, 다음과 같이 작동합니다. gif 변환 과정에서 바텀시트가 올라오는 모습이 좀 어색해졌네요.<img src="https://blog.kakaocdn.net/dn/b19Hpt/btr3XzquX1H/gL1rnkKKReXJ3e2dikVml1/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">여기까지 구현한거면 큰 뼈대는 다 구현한 것이니 사실 다 만든 것이나 다름없다고 생각해요. 이제는 드래그가 가능하게 만들 겁니다.단순히 핸들 뷰를 만들고 이것을 드래그할 때 cardViewTopConstraint가 변하는 것을 구현하면 됩니다.어떤 것이든 상태가 있는 경우에는 대부분 Enum을 통해서 관리하는 것이 편하다고 생각해요. 그래서 cardView의 위치 또한 Enum으로 관리하도록 할게요.enum CardViewState { case expanded // Safe Area Top에서 30pt 떨어진 상태 case normal // (Safe Area Height + Safe Area Bottom Inset) / 2 }
expanded를 어떻게 처리할까요? 이미 구현했던 showCard를 재사용하면 될 것 같습니다. 그러기 위해서 showCard를 리팩토링 하겠습니다.&nbsp;showCard의 매개변수는 void인데 재사용을 위해서 atState: CardViewState를 매개변수로 추가하겠습니다.&nbsp;그리고나서 if문이나 switch문을 통해서 atState의 값에 따라 분기처리 하면 됩니다.private func showCard(atState: CardViewState = .normal) { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { if atState == .expanded { cardViewTopConstraint.constant = 30.0 } else { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2 } cardPanStartingTopConstant = cardViewTopConstraint.constant } let showCard = UIViewPropertyAnimator(duration: 0.3, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) showCard.addAnimations({ self.dimmerView.alpha = 0.7 }) showCard.startAnimation() }
Card View를 드래그하기 위해서는, UIPanGestureRecognizer를 등록해야 합니다.GestureRecognizer는 사용자가 뷰에 행동을 취하는 것을 트랙킹 할 수 있도록 도와줍니다. 예를 들면 사용자가 뷰를 길게 터치하는 것, 뷰를 드래그하는 것들을 알 수 있고 그에 맞게 우리가 하고 싶은 행동(스크롤을 한다던가, 다른 뷰를 보여준다던가)을 취할 수 있게 됩니다.&nbsp;func panViewGesture() { let viewPan = UIPanGestureRecognizer(target: self, action: #selector(viewPanned(_: ))) // iOS는 기본적으로 touch를 감지 (recode) 하기 전에 약간의 딜레이를 준다. 즉시 반응해야 하기 때문에 false viewPan.delaysTouchesBegan = false viewPan.delaysTouchesEnded = false cardView.addGestureRecognizer(viewPan) handleView.addGestureRecognizer(viewPan) } @objc func viewPanned(_ panRecognizer: UIPanGestureRecognizer) { // 구현하면 될 것 }
이제 viewPanned 함수를 구현해보도록 하겠습니다. UIPanGestureRecognize의 state라는 property를 이용하면 돼요. 이 state에 따라서 cardViewTopConstaraint를 변화시켜 주면 되겠죠?코드 구현에 앞서 각 state를 어떻게 구현해야 할 지에 대해서 생각해 봅시다..began
드래그를 처음 시작했을 때의 topConstraint 값을 저장
.changed
드래그를 하고 있는 상태 (cardViewTopConstarint가 바뀌는 중)
topConstraint가 expanded mode(30) 보다 작아서는 안됨
드래그를 따라서, dimmer View의 alpha 값 조절
.ended
드래그가 끝난 후 액션 처리
그리고 추가적으로 만약 사용자가 아래로 드래그를 빠르게 했을 때 (Snap) 바텀시트를 닫으면 사용자 관점에서 엄청 편할 거예요. 얼마나 빠르게&nbsp;뷰를 드래그했는지 velocity라는 변수를 통해서 알 수 있습니다. 그래서 이것을 감지한다면 바텀시트를 닫아주면 돼요.@objc func viewPanned(_ panRecognizer: UIPanGestureRecognizer) { let translation = panRecognizer.translation(in: view) let velocity = panRecognizer.velocity(in: view) switch panRecognizer.state { case .began: cardPanStartingTopConstant = cardViewTopConstraint.constant case .changed: if cardPanStartingTopConstant + translation.y &gt; 30.0 { cardViewTopConstraint.constant = cardPanStartingTopConstant + translation.y } case .ended: if velocity.y &gt; 1500.0 { hideAndDismiss() return } if let safeAreaHeight = UIApplication .shared.windows .first? .safeAreaLayoutGuide .layoutFrame .size.height, let bottomPadding = UIApplication. shared.windows. first?. safeAreaInsets. bottom { if cardViewTopConstraint.constant &lt; (safeAreaHeight + bottomPadding) * 0.25 { showCard(atState: .expanded) } else if cardViewTopConstraint.constant &lt; safeAreaHeight - 70 { showCard(atState: .normal) } else { hideAndDismiss() } } default: break }
}
여기까지 따라오셨으면, 다음과 같은 결과물을 얻을 수 있습니다.<br><img src="https://blog.kakaocdn.net/dn/K8K6s/btr3ICC7PYS/9aMTgKNES93blUUkqi2tC0/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">//
// BottomCardViewController.swift
// DraggableBottomCard
//
// Created by psychehose on 2021/06/19.
// import UIKit class BottomCardViewController: UIViewController { enum CardViewState { case expanded case normal } var cardViewState: CardViewState = .normal private var imageView: UIImageView = { let imageView = UIImageView() imageView.translatesAutoresizingMaskIntoConstraints = false return imageView }() var dimmerView: UIView = { let dimmerView = UIView() dimmerView.alpha = 0.0 dimmerView.backgroundColor = .gray dimmerView.translatesAutoresizingMaskIntoConstraints = false return dimmerView }() var cardView: UIView = { let cardView = UIView() cardView.translatesAutoresizingMaskIntoConstraints = false cardView.backgroundColor = .white cardView.clipsToBounds = true cardView.layer.cornerRadius = 10.0 cardView.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner] return cardView }() var handleView: UIView = { let handleView = UIView() handleView.layer.cornerRadius = 3.0 handleView.clipsToBounds = true handleView.translatesAutoresizingMaskIntoConstraints = false handleView.backgroundColor = .gray return handleView }() var cardViewTopConstraint: NSLayoutConstraint! var cardPanStartingTopConstant: CGFloat = 30.0 var backgroundImage: UIImage? override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white imageView.image = backgroundImage configureLayout() tapBackgroundImageGesture() panViewGesture() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) showCard() } } // MARK: - Gesture extension BottomCardViewController { func tapBackgroundImageGesture() { let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapImageView(_: ))) imageView.addGestureRecognizer(tapGesture) imageView.isUserInteractionEnabled = true } @objc func tapImageView(_ sender: UITapGestureRecognizer) { hideAndDismiss() } func panViewGesture() { let viewPan = UIPanGestureRecognizer(target: self, action: #selector(viewPanned(_: ))) // iOS는 기본적으로 touch를 감지 (recode) 하기 전에 약간의 딜레이를 준다. 즉시 반응해야 하기 때문에 false viewPan.delaysTouchesBegan = false viewPan.delaysTouchesEnded = false cardView.addGestureRecognizer(viewPan) handleView.addGestureRecognizer(viewPan) } @objc func viewPanned(_ panRecognizer: UIPanGestureRecognizer) { let translation = panRecognizer.translation(in: view) let velocity = panRecognizer.velocity(in: view) switch panRecognizer.state { case .began: cardPanStartingTopConstant = cardViewTopConstraint.constant case .changed: if cardPanStartingTopConstant + translation.y &gt; 30.0 { cardViewTopConstraint.constant = cardPanStartingTopConstant + translation.y } self.dimmerView.alpha = dimmerAlphaWithTopConstant(value: cardViewTopConstraint.constant) case .ended: if velocity.y &gt; 1500.0 { hideAndDismiss() return } if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { if cardViewTopConstraint.constant &lt; (safeAreaHeight + bottomPadding) * 0.25 { showCard(atState: .expanded) } else if cardViewTopConstraint.constant &lt; safeAreaHeight - 70 { showCard(atState: .normal) } else { hideAndDismiss() } } default: break } }
} // MARK: - UILayout extension BottomCardViewController { func configureLayout() { view.addSubview(imageView) imageView.addSubview(dimmerView) view.addSubview(cardView) view.addSubview(handleView) imageView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true imageView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true imageView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true imageView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true dimmerView.topAnchor.constraint(equalTo: imageView.topAnchor).isActive = true dimmerView.bottomAnchor.constraint(equalTo: imageView.bottomAnchor).isActive = true dimmerView.leadingAnchor.constraint(equalTo: imageView.leadingAnchor).isActive = true dimmerView.trailingAnchor.constraint(equalTo: imageView.trailingAnchor).isActive = true if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint = cardView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: safeAreaHeight + bottomPadding) } cardView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true cardView.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true cardView.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true NSLayoutConstraint.activate([cardViewTopConstraint]) handleView.centerXAnchor.constraint(equalTo: cardView.centerXAnchor).isActive = true handleView.widthAnchor.constraint(equalToConstant: 60).isActive = true handleView.heightAnchor.constraint(equalToConstant: 6).isActive = true handleView.bottomAnchor.constraint(equalTo: cardView.topAnchor, constant: -10).isActive = true } } extension BottomCardViewController { private func showCard(atState: CardViewState = .normal) { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { if atState == .expanded { cardViewTopConstraint.constant = 30.0 } else { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) / 2 } cardPanStartingTopConstant = cardViewTopConstraint.constant } let showCard = UIViewPropertyAnimator(duration: 0.3, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) showCard.addAnimations({ self.dimmerView.alpha = 0.7 }) showCard.startAnimation() } private func hideAndDismiss() { self.view.layoutIfNeeded() if let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom { cardViewTopConstraint.constant = (safeAreaHeight + bottomPadding) } let hideAndDismiss = UIViewPropertyAnimator(duration: 0.3, curve: .easeIn, animations: { self.view.layoutIfNeeded() }) hideAndDismiss.addAnimations({ self.dimmerView.alpha = 0.0 }) hideAndDismiss.addCompletion({ position in if position == .end { if(self.presentingViewController != nil) { self.dismiss(animated: false, completion: nil) } } }) hideAndDismiss.startAnimation() }
} extension BottomCardViewController { private func dimmerAlphaWithTopConstant(value: CGFloat) -&gt; CGFloat { let fullDimAlpha: CGFloat = 0.7 guard let safeAreaHeight = UIApplication.shared.windows.first? .safeAreaLayoutGuide.layoutFrame.size.height, let bottomPadding = UIApplication.shared.windows.first?.safeAreaInsets.bottom else { return fullDimAlpha } let fullDimPosition = (safeAreaHeight + bottomPadding) / 2.0 let noDimPosition = safeAreaHeight + bottomPadding if value &lt; fullDimPosition { return fullDimAlpha } if value &gt; noDimPosition { return 0.0 } return fullDimAlpha * 1 - ((value - fullDimPosition) / fullDimPosition) }
}
<br><a data-tooltip-position="top" aria-label="https://fluffy.es/facebook-draggable-bottom-card-modal-2/" rel="noopener nofollow" class="external-link is-unresolved" href="https://fluffy.es/facebook-draggable-bottom-card-modal-2/" target="_self">https://fluffy.es/facebook-draggable-bottom-card-modal-1/</a>&nbsp;[Replicating Facebook's Draggable Bottom Card using Auto Layout - Part 2/2In Part 1, we have managed to implement the show and hide card animation when user tap on button or the dimmer view. In this part, we are going to implement the card dragging animation. This post assume that you already knew about Auto Layout and Delegate.<br>fluffy.es](<a rel="noopener nofollow" class="external-link is-unresolved" href="https://fluffy.es/facebook-draggable-bottom-card-modal-2/" target="_self">https://fluffy.es/facebook-draggable-bottom-card-modal-2/</a>)<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://fluffy.es/facebook-draggable-bottom-card-modal-2/" target="_self">https://fluffy.es/facebook-draggable-bottom-card-modal-2/</a>&nbsp;[Replicating Facebook's Draggable Bottom Card using Auto Layout - Part 2/2In Part 1, we have managed to implement the show and hide card animation when user tap on button or the dimmer view. In this part, we are going to implement the card dragging animation. This post assume that you already knew about Auto Layout and Delegate.<br>fluffy.es](<a rel="noopener nofollow" class="external-link is-unresolved" href="https://fluffy.es/facebook-draggable-bottom-card-modal-2/" target="_self">https://fluffy.es/facebook-draggable-bottom-card-modal-2/</a>)]]></description><link>ios/드래그가-가능한-bottomsheet를-만들어보자(draggablebottomsheet-).html</link><guid isPermaLink="false">iOS/드래그가 가능한 BottomSheet를 만들어보자(DraggableBottomSheet ).md</guid><pubDate>Tue, 31 Dec 2024 05:21:44 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/b19Hpt/btr3XzquX1H/gL1rnkKKReXJ3e2dikVml1/img.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/b19Hpt/btr3XzquX1H/gL1rnkKKReXJ3e2dikVml1/img.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PhotoKit을 다뤄보자 (커스텀 코드편)]]></title><description><![CDATA[이번에는 직접 Photo 프레임워크를 이용해서 사용자의 앨범에 접근을 해서 collectionView에 사진을 불러오고 카메라에 접근을 해서 촬영을 하고 촬영한 이미지를 불러오겠습니다.&nbsp;컬렉션 뷰의 첫 번째 아이템(카메라 이미지)을 선택해서 카메라로 넘어가서 촬영하거나, 그 외 아이템을 클릭하면 해당하는 이미지를 헤더에 띄우는 것입니다. PhoKit의 사용법을 알면 다음과 같은 화면을 구현할 수 있게 됩니다. 인스타그램 업로드 화면 같은 뷰인데, 이미지를 띄우는 것 자체는 정말 간단합니다. 스크롤을 다룰 경우 좀 복잡해지는 것 같습니다.&nbsp;<img src="https://blog.kakaocdn.net/dn/duKNv8/btr3IYRGSGx/uL1BCd1x4FYtj26p5jHsy0/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">중요! 구현 하기에 앞서 앱이 유저의 카메라와, 앨범에 접근하려면 권한이 필요합니다. Info.plist로 이동해서 Key들을 추가해 주세요.<br><img src="https://blog.kakaocdn.net/dn/RdKg1/btr3ky1Qbev/AJH4esSzjKHQ6Po2hfAjmk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">검정 버튼이 있는 화면을 TempViewController라고 작명할게요. 화면 전환을 했을 때, 사진들이 Load 되어 있는 컬렉션 뷰가 나타나게 하기 위해서 저는 이전 화면인 TempViewController에서 미리 Fetch를 하겠습니다. 저는 viewDidLoad에서 fetchAsset()을 했는데, 버튼을 클릭했을 때 비동기처리를 하는 것, TestCollectionViewController의 생성자로 PHAsset를 주입하는 것이 더 좋은 코드였겠죠? Sample 앱이라 그냥 넘어가도록 하겠습니다.&nbsp;제가 구현한 fetchAsset() 함수 내부를 살펴보면, PHFetchOptions()의 Instance를 생성하고 옵션 값을 여러 가지 설정하고 PHAsset의 class function인 fetchAssets() 사용하는 걸 알 수 있습니다. 이론 편에서 확인한 PHObject 같은 것들은 저희는 코드 내에서 직접 작성하는 경우가 거의 없다고 할 수 있습니다. 그 하위 클래스인 PHAsset만을 사용하는 것이죠. 특이한 점은 Instance를 생성하지 않는 것입니다. 사실 아이폰 사진 앱 기능을 생각해 보면 더 효율적이라는 생각이 들긴 드네요. 안드로이드 개발을 잠깐 찾아봤을 때, 흩어져있는 사진들을 모으는 게 좀 힘들었다고 본 것 같습니다. 아이폰 같은 경우는 모든 사진이 앨범에 모이기 때문에 애플 측에서 이런 방식으로 구현한 게 아닐까 싶습니다.&nbsp;import Photos
import UIKit class TempVC: UIViewController { let btn: 생략 var allPhotos: PHFetchResult&lt;PHAsset&gt;! override func viewDidLoad() { super.viewDidLoad() //...// fetchAsset() } private func fetchAsset() { let allPhotoOptions = PHFetchOptions() allPhotoOptions.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: true)] allPhotos = PHAsset.fetchAssets(with: allPhotoOptions) } private func tapButton() { var navigationController: UINavigationController let targetVC = TestCollectionViewController() // 여기가 핵심. targetVC에 있는 변수인 fetchResult에 넘겨준다. targetVC.fetchResult = allPhotos navigationController = UINavigationController(rootViewController: targetVC) navigationController.modalPresentationStyle = .fullScreen present(navigationController, animated: true) } }
다음으로는, PHFetchResult을 넘겨받아서 이미지를 collectionView에 띄어주는 ViewController를 구현하겠습니다. collectionView생성 및 화면 배치는 다들 익숙하니까 생략하도록 할게요.&nbsp;이전 챕터에서 언급했듯이, fetchResult의 결과는 메타데이터(정보)입니다. 실제 이미지를 받아 와야 하므로 이것을 기반으로 Image를 요청해야 합니다. 그러기 위해서 PHImageManager라는 것이 필요합니다. PHImageManger에 구현되어 있는 method requestImage를 통해 이미지를 받아올 수 있습니다.&nbsp;class TestCollectionViewController: UIViewController { // UIComponent var pictureCV = UICollectionView().then { } // Variable &amp; properties var fetchResult: PHFetchResutl&lt;PHAsset&gt;! var photoImage: UIImage? // 여기에 카메라로 찍은 사진 저장 fileprivate let imageManager = PHImageManager() fileprivate var thumbnailSize: CGSize! //MARK: - View Life Cycle override func viewDidLoad() { super.viewDidLoad() //...생략 // } override func viewWillAppear(_ animated: Bool) { let scale = UIScreen.main.scale let cellSize = pictureCV.size thumbnailSize = CGSize(width: cellSize.width * scale, height: cellSize.height * scale) }
}
extension TestCollectionViewController: UICollectionViewDataSource { func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int { return fetchResult.count + 1 // 카메라 이미지를 넣어야 하기 때문에, } func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell { guard let pictureCell = collectionView.dequeueReusableCell(withReuseIdentifier: "PictureCell", for: indexPath) as? PictureCell else { return UICollectionViewCell() } if indexPath.item == 0 { pictureCell.thumbnailImage = UIImage(systemName: "camera") return pictureCell } else { let asset = fetchResult.object(at: (indexPath.item)-1 ) pictureCell.representedAssetIdentifier = asset.localIdentifier imageManager.requestImage(for: asset, targetSize: thumbnailSize, contentMode: .aspectFill, options: nil, resultHandler: { image, _ in if pictureCell.representedAssetIdentifier == asset.localIdentifier { pictureCell.thumbnailImage = image } }) return pictureCell } }
}
&nbsp; 여기에서 가장 중요한 부분은 당연하게 cellForItemAt 부분입니다. 이미지를 불러오기 위해서는 다음과 같은 작업이 필요합니다.&nbsp;
이전 화면에서 넘겨받은 fetchResult의 메타데이터를 가지고 imageManager를 통해서 요청하면 CallBack 형식으로 UIImage에 접근할 수 있습니다.그리고 코드를 확인해 보면 Asset의 localIdentifier(메타데이터)가 보이는데, 이 프로퍼티는 Unique 합니다. 이 부분을 잘 이용하면, Cell 이벤트를 잘 처리할 수 있을 것 같습니다.마지막으로 카메라 이미지를 선택했을 때 이미지에 접근하는 법입니다. 애플에서 제공하는 UIImagePickerComtroller를 사용하게 되면, UIImagePickerControllerDelegate를 통해서 클로저로 간단하게 Image에 접근할 수 있습니다. 커스텀할 필요가 없다면 사용하는 것이 좋을 것 같습니다.class TestCollectionViewCotroller: UIViewController { ///...// func didTapCamera() { let camera = UIImagePickerController() camera.sourceType = .camera camera.cameraDevice = .rear camera.cameraCaptureMode = .photo camera.delegate = self present(camera, animated: true, completion: nil) } } extension TestCollectionViewCotroller: UIImagePickerControllerDelegate &amp; UINavigationControllerDelegate { func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) { // 미디어 종류 확인 let mediaType = info[UIImagePickerController.InfoKey.mediaType] as! NSString // 미디어가 사진이면 if mediaType.isEqual(to: kUTTypeImage as NSString as String){ // 사진을 가져옴 let captureImage = info[UIImagePickerController.InfoKey.originalImage] as! UIImage // 사진을 포토 라이브러리에 저장. 안하려면 없애주면 된다. UIImageWriteToSavedPhotosAlbum(captureImage, self, nil, nil) photoImage = captureImage } // 현재의 뷰(이미지 피커) 제거 self.dismiss(animated: true, completion: { self.didTapReset() let targetVC = tempCV() targetVC.photoImage = self.photoImage self.navigationController?.pushViewController(targetVC, animated: true) }) } func imagePickerControllerDidCancel(_ picker: UIImagePickerController) { self.dismiss(animated: true, completion: nil) } }
]]></description><link>ios/photokit을-다뤄보자-(커스텀-코드편).html</link><guid isPermaLink="false">iOS/PhotoKit을 다뤄보자 (커스텀 코드편).md</guid><pubDate>Tue, 31 Dec 2024 05:21:11 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/duKNv8/btr3IYRGSGx/uL1BCd1x4FYtj26p5jHsy0/img.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/duKNv8/btr3IYRGSGx/uL1BCd1x4FYtj26p5jHsy0/img.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PhotoKit을 다뤄보자 (이론편)]]></title><description><![CDATA[<img src="https://blog.kakaocdn.net/dn/5mg6k/btr3ft0Suio/SnPjEjZKMZu9EObJNZkfjK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">&nbsp;PhotoKit은 애플에서 자체적으로 제공하는 프레임워크로 사진 앱에서 관리하는 Asset(photo, Video)에 대해서 접근을 가능하게 해 줍니다. PhoKit을 이용하면 사진 앱에 있는 앨범에 접근하여 Asset들을 가져올 수 있습니다.PhotoKit의 객체는 PHObject 객체를 기본적으로 상속받습니다. PHObject는 Asset, Collection의 추상적인 superclass입니다.따라서 이 객체를 다룰 때, 직접적으로 생성하거나 사용해서는 안됩니다.&nbsp;대신에, 이 객체의 subclass인 PHAssectCollection, PHCollectionList, PHObjectPlaceHolder를 이용해서 개발을 해야 합니다.사진 앱에 있는 이미지, 비디오, 라이브 포토의 "A representation"입니다. 그러니까 사진, 비디오, 라이브 포토 하나하나가 PHAsset 인 셈입니다. PHAsset은 다음과 같은 특징을 가지고 있습니다.
Asset은 class method인 fectchAssets()을 통해 개발을 시작할 수 있다.
Asset은 메타데이터만을 가지고 있다.
Asset은 immutable이다. (불변성을 가진다.)
Photos Asset Collections과 Collection Lists의 superclass입니다.이것 역시 PHObject처럼 직접적으로 create 하거나 인스턴스로 작업을 할 수 없습니다. 대신에 이것의 subclass인 PHAssetCollection 또는 PHCollectionList로 작업을 할 수 있습니다.PHCollection을 상속받습니다. PHAssetCollection은 쉽게 말하면 앨범입니다. (Photos asset grouping)Photo 프레임워크 안에 있는 Collection Object들은 member object를 직접 참조할 수 없고, 어떠한 object들도 collection object들을 직접 참조할 수 없습니다. Asset Collection의 member를 가지고 오려면, PHAsset class method를 이용해서 fetch 해야 합니다. 이것 또한 Assets과 Collection List와 마찬가지로 immutable 하기 때문에 create, rename... 기타 등등 작업을 하기 위해서 PHAssetCollectionChangeRequest Object를 사용해서 Photo Library를 업데이트해야 합니다.여러 개의 Photo Asset Collection을 리스트화한 것입니다. ( 예를 들면 기억에 나는 순간들, 연별 폴더 등 같은 것들입니다.)위의 PHAssetCollection처럼 멤버들을 직접 참조할 수 없고 직접 참조될 수 없습니다. member를 가지고 오려면 PHCollection class method를 이용해서 fetch 해야 합니다. 또한 역시 immutable 하기 때문에, PHCollectionListChangeRequest를 이용해서 업데이트해야 합니다.이 메서드를 사용하면 PHAsset, PHCollection에서 An ordered list of asset and collection을 가져올 수 있습니다.Fetch를 어떻게 할 것인가에 대한 option class이다.
요약 및 정리 PHObject, PHCollection
PHAsset(사진, 비디오, 라이브포토), PHAssetCollection(앨범), PHCollectionList(앨범목록)&nbsp; superclass(PHObject, PHCollection)를 직접 create 하거나, Instance를 사용하는 것은 불가능 사진, 비디오, 라이브 포토를 다루기 위해서는 하위 클래스들의 fetchMethod를 이용해서 retrive 해야만 함. ]]></description><link>ios/photokit을-다뤄보자-(이론편).html</link><guid isPermaLink="false">iOS/PhotoKit을 다뤄보자 (이론편).md</guid><pubDate>Tue, 31 Dec 2024 05:20:38 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/5mg6k/btr3ft0Suio/SnPjEjZKMZu9EObJNZkfjK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/5mg6k/btr3ft0Suio/SnPjEjZKMZu9EObJNZkfjK/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Could not find module 'Alamofire' for target armv7-apple-ios';]]></title><description><![CDATA[Build Setting 중 만난 에러프로젝트를 진행하면서 나중에 개발서버와 상용서버를 나눌 필요가 생길 거 같아서 빌드 세팅을 진행했다.<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ios-development.tistory.com/660" target="_self">https://ios-development.tistory.com/660</a>&nbsp;을 따라가며 진행했는데, 이런 오류를 만났다. 이것은, 실기기로 빌드 했을 때 뜨는 것이고, (기억 상) 시뮬레이터로 빌드를 하게 되면 Could not find module ‘Alamofire’ for target ‘i386-apple - ios - simulator가 떴다.<br><img src="https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// podfile post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end
end
podfile에 다음과 같이 적으면 에러 해결!문제는 Alamofire다.위 스크린 샷의 에러가 Moya + Alamofire에서 발생하고, Alamofire를 사용하는 모든 Library에서 Compile error가 발생했다. (KakaoSDK, 커스텀한 Auth library ( inner DevPods))빌드 세팅을 하기 전에는 발생하지 않았던 오류인데 빌드 세팅을 하고나서 오류가 발생했다는 점에서 일단 매우 이상했다. 아무튼 이 에러를 해결 하기 위해, 무수한 삽질을 했다.Alamofire.framework를 /library/developer ~ /Alamofire/~ 뭐 이런 경로를 쭉 타고 가서 target을 확인 해봤는데 ‘x86_64’와 ‘arm64’ 두개가 있었다. 즉 armv7-apple-ios가 없어서 오류가 발생한 것이 맞다. (빌드 세팅을 하기 전에 단일 세팅일 떄는 왜 오류가 안났는 지는 아직도 의문이다.)그래서, 네비게이션 영역을 통해서 Pods project로 들어가서 Alamofire의 Architecture 부분을 확인하였다.Architectures의 부분이 $(ARCHS_STANDADRD_64_BIT)로 되어 있었다. 이 부분은을 STANDARD ARCH(arm7, arm64)로 고쳤을 때, 에러는 해결되었다. 다만 이렇게 설정했을 때, pod install을 다시하게 되면 본래대로 $(ARCHS_STANDADRD_64_BIT)로 바뀌어서 같은 에러가 발생한다.그래서 pod install 할 때, architecture setting을 지워주는 코드를 추가 했다.post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end
end
그리고 나서 Pod project의 Alamofire를 들어갔을 때, Architectures가 사라졌고 에러는 해결되었다.확실하진 않지만, 심증으로는 애플에서 디버그 용도는 32bit 아키텍쳐 ( 배포용도는 64bit도 )만을 지원하기 때문인 것 같다. 위에서 말한 것과 같이, 초기 세팅은 ARCHS_STANDARD_64_BIT 였기 때문이다.]]></description><link>ios/could-not-find-module-&apos;alamofire&apos;-for-target-armv7-apple-ios&apos;;.html</link><guid isPermaLink="false">iOS/Could not find module &apos;Alamofire&apos; for target armv7-apple-ios&apos;;.md</guid><pubDate>Tue, 31 Dec 2024 05:19:51 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Tuist 기본적인 사용법]]></title><description><![CDATA[&nbsp;요즘 회사에서 Tuist를 사용하고 있다. 왜냐하면 iOS는 보일러 플레이트 코드가 거의 없다시피 하기 때문에 새로운 프로젝트를 할 때 상당히 귀찮기 때문이다. info.plist도 원하는대로 설정할 수 있고 3rd Party Library를 멋지게 관리할 수 있기 때문이다. Tuist는 이외에도 엄청나게 많은 기능을 제공하는 것 같다. 물론 많은 기능을 제공하는 만큼 제대로 사용하기 위해서는 학습이 필요하다. 어차피 설정은 프로젝트 동안에 거의 한번만 하면 되는데 Project 생성 도구를 학습 해야 하나 싶기도 하지만 이것은 Mono Project일 때이고 앱 규모가 크고 모듈화를 염두에 두고 있다면 Tuist는 매우 강력한 도구가 될 것 같다.&nbsp;개발을 Module 단위로 진행하고 있다면, 많은 Project를 만들어야 하는데 Xcode에서 Project 만들기는 너무 번거롭고 해야할 것이 많다. 가령 iOS deployment target을 13으로 잡았는데 생성시 최신버전으로 생성 되기때문에 Target Setting에서 바꿔야 한다거나 Framework 생성시 default가 dynamic framework이기 때문에 static으로 바꿔줘야 한다던가 매우 번거롭다. 이 때 Tuist를 사용할 경우 코드로 Project를 생성하기 때문에 한번 만들어 놓으면 재사용이 가능하고 훨씬 더 효율적으로 Project를 생성하고 유지보수가 가능해진다. 아무튼 그렇다고 한다.$ curl -Ls &lt;https://install.tuist.io&gt; | bash
먼저 Tuist 부터 설치를 하자.Terminal을 열고 위 명렁어를 입력하면 Tuist를 설치할 수 있다. 그리고 Tuist로 Project를 생성한다.$ mkdir 'TuistPractice' #폴더 생성
$ cd 'TuistPractice'
$ tuist init --platform ios # 이렇게 하면 tuist로 Project를 관리할 수 있는 환경이 만들어짐.
$ tuist generate # tuist로 project 생성
그러면 프로젝트가 생성된다. 아주 멋지게 잘 생성된 거 같다. App을 실행해보면 나오는 ㅂ구조가 Tuist가 제공하는 기본 Template이다. 그러면 어떻게 우리만의 Project 세팅을 할 수 있을까?$ tuist edit
명령어를 입력하면 mainfests.xcodeproj가 열린다. 이건 Package.swift 같은 역할을 한다. 즉 Manifest.xcodeproj를 자기 입맛에 맞게 수정한 다음에 ‘tuist generate’를 하면 우리가 원하는 구조, 형태로 Project들을 세팅하고 생성할 수 있게 된다.<img src="https://blog.kakaocdn.net/dn/HL4gh/btrH1bsSD2d/gPuie03lbnXlZPqRGLKFA1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Tuist가 제공하는 기본 templateProject.swift에 Project.app()이 있는데 이 app() method는 Project + template.swift에 extension에 작성되어 있다. return 값은 Project (Tuist에서 정의된 Type)이다. 문자 그대로 Project다.Tuist는 Project.swift를 찾아서 그 안에 작성되어 있는 대로 Project를 생성한다.즉 우리는 Project.swift에 우리가 원하는 프로젝트 코드를 작성하면 된다.보통 Project 코드를 작성할 때 템플릿처럼 Extension을 만들어서 사용하는 것 같다. 물론 나도 Extension을 만들어놓고 필요한 부분에서 바로 사용한다. 하지만 처음이니까 Extenstion을 만들지 않고 바로 사용해보자.Project는 생성자는 다음과 같다.
name: String
organizationName: String
options: Project.Options
packages: [Package]
settings: Settings?
targets: [Target]
schemes: [Scheme]
fileHeaderTemplate: FileHeaderTemplate?
additionalFiles: [FileElement]
resourceSynthesizers: [ResourceSynthesizer]
생성자에 관한 자세한 설명은 Tuist Docs에서 확인 할 수 있다. Tuist는 이렇듯 코드로 많은 것들을 설정할 수 있게 한다. 이 부분은 아직 내 수준에서 그렇게까지 만질 필요가 없을 것 같기도 해서 정확하게 공부 해보지는 않았다.우리에게 필요한 것은3번 Options에 있는 Indent와 tab의 width 설정을 2로 바꾸는 것이었고 (xcode 기본설정은 4임!)4번에서는 사용법을 알기 위해서 Alamofire를 넣도록 하고5번에서는 Project 단위로 Project Settings를 사용하지는 않을 것이다.7번 개발 앱과 상용앱을 나누기 위해서 필요한 기능이지만 여기서는 사용하지 않을 것이다.8번, 9번, 10번은 잘 모르겠다. 어떻게 사용하는 지.다만 내가 생각하기에 가장 중요한 것은 6번이라고 생각한다. 왜냐하면 우리는 실제로 여기서 작업을 하고 이것을 실행하기 때문이다.따라서 우리는 간단하게 살펴보기 위해서 대부분 다 기본값으로 설정하고 필요한 부분만 작성해서 생성할 것이다.이제 Project를 생성해보자// Project.swift let project = Project( name: "TuistPractice", organizationName: "com.yourCompany", packages: [], settings: .settings(), targets: [ ]
)
package는 swift package다. 사용법을 알기 위해서 예시로 가장 유명한 라이브러리 중 하나인 Alamofire를 fetch 해봤다. 위에서 언급한 것처럼 가장 중요한 것은 target이다. targets 안에 target Target Type instance를 넣으면 되는데 보통 Main Target과, Test Target을 넣는데 Main Target만 넣도록 하자.// Project.swift let plist: [String: InfoPlist.Value] = [ "CFBundleShortVersionString": "1.0", "CFBundleVersion": "1", "UIMainStoryboardFile": "", "UILaunchStoryboardName": "LaunchScreen", "NSAppTransportSecurity": .dictionary([ "NSAllowsArbitraryLoads": .boolean(true) ])
] let appTarget = Target( name: "TuistPractice", platform: .iOS, product: .app, bundleId: "YourBudleID", deploymentTarget: .iOS(targetVersion: "14.0", devices: [.iphone, .ipad]), infoPlist: .extendingDefault(with: plist), sources: ["Sources/**/*.swift"], resources: ["Resources/**"], settings: .settings( configurations: [ .debug( name: "Development", settings: [:], xcconfig: .init("Configuration/TuistPractice-Development.xcconfig") ), .debug( name: "Staging", settings: [:], xcconfig: .init("Configuration/TuistPractice-Staging.xcconfig") ), .release( name: "Release", settings: [:], xcconfig: .init("Configuration/TuistPractice-Production.xcconfig") ) ] ) Target Type도 마찬가지로 엄청나게 많은 생성자를 가지고 있는데 역시 이것도 자세한 설명은Tuist Docs에서 확인할 수 있다. Project에서 가장 중요한 것은 Target 이라고 했는데, Target에서 가장 중요한 것들은 product인 것 같다.product에는 app, staticLibrary, staticFramework, framework, dynamic framework 등등이 있다. Tusit를 이용 하는 이유 중 하나는 모듈화 때문이기도 한데, 모듈화를 하기 위해서는 보통 모듈화 프로젝트 Main Target의 product를 static Library, staticFramework, framework로 만든다. 우리는 모듈화를 하기에 앞서, App Project를 만들어야 하기 때문에 product를 app으로 설정한다.$ tuist fetch // 3rd party를 사용하고 있다면 프로젝트를 생성 하기전에 이 명령어를 입력해줘야 한다
$ tuist generate
<br><img src="https://blog.kakaocdn.net/dn/zl8Ah/btrH5fngRIJ/gJUyyvffudGvDKtJW1p5W1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">여기까지 했다면 다음과 같이 뜨면서 생성이 안될텐데 저 에러메세지를 잘 읽어보고 해결하면 된다. 우리가 Target을 만들 때 Source 파일들을 ["Sources/*/.swift"] 이렇게 입력했기 때문에 이 path에 .swift 파일이 있어야 한다. 당연히 .xcconfig 파일도 마찬가지다.<br><img src="https://blog.kakaocdn.net/dn/bbpiHp/btrH1Brklij/zTJSdTvBtBbQjZQRljnQk0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cqPBIG/btrH2hTEqBE/wqX37LiYkoGGsEMn54TPi0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/nEBrR/btrH5d33ZBv/ylruykXbWknTH3KQWdlYC0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">$ tuist generate
<br><img src="https://blog.kakaocdn.net/dn/JgeLu/btrH6Hqi4LS/Mar5lLKlsYblYtqRTqedSK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Project가 아주 잘 생성되었다. 참고로 Sources 폴더 안에 있는 것들은 프로젝트 생성 후 잘되는 지 테스트하기 위해 만든 것이다.AppDelegate.swift, ViewController.swift 파일을 만들고 실행을 해보면// AppDelegate.swift
import UIKit @main
class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil ) -&gt; Bool { let window = UIWindow(frame: UIScreen.main.bounds) window.backgroundColor = .white window.rootViewController = ViewController() window.makeKeyAndVisible() self.window = window return true }
} // ViewController.swift import UIKit final class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() print("Hello Tuist") view.backgroundColor = .purple }
} ![](Build Setting 중 만난 에러프로젝트를 진행하면서 나중에 개발서버와 상용서버를 나눌 필요가 생길 거 같아서 빌드 세팅을 진행했다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ios-development.tistory.com/660" target="_self">https://ios-development.tistory.com/660</a>&nbsp;을 따라가며 진행했는데, 이런 오류를 만났다. 이것은, 실기기로 빌드 했을 때 뜨는 것이고, (기억 상) 시뮬레이터로 빌드를 하게 되면 Could not find module ‘Alamofire’ for target ‘i386-apple - ios - simulator가 떴다.<br><img src="https://blog.kakaocdn.net/dn/dYH3Sc/btrH6Hw3dUq/vgTYdeRV9NEDh7tVvux9qk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// podfile post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end
end
podfile에 다음과 같이 적으면 에러 해결!문제는 Alamofire다.위 스크린 샷의 에러가 Moya + Alamofire에서 발생하고, Alamofire를 사용하는 모든 Library에서 Compile error가 발생했다. (KakaoSDK, 커스텀한 Auth library ( inner DevPods))빌드 세팅을 하기 전에는 발생하지 않았던 오류인데 빌드 세팅을 하고나서 오류가 발생했다는 점에서 일단 매우 이상했다. 아무튼 이 에러를 해결 하기 위해, 무수한 삽질을 했다.Alamofire.framework를 /library/developer ~ /Alamofire/~ 뭐 이런 경로를 쭉 타고 가서 target을 확인 해봤는데 ‘x86_64’와 ‘arm64’ 두개가 있었다. 즉 armv7-apple-ios가 없어서 오류가 발생한 것이 맞다. (빌드 세팅을 하기 전에 단일 세팅일 떄는 왜 오류가 안났는 지는 아직도 의문이다.)그래서, 네비게이션 영역을 통해서 Pods project로 들어가서 Alamofire의 Architecture 부분을 확인하였다.Architectures의 부분이 $(ARCHS_STANDADRD_64_BIT)로 되어 있었다. 이 부분은을 STANDARD ARCH(arm7, arm64)로 고쳤을 때, 에러는 해결되었다. 다만 이렇게 설정했을 때, pod install을 다시하게 되면 본래대로 $(ARCHS_STANDADRD_64_BIT)로 바뀌어서 같은 에러가 발생한다.그래서 pod install 할 때, architecture setting을 지워주는 코드를 추가 했다.post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings.delete('ARCHS') end end
end
그리고 나서 Pod project의 Alamofire를 들어갔을 때, Architectures가 사라졌고 에러는 해결되었다.확실하진 않지만, 심증으로는 애플에서 디버그 용도는 32bit 아키텍쳐 ( 배포용도는 64bit도 )만을 지원하기 때문인 것 같다. 위에서 말한 것과 같이, 초기 세팅은 ARCHS_STANDARD_64_BIT 였기 때문이다.)아주 잘 작동한다. 가장 기본적인 사용 방식은 이렇듯 매우 간단하다. 실제 진행하는 프로젝트에서는 모듈화를 하기 때문에 이것보다 더 복잡한 방식으로 사용하지만 기본적인 사용방식을 벗어나지는 않는다. 많은 iOS 개발자들이 Tuist를 사용해 봤으면 좋겠다.끝.]]></description><link>ios/tuist-기본적인-사용법.html</link><guid isPermaLink="false">iOS/Tuist 기본적인 사용법.md</guid><pubDate>Tue, 31 Dec 2024 05:19:31 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/HL4gh/btrH1bsSD2d/gPuie03lbnXlZPqRGLKFA1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/HL4gh/btrH1bsSD2d/gPuie03lbnXlZPqRGLKFA1/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Tuist에서 RIBs Fetch하기. (Carthage)]]></title><description><![CDATA[Tuist를 이용해서 새로운 프로젝트를 시작했다. 어떤 방식으로 프로젝트를 설계할까에 대해 고민을 하고 많은 블로그들을 읽었고, 고민을 거듭한 끝에 다음 같이 구성했다.&nbsp;처음에 설계한 방식은 그래프에 나와있지는 않지만 CoreKit 아래에 RxPackage를 가지고 있었다.<img src="https://blog.kakaocdn.net/dn/yMkiy/btrBJMGgTgu/nkPRqkuukxwk7EW5249F1k/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// Package.swift
// swift-tools-version: 5.5
// The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( name: "RxPackage", products: [ // Products define the executables and libraries a package produces, and make them visible to other packages. .library( name: "RxPackage", targets: ["RxPackage"]), ], dependencies: [ .package(url: "https://github.com/ReactiveX/RxSwift.git", from: "6.5.0"), .package(url: "https://github.com/uber/RIBs.git", from: "0.9.0"), ], targets: [ // Targets are the basic building blocks of a package. A target can define a module or a test suite. // Targets can depend on other targets in this package, and on products in packages this package depends on. .target( name: "RxPackage", dependencies: [ "RxSwift", "RIBs" ]), .testTarget( name: "RxPackageTests", dependencies: ["RxPackage"]), ]
)
RIBs는 RxSwift와 RxRelay에 의존성을 가지기 때문에 Package에서 url을 통해 fetch 하고 의존성을 해결하였다. 여기서 문제가 발생했다.Feature RIBs에서 RxCocoa의 rx.tap과 같은 기능들을 사용할 수가 없었다. 왜냐하면 RxPackage는 dependency로 RxCocoa를 가지고 있지 않기 때문. 위의 Package.swift를 다음처럼 조금만 더 수정하면 되지 않을까?// Package.swift
// swift-tools-version: 5.5
// The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( targets: [ // 생략 .target( name: "RxPackage", dependencies: [ "RxSwift", "RIBs", .product(name: "RxCocoa", package: "RxSwift") ]), // 생략 ]
)
import RxCocoa가 되고 RxCocoa의 기능을 사용할 수 있었다.(자동완성) 그런데 빌드를 하고 나면 Missing required module RxCocoaRuntime이라는 Error가 발생하고 앱이 죽었다. 검색을 통해서 RxSwift Issue에서 관련된 두 가지 질문을 찾을 수 있었다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/ReactiveX/RxSwift/issues/2210" target="_self">https://github.com/ReactiveX/RxSwift/issues/2210</a>&nbsp;이 이슈에서는 UITest target에서 발생한 Issue이고 해당 답변에서 SPM Bug라고 한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/ReactiveX/RxSwift/issues/2057" target="_self">https://github.com/ReactiveX/RxSwift/issues/2057</a>다음은 아래와 같은 해결책을 제시하였는데, 적용을 해봤지만 해결이 되지 않았다.<br><img src="https://blog.kakaocdn.net/dn/bxMQPw/btrBLVChZ5D/0NKg3NZ18iPPgW5nyq8dw0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">왜 안되는 지 정확하게 원인을 파악할 수 없었기 때문에 과감하게 Package를 이용해서 RIBs를 사용하는 방식을 포기하고 다른 방법을 모색하기 시작했다.많은 iOS 개발자들이 Carthage를 사용하기 때문에 tuist도 Carthage를 아주 잘 지원한다. (CocoaPod은 이제 지원 안 한다고 한다. 많은 사람들이 아직 많이 사용하는데...)Carthage를 이용하기 위해서 tuist edit 명렁어를 입력하고 Dependencies 파일에 Rx와 RIBs를 추가했다.그러고 나서 RxPackageKit이라는 Project를 만들고 이것은 ‘RxSwift’, ‘RIBs’ Dependencies를 가지고 있다.
(Project.dynamicFramework()는 extension 입니다.)
//
// Dependencies.swift
// ProjectDescriptionHelpers
//
// Created by // import ProjectDescription let dependencies = Dependencies( carthage: [ // ... .github(path: "ReactiveX/RxSwift", requirement: .exact("6.5.0")), .github(path: "uber/RIBs", requirement: .branch("main")), // ... ], swiftPackageManager: [ ], platforms: [.iOS]
)
/
// Project.swift
// ProjectDescriptionHelpers
//
// Created by 김호세 on 2022/05/09.
// import ProjectDescription
import ProjectDescriptionHelpers let project = Project( name: "RxPackageKit", organizationName: "com.jstock", packages: [], targets: Project.dynamicFramework( name: "RxPackageKit", frameworkDependencies: [ .external(name: "RxSwift"), .external(name: "RxCocoa"), .external(name: "RIBs") ], testDependencies: [] ), schemes: []
)
다음으로 ‘Tuist 디렉토리가 있는’ 디렉토리에서 tuist fetch를 한다.$ tuist fetch
<br><img src="https://blog.kakaocdn.net/dn/xrHws/btrBLGle4wn/SIKUMuTPcciFSVCFzTzB81/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">빌드에 실패하게 된다. 다음과 같은 오류를 뱉었으면, Tuist/Dependencies/Carthage/Build를 확인하자.<br><img src="https://blog.kakaocdn.net/dn/A8iOt/btrBKwbHofk/jSOA0SKLWhs8yMNVsNcfwk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위처럼 Build 폴더에 Rx~.xcframework들이 있으면 성공이다.이렇지 못한 경우가 있는데 개인 노트북(M1 - XCode 12)으로 작업하는 경우 Carthage Bug(?)가 있어서 Build를 할 수 없다. 이때 Scirpt를 만들어서 carthage를 빌드해줘야 한다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md" target="_self">https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md</a>&nbsp;을 참고해서 carthage.sh를 생성하고 (./는 스크립트 생성한 위치)$ ./carthage.sh build RxSwift Tuist/Dependencies --platform iOS --use-xcframeworks --no-use-binaries --use-netrc --cache-builds --verbose
$ ./carthage.sh build RIBs Tuist/Dependencies --platform iOS --use-xcframeworks --no-use-binaries --use-netrc --cache-builds --verbose
를 입력하면 Rx~.xcframework들이 생성된다이제 Tuist/Dependencies/Carthage/Checkouts/RIBs/ios/RIBs.xcodeproj를 열고 RIBs Target을 확인해보면 RxRelay.framework, RxSwfit.framework에 의존성을 가지는데 RxSwift를 우리는 xcframework로 받았기 때문에 이것을 xcframework로 교체한다.(왼쪽 아래에서 add 하면 됨)<br><img src="https://blog.kakaocdn.net/dn/b38Nya/btrBOuwTj1G/uZgenHeGp6646RqN3gt6Ik/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/Ok2FB/btrBMa0ecow/f2cATHbznLXv4vVF9O6GeK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그런 다음에 RIBs를 다시 Build 한다.( Xcode 12인 경우 위처럼 스크립트로 실행해야 함.)$ carthage build RIBs --project-directory Tuist/Dependencies --platform iOS --use-xcframeworks --no-use-binaries --use-netrc --cache-builds --verbose
<br><img src="https://blog.kakaocdn.net/dn/bBe8s0/btrBJMzw2Zw/agb4OgqaPAntmpqKJMfTaK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 빌드에 성공한다. 프로젝트를 생성해주고$tuist generate
<br><img src="https://blog.kakaocdn.net/dn/c5YQHD/btrBOup9phI/tabJrFaHT48lhlhKcyRRyk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">다음과 같은 예쁜 모양을 만들 수 있다. 그래프로 출력하게 되면 (-t 옵션은 테스트 타겟들 제외) 그래프가 예쁘게 나온다.$ tuist graph -t
<br><img src="https://blog.kakaocdn.net/dn/bUUrsq/btrBMg0JE4a/V0Klqw0WIxAoPgJBcjXgyK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">프로젝트를 열고 App을 실행하면 RxCocoa도 성공적으로 import 할 수 있고, 빌드도 할 수 있게 된다.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-2" target="_self">http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-2</a>&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-1" target="_self">http://minsone.github.io/mac/ios/ios-clean-architecture-with-ribs-reactorkit-and-modularization-using-tuist-1</a>&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/minsOne/iOSApplicationTemplate" target="_self">https://github.com/minsOne/iOSApplicationTemplate</a>&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md" target="_self">https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md</a>&nbsp;<a data-tooltip-position="top" aria-label="https://okanghoon.medium.com/xcode-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-tuist-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-6a92950780be" rel="noopener nofollow" class="external-link is-unresolved" href="https://okanghoon.medium.com/xcode-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-tuist-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-6a92950780be" target="_self">https://okanghoon.medium.com/xcode-프로젝트-관리를-위한-tuist-알아보기-6a92950780be</a>
]]></description><link>ios/tuist에서-ribs-fetch하기.-(carthage).html</link><guid isPermaLink="false">iOS/Tuist에서 RIBs Fetch하기. (Carthage).md</guid><pubDate>Tue, 31 Dec 2024 05:11:38 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/yMkiy/btrBJMGgTgu/nkPRqkuukxwk7EW5249F1k/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/yMkiy/btrBJMGgTgu/nkPRqkuukxwk7EW5249F1k/img.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[내가 블로그를 시작한 이유]]></title><description><![CDATA[나는 왜 블로그를 하려고 결심했을까? 이상하게도 나는 처음에 이 글을 쓰기로 결심을 하고 블로그를 시작해야 할 이유에 대해 생각을 해봤다. 그래서 먼저 든 생각은 우리가 흔히 쓰는 블로그라는 말이 어떤 의미가 있는지 궁금했다. 위키피디아에 의하면 블로그의 정의는 다음과 같다고 한다.
블로그라는 말은 웹(web)과 로그(log, 기록)를 합친 낱말로, 스스로가 가진 느낌이나 품어오던 생각, 알리고 싶은 견해나 주장 같은 것을&nbsp;<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%B0" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%B0" target="_self">일기</a>처럼 차곡차곡 적어 올리는 형식을 취한다
무엇인가를 '기록하다' 라는 글을 보았을 때 나는 Record 라는 단어를 떠올렸다. 이 단어는 나에게 어떠한 감흥조차 주지 못했는데 Log 라는 단어는 왜인지 모르게&nbsp;(사실 안다)&nbsp;중요한 느낌을 준다.나는 2016년 가을부터 학교에서 컴퓨터 관련 수업을 들었고, 2020년부터 iOS 개발을 시작했다. 개발을 시작하기 전에 나는 내가 생각한 대로&nbsp;많은 것들을 손쉽게 구현할 수 있을 거라고 생각했지만, 현실은 달랐다. 아직도 기억나는 일이 있다. SOPT 과제에서 서버와 통신해서 그 값들을 보여주는 기능을 구현했어야 했다. 나는 호기롭게 네트워킹을 시도했었지만, 화면에 어떠한 변화도 없었다. 나는 어떤 코드를 잘못 작성했는지 파악할 수 없었기 때문에&nbsp;여러 곳에 dump 함수를 이용해서 잘못된 부분을 찾을 수 있었다. 이것이 아마 나의&nbsp;의미 있는 첫&nbsp;Log&nbsp;일 것이다.나(코드몽키)와 마찬가지로 개발자들은 Log의 중요성을 매우 잘 알 것이다.&nbsp;어떠한 문제가 발생했을 때 Log를 통해서 문제 해결의 단초를 얻을 수 있고, Log 분석을 통해 중요한 정보들을 수집할 수도 있다. 따라서 Logging은 정말 중요하다.나는 개발을 하면서 크고 작은 문제에 부딪힌다. 보통 stackoverflow, 국내 개발 블로그, 공식문서를 보면 많은 것들이 해결된다. 그러나, 해결되지 않는 경우도 많다. 나는 문제에 직면했을 때, 만화 나루토에 나오는&nbsp;마이트 가이를 존경하기 때문에, 포기하지 않고 노력한다. 그래서 정말 많은 시간을 들여서 어찌어찌 어려운 것들을 해결한 경험들이 있다. '역시 난 대단하다.' 이렇게 끝났으면 참 좋은 결말일 텐데,&nbsp;생각해보면 현재의 나에겐 남는 것이 많이 없는 것 같다.&nbsp;시간이 흘러 같은 문제를 직면했을 때,&nbsp;노력한 기억만 남아서, 시간이 좀 덜 걸릴 뿐이지 다시 시행착오를 겪을 것이다. 정말&nbsp;비효율적이지 않나?&nbsp;개발을 하다가 Issue가 생겼을 때 검색 하면 인터넷에 양질의 글들이 참 많다는 것을 알 수 있다. 그러나, 글들이 추상적이고 과감한 생략되어 있으면 나는 이 Issue를 어렵다고 생각하고 이해하기를 포기한 적도 있다.&nbsp;그럴 때마다 자책하면서 자존감이 떨어졌었는데, 시간을 들여&nbsp;시행착오를 겪어보니 사실은 어려울 게 없는 것이었다. &nbsp;만약 해당 Issue가 좀 더&nbsp;자세하게 기록되어 있었다면 바로 감을 잡을 수 있었을지도 모른다. 마치 해석학에서 Compact를 공부할 때와 같았다. 혼자 책을 볼 때 어떠한 것도 이해하지 못하고 자책만 했었는데, 교수님의 설명을 듣고 몇 문제를 풀어보니 감을 잡을 수 있었기 때문이다.&nbsp;(감만 잡았었음.)최근에 Architecture에 지대한 관심을 가지기 시작했다.&nbsp;Framework와 Library, DIP, Modularize 등등 어려운 개념들에 대한 글들을 열심히 읽었고 어떤 것들은 5번 이상씩 읽었다. 그래서 나는 이러한 개념들을 이해했다고 생각했다. 어느 날 이러한 주제에 대해서 이야기가 나왔는데 누군가가 나에게 설명을 요구했는데 나는 말하는 것에 확신이 없었다. 나는 안다는 착각에 빠져있었던 것 같다. 내가 어떤 지식에 관해서&nbsp;확실하게 누군가에게 설명할 수 있다면 그것은 내가 확실하게 아는 것이지 않을까?결론은 다음과 같다.나는 개발에 있어서 비효율을 제거하고 싶고, 좀 더 상세하게 기록해서 같은 어려움을 겪는 사람들에게 도움이 되고 싶고, 내가 확실하게 설명할 수 있을 정도로 알고 싶기 때문에 블로그를 시작하게 되었다.]]></description><link>hose/내가-블로그를-시작한-이유.html</link><guid isPermaLink="false">Hose/내가 블로그를 시작한 이유.md</guid><pubDate>Tue, 31 Dec 2024 05:10:05 GMT</pubDate></item><item><title><![CDATA[AGDE와 UE연동]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.android.com/games/agde?hl=ko" target="_self">https://developer.android.com/games/agde?hl=ko</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.android.com/games/agde/quickstart?hl=ko" target="_self">https://developer.android.com/games/agde/quickstart?hl=ko</a>AGDE: Android Game Development Extension.
Visual Studio 다운로드
.NET CORE SDK 2.2 다운
Android SDK 및 NDK 설치
AGDE 설치
AGDE 버전에 맞게 JDK 설정
Android 게임 개발 확장 프로그램은 MSBuild를 호출하여 공유 라이브러리(.so)와 정적 라이브러리(.a)에 C/C++ 소스 코드를 빌드를 함.
Android 플랫폼을 추가
]]></description><link>ue/agde와-ue연동.html</link><guid isPermaLink="false">UE/AGDE와 UE연동.md</guid><pubDate>Mon, 30 Dec 2024 17:24:47 GMT</pubDate></item><item><title><![CDATA[내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유]]></title><description><![CDATA[기본적으로 내비게이션 영역은 내비게이션 메쉬가 커버하고 있는 영역 중에서 월드의 충돌 지오메트리를 통해 길찾기 영역이 설정됩니다. 그리고 내비게이션 메시를 타일로 분할하기 때문에 벽은 영역에 표시되지 않습니다. 그리고 내비게이션 메시는 폴리곤으로 구성되고 각 폴리곤에 비용이 할당되는데, 이를 이용해 비용이 가장 낮은 최적의 경로를 찾으려고 시도합니다. 폴리곤에 할당하는 비용을 조절함으로써 고도화된 내비게이션 시스템을 만들 수 있습니다.<img alt="Navigation.png" src="images/navigation.png" target="_self">]]></description><link>ue/내비게이션-볼륨-영역-추적에서-바닥은-되고-벽은-안되는-이유.html</link><guid isPermaLink="false">UE/내비게이션 볼륨 영역 추적에서 바닥은 되고 벽은 안되는 이유.md</guid><pubDate>Mon, 30 Dec 2024 16:59:09 GMT</pubDate><enclosure url="images/navigation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/navigation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ETriggerEvent]]></title><description><![CDATA[enum class ETriggerEvent : uint8
{ // No significant trigger state changes occurred and there are no active device inputs None = (0x0) UMETA(Hidden), // Triggering occurred after one or more processing ticks Triggered	= (1 &lt;&lt; 0),	// ETriggerState (None -&gt; Triggered, Ongoing -&gt; Triggered, Triggered -&gt; Triggered) // An event has occurred that has begun Trigger evaluation. Note: Triggered may also occur this frame, but this event will always be fired first. Started = (1 &lt;&lt; 1),	// ETriggerState (None -&gt; Ongoing, None -&gt; Triggered) // Triggering is still being processed. For example, an action with a "Press and Hold" trigger // will be "Ongoing" while the user is holding down the key but the time threshold has not been met yet. Ongoing = (1 &lt;&lt; 2),	// ETriggerState (Ongoing -&gt; Ongoing) // Triggering has been canceled. For example, the user has let go of a key before the "Press and Hold" time threshold. // The action has started to be evaluated, but never completed. Canceled	= (1 &lt;&lt; 3),	// ETriggerState (Ongoing -&gt; None) // The trigger state has transitioned from Triggered to None this frame, i.e. Triggering has finished. // Note: Using this event restricts you to one set of triggers for Started/Completed events. You may prefer two actions, each with its own trigger rules. // Completed will not fire if any trigger reports Ongoing on the same frame, but both should fire. e.g. Tick 2 of Hold (= Ongoing) + Pressed (= None) combo will raise Ongoing event only. Completed	= (1 &lt;&lt; 4),	// ETriggerState (Triggered -&gt; None)
};
ETriggerEvent는 Enum으로 6가지 타입이 있다.
None
Triggered,
Started
Ongoing
Canceled
Completed
이 타입들은 Action에서 Triggers를 어떻게 설정한지에 따라 달라진다.Action Triggers에 Pressed를 설정했을 때ETriggerEvent는 1틱씩None -&gt; Start -&gt; Triggered -&gt; Completed 순으로 발생한다.Action Triggers에 Pressed, Release로 설정할 시에는None -&gt; Start-&gt; Trigger -&gt; Ongoing -&gt; Trigger -&gt; CompletedAction Triggers에 Hold And Release로 설정하고 Hold Time Threshold를 0.5초로 설정이벤트를 주면None -&gt; Start -&gt; Ongoing -&gt; Triggered -&gt; Completed Hold Time Threshold를 5초로 설정하고 스페이스를 2초 후에 눌렀다 떼면None -&gt; Start -&gt; Ongoing -&gt; Canceled정리하면 기본상태는 None이고, 이벤트가 취해질 때 맨 처음 Start로 상태가 한틱 변경된다. 그리고 이벤트 요구사항이 충족 되기 전까지는 Ongoing을 유지하고 충족 되면 Triggered로, 충족되지 않는다면 Canceled로 상태가 변경된다. 그리고 다시 None으로 변경됨.]]></description><link>ue/etriggerevent.html</link><guid isPermaLink="false">UE/ETriggerEvent.md</guid><pubDate>Mon, 30 Dec 2024 16:58:59 GMT</pubDate></item><item><title><![CDATA[BlendSpace와 BlendSpace1D 차이점]]></title><description><![CDATA[ 애니메이션 블렌딩이란 하나의 캐릭터 또는 스켈레탈 메시에 둘 이상의 애니메이션이 부드럽게 전환되도록 만드는 것.언리얼엔진에서 블렌딩 하는 방법은 두 가지.
애님그래프에서 블루프린트로 블렌딩
블렌드스페이스 사용 블렌드 스페이스는 애님그래프에서 샘플링할 수 있는 특수 애셋 두 입력값에 따라서 애니메이션을 블렌딩시켜주는 것.블렌드스페이스와 블렌드스페이스1D의 차이점은 입력값의 차이 1D는 가로축 하나라서 기준이 단일 입력값으로 블렌딩을 하는 반면에 2D는 가로, 세로축이 존재해 두 입력에 따라 애니메이션을 블렌딩할 수 있습니다.언리얼엔진5에서 Legacy에 BlendSpace1D가 들어가있는 이유는 블렌드스페이스와 차이는 단순히 축뿐이기 때문입니다. 세로축을 사용하지 않으면 그게 바로 Blendspace1D이기 때문입니다.<img alt="Blendspace.png" src="images/blendspace.png" target="_self">]]></description><link>ue/blendspace와-blendspace1d-차이점.html</link><guid isPermaLink="false">UE/BlendSpace와 BlendSpace1D 차이점.md</guid><pubDate>Mon, 30 Dec 2024 16:58:42 GMT</pubDate><enclosure url="images/blendspace.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/blendspace.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[월드의 생명주기]]></title><description><![CDATA[월드는 액터와 컴포넌트가 존재하고 렌더링 되는 top level 오브젝트다. 쉽게 맵이라고 생각할 수 있다. 그렇다면 월드의 생명주기는 무엇일까?게임플로우의 일반적인 순서는 Engine 초기화 -&gt; GameInstance 생성 및 초기화 -&gt; Level 로드다. 월드는 레벨이 로드될 때 생성되고 초기화 되고 로드된다.월드는 레벨에 종속되어 있는 오브젝트라고 할 수 있다. 따라서 Level이 생성될 때 World도 같이 생성 및 초기화가 진행되고, Level이 사라질 때 월드도 같이 사라지는 것이라고 할 수 있다.<img alt="GameFlowChart.png" src="images/gameflowchart.png" target="_self">]]></description><link>ue/월드의-생명주기.html</link><guid isPermaLink="false">UE/월드의 생명주기.md</guid><pubDate>Mon, 30 Dec 2024 16:58:12 GMT</pubDate><enclosure url="images/gameflowchart.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gameflowchart.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FTP Manager]]></title><description><![CDATA[
개요 내용
기존 Wave M에서 FTP를 사용하는 기능은 펌웨어 업데이트 하나였음. 추가되는 R1 나스모 기능은 FTP를 이용함. FTPClient는 새로운 인스턴스를 만들어도, 플러그인 코드 내부 객체는 static으로 선언 되어 있음. FTP를 연결할 때 펌웨어와 R1 나스모는 다른 Username을 가지고 로그인하고 다른 역할을 수행함. 따라서 기존의 FTP에 R1 나스모에 필요한 기능을 추가하고 FTP 연결을 관리할 필요성이 생김.// U2Define.h에 정의
UENUM()
enum class EFTPAddress : uint8
{ None = 0, Firmware, SwingMotion
};
FTP는 Firmware , SwingMotion 두 가지 타입을 가지고 있음.
// Connecting &amp; Disconnecting
void ConnectToFTP(EFTPAddress InAddress);
void DisconnectFromFTP(); // Upload &amp; Download
void UploadDataToFTP(const FString&amp; LocalFilePath, const FString&amp; RemoteFilePath);
void DownloadDataFromFTP(const FString&amp; LocalFilePath, const FString&amp; RemoteFilePath); // Get List
void GotoDirectory(const FString&amp; Directory);
void ListCurrentDirectory(); 각 함수에 대한 결과를 바인딩을 통해 Callback으로 받을 수 있음. 아래 Delegate Binding을 참고
// U2FTPManager.h에 정의 DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FOnU2FTPConnection, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FOnU2FTPStatus, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_SevenParams(FOnU2FTPProgress, const EFTPAddress, Address, const bool, bUploaded, const bool, end, const float, megabyteLeft, const float, megabyteSent, const int32, percent, const float, speedInMegabit);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FiveParams(FOnU2FTPGotoDirectory, const EFTPAddress, Address, const bool, success, const int32, code, const FString, serverMessage, FString, currentDir);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnFTPList, const EFTPAddress, Address, const TArray&lt;FString&gt;&amp;, files); FOnU2FTPConnection OnU2FTPConnection;
FOnU2FTPStatus OnU2FTPStatus;
FOnU2FTPProgress OnU2FTPProgress;
FOnU2FTPGotoDirectory OnU2FTPGotoDirectory;
FOnFTPList OnU2FTPList; Connecting &amp; Disconnecting에 대한 콜백을 받고 싶음 -&gt; OnU2FTPConnection에 바인딩. Uploading &amp; Downloading에 대한 콜백을 받고 싶음 -&gt; OnU2FTPProgress에 바인딩. FTP에서 워킹 폴더를 변경에 대한 콜백을 받고 싶음 -&gt; OnU2FTPGotoDirectory에 바인딩. FTP에서 해당 폴더에 있는 파일 이름들을 가져오고 싶음 -&gt; OnU2FTPList에 바인딩 ]]></description><link>ue/ftp-manager.html</link><guid isPermaLink="false">UE/FTP Manager.md</guid><pubDate>Mon, 30 Dec 2024 16:46:48 GMT</pubDate></item><item><title><![CDATA[Sounds 개선]]></title><description><![CDATA[
개요
컨텐츠 폴더 구조 (기획 ,디자인, 개발)
U2SoundDataTable - SoundType 카테고리 (기획, 디자인)
U2SoundManager - Init, Load (개발)
Audio Stream Caching 적용 (개발)
Sound 출력 Rule (기획, 디자인, 개발)
결과
P.S 사운드 작업 시 살펴봐야할 에셋들 기존에 사운드 관리자의 부재로 인해 유지보수가 지속적으로 이뤄지지 않았음. 기존의 사운드 시스템은 게임 시작 버튼 클릭시에 로딩바에서 SoundsDataTable에 있는 모든 사운드 에셋을 로딩하고, 이것들을 TMap에 저장한 후에 필요할 때 출력하는 방식으로 구성되어 있었음. 유지보수 하기 쉽고 안정적이지만 사용하지 않는 사운드 모두 메모리에 올리기 때문에 로비에서 메모리가 낭비되는 결과를 가져올 수 있음. <img src="images/foldering_to_be.png" target="_self"> ann_crash: 볼 맞추고 판정소리 () 아나운서가 벙커, OB 이런거 내주는 소리
SoundType:인게임
모두 ShotResult로 시작함.
ReplayState, U2GolfGameSoundComponent, UIIngameStrokePage에서 사용 ann_score: 찬스랑 결과 말해주는 소리 총 세가지 유형: 찬스, 홀인 결과, 컨시드 결과
SoundType: 인게임
찬스는 ScoreChane. 로 시작, UU2CaddieComponent에 종속
홀인 결과와 컨시드 결과는 UU2GolfGameSoundComponent에 종속
홀인원은 UMG(홀인원 결산)에서도 쓰임 ann_shot 스윙했을 때 나는 소리들 (굿샷, 나이스어프로치, 나이스온, 나이스플레이, 나이스샷)
SoundType: 인게임
모두 ShotResult. 로 시작함
ReplayState, U2GolfGameSoundComponent, UIIngameStrokePage에 종속
ann_crash와 거의 같음. ambient UU2GolfGameSoundComponent에 귀속
SoundType: 인게임 ball_crash BallCollidedDataTable에서 참조
SoundType: 인게임 bgm BGM
SoundType: BGM button 버튼 클릭 소리 SoundType: Common event 이벤트 소리
애니메이션에 넣지 못하는 소리 (분기처리 때문에 코드로 출력해야하는 사운드)
코드로 호출
SoundType: Common 또는 인게임 gallery 갤러리 사운드 (박수, 환호, 야유)
인게임 swing_shot 클럽별 임팩트 소리
인게임 swing_control - 전부 인게임 스윙게이지 소리
인게임 animation UMG 애니메이션에 넣는 소리
SoundType: Animation
<br><img src="images/u2_soundtype.png" target="_self"> None
사용 안함 표시 -&gt; 게임에서 사용하지 않겠다. In Game 게임 시작시에 로딩 됨
게임중에만 사용
스윙 임팩트, 스코어 사운드 등등
코드로 호출 BGM BGM
코드로 호출 Animation UMG에서 Animation - Audio Track에 추가할 사운드
코드로 호출 불가 Common 버튼 클릭 사운드
코드로 호출할 필요가 있는 사운드 (클럽, 의상 갓챠는 시네마틱 분기가 안되어서 어쩔 수 없이 여기 넣음)
코드 호출 가능 U2SoundManager 클래스는 게임 내 사운드 관리를 담당합니다. Init() 메서드를 통해 초기화되며, 다음과 같은 작업을 수행함 메시지 매니저 초기화 사운드 테이블 로드 콘솔 명령어 설정 (에디터 모드에서만) void UU2SoundManager::Init()
{ InitMessageManager(); LoadSoundTable(); #if WITH_EDITOR // 에디터에서만 콘솔 명령어 설정 if (CMD_LogSound == nullptr) { CMD_LogSound = UU2ConsoleManager::Instance()-&gt;RegisterConsoleCommand( DEF_CSC_LOG_SOUND, TEXT("테스트용: 사운드 로그"), FConsoleCommandWithArgsDelegate::CreateUObject(this, &amp;UU2SoundManager::CONSOLE_LogSound), ECVF_Default ); } #endif
} 등록된 콘솔 명령어는 런타임에서 사용할 수 있음.U2.Log.Sound 0 - Sound 로그 가리기U2.Log.Sound 1 - Sound 로그 보이기LoadSoundTable() SoundsDataTable의 모든 행을 읽음.각 행의 SoundType으로 각 사운드 에셋을 저장할 Map을 지정함.코드에서 None, Animation은 break; 처리함.None은 사용하지 않기 때문에 Map에 저장하지 않아도 되기 때문이고, Animation은 UMG에서 로드하고, 언로드하기 때문에 Map에 저장하지 않는다. (코드로 호출할 필요가 없기 때문)InGame, BGM, Common은 코드로 호출할 필요가 있기 때문에, 지정된 Map에 저장을 한다. 그 중 InGame 사운드는 사운드 큐를 넣을 곳 (Value) nullptr을 넣는다. 이유는 로비에서 InGame 사운드를 사용하지 않기 때문에 미리 로드하지 않기 때문이다. BGm, Common은 LoadSound를 하고 지정된 Map의 Value에 사운드 큐를 저장한다.void UU2SoundManager::LoadSoundTable()
{ if (IsAlreadyCalling) { return; } IsAlreadyCalling = true; TArray&lt;FU2SoundDataTable*&gt; RowArray; UU2DBManager::Instance()-&gt;GetDataTableRows&lt;FU2SoundDataTable&gt;(TEXT("SoundsDataTable"), RowArray); for (FU2SoundDataTable* it : RowArray) { switch (it-&gt;SoundType) { case EU2SoundType::None: break; case EU2SoundType::InGame: InGameSounds.Emplace(it-&gt;KeyValue, nullptr); break; case EU2SoundType::BGM: LoadSound(it-&gt;KeyValue, it-&gt;Sound, it-&gt;SoundType); break; case EU2SoundType::Animation: break; case EU2SoundType::Common: LoadSound(it-&gt;KeyValue, it-&gt;Sound, it-&gt;SoundType); break; default: break; } }
} 인게임 사운드 로드와 언로드는 UU2RoundLoadingState와, UU2GameToLobbyState에서 아래 함수를 통해서 이뤄진다.void UU2SoundManager::LoadInGameSounds()
{ for (auto&amp; Elem : InGameSounds) { if (!Elem.Value) { FU2SoundDataTable* Row = UU2DBManager::Instance()-&gt;GetDataTableRow&lt;FU2SoundDataTable&gt;(TEXT("SoundsDataTable"), FName(Elem.Key)); TSoftObjectPtr&lt;USoundBase&gt; SoundPtr(Row-&gt;Sound); LoadSoundInternalAsync(Elem.Key, SoundPtr, EU2SoundType::InGame); } }
} void UU2SoundManager::UnloadGameOnlySounds()
{ for (auto&amp; Elem : InGameSounds) { if (Elem.Value) { Elem.Value = nullptr; OutGameSounds.Remove(Elem.Key); } }
} Audio Stream Caching은 Unreal Engine에서 오디오 성능을 최적화하기 위한 기능 효과 쿡 타임에서 이 기능을 활성화하면 거의 모든 압축 오디오 데이터가 USoundWave 자산에서 분리되어 .pak 파일의 끝에 배치됨. 이를 통해 오디오가 어느 시점에서든 메모리에 로드되고 최근에 사용되지 않았을 때 다시 해제되는 것이 가능 Audio Stream Caching 사용법 각 Platform → iOS / Android → Audio → CookOverrides → Use Stream Caching
Max Cache Size 설정 Prime On Load 적용 Sound 재생 초기 부분을 미리 메모리에 올린다 → 재생 지연 방지 Sound Class - Loading 에서 적용 가능 BGM: 코드로 출력 (보통 State에서 출력함)Animation: UMG에서 오디오 트랙을 이용해서만 호출 (코드로 호출 X) In Game: 코드로 호출
swing impact, crash 등등: 코드로만 호출
Ingame UI: UMG 오디오 트랙으로 호출 가능Common
현재는 코드로 호출
추후 BP를 이용해서 호출할 예정
적용 전
로비, 게임: 132.275 MiB<br>
<img src="images/insight_before.png" target="_self">
적용 후 (Audio Stream Caching 사용)
Lobby ~ InGame 결과
초기화 ~ Lobby ~ 인게임: 132.275 MiB → 20~ 30 MiB (감소율 81.01%)<br>
<img src="images/insight_after.png" target="_self">]]></description><link>ue/sounds-개선.html</link><guid isPermaLink="false">UE/Sounds 개선.md</guid><pubDate>Mon, 30 Dec 2024 16:43:11 GMT</pubDate><enclosure url="images/foldering_to_be.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/foldering_to_be.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Helix Core Workflow]]></title><description><![CDATA[Update: 2024/12/18
소개
Stream Depot 구조 이해하기
일반적인 작업 흐름
코드 리뷰 프로세스
주의사항
이 문서는 우리 팀의 Helix Core 작업 환경과 프로세스를 설명합니다. 개발팀과 아트팀이 효율적으로 협업할 수 있도록 설계되었습니다.우리는 Local Depot 대신 Stream Depot을 사용합니다. Stream Depot의 주요 장점은:
브랜치 관리의 용이성
변경사항의 명확한 추적
팀 간 협업 효율성 향상
자동화된 머지 충돌 감지 Mainline Stream: 제품의 안정된 버전을 포함하는 최상위 스트림
Development Stream: 활발한 개발이 이루어지는 주요 통합 스트림
Task/Feature Stream 개별 개발자나 아티스트의 작업 공간
Development 스트림에서 분기
특정 기능이나 작업을 위한 독립된 환경 Release Stream: 출시된 버전을 보관하는 스트림 작업 시작하기 Development 스트림에서 새로운 Task/Feature 스트림 생성
작업할 스트림으로 전환 변경사항 제출 자신의 Task/Feature 스트림에는 자유롭게 submit 가능
Development 스트림으로의 머지는 코드 리뷰 필수 머지 프로세스 작업 완료 후 Development 스트림과 머지 진행
Swarm을 통한 코드 리뷰 승인 필요
승인 후 머지 진행 Swarm 설정이 필요한 부분:
리뷰어 자동 할당 규칙 설정
승인 필요 인원 수 설정
머지 전 필수 리뷰 정책 설정
리뷰 만료 기간 설정
자동 알림 설정 스트림 접근 제한 Development와 Mainline 스트림에 직접 submit 금지
반드시 머지 프로세스를 통해서만 변경사항 반영 코드 품질 관리 Mainline 스트림에는 검증된 코드만 허용
모든 머지는 코드 리뷰 승인 필수 ]]></description><link>infra/helix-core-workflow.html</link><guid isPermaLink="false">Infra/Helix Core Workflow.md</guid><pubDate>Mon, 30 Dec 2024 15:54:02 GMT</pubDate></item><item><title><![CDATA[UE4 Source iOS Debugging on MacOS]]></title><description><![CDATA[$ sudo chmod -R 755 ./
Setup.command는 엔진을 빌드하기 위한 의존성 컨텐트(PhysX, Make, Cmake etc.. ) 를 다운로드 합니다.(binary content for engiene)overwrite 할 것이냐고 묻는데 N 눌러야 합니다.(만약 덮어쓸 경우 PhysX iOS 라이브러리 뽑아서 덮어쓴 다음에 엔진 빌드 해야함)Engine Source를 빌드하는 IDE를 설정합니다. 기본적으로 값이 없거나 보통 VisualStudio로 되어 있습니다.$ vim {Engine Source}/Engine/Config/BaseEditorSetting
# BaseEditorSettings.ini ... [/Script/SourceCodeAccess.SourceCodeAccessSettings] PreferredAccessor=XCodeSourceCodeAccessor
엔진 워크 스페이스를 생성합니다.엔진 워크스페이스를 열고 타겟을 ShaderCompileWorker 변경하고 로제타를 이용해서 빌드합니다. 그런 다음에 타겟을 UE4로 변경 후 역시 로제타를 이용해서 빌드 합니다. 빌드가 성공하면 엔진 빌드 성공입니다.로제타 빌드가 없는 경우는'Xcode -&gt; Product -&gt; destination -&gt; Destination Archtectures -&gt; show rosseta destination'를 확인해서 체크하기맥에서 빌드를 하고 iOS 기기로 디버깅을 하기 위해서는 몇가지 번거로운 작업을 해야합니다. 먼저 Windows에서 필요한 작업이 있습니다. 윈도우 데스크탑에서 아래 경로 폴더들을 맥으로 가져옵니다.{프로젝트 경로}/Intermediate/IOS(info.plist 제외)
{프로젝트 경로}/Intermediate/Plugins (NativizedAssets)
그런 다음에 리모트 빌드를 하고 .ipa 파일을 뽑고 맥으로 가져옵니다.$ cd {엔진 소스 경로}/Build/BatchFiles/Mac
$ ./GenerateProjectFiles.sh -project={프로젝트 경로}/{프로젝트}.uproject -game
프로젝트를 생성하면 Intermediate 폴더가 생기는데 Intermediate안에 위에서 가져온 폴더들을 넣습니다.그러고나서 타겟을 프로젝트로 바꾸고 Edit Scheme을 눌러서 Run을 클릭하고 Configuration을 Debug Game으로 바꿉니다. iOS 기기를 연결하고 빌드 합니다.위에서 리모트 빌드로 뽑은 .ipa 파일을 .zip 확장자로 바꿉니다. unzip을 한 후 Payload-{프로젝트}.app을 클릭하고 Show package contents를 클릭합니다.$ cd {프로젝트소스}/Binaries/iOS/Payload
마찬가지로 .app에 Show package contents를 클릭하고 누락된 부분(cookeddata등)을 복사, 붙여넣기를 합니다.그런 다음에 빌드를 하고 XCode에서 Debug - Attach to Process를 클릭해서 중단점 찍어서 디버깅할 수 있게 됩니다.$ sudo chmod -R 755 ./
Permission Denied 시에 권한을 줘야함 Setup.command는 여러 스크립트를 실행 시키므로각 스크립트에
권한을 줘야함.
OS 자체적으로 막는 경우는 System preference에서 GateKeeper 검색하고 Open anyway 클릭함
Checking dependencies...
Updating dependencies: 0% (0/63485)...
Failed to download '<a rel="noopener nofollow" class="external-link is-unresolved" href="http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94" target="_self">http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94</a>': The remote server returned an error: (403) Forbidden. (WebException)
이 경우에 Engine/Build/Commit.gitdeps.xml을 적절한 버전의 Engine/Build/Commit.gitdeps.xml으로 교체예를 들어 Unreal 4.27 같은 경우는 Unreal Engine Github의 4.27-plus 브랜치를 받으면 됨
Running bundled mono, version: Mono JIT compiler version 5.16.0.220 (2018-06/bb3ae37d71a Fri Nov 16 17:12:11 EST 2018)
The domain/default pair of (com.epicgames.ue4, MonoAOT) does not exist
WARNING: Visual Studio C++ 2019 installation not found - ignoring preferred project file format.
While compiling /Users/choeseung-in/Desktop/GolfzonMEngineSource/Engine/Intermediate/Build/BuildRules/UE4Rules.dll:
../Plugins/GSDevices/CardReader/Source/CardReader/CardReader.Build.cs(58,10) : warning CS0219: The variable `RfdllIncludePath' is assigned but its value is never used
Generating data for project indexing...
Couldn't find PLCrashReporter in folder 'lib-Xcode-14.1', using default 'lib-Xcode-12.4'
Generating data for project indexing... 100%
Writing project files... 0%
ERROR: Visual Studio 2017 must be installed in order to build this target.Saving session...completed.
Source Code를 빌드하는 IDE에 대한 오류 Engine/Config/BaseEditorSettings.ini에 있는 [/Script/SourceCodeAccess.SourceCodeAccessSettings] 설정이 VisualStudio라서 발생한 이슈Mac에서는 Xcode로 설정 해야함[/Script/SourceCodeAccess.SourceCodeAccessSettings] PreferredAccessor=XCodeSourceCodeAccessor
// Engine/Source/Runtime/Engine/Private/Components/DeferredRoadComponent.cpp // TAtomic&lt;int&gt; OverlapCounter = 0;
int32 OverlapCounter = 0; // Engine/Source/Editor/UnrealEd/Private/EditorEngine.cpp int32 XIndex = FString(PackageName).Find(TEXT("_X"), ESearchCase::IgnoreCase, ESearchDir::FromEnd); int32 YIndex = FString(PackageName).Find(TEXT("_Y"), ESearchCase::IgnoreCase, ESearchDir::FromEnd);
// Engine/Source/Editor/TranslationEditor/Private/TranslationEditor.cpp if (!((AssetData.PackageFlags &amp; (PKG_ContainsMap | PKG_PlayInEditor | PKG_ContainsMapData)) == 0)) { OutFailureReason = FString::Printf(TEXT("The AssetData '%s' is not accessible because it is of type Map/Level."), *ObjectPath); return FAssetData(); }
Showing All Messages
Undefined symbols for architecture arm64:
"PxSetGSConfPxGSConf const&amp;", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; "PxSetCoefftablesPxCoefftableSource*", referenced from:&nbsp;
UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; "PxSetHolecupRadius(float)", referenced from: &nbsp; &nbsp; &nbsp; UHoleContext::UpdateHole(unsigned char, EGreenType, EHoleType, FVector) in Module.U1Engine.cpp.o&nbsp; "PxSetGreenSpeedTypeGZGreenSpeedType", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::UpdateGreenSpeedTypeGZGreenSpeedType in Module.U1Engine.cpp.o&nbsp; "PxSetHolecupPositionPxVec3 const&amp;", referenced from:&nbsp; &nbsp; &nbsp; UHoleContext::UpdateHole(unsigned char, EGreenType, EHoleType, FVector) in Module.U1Engine.cpp.o &nbsp; "PxSetSurfacetypeTablePxGSSurfacetypeTable*", referenced from:&nbsp; &nbsp; &nbsp; UPhysicsServer::Init(TArray&lt;FCoeffSetting, TSizedDefaultAllocator&lt;32&gt;&gt; const&amp;) in Module.U1Engine.cpp.o&nbsp; "PxSetWindPxVec3 const&amp;", referenced from: &nbsp; &nbsp; &nbsp; UHoleContext::SetWind(FVector2D const&amp;) in Module.U1Engine.cpp.old: symbol(s) not found for architecture arm64
Module.U1Engine.cpp.o의 심볼을 확인할 때, PxSetGS... 같이 커스텀한 함수를 호출함. 근데, Engine은 PxSetGS 함수를 알지 못함.
$ cd&nbsp;{엔진소스}/Engine/Source/ThirdParty/PhysX3/Lib/IOS
$ nm libPxFoundationDEBUG.a
그리고 PxSetGS를 검색 -&gt; 심볼이 있으면 엔진 XCode DerivedData 삭제, 클린 빌드 후 엔진 리빌드, 프로젝트 재생성심볼이 없는 경우 PhysX를 빌드하고 Binary를 교체한 후에 위의 과정을 따라감NativizedAssets 관련 - 프로젝트 Run 이후<br><img alt="NativizedAssets.png" src="images/nativizedassets.png" target="_self">Blueprint로 작성한 내용들이 Native 코드로 변환되는 작업이 있음. 이를 윈도우에서 Intermediat/Plugin/IOS에서 가져 와야함.]]></description><link>ue/ue4-source-ios-debugging-on-macos.html</link><guid isPermaLink="false">UE/UE4 Source iOS Debugging on MacOS.md</guid><pubDate>Mon, 30 Dec 2024 15:42:57 GMT</pubDate><enclosure url="images/nativizedassets.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/nativizedassets.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Sounds 개념]]></title><description><![CDATA[사운드 큐는 하나 이상의 사운드 웨이브를 포함할 수 있는 오브젝트입니다. 이를 통해 복잡한 사운드 효과를 구성할 수 있습니다. 사운드 큐는 다양한 노드를 통해 사운드를 조작할 수 있습니다.
모듈레이션 노드: 피치나 볼륨을 변경할 수 있습니다.
믹서 노드: 여러 사운드를 믹싱할 수 있습니다.
랜덤 노드: 여러 사운드 중 랜덤으로 하나를 재생합니다.
시퀀스 노드: 여러 사운드를 순차적으로 재생합니다.
사운드 웨이브는 실제 오디오 데이터를 포함하는 가장 기본적인 사운드 자산입니다. WAV, MP3 등의 파일 형식을 사용할 수 있으며, 주파수, 볼륨, 피치 등의 기본 속성을 설정할 수 있습니다.사운드 클래스는 사운드를 그룹화하고 그 그룹에 공통된 설정을 적용할 수 있게 해줍니다. 예를 들어, 음악, 효과음, 대사를 각각의 사운드 클래스로 나누고, 볼륨이나 믹싱 설정을 개별적으로 조정할 수 있습니다.사운드 믹스는 여러 사운드 클래스의 볼륨이나 피치를 조정하는 데 사용됩니다. 특정 이벤트가 발생했을 때, 사운드 믹스를 적용하여 게임 내 모든 사운드의 특성을 변경할 수 있습니다.오디오 컴포넌트는 액터에 붙여서 사운드를 재생하는 데 사용됩니다. 이를 통해 액터의 위치에 따라 3D 공간에서 사운드를 재생할 수 있습니다.
리버브: 공간의 울림을 시뮬레이션하여 더 현실적인 사운드를 제공합니다.
필터: 특정 주파수를 강조하거나 감소시켜 다양한 효과를 만들 수 있습니다.
채널 (Channel)• 채널은 오디오 시스템에서 독립된 오디오 신호 경로를 의미합니다. 오디오의 방향성과 관련이 깊습니다.• 모노 (Mono), 스테레오 (Stereo), 서라운드 사운드 (Surround Sound) 같은 다양한 채널 구성은 사운드를 어떻게 분배하고 재생할지를 결정합니다.Mono (모노)• 모노는 단일 오디오 채널을 사용하여 소리를 재생합니다.
• 모든 스피커에서 동일한 오디오 신호를 재생하기 때문에, 공간적인 방향성 없이 하나의 소리 원천처럼 들립니다.Stereo (스테레오)• 스테레오는 두 개의 채널(좌, 우)을 사용합니다.
• 각 채널에 다른 오디오 신호를 보내어 공간감을 만들어냅니다. 예를 들어, 음악에서는 악기나 보컬이 왼쪽이나 오른쪽에서 더 크게 들릴 수 있습니다.Surround Sound (서라운드 사운드)
• 서라운드 사운드는 다수의 채널(5.1, 7.1 등)을 사용하여 모든 방향에서 소리가 나오는 듯한 환경을 만듭니다.
• 영화관, 홈시어터 시스템, 고급 게임 환경에서 주로 사용됩니다.Mono vs. Stereo의 차이• 모노는 단일 포인트에서 소리가 나오는 느낌을 줍니다.
• 스테레오는 소리가 좌우로 퍼져 나가며, 청취자에게 더 풍부하고 입체적인 경험을 제공합니다.근데 모노를 사용하는 이유?
용량
공간감 표현 (3d)
실제세계는 모노로 나가는게.. 좀 더 현실적임
SoundManager를 어떻게 고도화할 수 있을까? 사운드 풀링 시스템 구현: 사운드가 재생될 때마다 새로운 오디오 구성 요소를 만드는 대신 재사용 가능한 오디오 구성 요소 풀을 구현합니다. 이는 특히 자주 재생되는 사운드의 경우 성능을 향상시키고 메모리 할당 오버헤드를 줄일 수 있습니다. 사운드 우선순위 구현: 바쁜 오디오 환경에서도 중요한 오디오 신호가 항상 들리도록 사운드 우선순위 시스템을 만듭니다.(6) 로깅시스템 및 에러처리 (5) 사운드 로딩 최적화: 초기화 시 모든 사운드를 로드하는 대신 요청 시 또는 일괄적으로 사운드를 로드하는 시스템을 구현하여 초기 로딩 시간을 줄입니다. 8 동적 음악 시스템에 대한 지원 추가: 게임 상태 또는 이벤트에 따라 다양한 음악 트랙 간에 원활하게 전환하는 시스템을 구현합니다.7 현지화 지원 추가: 오디오 파일의 다양한 언어 버전 간을 쉽게 전환할 수 있는 시스템을 구현합니다 사운드 자산에 비동기 로딩 사용: 동기 로딩을 비동기 로딩으로 대체하여 특히 대용량 사운드 파일의 성능을 향상시킵니다. ]]></description><link>ue/sounds-개념.html</link><guid isPermaLink="false">UE/Sounds 개념.md</guid><pubDate>Mon, 30 Dec 2024 15:41:18 GMT</pubDate></item><item><title><![CDATA[PSO (Pipeline State Object) 수집]]></title><description><![CDATA[언리얼 엔진에서 PSO(Pipeline State Object)는 그래픽 렌더링 파이프라인의 상태를 정의하는 객체. PSO는 주로 Direct3D 12 및 Vulkan 같은 저수준 그래픽 API에서 사용되며, 그래픽 파이프라인의 다양한 설정(셰이더, 블렌딩)을 캡슐화합니다. 이를 통해 렌더링을 효율적으로 관리할 수 있습니다.
PSO는 그래픽 파이프라인 상태를 한 번에 정의하고 이를 캐시할 수 있습니다. 이는 매 프레임마다 상태를 변경하는 것보다 훨씬 효율적입니다. PSO는 다양한 파이프라인 상태를 하나의 객체로 관리할 수 있어 상태 변경 관리가 단순해집니다. Unreal Engine은 이러한 저수준 API들을 추상화하여 PSO를 통해 다양한 플랫폼에서 최적화된 렌더링을 제공합니다. PSO 데이터 수집 목적은 성능 최적화, 셰이더 컴파일 시간 단축, 일관된 성능 제공, 런타임 프레임 드롭 방지, 디버깅 및 최적화에 있다. PSO를 미리 컴파일하여 필요할 때 빠르게 사용할 수 있어 런타임 성능을 향상시킵니다. 사전 정의된 PSO를 사용하면 상태 설정 과정에서 발생할 수 있는 불필요한 연산을 피할 수 있습니다. PSO는 패키징 설정을 Development로 바꾸고 Share Material Shader Code 체크 PSO 데이터 수집을 위해서는 디버깅 정보를 포함해서 패키징 해야하므로 Dev 빌드
여러 머터리얼이 공통으로 사용하는 셰이더 코드를 공유하도록 함 → 중복된 셰이더 제거 → 메모리 효율 증가 맵 포함 패키징 맵에서 사용하는 모든 셰이더와 랜더링 상태를 로드하고 기록하기 위해 맵 전체 포함 .shk 파일을 백업 셰이더 키 캐시(Shader Key Cache) 파일
파일은 셰이더 컴파일 과정에서 생성되며, 특정 셰이더의 키 정보를 저장합니다. 이 키 정보는 셰이더가 변경되었는지 여부를 확인하고, 캐싱된 버전을 사용할 수 있는지를 판단
셰이더 키 캐시를 통해 게임 실행 시 셰이더 로딩 시간을 줄일 수 있음 위에서 뽑은 맵을 이용해서 PSO 데이터 수집 Android, iOS 각 플랫폼마다 게임을 플레이하면서 PSO 데이터를 수집 데이터 수집한 디바이스에서 .upipelinecache 확장자명을 가진 파일 추출 PSO 데이터가 저장된 .upipelinecache 백업한 파일과 upipelinecache 확장자명을 가진 파일을 이용해서 csv 파일로 추출 (with 최승인 프로) .shk 키와 .upipelinecache 데이터를 이용해서 PSO 데이터를 텍스트 형식으로 저장해 분석/수정 가능하게 수정 이를 {Project}/Build/{Platform}/PipelineCaches에 넣고, Shipping, Share Material Shader Code를 체크 해제하고 해당 맵을 포함한채로 패키징 해당 경로에 CSV 배치해두면 패키징 과정에서 해당 파일 참조하여 PSO 데이터 포함하게 된다. 모바일 디바이스를 PC에 연결하고 앱 Saved/CollectedPSOs 위치에 아래와 같은 파일들이 있다.
<img alt="collectpso.png" src="images/collectpso.png" target="_self">
셰이더 키 캐시 파일(.shk)과 upipelinecache 파일을 한 폴더에 넣고 UE4Editor-Cmd를 이용해서 csv 파일을 추출한다.
<br><img alt="pso_data.png" src="images/pso_data.png" target="_self">cd {your_engine folder}/Engine/Binaries/Win64 .\UE4Editor-Cmd.exe D:\Develop\WaveM\U2Client_Wave\U2Client.uproject -run=ShaderPipelineCacheTools expand C:\Users\psyche95\Desktop\WM_Backup\pso_2.1.1_backup\psodata\*.rec.upipelinecache C:\Users\psyche95\Desktop\WM_Backup\pso_2.1.1_backup\psodata\*.shk U2Client_SF_METAL.stablepc.csv 안드로이드는 GPU에 따라 OpenGL, 또는 Vulkan을 사용할 수 있다. (둘 다 지원할 수도 있음) 그렇기 때문에 안드로이드는 PSO 수집을 두 번 해야 한다.안드로이드 신버전은 앱에서 파일을 뽑는 것을 보안상 막아놓았기 때문에 구버전 (현재 가지고 있는 기기 s9, note9) 으로 진행한다.노트9, s9의 GPU는 Mali_72이고, OpenGL, Vulkan을 지원한다.따라서 Mali_72를 이용해서 OpenGL, Vulkan PSO 데이터를 수집하면 된다.
[Android_Mali_G72 DeviceProfile] DeviceType=Android BaseProfileName=Android_High; enable Vulkan on Android 9 and up, older versions crash on creating PSO with a compute shader that uses texel_buffer (eye adaptation) +CVars=r.Android.DisableVulkanSupport=0
+CVars=r.Vulkan.RobustBufferAccess=1 +CVars=r.Vulkan.DescriptorSetLayoutMode=2 +CVars=r.DefaultBackBufferPixelFormat=0 +CVars=r.Vulkan.RayTracing.AllowCompaction=0 +CVars=r.Vulkan.RayTracing.TLASPreferFastTraceTLAS=0
위의 코드가 들어가 있으면 Mali_72 GPU는 Vulkan API를 사용한다는 뜻이다. → 불칸용 PSO 데이터 수집위의 코드가 들어가 있지 않으면 Mali_72 GPU는 OpenGL API를 사용한다는 뜻이다 → OpenGL PSO 데이터 수집Saved/Cooked/Android_ASTC/{GameProject}/Metadata/PipelineCaches에 .shk 파일이 생김. 이를 백업해놓아야함.]]></description><link>ue/pso-(pipeline-state-object)-수집.html</link><guid isPermaLink="false">UE/PSO (Pipeline State Object) 수집.md</guid><pubDate>Mon, 30 Dec 2024 15:40:58 GMT</pubDate><enclosure url="images/collectpso.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/collectpso.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Media Framework]]></title><description><![CDATA[MediaPlayer, MediaSource, MediaTexture, UImage, UMaterialInstanceDynamic 관계 MediaSource 역할: 미디어 데이터의 원천을 정의
UFileMediaSource, UStreamMediaSource 등 부모 클래스
관계 MediaPlayer와 직접 연결 다른 컴포넌트들과는 직접적인 관계가 없음. MediaPlayer 역할: 미디어를 재생하고 제어합니다.
관계 MediaSource로부터 데이터를 받아 디코딩함.
MediaTexture에 디코딩된 비디오 프레임을 제공.
전체 시스템의 중심 역할 MediaTexture 역할: MediaPlayer가 제공하는 비디오 프레임을 텍스처로 변환
관계 MediaPlayer로부터 비디오 프레임을 받음
UMaterialInstanceDynamic의 텍스처 파라미터로 사용됨 UMaterialInstanceDynamic 역할: 동적으로 변경 가능한 머티리얼 인스턴스를 제공
관계 MediaTexture를 텍스처 파라미터로 사용
UImage의 브러시로 사용됨 UImage 역할: UI에 이미지나 비디오를 표시
관계 UMaterialInstanceDynamic을 브러시로 사용하여 비디오를 표시 ]]></description><link>ue/media-framework.html</link><guid isPermaLink="false">UE/Media Framework.md</guid><pubDate>Mon, 30 Dec 2024 15:37:41 GMT</pubDate></item><item><title><![CDATA[insight]]></title><description><![CDATA[insight를 위한 명령어를 넣어줘어야 함.ADB로 Trace를 위한 포트 오픈 (1980)리버스로 해야 들어온다. 포워드로 하면 반대로 가겠지Unreal Insight 실행해서 AutoStart 설정해두면 게임 실행시 Insight 프로세스가 자동실행된다.쭉 추적하고, Trace Sessions에 들어온 Insight 파일로 프로파일링 진행한다.UE4Editor.exe "D:\Develop\GolfzonM\U2Client\U2Client.uproject" -game -WINDOWED -ResX=1280 -ResY=720 -trace=cpu,gpu,memory,log,frame -engine="D:\Develop\GolfzonMEngine\Engine"
PowerShell로 할 경우 인자 추가가 안됨 (cpu,gpu...) -&gt; Cmd로 할 것이 명령어는 언리얼 엔진 4에서 Unreal Insights를 사용하기 위한 실행 인자들입니다. 각 인자에 대해 설명 -NetTrace=1
네트워크 트레이싱을 활성화합니다. -trace=cpu,frame,gpu,memory,log,counters
트레이스할 데이터 유형을 지정합니다. 여기서는 CPU, 프레임, GPU, 메모리, 로그, 카운터 데이터를 수집합니다. -tracehost=127.0.0.1
트레이스 데이터를 전송할 호스트 IP를 지정합니다. 여기서는 로컬호스트를 사용합니다. -Messaging
메시징 시스템을 활성화합니다. Unreal Insights와의 통신에 필요합니다. -SessionId=
세션 ID를 지정합니다. 여기서는 비어 있어 자동 생성됩니다. -SessionOwner=""
세션 소유자의 이름을 지정합니다. -SessionName=""
세션의 이름을 지정합니다. 여기서는 비어 있어 자동 생성됩니다. -iterative
반복적 빌드 모드를 활성화합니다. 개발 중 빠른 재컴파일을 위해 사용됩니다. -fileopenlog
파일 열기 작업에 대한 로깅을 활성화합니다. -tracefile=PathToSaveTraceTo.utrace
트레이스 데이터를 저장할 파일 경로를 지정합니다. .utrace 확장자를 사용합니다. 이 명령어는 Unreal Insights를 사용하여 상세한 성능 데이터를 수집하고 분석하는 데 사용됩니다. CPU, GPU, 메모리 사용량, 프레임 정보 등 다양한 성능 지표를 추적하며, 네트워크 활동도 모니터링합니다. 개발자 이름(chin)을 지정하고 있어, 팀 환경에서 누가 어떤 세션을 실행했는지 추적하는 데 유용할 수 있습니다. 또한 트레이스 파일을 지정된 경로에 저장하므로, 나중에 이 데이터를 Unreal Insights 툴에서 분석할 수 있습니다.언리얼 엔진 4에서 Unreal Insights와 관련된 추가적인 명령 인자들을 알려드리겠습니다. 이 목록은 주요 인자들을 포함하고 있지만, 모든 인자를 망라하지는 않을 수 있습니다. -TraceGameThread=1
게임 스레드의 트레이싱을 활성화합니다. -TraceRenderThread=1
렌더링 스레드의 트레이싱을 활성화합니다. -TraceAudioThread=1
오디오 스레드의 트레이싱을 활성화합니다. -TraceTasks=1
태스크 시스템의 트레이싱을 활성화합니다. -TraceMemory=1
메모리 할당 및 해제의 트레이싱을 활성화합니다. -TraceUI=1
사용자 인터페이스 관련 활동의 트레이싱을 활성화합니다. -TraceFrames=1
프레임 정보의 트레이싱을 활성화합니다. -TraceAnim=1
애니메이션 시스템의 트레이싱을 활성화합니다. -TraceLoadTime=1
자산 로딩 시간의 트레이싱을 활성화합니다. -TraceRHI=1
렌더링 하드웨어 인터페이스(RHI) 호출의 트레이싱을 활성화합니다. -InsightsBufferSize=
Insights 트레이스 버퍼의 크기를 설정합니다. (예: -InsightsBufferSize=100) -statnamedevents
네임드 이벤트에 대한 통계를 활성화합니다. -NoInsightsConsole
Insights 콘솔 출력을 비활성화합니다. -InsightsLatencyCompensation=
네트워크 지연 보상 값을 설정합니다. (밀리초 단위) -InsightsCollectorPort=
Insights 콜렉터가 사용할 포트 번호를 지정합니다. -InsightsCollectorHost=
Insights 콜렉터의 호스트 주소를 지정합니다. -TraceBookmarks=1
북마크 이벤트의 트레이싱을 활성화합니다. -TraceLiveInterval=
라이브 트레이싱 업데이트 간격을 설정합니다. (초 단위) -TraceMaxFileSize=
트레이스 파일의 최대 크기를 설정합니다. (MB 단위) -TraceScreenshots=1
스크린샷 캡처를 트레이스에 포함시킵니다. ]]></description><link>ue/insight.html</link><guid isPermaLink="false">UE/insight.md</guid><pubDate>Mon, 30 Dec 2024 15:35:51 GMT</pubDate></item><item><title><![CDATA[Get_AudioTrackInfo_UMG]]></title><description><![CDATA[UMG 사운드 출력은 애니메이션에서 오디오 트랙을 추가해서 할 것이다.
이때, UMG에서 사운드가 출력될 때 코드 처리가 필요하거나 로깅을 해야할 수 있다.UMG에서 오디오 트랙 정보를 얻고, 이 애니메이션이 재생될 때 브로드캐스팅을 받는 방법이다.
{Project}.Build.cs에 "MovieScene", "MovieSceneTracks" 의존성 추가해야함. // Dependency header
#include "Tracks/MovieSceneAudioTrack.h"
#include "Sections/MovieSceneAudioSection.h" void UUCustomWidget::OnAnimationStarted_Implementation(const UWidgetAnimation* Animation)
{ Super::OnAnimationStarted_Implementation(Animation); #if defined(WITH_EDITOR) &amp;&amp; defined(__FUNC_LOG_DETAIL_SOUND__) U2_LOG(U2Sound, Log, TEXT("Animation started: %s"), *Animation-&gt;GetName()); GetAudioTrackInfo(Animation);
#endif
} void UUCustomWidget::GetAudioTrackInfo(const UWidgetAnimation* Animation) const
{ if (!Animation) return; if (!Animation-&gt;GetMovieScene()) return; UMovieScene* MovieScene = Animation-&gt;GetMovieScene(); TArray&lt;UMovieSceneTrack*&gt; AudioTracks = MovieScene-&gt;GetMasterTracks(); for (UMovieSceneTrack* Track : AudioTracks) { if (UMovieSceneAudioTrack* AudioTrack = Cast&lt;UMovieSceneAudioTrack&gt;(Track)) { // Get Audio Tack info TArray&lt;UMovieSceneSection*&gt; Sections = AudioTrack-&gt;GetAllSections(); for (UMovieSceneSection* Section : Sections) { // Process Section if (UMovieSceneAudioSection* AudioSection = Cast&lt;UMovieSceneAudioSection&gt;(Section)) { if (AudioSection-&gt;HasStartFrame()) { FFrameNumber StartFrame = AudioSection-&gt;GetInclusiveStartFrame(); float StartTime = MovieScene-&gt;GetTickResolution().AsSeconds(StartFrame); U2_LOG(U2Sound, Log, TEXT("@@@@@@@@@@@@@@@@@@@@@@Audio Track Start Time: %f @@@@@@@@@@@@@@@@@@@"), StartTime); USoundBase* Sound = AudioSection-&gt;GetSound(); if (Sound) { FString SoundName = Sound-&gt;GetName(); FTimerHandle LogSoundTimer; // #TDBH - will later implement LogSound in Soundmanager //GetWorld()-&gt;GetTimerManager().SetTimer(LogSoundTimer, FTimerDelegate::CreateLambda([SoundName]() //	{ // UU2SoundManager::Instance()-&gt;LogSound(SoundName); //	}), StartTime, false); } } } } } }
} ]]></description><link>ue/get_audiotrackinfo_umg.html</link><guid isPermaLink="false">UE/Get_AudioTrackInfo_UMG.md</guid><pubDate>Mon, 30 Dec 2024 15:33:09 GMT</pubDate></item><item><title><![CDATA[DataTable_Asset_Ref]]></title><description><![CDATA[문제상황:
모든 사운드 에셋 USound는 USoundDatable에서 관리한다. USoundDatable은 TSoftObjectPtr로 사운드큐를 직접 가지고 있다. 그리고 다른 특정상황에서 사용하는 데이터테이블이 있다. (CollidedSoundDataTable - 이를 C데이터테이블이라 칭함.) C데이터테이블도 마찬가지로 사운드큐를 가지고 있다. 만약 충돌 소리가 변경된다면 USoundDataTable 사운드큐도 바꿔줘야하고, C데이터테이블 사운드큐도 바꿔줘야한다.
C데이터테이블에서 USoundDataTable의 특정 Row를 참조하면 된다.USTRUCT()
struct U2CLIENT_API FU2BallCollidedDataTable : public FU2TableRowBase
{ GENERATED_USTRUCT_BODY()
public: UPROPERTY(EditAnywhere) ESurfaceType surfaceType = ESurfaceType::None; UPROPERTY(EditAnywhere) FDataTableRowHandle SoundRowHandle; UPROPERTY(EditAnywhere) TSoftObjectPtr&lt;UParticleSystem&gt; PS_Collided = nullptr;
}; 결과<img src="images/datahandle_row_result.png" target="_self">코드에서 꺼내 쓰는 법.FU2SoundDataTable* row = resDT-&gt;SoundRowHandle.GetRow&lt;FU2SoundDataTable&gt;(TEXT("BallCollisionSound")); if (row == nullptr) return; if (row-&gt;bUseSound) { UU2SoundManager::Instance()-&gt;PlaySound(row-&gt;KeyValue); }
]]></description><link>ue/datatable_asset_ref.html</link><guid isPermaLink="false">UE/DataTable_Asset_Ref.md</guid><pubDate>Mon, 30 Dec 2024 15:31:49 GMT</pubDate><enclosure url="images/datahandle_row_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/datahandle_row_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Content Cooking & pak & chunk]]></title><description><![CDATA[게임 실행파일과 필수 에셋: pak0pak0을 설정하는 방법
DefaultGame.ini에서 DirectoriesToAlwaysCook로 설정
DataAsset에서 chunk id를 0로 설정한다.
언리얼 엔진 4.27의 DataAsset에 있는 해당 옵션들
Apply Recursively (재귀적 적용): 이 옵션을 활성화하면 선택한 디렉토리 내의 모든 하위 폴더와 파일에 대해서도 변경 사항이 적용됩니다. 즉, 현재 폴더뿐만 아니라 그 안에 포함된 모든 폴더와 에셋에 대해 동일한 설정이 적용됩니다.
Label Assets in My Directories (내 디렉토리의 에셋 라벨링): 이 옵션을 선택하면 현재 프로젝트의 콘텐츠 디렉토리 내에 있는 에셋들에 대해서만 라벨을 적용합니다. 엔진이나 플러그인의 콘텐츠는 제외됩니다.
Is Runtime Label (런타임 라벨 여부): 이 옵션을 활성화하면 해당 라벨이 게임 실행 중에도 사용 가능하도록 설정됩니다. 런타임에 라벨을 통해 에셋을 검색하거나 필터링해야 하는 경우에 유용합니다.
이 옵션들은 주로 에셋 관리와 조직화, 그리고 런타임 시 에셋 접근성을 향상시키는 데 사용됩니다. 프로젝트의 규모와 요구사항에 따라 적절히 설정하면 에셋 관리를 더욱 효율적으로 할 수 있습니다.
보완적 사용: 두 방식은 서로 보완적으로 사용될 수 있음. DirectoriesToAlwaysCook가 전체 디렉토리를 다룬다면, 0RequiredPak은 더 세밀한 제어가 필요한 개별 에셋을 관리함
중복 가능성: 0RequiredPak에 명시된 에셋이 DirectoriesToAlwaysCook에 지정된 디렉토리 내에 있을 수 있음. 이 경우 해당 에셋은 두 번 쿠킹되지 않고, 한 번만 처리됨
우선순위: 일반적으로 0RequiredPak의 설정이 더 구체적이므로, 충돌이 있을 경우 이 설정이 우선적으로 적용됨.
pak0 생성: 두 설정 모두 chunk id가 0인 에셋들을 지정하므로, 이들은 함께 pak0의 내용을 구성하는 데 기여 The required attribute "Include" is empty ...
error MSB4035: The required attribute "Include" is empty or missing from the element &lt;ModulesToBuild&gt;.
RunUAT 실행할 때 -compile 옵션을 없앴음. RunUAT에서 선택적으로 cooking이 되는 거 같지 않음
출처: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://forums.unrealengine.com/t/command-line-compilation-error-uat/467076/9" target="_self">https://forums.unrealengine.com/t/command-line-compilation-error-uat/467076/9</a> 현재 구조에서 맵이 없이 패키징 하는 것이 가능한가? 게임 실행 파일 + pak0만 쿠킹하고 싶음
많은 에셋 쿠킹이 오버라이드를 통해서 진행되어서 파악이 어려움
DefaultGame.ini와 Tables, DataAsset 여러개가 엮어있음
예를들면 CC데이터테이블을 DefaultGame.ini에서 always cook으로 사용함 -&gt;
맵이 패키징됨 Error: CDO Constructor (Canvas): EngineResources/WhiteSquareTexture
-&gt; DefaultGame.ini에서 +DirectoriesToAlwaysCook=(Path="/Game/StarterContent")로 변경 시간이 금.....요일 할 게 있으니까 먼저 우직하게 workspace 2개 만들고맵 없이, 맵 있는 채로먼저 해야할 것젠킨스로 s3 브라우저 자동 업로드 하는 방법 및 Manifest 생성]]></description><link>ue/content-cooking-&amp;-pak-&amp;-chunk.html</link><guid isPermaLink="false">UE/Content Cooking &amp; pak &amp; chunk.md</guid><pubDate>Mon, 30 Dec 2024 15:31:07 GMT</pubDate></item><item><title><![CDATA[Console_Command 등록 하는 법]]></title><description><![CDATA[
IConsoleCommand: 콘솔 명령어
IConsoleManager: 콘솔 명령어를 실행하는 주체
RegisterConsoleCommand: 콘솔 명령어 등록
UnregisterConsoleObject: 콘솔 명령어 해제 virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithArgsDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldAndArgsDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithWorldArgsAndOutputDeviceDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandWithOutputDeviceDelegate&amp; Command, uint32 Flags) override; virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, uint32 Flags) override; virtual void UnregisterConsoleObject( IConsoleObject* Object, bool bKeepState) override; /** Console command delegate type (takes no arguments.) This is a void callback function. */
DECLARE_DELEGATE( FConsoleCommandDelegate ); /** Console command delegate type (with arguments.) This is a void callback function that always takes a list of arguments. */
DECLARE_DELEGATE_OneParam( FConsoleCommandWithArgsDelegate, const TArray&lt; FString &gt;&amp; ); /** Console command delegate type with a world argument. This is a void callback function that always takes a world. */
DECLARE_DELEGATE_OneParam( FConsoleCommandWithWorldDelegate, UWorld* ); /** Console command delegate type (with a world and arguments.) This is a void callback function that always takes a list of arguments and a world. */
DECLARE_DELEGATE_TwoParams(FConsoleCommandWithWorldAndArgsDelegate, const TArray&lt; FString &gt;&amp;, UWorld*); /** Console command delegate type (with a world arguments and output device.) This is a void callback function that always takes a list of arguments, a world and output device. */
DECLARE_DELEGATE_ThreeParams(FConsoleCommandWithWorldArgsAndOutputDeviceDelegate, const TArray&lt; FString &gt;&amp;, UWorld*, FOutputDevice&amp;); /** Console command delegate type with the output device passed through. */
DECLARE_DELEGATE_OneParam( FConsoleCommandWithOutputDeviceDelegate, FOutputDevice&amp; ); FConsoleCommandDelegate: 인자 없이 실행되는 가장 단순한 콘솔 명령을 위한 델리게이트입니다. FConsoleCommandWithArgsDelegate: 문자열 배열(TArray&lt;FString&gt;&amp;)을 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 사용자가 입력한 추가 인자를 처리할 수 있습니다. FConsoleCommandWithWorldDelegate: UWorld* 타입의 인자를 받는 콘솔 명령을 위한 델리게이트입니다. 현재 게임 월드에 접근해야 하는 명령에 유용합니다. FConsoleCommandWithWorldAndArgsDelegate: 문자열 배열과 UWorld* 포인터를 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 인자와 함께 게임 월드에 접근해야 하는 명령에 사용됩니다. FConsoleCommandWithWorldArgsAndOutputDeviceDelegate: 문자열 배열, UWorld* 포인터, 그리고 FOutputDevice&amp; 참조를 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 출력 장치를 통해 결과를 직접 제어할 수 있는 고급 명령에 사용됩니다. FConsoleCommandWithOutputDeviceDelegate: FOutputDevice&amp; 참조만을 인자로 받는 콘솔 명령을 위한 델리게이트입니다. 출력 제어가 필요하지만 다른 인자는 필요 없는 명령에 사용됩니다. enum EConsoleVariableFlags
{ /* Mask for flags. Use this instead of ~ECVF_SetByMask */ ECVF_FlagMask = 0x0000ffff, /** * Default, no flags are set, the value is set by the constructor */ ECVF_Default = 0x0, /** * Console variables marked with this flag behave differently in a final release build. * Then they are are hidden in the console and cannot be changed by the user. */ ECVF_Cheat = 0x1, /** * Console variables cannot be changed by the user (from console). * Changing from C++ or ini is still possible. */ ECVF_ReadOnly = 0x4, /** * UnregisterConsoleObject() was called on this one. * If the variable is registered again with the same type this object is reactivated. This is good for DLL unloading. */ ECVF_Unregistered = 0x8, /** * This flag is set by the ini loading code when the variable wasn't registered yet. * Once the variable is registered later the value is copied over and the variable is destructed. */ ECVF_CreatedFromIni = 0x10, /** * Maintains another shadow copy and updates the copy with render thread commands to maintain proper ordering. * Could be extended for more/other thread. * Note: On console variable references it assumes the reference is accessed on the render thread only * (Don't use in any other thread or better don't use references to avoid the potential pitfall). */ ECVF_RenderThreadSafe = 0x20, /* ApplyCVarSettingsGroupFromIni will complain if this wasn't set, should not be combined with ECVF_Cheat */ ECVF_Scalability = 0x40, /* those cvars control other cvars with the flag ECVF_Scalability, names should start with "sg." */ ECVF_ScalabilityGroup = 0x80, // ------------------------------------------------ /* Set flags */ ECVF_SetFlagMask = 0x00ff0000, // Use to set a cvar without calling all cvar sinks. Much faster, but potentially unsafe. Use only if you know the particular cvar/setting does not require a sink call ECVF_Set_NoSinkCall_Unsafe =	0x00010000, // ------------------------------------------------ /* to get some history of where the last value was set by ( useful for track down why a cvar is in a specific state */ ECVF_SetByMask = 0xff000000, // the ECVF_SetBy are sorted in override order (weak to strong), the value is not serialized, it only affects it's override behavior when calling Set() // lowest priority (default after console variable creation) ECVF_SetByConstructor = 0x00000000, // from Scalability.ini (lower priority than game settings so it's easier to override partially) ECVF_SetByScalability = 0x01000000, // (in game UI or from file) ECVF_SetByGameSetting = 0x02000000, // project settings (editor UI or from file, higher priority than game setting to allow to enforce some setting fro this project) ECVF_SetByProjectSetting = 0x03000000, // per project setting (ini file e.g. Engine.ini or Game.ini) ECVF_SetBySystemSettingsIni =	0x04000000, // per device setting (e.g. specific iOS device, higher priority than per project to do device specific settings) ECVF_SetByDeviceProfile = 0x05000000, // consolevariables.ini (for multiple projects) ECVF_SetByConsoleVariablesIni = 0x06000000, // a minus command e.g. -VSync (very high priority to enforce the setting for the application) ECVF_SetByCommandline = 0x07000000, // least useful, likely a hack, maybe better to find the correct SetBy... ECVF_SetByCode = 0x08000000, // editor UI or console in game or editor ECVF_SetByConsole = 0x09000000, // ------------------------------------------------
}; ECVF_Default (0x0): 기본값으로, 아무 플래그도 설정되지 않은 상태입니다.
ECVF_Cheat (0x1): 치트 플래그입니다. 최종 릴리스 빌드에서는 콘솔에 숨겨지고 사용자가 변경할 수 없습니다.
ECVF_ReadOnly (0x4): 읽기 전용 플래그입니다. 사용자가 콘솔에서 변경할 수 없지만, C++ 코드나 ini 파일을 통해 변경 가능합니다.
ECVF_Unregistered (0x8): UnregisterConsoleObject()가 호출되어 등록 해제된 상태를 나타냅니다.
ECVF_CreatedFromIni (0x10): ini 파일에서 로드되었지만 아직 등록되지 않은 변수를 나타냅니다.
ECVF_RenderThreadSafe (0x20): 렌더 스레드에서 안전하게 사용할 수 있는 변수임을 나타냅니다.
ECVF_Scalability (0x40): 스케일러빌리티 설정과 관련된 변수임을 나타냅니다.
ECVF_ScalabilityGroup (0x80): 스케일러빌리티 그룹을 제어하는 변수임을 나타냅니다.
ECVF_Set_NoSinkCall_Unsafe (0x00010000): 콜백 없이 빠르게 설정할 수 있는 플래그입니다.
ECVF_SetByXXX 플래그들: 변수가 어디서 설정되었는지를 나타내는 플래그들입니다. 예를 들어 ECVF_SetByConsole은 콘솔에서 설정되었음을 의미합니다.
이 플래그들은 비트 마스크로 사용되어 콘솔 변수의 특성과 동작을 제어합니다. 예를 들어, 치트 변수를 만들려면 ECVF_Cheat 플래그를, 읽기 전용 변수를 만들려면 ECVF_ReadOnly 플래그를 사용할 수 있습니다. ECVF_Default (0x0):
static FConsoleVariableRef CVarDefaultExample( TEXT("example.Default"), DefaultValue, TEXT("An example of a default console variable"), ECVF_Default
); 사용 사례: 특별한 제한이나 동작이 필요 없는 일반적인 콘솔 변수에 사용됩니다. ECVF_Cheat (0x1):
static FConsoleVariableRef CVarInfiniteAmmo( TEXT("cheat.InfiniteAmmo"), bInfiniteAmmo, TEXT("Enables infinite ammo"), ECVF_Cheat
); 사용 사례: 치트나 디버그 목적으로 사용되는 변수에 적용됩니다. ECVF_ReadOnly (0x4):
static FConsoleVariableRef CVarBuildVersion( TEXT("game.BuildVersion"), BuildVersion, TEXT("Current build version"), ECVF_ReadOnly
); 사용 사례: 사용자가 수정해서는 안 되는 정보를 저장하는 변수에 사용됩니다. ECVF_Unregistered (0x8):
// This flag is typically set internally by the engine
SomeConVar-&gt;SetFlags(SomeConVar-&gt;GetFlags() | ECVF_Unregistered); 사용 사례: 콘솔 변수가 언레지스터되었음을 나타냅니다. 주로 내부적으로 사용됩니다. ECVF_CreatedFromIni (0x10):
// This flag is typically set internally by the engine when loading from INI
NewConVar-&gt;SetFlags(NewConVar-&gt;GetFlags() | ECVF_CreatedFromIni); 사용 사례: INI 파일에서 생성된 콘솔 변수를 표시합니다. 주로 내부적으로 사용됩니다. ECVF_RenderThreadSafe (0x20):
static FConsoleVariableRef CVarShadowQuality( TEXT("r.ShadowQuality"), ShadowQuality, TEXT("Controls shadow quality (0-4)"), ECVF_RenderThreadSafe
); 사용 사례: 렌더 스레드에서 안전하게 접근할 수 있는 변수에 사용됩니다. ECVF_Scalability (0x40):
static FConsoleVariableRef CVarViewDistance( TEXT("sg.ViewDistanceQuality"), ViewDistanceQuality, TEXT("Controls view distance quality (0-3)"), ECVF_Scalability
); 사용 사례: 스케일러빌리티 설정의 일부로 사용되는 변수에 적용됩니다. ECVF_ScalabilityGroup (0x80):
static FConsoleVariableRef CVarScalabilityGroup( TEXT("sg.ResolutionQuality"), ResolutionQuality, TEXT("Controls the resolution quality"), ECVF_ScalabilityGroup
); 사용 사례: 다른 스케일러빌리티 설정을 제어하는 그룹 변수에 사용됩니다. ECVF_SetByConstructor (0x00000000):
// This is typically handled internally by the engine
SomeConVar-&gt;Set(InitialValue, ECVF_SetByConstructor); 사용 사례: 변수가 생성자에 의해 초기화되었음을 나타냅니다. ECVF_SetByScalability (0x01000000):
// This would be set when loading scalability settings
TextureQuality-&gt;Set(ScalabilityTextureQuality, ECVF_SetByScalability); 사용 사례: Scalability.ini 파일에서 설정된 값임을 나타냅니다. ECVF_SetByGameSetting (0x02000000):
// This would be set when the user changes a setting in the game menu
AudioVolume-&gt;Set(UserSelectedVolume, ECVF_SetByGameSetting); 사용 사례: 게임 내 설정에서 변경된 값임을 나타냅니다. ECVF_SetByProjectSetting (0x03000000):
// This would be set when loading project settings
MaxFPS-&gt;Set(ProjectMaxFPS, ECVF_SetByProjectSetting); 사용 사례: 프로젝트 설정에서 정의된 값임을 나타냅니다. ECVF_SetBySystemSettingsIni (0x04000000):
// This would be set when loading from Engine.ini or Game.ini
GravityZ-&gt;Set(IniGravityZ, ECVF_SetBySystemSettingsIni); 사용 사례: 시스템 설정 INI 파일에서 로드된 값임을 나타냅니다. ECVF_SetByDeviceProfile (0x05000000):
// This would be set when applying device-specific settings
MobileQualitySettings-&gt;Set(DeviceSpecificQuality, ECVF_SetByDeviceProfile); 사용 사례: 특정 디바이스 프로필에 의해 설정된 값임을 나타냅니다. ECVF_SetByConsoleVariablesIni (0x06000000):
// This would be set when loading from ConsoleVariables.ini
PoolSize-&gt;Set(IniPoolSize, ECVF_SetByConsoleVariablesIni); 사용 사례: ConsoleVariables.ini 파일에서 설정된 값임을 나타냅니다. ECVF_SetByCommandline (0x07000000):
// This would be set when parsing command line arguments
bStartInFullscreen-&gt;Set(CommandLineFullscreen, ECVF_SetByCommandline); 사용 사례: 명령줄 인자로 설정된 값임을 나타냅니다. ECVF_SetByCode (0x08000000):
// This would be set directly in game code
AILogicInterval-&gt;Set(CalculatedInterval, ECVF_SetByCode); 사용 사례: 코드에서 직접 설정된 값임을 나타냅니다. ECVF_SetByConsole (0x09000000):
// This would be set when a user enters a command in the console
DrawDebugLines-&gt;Set(UserInputDebugLines, ECVF_SetByConsole); 사용 사례: 콘솔에서 사용자가 직접 입력하여 설정된 값임을 나타냅니다. 이러한 플래그들은 콘솔 변수의 동작을 제어하고, 값이 어디서 설정되었는지를 추적하는 데 사용됩니다. 이를 통해 개발자는 게임의 다양한 설정과 동작을 효과적으로 관리하고 디버그할 수 있습니다.]]></description><link>ue/console_command-등록-하는-법.html</link><guid isPermaLink="false">UE/Console_Command 등록 하는 법.md</guid><pubDate>Mon, 30 Dec 2024 10:56:57 GMT</pubDate></item><item><title><![CDATA[physX]]></title><description><![CDATA[커스텀 물리를 적용하기 위해서 해야할 것?
물리 시뮬레이션 중 onAdvance()을 하이재킹 한 후 그곳에 코드를 작성해야함.PhysX는 물리 시뮬레이션 - 실행단계 - 적용(인터그레이션)를 가짐. // 예시코드 PxScene scene; scene-&gt;simulate(timestep); scene-&gt;fetchResults(true); 시뮬레이션 준비 단계 시뮬레이션 실행 실제 물리 계산 수행
충돌 해결 및 제약 조건 처리
힘과 토크 적용 통합 단계 계산된 물리 상태를 게임 객체에 반영
이벤트 처리 (충돌 콜백 등) PhysScene은 Unreal Engine에서 물리 시뮬레이션이 실행되는 독립된 공간 -&gt; 게임 월드의 물리적 표현PhysScene은 템플릿 클래스로 추상화 되어있음.구현체: PhysScene_Chaos, PhysScene_PhysX[1. 기본 초기화 및 업데이트 함수]void Init()
void Tick(float InDeltaSeconds)
Init(): 물리 씬의 초기 설정을 담당. 메모리 할당, 기본 파라미터 설정 등의 초기화 작업
Tick(): 매 프레임마다 호출되어 물리 시뮬레이션을 업데이트. InDeltaSeconds는 이전 프레임과의 시간 간격입니다.[2. 키네마틱 및 프레임 관련 함수]void SetKinematicUpdateFunction(...)
void SetStartFrameFunction(...)
void SetEndFrameFunction(...)
SetKinematicUpdateFunction:
키네마틱 객체들의 움직임을 제어하는 함수를 설정
애니메이션이나 스크립트로 제어되는 물리 객체의 업데이트를 담당
매개변수: 데이터, 델타 시간, 누적 시간, 반복 횟수SetStartFrameFunction:
각 물리 시뮬레이션 프레임 시작 시 실행될 함수 설정
초기 상태 설정, 데이터 준비 등을 수행SetEndFrameFunction:
각 물리 시뮬레이션 프레임 종료 시 실행될 함수 설정
결과 처리, 상태 저장 등을 수행[3. 물리 객체 생성 및 파라미터 관리]void SetCreateBodiesFunction(...)
void SetParameterUpdateFunction(...)
SetCreateBodiesFunction:
물리 객체(강체, 파티클 등)를 생성하는 함수 설정
새로운 물리 객체가 필요할 때 호출됨
매개변수: 물리 데이터 구조체 참조SetParameterUpdateFunction:
물리 시뮬레이션 파라미터 업데이트 함수 설정
질량, 마찰, 탄성 등의 물리 속성 업데이트
매개변수: 데이터, 델타 시간, 반복 횟수[4. 충돌 및 제약조건 관리]void SetDisableCollisionsUpdateFunction(...)
void AddPBDConstraintFunction(...)
SetDisableCollisionsUpdateFunction:
특정 객체 쌍 간의 충돌을 비활성화하는 함수 설정
매개변수: 충돌 비활성화할 객체 쌍의 인덱스 집합AddPBDConstraintFunction:
Position Based Dynamics 제약조건 추가 함수
물리 기반 애니메이션, 천 시뮬레이션 등에 사용
매개변수: 데이터, 델타 시간[5. 힘 적용 및 구현 접근]void AddForceFunction(...)
ImplType&amp; GetImpl()
AddForceFunction:
물리 객체에 힘을 적용하는 함수 추가
중력, 바람, 폭발 등의 외력 시뮬레이션
매개변수: 데이터, 델타 시간, 반복 횟수GetImpl():
실제 구현체에 대한 접근자
템플릿 구현체의 세부 기능 접근에 사용Unreal Engine에서 사용하는 PhysScene 구현체임. 물리 엔진은 PhysX를 사용.NVIDIA APEX는 PhysX 엔진을 확장한 물리 시뮬레이션 미들웨어[주요 기능]
파괴 시뮬레이션
건물이나 구조물의 사실적인 파괴 효과
동적인 파편(debris) 생성의류 시뮬레이션
캐릭터의 옷감 물리
실시간 의류 변형입자 시스템
연기, 불, 폭발 효과
대규모 입자 시뮬레이션CCD(Continuous Collision Detection, 연속 충돌 감지)
[핵심 개념]
CCD는 고속으로 움직이는 물체들의 충돌을 정확하게 감지하기 위한 물리 시뮬레이션 기술[장점]
정확한 충돌 감지
빠른 물체의 충돌도 놓치지 않음
얇은 물체 통과 현상 방지
더 나은 게임플레이 경험
물리 기반 게임에서 중요
총알, 발사체 등의 정확한 처리
[단점]
성능 오버헤드
더 많은 계산이 필요
모든 물체에 적용하면 성능 저하
ISimEventCallbackFactory를 상속받은 CallbackFactory 구현
실제 콜백 클래스도 구현
팩토리 등록 및 사용
// 커스텀 시뮬레이션 이벤트 콜백 팩토리
class FMySimEventCallbackFactory : public ISimEventCallbackFactory
{
public: // Create 메서드 구현 virtual physx::PxSimulationEventCallback* Create(FPhysScene_PhysX* PhysScene) override { // 새로운 콜백 객체 생성 return new FMySimulationCallback(PhysScene); } // Destroy 메서드 구현 virtual void Destroy(physx::PxSimulationEventCallback* Callback) override { // 콜백 객체 정리 delete Callback; }
}; // 커스텀 시뮬레이션 콜백
class FMySimulationCallback : public physx::PxSimulationEventCallback
{
public: FMySimulationCallback(FPhysScene_PhysX* InPhysScene) : PhysScene(InPhysScene) {} // 충돌 이벤트 처리 virtual void onContact(const physx::PxContactPairHeader&amp; PairHeader, const physx::PxContactPair* Pairs, PxU32 NumPairs) override { // 충돌 처리 로직 UE_LOG(LogPhysics, Log, TEXT("충돌 발생!")); } // 다른 필요한 이벤트 메서드들도 구현 virtual void onConstraintBreak(...) override { } virtual void onWake(...) override { } virtual void onSleep(...) override { } // ... private: FPhysScene_PhysX* PhysScene;
}; // 엔진 초기화 시점에서
void InitializePhysics()
{ // 전역 팩토리 설정 FPhysScene_PhysX::SimEventCallbackFactory = MakeShared&lt;FMySimEventCallbackFactory&gt;();
} Aggregate - 집합체Aggregate(집합체)는 여러 개의 Actor들을 하나의 그룹으로 관리하는 PhysX의 개념[차이점]성능 최적화
Aggregate: 여러 물체를 하나의 broad-phase 영역으로 처리
Actor: 개별적으로 broad-phase 검사 수행메모리 관리
Aggregate: 그룹 단위로 메모리 관리 가능
Actor: 개별적인 메모리 관리 필요메서드 안에서 PhysScene에 대한 플래그를 설정함.PxSceneFlagActive Actors/Transform 관련
eENABLE_ACTIVE_ACTORS // 활성화된 액터 알림 기능
eENABLE_ACTIVETRANSFORMS // 활성화된 트랜스폼 알림 기능
움직이는 물체들의 상태를 추적할 때 사용
성능에 영향을 줄 수 있으므로 필요한 경우에만 활성화
충돌 감지 관련
eENABLE_CCD // 연속 충돌 감지(CCD) 활성화
eDISABLE_CCD_RESWEEP // CCD 재스윕 비활성화
eENABLE_PCM // GJK 기반 거리 충돌 감지
CCD는 고속 이동 물체의 터널링을 방지
PCM은 더 정확한 충돌 감지를 제공
키네마틱 상호작용
eENABLE_KINEMATIC_STATIC_PAIRS // 키네마틱-정적 물체 간 상호작용
eENABLE_KINEMATIC_PAIRS // 키네마틱 물체들 간 상호작용
키네마틱 물체들의 충돌 필터링을 제어
기본적으로는 비활성화
[중요한 성능 관련 플래그]
캐시와 버퍼
eDISABLE_CONTACT_CACHE // 접촉 캐시 비활성화
eDISABLE_CONTACT_REPORT_BUFFER_RESIZE // 접촉 보고 버퍼 크기 조정 비활성화
메모리 사용량과 성능 사이의 균형을 조절
안정성 향상
eENABLE_STABILIZATION // 추가적인 안정화 패스 활성화
eENABLE_AVERAGE_POINT // 접촉 매니폴드의 평균점 활성화PxSceneFlag::eENABLE_ACTIVE_ACTORS; 플래그를 켜야 onAdvance() 하이재킹 가능]]></description><link>physics/physx.html</link><guid isPermaLink="false">physics/physX.md</guid><pubDate>Mon, 30 Dec 2024 10:32:35 GMT</pubDate></item><item><title><![CDATA[Fat Framework]]></title><description><![CDATA[환경 : Apple Silicon (M1), Xcode 14.3Fat Framework 또는 Universal Framework는 xcframework와 다르다. xcframework가 나오기전에 프레임워크를 사용하는 방법은 .framework를 사용하는 것이었다.Xcode에서 프로젝트로 framework를 생성하고 Logger.swift를 만들고 간단한 코드 작성
// Logger.swift import Foundation public class LoggerInFramework { public static func Logging(_ args: String) -&gt; String { debugPrint(args) return args } } 그러고나서 시뮬레이터로 빌드로 하고 Product - Show Build Folder in Finder를 클릭<img alt="framework_path.png" src="images/framework_path.png" target="_self">LoggerFramework.swiftmodule 안에 arm64-apple-ios-simulator가 있는 것을 확인이제 이 프레임워크를 테스트 해보기 위해 새로운 앱 프로젝트를 하나 만듬<br><img alt="hostapp_file.png" src="images/hostapp_file.png" target="_self">위처럼 프레임워크를 네비게이터에 추가해주고 Project - Targets에서 Embed를 Embed &amp; Sign으로 변경하기
// ViewController.swift import UIKit
import LoggerFramework class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() LoggerInFramework.Logging("Hello World") } } Simulator로 빌드 시 성공, 그러나 실제 기기로 빌드 하면 다음과 같은 에러를 뱉음
Could not find module 'LoggerFramework' for target 'arm64-apple-ios'; found: arm64-apple-ios-simulator, at: /Users/psychehose/Study/iOSLaboratory/HostingLoggingFrameworkApp/HostingLoggingFrameworkApp/LoggerFramework.framework/Modules/LoggerFramework.swiftmodule
swiftmodule 안에 arm64-apple-ios-simulator만 존재하기 때문그렇다면 swiftmodule 안에 arm64-apple-ios와 x86_64-apple-ios-simulator가 있다면 M1 Mac과 Intel Mac에서 모두 시뮬레이터를 돌리고 실기기에 빌드할 수 있을 것이다.framework에 저 위의 경우를 다 때려넣어서 만든 것이 Fat Framework이다.Fat Framework를 만드는 법은 Framework 프로젝트에서 Aggreate 타겟을 만들고 script를 짜서 만드는 것이 가장 간단하다.<br><img alt="aggregate.png" src="images/aggregate.png" target="_self">Product 이름은 FatFramework로 만듬
타겟에서 FatFramework - Build Phases에서 Target Dependency Framework (LoggerFramework) 추가하기 버튼 누르고 run script 추가하기 #!/bin/sh UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal mkdir -p "${UNIVERSAL_OUTPUTFOLDER}" xcodebuild BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS="-fembed-bitcode" -target "${PROJECT_NAME}" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR="${BUILD_DIR}" BUILD_ROOT="${BUILD_ROOT}" clean build xcodebuild BITCODE_GENERATION_MODE=bitcode OTHER_CFLAGS="-fembed-bitcode" -target "${PROJECT_NAME}" ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphonesimulator BUILD_DIR="${BUILD_DIR}" BUILD_ROOT="${BUILD_ROOT}" EXCLUDED_ARCHS="arm64" clean build cp -R "${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework" "${UNIVERSAL_OUTPUTFOLDER}/" cp -R "${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule/." 그리고 FatFramework Scheme을 편집을 누르고 Run에서 Build Configuration을 Release로 변경하고 기기를 Any iOS Device로 하고 빌드한다<br><img alt="sandbox_error.png" src="images/sandbox_error.png" target="_self">위의 에러가 발생하면 Build Setting - User Script Sandboxing을 No로 설정하고 다시 빌드이제 framework의 swiftmodule을 보면 arm64-apple-ios, x86_64-apple-ios-simulator가 있게 된다.
(arm64-apple-ios-simulator가 없는 이유는 스크립트에서 EXCLUDED_ARCHS를 했기 때문)<br><img alt="fatframework_path.png" src="images/fatframework_path.png" target="_self">아까 만든 테스트앱에서 프레임워크를 교체하고 실기기를 빌드하면 성공한다. 그리고 intel mac에서도 simulator로 빌드하면 성공할 것임. 근데 Apple Silicon을 사용하는 맥에서 시뮬레이터로 빌드할 수 없다.swiftmodule에 arm64-apple-ios-simulator를 추가할 수는 있다. 그런데, m1 맥 테스트 앱에서 시뮬레이터로 빌드하면 다음과 같은 에러가 뜬다.<br><img alt="simulator_device_error.png" src="images/simulator_device_error.png" target="_self">왜 이런 이유가 발생할까?Derived Data를 삭제하고, Aggregate가 아닌 프레임워크를 iOS 디바이스, 시뮬레이터 빌드를 각각 하고 프레임워크 path로 가서 손수 lipo 명령어를 사용하자lipo -create -output UniversalFramework.framework/UniversalFramework \ Debug-iphonesimulator/LoggerFramework.framework/LoggerFramework \ Debug-iphoneos/LoggerFramework.framework/LoggerFramework 그러면 아래와 같은 에러가 발생할 것이다.
fatal error: /Library/Developer/CommandLineTools/usr/bin/lipo: Debug-iphonesimulator/LoggerFramework.framework/LoggerFramework and Debug-iphoneos/LoggerFramework.framework/LoggerFramework have the same architectures (arm64) and can't be in the same fat output file
정확한 이유는 아니지만, 위의 에러 로그처럼 simulator와 실제 device의 아키텍쳐가 같아서 프레임워크를 호스팅하는 앱(Test App)이 arm64-apple-ios-simulator를 못찾는 것 같다.그래서 M1 Mac이 등장한 이후로 Fat Framework를 잘 사용하지 않는 것 같다. 대신 대부분의 경우에 xcframework를 사용한다.]]></description><link>ios/fat-framework.html</link><guid isPermaLink="false">iOS/Fat Framework.md</guid><pubDate>Mon, 30 Dec 2024 10:28:12 GMT</pubDate><enclosure url="images/framework_path.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/framework_path.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Two Pointer]]></title><description><![CDATA[
두 개의 포인터를 사용하여 배열을 순회하면서 문제를 해결
주로 배열이나 리스트와 같은 선형 자료구조를 다룰 때 사용
시간 복잡도 O(n^2) -&gt; O(n)
예시
정렬된 배열에서 두 수의 합이 특정 값이 되는 쌍 찾기
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt; std::vector&lt;std::pair&lt;int, int&gt;&gt; findAllPairsWithSum(const std::vector&lt;int&gt;&amp; arr, int targetSum) { std::vector&lt;std::pair&lt;int, int&gt;&gt; result; int left = 0; int right = arr.size() - 1; while (left &lt; right) { int currentSum = arr[left] + arr[right]; if (currentSum == targetSum) { result.push_back({arr[left], arr[right]}); // 중복 원소 건너뛰기 while (left &lt; right &amp;&amp; arr[left] == arr[left + 1]) left++; while (left &lt; right &amp;&amp; arr[right] == arr[right - 1]) right--; left++; right--; } else if (currentSum &lt; targetSum) { left++; } else { right--; } } return result;
} int main() { std::vector&lt;int&gt; sortedArray = {1, 2, 3, 4, 5, 5, 6, 7, 8, 9}; int target = 10; auto pairs = findAllPairsWithSum(sortedArray, target); if (!pairs.empty()) { std::cout &lt;&lt; "합이 " &lt;&lt; target &lt;&lt; "인 모든 쌍:" &lt;&lt; std::endl; for (const auto&amp; pair : pairs) { std::cout &lt;&lt; pair.first &lt;&lt; ", " &lt;&lt; pair.second &lt;&lt; std::endl; } } else { std::cout &lt;&lt; "합이 " &lt;&lt; target &lt;&lt; "인 쌍을 찾지 못했습니다." &lt;&lt; std::endl; } return 0;
} 배열에서 중복 요소 제거
#include &lt;iostream&gt;
#include &lt;vector&gt; int removeDuplicates(std::vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int writePointer = 1; for (int readPointer = 1; readPointer &lt; nums.size(); readPointer++) { if (nums[readPointer] != nums[writePointer - 1]) { nums[writePointer] = nums[readPointer]; writePointer++; } } return writePointer;
} int main() { std::vector&lt;int&gt; nums = {1, 1, 2, 2, 3, 4, 4, 5}; int newLength = removeDuplicates(nums); std::cout &lt;&lt; "새로운 배열 길이: " &lt;&lt; newLength &lt;&lt; std::endl; std::cout &lt;&lt; "중복이 제거된 배열: "; for (int i = 0; i &lt; newLength; i++) { std::cout &lt;&lt; nums[i] &lt;&lt; " "; } std::cout &lt;&lt; std::endl; return 0;
} writePointer: 고유한 요소를 쓸 위치를 가리킴
readPointer: 배열을 순회하며 각 요소를 확인 readPointer가 새로운 요소를 발견하면, 그 요소를 writePointer 위치에 씀
미리 readPointer가 들여다보고 중복여부 파악 후 쓸 지 결정 부분 배열의 합이 특정 값이 되는 구간 찾기 (정렬되어 있어야함)
#include &lt;iostream&gt;
#include &lt;vector&gt; std::pair&lt;int, int&gt; findSubarrayWithSum(const std::vector&lt;int&gt;&amp; nums, int targetSum) { int left = 0, right = 0; int currentSum = 0; while (right &lt; nums.size()) { currentSum += nums[right]; while (currentSum &gt; targetSum &amp;&amp; left &lt; right) { currentSum -= nums[left]; left++; } if (currentSum == targetSum) { return {left, right}; } right++; } return {-1, -1}; // 합이 targetSum인 부분 배열을 찾지 못한 경우
} int main() { std::vector&lt;int&gt; nums = {1, 4, 20, 3, 10, 5}; int targetSum = 33; auto result = findSubarrayWithSum(nums, targetSum); if (result.first != -1) { std::cout &lt;&lt; "합이 " &lt;&lt; targetSum &lt;&lt; "인 부분 배열을 찾았습니다: "; std::cout &lt;&lt; "인덱스 " &lt;&lt; result.first &lt;&lt; "부터 " &lt;&lt; result.second &lt;&lt; "까지" &lt;&lt; std::endl; } else { std::cout &lt;&lt; "합이 " &lt;&lt; targetSum &lt;&lt; "인 부분 배열을 찾지 못했습니다." &lt;&lt; std::endl; } return 0;
} left: 부분 배열의 시작을 가리킴.
right: 부분 배열의 끝을 가리킴 현재 부분 배열의 합이 목표값보다 크면 left를 오른쪽으로 이동시켜 합을 줄이고, 작으면 right를 오른쪽으로 이동시켜 합을 늘림 펠린드롬
#include &lt;iostream&gt;
#include &lt;string&gt; bool isPalindrome(const std::string&amp; s) { int left = 0; int right = s.length() - 1; while (left &lt; right) { if (s[left] != s[right]) { return false; } left++; right--; } return true;
} int main() { std::string str1 = "racecar"; std::string str2 = "hello"; std::cout &lt;&lt; str1 &lt;&lt; " 은 팰린드롬" &lt;&lt; (isPalindrome(str1) ? "입니다." : "이 아닙니다.") &lt;&lt; std::endl; std::cout &lt;&lt; str2 &lt;&lt; " 은 팰린드롬" &lt;&lt; (isPalindrome(str2) ? "입니다." : "이 아닙니다.") &lt;&lt; std::endl; return 0;
}
]]></description><link>algorithm/study/two-pointer.html</link><guid isPermaLink="false">Algorithm/Study/Two Pointer.md</guid><pubDate>Mon, 30 Dec 2024 10:20:00 GMT</pubDate></item><item><title><![CDATA[Heap & 우선순위 큐]]></title><description><![CDATA[완전 이진 트리의 일종으로 두가지 조건 충족
완전 이진 트리
최대 힙 (부모 노드값 &gt; 자식 노드값) , 최소 힙 (부모 노드 값 &lt; 자식 노드값)
우선순위 큐는 각 요소가 우선순위를 가지고 있으며, 우선순위가 높은 요소가 먼저 나가는 특수한 큐
힙을 사용하여 효율적으로 구현 가능
삽입 - 새로운 요소를 힙의 마지막에 추가한 후 힙 정렬
삭제 - 힙의 루트 요소를 제거 하고 마지막 요소를 루트로 이동시킨 후 힙 정렬 삽입: O(log n)
삭제 (Olog n)
탐색 (루트 요소 확인): O(1)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; heap = {10, 20, 30, 5, 15}; // 힙으로 변환 std::make_heap(heap.begin(), heap.end()); std::cout &lt;&lt; "Initial max-heap: "; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; std::endl; // 힙에 요소 추가 heap.push_back(99); std::push_heap(heap.begin(), heap.end()); std::cout &lt;&lt; "After adding an element: "; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; std::endl; // 힙에서 최대 요소 제거 std::pop_heap(heap.begin(), heap.end()); heap.pop_back(); std::cout &lt;&lt; "After removing the max element: "; for (int i : heap) std::cout &lt;&lt; i &lt;&lt; " "; std::cout &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt; int main() { std::priority_queue&lt;int&gt; pq; // 아래처럼 생성하면 최소힙 // std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; min_pq; // 요소 삽입 pq.push(10); pq.push(20); pq.push(30); pq.push(5); pq.push(15); std::cout &lt;&lt; "Priority queue elements: "; while (!pq.empty()) { std::cout &lt;&lt; pq.top() &lt;&lt; " "; pq.pop(); } std::cout &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt; struct Task { int priority; std::string description; // 커스텀 비교 함수 (작은 값이 높은 우선순위) bool operator&lt;(const Task&amp; other) const { return priority &gt; other.priority; }
}; int main() { std::priority_queue&lt;Task&gt; taskQueue; // 요소 삽입 taskQueue.push({1, "Low priority task"}); taskQueue.push({3, "High priority task"}); taskQueue.push({2, "Medium priority task"}); std::cout &lt;&lt; "Tasks in priority order: "; while (!taskQueue.empty()) { Task t = taskQueue.top(); std::cout &lt;&lt; "(" &lt;&lt; t.priority &lt;&lt; ", " &lt;&lt; t.description &lt;&lt; ") "; taskQueue.pop(); } std::cout &lt;&lt; std::endl; return 0;
}
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; class MaxHeap {
private: std::vector&lt;int&gt; heap; void heapifyUp(int index) { while (index &gt; 0) { int parent = (index - 1) / 2; if (heap[index] &gt; heap[parent]) { std::swap(heap[index], heap[parent]); index = parent; } else { break; } } } void heapifyDown(int index) { int size = heap.size(); while (index * 2 + 1 &lt; size) { int left = index * 2 + 1; int right = index * 2 + 2; int largerChild = left; if (right &lt; size &amp;&amp; heap[right] &gt; heap[left]) { largerChild = right; } if (heap[index] &lt; heap[largerChild]) { std::swap(heap[index], heap[largerChild]); index = largerChild; } else { break; } } } public: void insert(int value) { heap.push_back(value); heapifyUp(heap.size() - 1); } int extractMax() { if (heap.empty()) { throw std::runtime_error("Heap is empty"); } int maxValue = heap[0]; heap[0] = heap.back(); heap.pop_back(); heapifyDown(0); return maxValue; } void printHeap() { for (int value : heap) { std::cout &lt;&lt; value &lt;&lt; " "; } std::cout &lt;&lt; std::endl; } void preorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; " "; // 왼쪽 자식 노드 방문 preorderTraversal(2 * index + 1); // 오른쪽 자식 노드 방문 preorderTraversal(2 * index + 2); } void inorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 왼쪽 자식 노드 방문 inorderTraversal(2 * index + 1); // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; " "; // 오른쪽 자식 노드 방문 inorderTraversal(2 * index + 2); } void postorderTraversal(int index = 0) { if (index &gt;= heap.size()) { return; } // 왼쪽 자식 노드 방문 postorderTraversal(2 * index + 1); // 오른쪽 자식 노드 방문 postorderTraversal(2 * index + 2); // 현재 노드 방문 std::cout &lt;&lt; heap[index] &lt;&lt; " "; }
}; int main() { MaxHeap heap; heap.insert(10); heap.insert(20); heap.insert(30); heap.insert(5); heap.insert(15); std::cout &lt;&lt; "Heap elements: "; heap.printHeap(); std::cout &lt;&lt; "Preorder traversal: "; heap.preorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Inorder traversal: "; heap.inorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Postorder traversal: "; heap.postorderTraversal(); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Extracted max: " &lt;&lt; heap.extractMax() &lt;&lt; std::endl; std::cout &lt;&lt; "Heap after extraction: "; heap.printHeap(); return 0;
}
]]></description><link>algorithm/study/heap-&amp;-우선순위-큐.html</link><guid isPermaLink="false">Algorithm/Study/Heap &amp; 우선순위 큐.md</guid><pubDate>Mon, 30 Dec 2024 10:19:36 GMT</pubDate></item><item><title><![CDATA[DP]]></title><description><![CDATA[
Top down -&gt; 재귀
Bottom up -&gt; 배열 작은 상황을 이용해서 큰 상황을 구할 때 dp[n]을 잘 정의하는 것
관계식, 점화식 잘 세우기
]]></description><link>algorithm/study/dp.html</link><guid isPermaLink="false">Algorithm/Study/DP.md</guid><pubDate>Mon, 30 Dec 2024 10:19:31 GMT</pubDate></item><item><title><![CDATA[cpp_14]]></title><description><![CDATA[<img src="images/cpp_14.png" target="_self">]]></description><link>images/cpp_14.html</link><guid isPermaLink="false">images/cpp_14.png</guid><pubDate>Fri, 27 Dec 2024 14:19:22 GMT</pubDate><enclosure url="images/cpp_14.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_14.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_13]]></title><description><![CDATA[<img src="images/cpp_13.png" target="_self">]]></description><link>images/cpp_13.html</link><guid isPermaLink="false">images/cpp_13.png</guid><pubDate>Thu, 26 Dec 2024 10:56:21 GMT</pubDate><enclosure url="images/cpp_13.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_13.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_12]]></title><description><![CDATA[<img src="images/cpp_12.png" target="_self">]]></description><link>images/cpp_12.html</link><guid isPermaLink="false">images/cpp_12.png</guid><pubDate>Wed, 25 Dec 2024 07:10:47 GMT</pubDate><enclosure url="images/cpp_12.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_12.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_11]]></title><description><![CDATA[<img src="images/cpp_11.png" target="_self">]]></description><link>images/cpp_11.html</link><guid isPermaLink="false">images/cpp_11.png</guid><pubDate>Wed, 25 Dec 2024 06:50:44 GMT</pubDate><enclosure url="images/cpp_11.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_11.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_10]]></title><description><![CDATA[<img src="images/cpp_10.png" target="_self">]]></description><link>images/cpp_10.html</link><guid isPermaLink="false">images/cpp_10.png</guid><pubDate>Wed, 25 Dec 2024 06:47:16 GMT</pubDate><enclosure url="images/cpp_10.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_10.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[18. HTTP]]></title><description><![CDATA[HTTP는 문자열으로 날라옴헤더 + Payload헤더
일반
요청
응답
엔티티
]]></description><link>network/18.-http.html</link><guid isPermaLink="false">Network/18. HTTP.md</guid><pubDate>Mon, 09 Dec 2024 13:10:48 GMT</pubDate></item><item><title><![CDATA[17. DNS]]></title><description><![CDATA[Domain name
www - 호스트 네임
naver.com - 도메인 네임naver.com의 www 호스트를 찾아라ISP ( KT, LG , SK etc)에 호스트가 붙어있음.<a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.naver.com" target="_self">http://www.naver.com</a> 라고 씀<br>DNS 서버한테 질의를 함 - <a data-tooltip-position="top" aria-label="http://www.naver.com" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.naver.com" target="_self">www.naver.com</a> ip 주소를 알려줘ip 받으면 접속하기질의 했을 때 응답으로 유효시간이 옮.
한번이라도 질의 하면 pc가 DNS 캐싱함. (DNS 캐시)DNS Cache, host 파일, 공유기 DNS 포워딩 기능은 DNS 서버에 직접 질의하는 걸 줄여줌.<br>DNS에 질의를 했는데 모를수도 있음. (예를들어 <a data-tooltip-position="top" aria-label="http://www.naver.com" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.naver.com" target="_self">www.naver.com</a>)
그러면, Root DNS한테 요청함
Root DNS는 com 담당하는 DNS 목록을 알려줌.
naver 목록을 알려줘
naver 목록을 알려줌
www인 호스트 알려줘
naver 목록을 알려줌]]></description><link>network/17.-dns.html</link><guid isPermaLink="false">Network/17. DNS.md</guid><pubDate>Mon, 09 Dec 2024 13:08:08 GMT</pubDate></item><item><title><![CDATA[Metal]]></title><description><![CDATA[<img alt="metal_rendering_pipeline.png" src="images/metal_rendering_pipeline.png" target="_self">MTLDevice
GPU에 대한 추상화된 인터페이스
리소스(버퍼, 텍스처 등) 생성을 담당
커맨드 큐 생성
GPU 메모리 할당 관리
일반적으로 MTLCreateSystemDefaultDevice()로 생성
MTLCommandQueue
GPU에 전송할 명령어들의 큐
커맨드 버퍼들을 순차적으로 관리
렌더링 명령을 GPU에 전달하는 파이프라인
device.makeCommandQueue()로 생성
MTLRenderPipelineState
그래픽스 렌더링 파이프라인의 상태를 캡슐화
셰이더 프로그램, 버텍스 레이아웃, 블렌딩 모드 등 포함
렌더링 설정을 고정하여 성능 최적화
MTLBuffer
GPU 메모리에 할당된 데이터 버퍼
버텍스 데이터, 변환 행렬 등을 저장
CPU-GPU 간 데이터 전송에 사용
MTLDepthStencilState
깊이(Z) 테스트와 스텐실 테스트 설정을 관리
3D 렌더링에서 물체의 앞뒤 관계 처리
Camera
가상 카메라의 속성과 행렬을 관리하는 커스텀 클래스
View와 Projection 행렬 계산
렌더링과정
MTLDevice로 필요한 리소스들 생성
MTLBuffer에 데이터 저장
MTLRenderPipelineState로 렌더링 파이프라인 설정
MTLCommandQueue를 통해 커맨드 버퍼 생성
커맨드 버퍼에 렌더링 명령 인코딩
커맨드 버퍼 커밋하여 GPU 실행
// 1. 깊이 버퍼 포맷 설정 // 32비트 부동소수점 형식의 깊이 버퍼 사용
metalView.depthStencilPixelFormat = .depth32Float // 2. 깊이 테스트 설정
let depthDescriptor = MTLDepthStencilDescriptor()
// 새로운 픽셀의 깊이 값이 기존 깊이 값보다 작거나 같을 때만 렌더링
depthDescriptor.depthCompareFunction = .lessEqual // 깊이 비교 함수
// 렌더링된 픽셀의 깊이값을 깊이 버퍼에 저장
// 왜 있을까? - 다음 렌더링 할 물체와의 깊이 비교
depthDescriptor.isDepthWriteEnabled = true // 깊이 값 쓰기 활성화
이유: 3D 객체들의 앞뒤 관계를 올바르게 표현하기 위해서import Foundation
import MetalKit
import simd class Camera { var position: SIMD3&lt;Float&gt; var target: SIMD3&lt;Float&gt; var up: SIMD3&lt;Float&gt; = [0, 1, 0] var aspect: Float = 1.0 var fov: Float = Float.pi / 3 var near: Float = 0.1 var far: Float = 100 init(position: SIMD3&lt;Float&gt;, target: SIMD3&lt;Float&gt;) { self.position = position self.target = target } var viewMatrix: float4x4 { // 시선 방향 계산 let direction = normalize(target - position) let right = normalize(cross(direction, up)) let newUp = normalize(cross(right, direction)) let translation = float4x4(columns: ( SIMD4&lt;Float&gt;(1, 0, 0, 0), SIMD4&lt;Float&gt;(0, 1, 0, 0), SIMD4&lt;Float&gt;(0, 0, 1, 0), SIMD4&lt;Float&gt;(-position.x, -position.y, -position.z, 1) )) let rotation = float4x4(columns: ( SIMD4&lt;Float&gt;(right.x, newUp.x, -direction.x, 0), SIMD4&lt;Float&gt;(right.y, newUp.y, -direction.y, 0), SIMD4&lt;Float&gt;(right.z, newUp.z, -direction.z, 0), SIMD4&lt;Float&gt;(0, 0, 0, 1) )) return rotation * translation } var projectionMatrix: float4x4 { let y = 1 / tan(fov * 0.5) let x = y / aspect let z = far / (far - near) let w = -z * near return float4x4(columns: ( SIMD4&lt;Float&gt;(x, 0, 0, 0), SIMD4&lt;Float&gt;(0, y, 0, 0), SIMD4&lt;Float&gt;(0, 0, z, 1), SIMD4&lt;Float&gt;(0, 0, w, 0) )) }
}
// SIMD3&lt;Float&gt;
- Single Instruction Multiple Data 벡터 타입
- 3D 공간의 x, y, z 좌표를 표현
- 고성능 벡터 연산을 위해 사용 // float4x4
- 4x4 부동소수점 행렬
- 3D 변환(이동, 회전, 크기 조절)을 표현
- 뷰와 투영 변환에 사용 // viewMatrix
- 월드 공간을 카메라 공간으로 변환
- 카메라의 위치와 방향을 기준으로 모든 객체의 위치 계산
- 구성: 회전 행렬 × 이동 행렬
- Translation: 물체들을 카메라 위치만큼 이동
- Rotation: 카메라 방향으로 회전 // projectionMatrix
- 3D 공간을 2D 화면으로 투영
- 원근감 표현 (가까운 물체는 크게, 먼 물체는 작게)
- fov, aspect, near, far 평면으로 계산
- 원근 투영을 위한 4x4 행렬
- fov와 aspect ratio로 시야 영역 정의
- near/far로 보이는 범위 제한 fov (시야각):
- 작은 값: 망원 렌즈 효과 (확대)
- 큰 값: 광각 렌즈 효과 (축소) near/far 평면:
- near: 너무 가까운 물체 잘림
- far: 너무 먼 물체 잘림 aspect ratio:
- 화면 비율에 맞춰 이미지 왜곡 방지 CPU와 GPU 간의 효율적인 데이터 공유
동적으로 업데이트되는 데이터 처리에 적합
메모리 정렬과 크기 관리 중요
적절한 에러 처리 필요
device.makeBuffer( length: MemoryLayout&lt;Uniforms&gt;.size, // 버퍼 크기 options: .storageModeShared // 메모리 저장 모드
)
// MTLDevice의 메서드
func makeBuffer( length: Int, // 버퍼 크기 (바이트) options: MTLResourceOptions // 메모리 관리 옵션
) -&gt; MTLBuffer? // 생성된 Metal 버퍼 반환
// 가능한 옵션들:
.storageModeShared // CPU와 GPU가 모두 접근 가능
.storageModePrivate // GPU만 접근 가능
.storageModeManaged // CPU와 GPU 각각 별도 복사본 관리 // .storageModeShared 사용 시
CPU (Swift) ⟷ 공유 메모리 ⟷ GPU (Metal)
- 양방향 직접 접근 가능
- 동기화 오버헤드 최소화
- 작은 크기의 자주 업데이트되는 데이터에 적합 // Uniform 버퍼 생성
let uniformBuffer = device.makeBuffer( length: MemoryLayout&lt;Uniforms&gt;.size, options: .storageModeShared
) // 데이터 업데이트
let uniforms = Uniforms( modelMatrix: modelMatrix, viewMatrix: camera.viewMatrix, projectionMatrix: camera.projectionMatrix
)
memcpy(uniformBuffer.contents(), &amp;uniforms, MemoryLayout&lt;Uniforms&gt;.size)
구를 그릴 때 지구본처럼 위도 경도를 이용해서 그림.// 구면 좌표계에서 데카르트 좌표계로 변환하는 공식:
x = r * cos(θ) * cos(φ)
y = r * sin(θ)
z = r * cos(θ) * sin(φ) 여기서:
r = radius (골프공 반지름)
θ (theta) = 위도 (-π/2 ~ π/2)
φ (phi) = 경도 (0 ~ 2π) // 1. 위도(latitude) 계산
let lat = Float.pi * (-0.5 + Float(i) / Float(segments))
/*
i = 0 일 때: -π/2 (-90°) i = segments/2 일 때: 0° (적도)
i = segments 일 때: π/2 (90°)
*/ // 2. y 좌표 계산
let y = radius * sin(lat)
/*
lat = -π/2 일 때: y = -radius (아래)
lat = 0 일 때: y = 0 (중간)
lat = π/2 일 때: y = radius (위)
*/ // 3. 현재 위도에서의 원의 반지름
let conLat = radius * cos(lat)
/*
lat = -π/2 일 때: conLat = 0 (점)
lat = 0 일 때: conLat = radius (가장 큰 원)
lat = π/2 일 때: conLat = 0 (점)
*/ // 경도에 따른 x,z 좌표 계산
let lng = 2 * Float.pi * Float(j) / Float(segments)
let x = conLat * cos(lng)
let z = conLat * sin(lng) /*
j = 0 일 때: (x,z) = (conLat, 0) [0°]
j = segments/4 일 때: (x,z) = (0, conLat) [90°]
j = segments/2 일 때: (x,z) = (-conLat, 0) [180°]
j = 3*segments/4 일 때: (x,z) = (0, -conLat) [270°]
j = segments 일 때: (x,z) = (conLat, 0) [360°]
*/ import MetalKit class GolfBallRenderer: NSObject, MTKViewDelegate { // MARK: - Geometry Creation static func createGeometry(device: MTLDevice) -&gt; (MTLBuffer?, MTLBuffer?) { // 골프공 메시 데이터 생성 (UV 구) var ballVertices: [Float] = [] let segments = 32 let radius: Float = 0.0213 // 실제 골프공 크기 (미터) for i in 0...segments { let lat = Float.pi * (-0.5 + Float(i) / Float(segments)) let y = radius * sin(lat) let cosLat = radius * cos(lat) for j in 0...segments { let lng = 2 * Float.pi * Float(j) / Float(segments) let x = cosLat * cos(lng) let z = cosLat * sin(lng) // 위치 ballVertices.append(x) ballVertices.append(y) ballVertices.append(z) // 법선 벡터 ballVertices.append(x/radius) ballVertices.append(y/radius) ballVertices.append(z/radius) } } // 지면 메시 데이터 생성 let groundVertices: [Float] = [ -50, 0, -50, 0, 1, 0, 50, 0, -50, 0, 1, 0, 50, 0, 50, 0, 1, 0, -50, 0, -50, 0, 1, 0, 50, 0, 50, 0, 1, 0, -50, 0, 50, 0, 1, 0 ] guard let ballBuffer = device.makeBuffer(bytes: ballVertices, length: ballVertices.count * MemoryLayout&lt;Float&gt;.stride, options: []), let groundBuffer = device.makeBuffer(bytes: groundVertices, length: groundVertices.count * MemoryLayout&lt;Float&gt;.stride, options: []) else { return (nil, nil) } return (ballBuffer, groundBuffer) }
}
let library = device.makeDefaultLibrary() let vertexFunction = library.makeFunction(name: "vertexShader") let fragmentFunction = library.makeFunction(name: "fragmentShader") 컴파일된 셰이더 코드를 로드
버텍스와 프래그먼트 셰이더 함수 참조 획득
let pipelineDescriptor = MTLRenderPipelineDescriptor()
pipelineDescriptor.vertexFunction = vertexFunction
pipelineDescriptor.fragmentFunction = fragmentFunction
pipelineDescriptor.colorAttachments[0].pixelFormat = metalView.colorPixelFormat 렌더링 파이프라인 구성 설정
셰이더 함수 연결
색상 출력 포맷 지정
]]></description><link>golf-simulator/metal.html</link><guid isPermaLink="false">Golf Simulator/Metal.md</guid><pubDate>Mon, 25 Nov 2024 13:33:02 GMT</pubDate><enclosure url="images/metal_rendering_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/metal_rendering_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[metal_rendering_pipeline]]></title><description><![CDATA[<img src="images/metal_rendering_pipeline.png" target="_self">]]></description><link>images/metal_rendering_pipeline.html</link><guid isPermaLink="false">images/metal_rendering_pipeline.png</guid><pubDate>Sun, 24 Nov 2024 06:54:43 GMT</pubDate><enclosure url="images/metal_rendering_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/metal_rendering_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[insight_before]]></title><description><![CDATA[<img src="images/insight_before.png" target="_self">]]></description><link>images/insight_before.html</link><guid isPermaLink="false">images/insight_before.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/insight_before.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/insight_before.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[insight_after]]></title><description><![CDATA[<img src="images/insight_after.png" target="_self">]]></description><link>images/insight_after.html</link><guid isPermaLink="false">images/insight_after.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/insight_after.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/insight_after.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vertext_shader_parallel]]></title><description><![CDATA[<img src="images/vertext_shader_parallel.png" target="_self">]]></description><link>images/vertext_shader_parallel.html</link><guid isPermaLink="false">images/vertext_shader_parallel.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/vertext_shader_parallel.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/vertext_shader_parallel.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vertex_shader]]></title><description><![CDATA[<img src="images/vertex_shader.png" target="_self">]]></description><link>images/vertex_shader.html</link><guid isPermaLink="false">images/vertex_shader.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/vertex_shader.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/vertex_shader.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[using_uniform]]></title><description><![CDATA[<img src="images/using_uniform.png" target="_self">]]></description><link>images/using_uniform.html</link><guid isPermaLink="false">images/using_uniform.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/using_uniform.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/using_uniform.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[use_vertex_attirbute_arrays]]></title><description><![CDATA[<img src="images/use_vertex_attirbute_arrays.png" target="_self">]]></description><link>images/use_vertex_attirbute_arrays.html</link><guid isPermaLink="false">images/use_vertex_attirbute_arrays.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/use_vertex_attirbute_arrays.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/use_vertex_attirbute_arrays.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[type_structure]]></title><description><![CDATA[<img src="images/type_structure.png" target="_self">]]></description><link>images/type_structure.html</link><guid isPermaLink="false">images/type_structure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/type_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/type_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[shader_program_structure]]></title><description><![CDATA[<img src="images/shader_program_structure.png" target="_self">]]></description><link>images/shader_program_structure.html</link><guid isPermaLink="false">images/shader_program_structure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/shader_program_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/shader_program_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rasterization_mean]]></title><description><![CDATA[<img src="images/rasterization_mean.png" target="_self">]]></description><link>images/rasterization_mean.html</link><guid isPermaLink="false">images/rasterization_mean.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/rasterization_mean.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rasterization_mean.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[register_vec]]></title><description><![CDATA[<img src="images/register_vec.png" target="_self">]]></description><link>images/register_vec.html</link><guid isPermaLink="false">images/register_vec.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/register_vec.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/register_vec.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[programmable_pipeline]]></title><description><![CDATA[<img src="images/programmable_pipeline.png" target="_self">]]></description><link>images/programmable_pipeline.html</link><guid isPermaLink="false">images/programmable_pipeline.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/programmable_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/programmable_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[prog_debugging]]></title><description><![CDATA[<img src="images/prog_debugging.png" target="_self">]]></description><link>images/prog_debugging.html</link><guid isPermaLink="false">images/prog_debugging.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/prog_debugging.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/prog_debugging.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[primitive_assembly_rasterization]]></title><description><![CDATA[<img src="images/primitive_assembly_rasterization.png" target="_self">]]></description><link>images/primitive_assembly_rasterization.html</link><guid isPermaLink="false">images/primitive_assembly_rasterization.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/primitive_assembly_rasterization.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/primitive_assembly_rasterization.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[opengl_shader_program_process]]></title><description><![CDATA[<img src="images/opengl_shader_program_process.png" target="_self">]]></description><link>images/opengl_shader_program_process.html</link><guid isPermaLink="false">images/opengl_shader_program_process.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/opengl_shader_program_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/opengl_shader_program_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[paralle_processing]]></title><description><![CDATA[<img src="images/paralle_processing.png" target="_self">]]></description><link>images/paralle_processing.html</link><guid isPermaLink="false">images/paralle_processing.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/paralle_processing.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/paralle_processing.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[matrix_row_prior]]></title><description><![CDATA[<img src="images/matrix_row_prior.png" target="_self">]]></description><link>images/matrix_row_prior.html</link><guid isPermaLink="false">images/matrix_row_prior.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/matrix_row_prior.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/matrix_row_prior.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[linear_interpolation]]></title><description><![CDATA[<img src="images/linear_interpolation.png" target="_self">]]></description><link>images/linear_interpolation.html</link><guid isPermaLink="false">images/linear_interpolation.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/linear_interpolation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/linear_interpolation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[math_func]]></title><description><![CDATA[<img src="images/math_func.png" target="_self">]]></description><link>images/math_func.html</link><guid isPermaLink="false">images/math_func.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/math_func.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/math_func.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[layout_qualifier]]></title><description><![CDATA[<img src="images/layout_qualifier.png" target="_self">]]></description><link>images/layout_qualifier.html</link><guid isPermaLink="false">images/layout_qualifier.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/layout_qualifier.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/layout_qualifier.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glsl_debugging_1]]></title><description><![CDATA[<img src="images/glsl_debugging_1.png" target="_self">]]></description><link>images/glsl_debugging_1.html</link><guid isPermaLink="false">images/glsl_debugging_1.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/glsl_debugging_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glsl_debugging_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[gpu_structure]]></title><description><![CDATA[<img src="images/gpu_structure.png" target="_self">]]></description><link>images/gpu_structure.html</link><guid isPermaLink="false">images/gpu_structure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/gpu_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gpu_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glsl_debugging2]]></title><description><![CDATA[<img src="images/glsl_debugging2.png" target="_self">]]></description><link>images/glsl_debugging2.html</link><guid isPermaLink="false">images/glsl_debugging2.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/glsl_debugging2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glsl_debugging2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[gl_error_flag]]></title><description><![CDATA[<img src="images/gl_error_flag.png" target="_self">]]></description><link>images/gl_error_flag.html</link><guid isPermaLink="false">images/gl_error_flag.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/gl_error_flag.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gl_error_flag.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glVertexAttribPointer]]></title><description><![CDATA[<img src="images/glvertexattribpointer.png" target="_self">]]></description><link>images/glvertexattribpointer.html</link><guid isPermaLink="false">images/glVertexAttribPointer.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/glvertexattribpointer.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glvertexattribpointer.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fragment_shader_execute]]></title><description><![CDATA[<img src="images/fragment_shader_execute.png" target="_self">]]></description><link>images/fragment_shader_execute.html</link><guid isPermaLink="false">images/fragment_shader_execute.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/fragment_shader_execute.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/fragment_shader_execute.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[func_1]]></title><description><![CDATA[<img src="images/func_1.png" target="_self">]]></description><link>images/func_1.html</link><guid isPermaLink="false">images/func_1.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/func_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/func_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fragment_shader]]></title><description><![CDATA[<img src="images/fragment_shader.png" target="_self">]]></description><link>images/fragment_shader.html</link><guid isPermaLink="false">images/fragment_shader.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/fragment_shader.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/fragment_shader.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[export_shader_code]]></title><description><![CDATA[<img src="images/export_shader_code.png" target="_self">]]></description><link>images/export_shader_code.html</link><guid isPermaLink="false">images/export_shader_code.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/export_shader_code.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/export_shader_code.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[debugging_failure]]></title><description><![CDATA[<img src="images/debugging_failure.png" target="_self">]]></description><link>images/debugging_failure.html</link><guid isPermaLink="false">images/debugging_failure.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/debugging_failure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/debugging_failure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[debugging_success]]></title><description><![CDATA[<img src="images/debugging_success.png" target="_self">]]></description><link>images/debugging_success.html</link><guid isPermaLink="false">images/debugging_success.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/debugging_success.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/debugging_success.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bi_linear_interpolation]]></title><description><![CDATA[<img src="images/bi_linear_interpolation.png" target="_self">]]></description><link>images/bi_linear_interpolation.html</link><guid isPermaLink="false">images/bi_linear_interpolation.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/bi_linear_interpolation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bi_linear_interpolation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Audio_Stream_caching]]></title><description><![CDATA[Audio Stream Caching은 Unreal Engine에서 오디오 성능을 최적화하기 위한 기능
메모리 최적화: 전체 오디오 파일을 메모리에 로드하는 대신 필요한 부분만 캐시에 저장
스트리밍 성능 향상: 자주 사용되는 오디오 데이터를 캐시에 유지하여 디스크 액세스를 줄입니다. When this feature is enabled at cook time, almost all compressed audio data is separated from the USoundWave asset and placed at the end of the .pak file. This makes it possible for audio to be loaded into memory at any point, and released again when it has not been recently used. 전체 오디오 파일 로드 X -&gt; 메모리 사용량 감소
전체 오디오 파일 로드 X -&gt; 로딩 시간 단축
대용량 오디오 파일 처리 효율 증가 SoundWave가 로드되었다고, 오디오가 즉시 재생 가능하다고 보장 X -&gt; 재생이 재연될 수 있음.
스트리밍 오버헤드 -&gt; 재생 중 지속적인 데이터 로딩 -&gt; CPU 연산 증가
디스크 I/O: 디스크 성능 중요성 커짐 캐시 크기 설정에 따라 성능이 좌지우지됨 -&gt; 적절한 사이즈를 결정해야함.
재생 지연은 캐시 크기에 따라 관련이 있을 확률이 높음 사운드 로드 후 맵에 저장하는 방식은 모든 오디오 데이터가 메모리에 상주
오디오 스트림 캐싱 사용을 하고 맵에 저장하는 방식은 오디오 파일에 대한 참조와 메타데이터 저장 맵에 저장한다는 것이 반드시 전체 데이터를 메모리에 올린다는 의미X
오디오 스트림 캐싱을 사용할 때, TMap에 저장되는 것은 주로 오디오 파일에 대한 참조와 메타데이터임
실제 오디오 데이터는 디스크에 남아있고, 필요한 부분만 작은 청크(chunk) 단위로 캐시에 로드됨 스트림 캐싱을 사용하면, 대부분의 오디오 데이터는 디스크에 남아있음
메인 메모리에는 작은 캐시와 오디오 파일 참조만 존재함 초기 로드 과정 오디오 파일의 메타데이터와 스트리밍에 필요한 정보를 로드 캐시프라이밍 - 오디오 데이터 일부를 메모리에 로드 재생을 빠르게 시작 -&gt; 재생 지연 낮춤
Prime On Load 옵션 사용 스트리밍 준비 실제 오디오 데이터의 위치와 접근 방법에 대한 정보를 설정 런타임 로딩 오디오 재생 시, 필요한 부분을 그때그때 캐시로 로드
백그라운드에서 비동기적으로 이뤄짐 전통적인 방식: 전체 오디오 파일을 한 번에 메모리에 로드스트림 캐싱 방식: 메타데이터와 초기 캐시 데이터만 로드하고, 나머지는 필요할 때 스트리밍 Inherited: 기본 설정
사운드 클래스나 전역 설정에서 로딩 동작을 상속 RetainOnLoad: 사운드 전체를 메모리에 로드하고 유지
작고 자주 사용되는 사운드에 적합 (예: UI 효과음, 짧은 캐릭터 음성)
장점: 빠른 재생 시작, 지연 없음.
단점: 메모리 사용량 증가. PrimeOnLoad: 사운드의 시작 부분만 메모리에 로드
큰 사운드 파일의 빠른 초기 재생이 필요할 때 유용
장점: 빠른 초기 재생, 상대적으로 적은 메모리 사용.
단점: 전체 사운드가 필요할 때 추가 로딩 시간 발생 가능 LoadOnDemand: 필요할 때만 사운드 데이터를 로드
큰 사운드 파일이나 자주 사용되지 않는 사운드에 적합
장점: 메모리 사용 최소화.
단점: 초기 재생 시 약간의 지연 발생 가능. ForceInline: 사운드를 스트리밍 가능한 에셋 패키지에 강제로 인라인화
특수한 경우에 사용됨(예: 패키징 요구사항이 특별한 경우). 사용시 고려사항 게임의 메모리 제약: 모바일 게임의 경우 LoadOnDemand나 PrimeOnLoad가 유용할 수 있음
사운드의 크기와 사용 빈도: 작고 자주 사용되는 사운드는 RetainOnLoad, 큰 배경음악은 LoadOnDemand가 적합
초기 로딩 시간 vs 런타임 성능: RetainOnLoad는 초기 로딩 시간을 증가시키지만 런타임 성능이 좋음 실제 적용 예시: UI 효과음: RetainOnLoad (빠른 반응성 필요)
배경 음악: LoadOnDemand 또는 PrimeOnLoad (파일 크기가 크지만 즉각적인 재생 시작이 필요하지 않을 수 있음)
레벨별 특수 효과음: LoadOnDemand (필요할 때만 로드)
자주 사용되는 캐릭터 음성: RetainOnLoad 또는 PrimeOnLoad (반응성과 메모리 사용의 균형) ]]></description><link>ue/audio_stream_caching.html</link><guid isPermaLink="false">UE/Audio_Stream_caching.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[언리얼엔진에서의 Lamda]]></title><description><![CDATA[참조로 변수를 캡쳐하는데 람다가 실행되기 전에 해당 '객체'가 파괴되면 널 포인터 참조가 발생함. 이 현상이 언리얼엔진의 Deferred Execution(지연 실행), 비동기 작업, 생명주기 같은 것들과 맞물려서 위험할 수 있음. Prefer Capturing by Value
가능하다면 참조 캡쳐보다 값 캡쳐를 사용할 것. 람다는 값을 복사해서 사용할 것이므로 독립적인 생명주기를 가지게 됨 Use TWeakObjectPtr
Unreal 객체에 대한 포인터를 캡처할 때 raw 포인터 대신 TWeakObjectPtr를 사용하는 것. TWeakObjectPtr는 객체가 파괴되는 경우를 안전하게 처리하여 객체에 액세스하기 전에 객체가 여전히 유효한지 확인 Check for Validity
캡쳐된 포인터나 레퍼런스에 접근하기 전에 nullptr 또는 TWeakObjectPtr를 체크한다. Using a Weak Lambda
Weak Lamda를 사용하면 람다 내부의 객체를 안전하게 참조할 수 있음. 소유 객체가 유효하지 않다면 대리자를 통해 람다를 호출하지 않음.
if (const UWorld* World = OwnerComp.GetWorld())
{ const float DeltaTime = NumTicksExecuting * FAITestHelpers::TickInterval; World-&gt;GetTimerManager().SetTimerCreateWeakLambda(this, [&amp;OwnerComp, TaskMemory, this]() // &lt;---- This is the declaration of a weak lambda
{
TaskMemory-&gt;TimerHandle.Invalidate(); &lt;span class="token function"&gt;ensure&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;!&lt;/span&gt;TaskMemory&lt;span class="token operator"&gt;-&amp;gt;&lt;/span&gt;bIsAborting&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token function"&gt;LogExecution&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;OwnerComp&lt;span class="token punctuation"&gt;,&lt;/span&gt; LogIndexExecuteFinish&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token function"&gt;FinishLatentTask&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;OwnerComp&lt;span class="token punctuation"&gt;,&lt;/span&gt; LogResult&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token punctuation"&gt;}&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; DeltaTime&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token boolean"&gt;false&lt;/span&gt;&lt;span class="token punctuation"&gt;
;
} ]]></description><link>ue/언리얼엔진에서의-lamda.html</link><guid isPermaLink="false">UE/언리얼엔진에서의 Lamda.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[broadcastip_address]]></title><description><![CDATA[<img src="images/broadcastip_address.png" target="_self">]]></description><link>images/broadcastip_address.html</link><guid isPermaLink="false">images/broadcastip_address.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/broadcastip_address.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/broadcastip_address.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ip4v_header]]></title><description><![CDATA[<img src="images/ip4v_header.png" target="_self">]]></description><link>images/ip4v_header.html</link><guid isPermaLink="false">images/ip4v_header.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/ip4v_header.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ip4v_header.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[subnetmask]]></title><description><![CDATA[<img src="images/subnetmask.png" target="_self">]]></description><link>images/subnetmask.html</link><guid isPermaLink="false">images/subnetmask.png</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/subnetmask.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subnetmask.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[16.  TCP 연결 종료 과정]]></title><description><![CDATA[
4-way handshaking
클라가 FIN + ACK를 보냄
서버가 ACK를 보냄 그리고 다음 스텝에서 FIN + ACK를 보냄
클라이언트가 FIN + ACK를 받고 ACK를 보냄
서버가 ACK를 받음 -&gt; 종료완료
클라이언트가 Active하게 종료해야함
서버는 Passive하게 종료해야함
]]></description><link>network/16.-tcp-연결-종료-과정.html</link><guid isPermaLink="false">Network/16.  TCP 연결 종료 과정.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[07. IPv4 Header 형식]]></title><description><![CDATA[
MTU: 1500 bytes
Header: 20 bytes
Payload: 1500 - 20 bytes
<img alt="ip4v_header.png" src="images/ip4v_header.png" target="_self"> Version IPv4는 항상 4
4비트 IHL 헤더의 길이를 나타냄. 최소값은 5행(20bytes)임. 위의 스샷에서 20bytes가 헤더 길이임.
4비트 QOS(Quality of Service) or TOS QOS, TOS 정보를 포함
8비트 Total Length 헤더와 데이터를 포함한 전체 패킷의 길이 (bytes)
16비트 Identification 패킷 조각들을 구분하는 데 사용
16비트 Flag 패킷의 단편화와 관련된 제어 플래그
3비트 Fragment offset 원본 패킷에서의 데이터 오프셋을 8바이트 단위로 나타냄
13비트 TTL (Time To Live) 패킷의 수명을 제한
8비트 Protocol 위 계층 프로토콜(예: TCP, UDP)을 식별
8비트 Header checksum 헤더의 무결성을 검증
16비트 Source address 송신자의 IP 주소
32비트 Destination Address 수신자의 IP 주소
32비트 Options 선택적 필드로, 추가 기능을 제공
가변 길이 0 ~ 40 bytes Data Up to 65515 bytes까지지만 대부분의 경우 MTU - Header 길이를 넘지 않음! ]]></description><link>network/07.-ipv4-header-형식.html</link><guid isPermaLink="false">Network/07. IPv4 Header 형식.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/ip4v_header.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ip4v_header.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[08. 서브넷 마스크와 CIDR]]></title><description><![CDATA[IP 주소에서 Net ID와 Host ID는 Subnet mask와 함께 고려해야 함.
192.168.23.5 이라는 IP 주소가 있다고 가정
Subnet Mask가 255.255.255.0임
192.168.23 은 Net ID
5은 Host ID
즉 Subnet Mask란, IP주소에서 NetID와 Host ID를 구분하기 위한 용도 Class A -&gt;Network ID는 8비트
Class B-&gt; Network ID는 16비트
Class C -&gt; Network ID는 24비트 서브넷 마스크와 IP 주소를 AND 연산하면 Net ID는 본래의 값이 나오고 Host ID는 0이 나옴 -&gt; Host ID 마스킹 함
Net ID 구분이 중요한 이유 패킷이 올 때, 네트워크 ID가 같으면 우리쪽으로 유입하는 것임을 알 수 있음. <img alt="subnetmask.png" src="images/subnetmask.png" target="_self"> 요즘은 CIDR 표기방식을 사용함. 서브넷마스크를 이용
192.168.23.5
255.255.255.0 CIDR 이용
192.168.23.5 / 24 ]]></description><link>network/08.-서브넷-마스크와-cidr.html</link><guid isPermaLink="false">Network/08. 서브넷 마스크와 CIDR.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/subnetmask.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subnetmask.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[09. Broadcast IP 주소 & Loopback 주소]]></title><description><![CDATA[
패킷을 보낼때 dst를 보고 Gateway로 전달을 함.
Gateway는 Internet으로 보냄
dst가 특정 IP면 Unicast임 (콕 집어서 보내는 거)
<img alt="broadcastip_address.png" src="images/broadcastip_address.png" target="_self">
Net ID를 제외한 Host ID를 모두 1로 채우면 Broadcast IP 주소임
dst가 Broadcast 주소면 전체한테 다 보냄
브로드캐스팅은 효율성이 떨어짐 Host ID가 0 인 경우 -&gt; 서브넷 마스크와 일치
Host ID가 255인 경우 -&gt; 브로드캐스트 주소 IP 주소를 사용해 통신하는 주체는 Process임.
내 Process간의 통신 이뤄질 때 사용하는 주소: Loopback address -&gt; 127.0.0.1
이 주소를 사용하면 패킷을 H/W영역에 보내지 않아도 됨
]]></description><link>network/09.-broadcast-ip-주소-&amp;-loopback-주소.html</link><guid isPermaLink="false">Network/09. Broadcast IP 주소 &amp; Loopback 주소.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate><enclosure url="images/broadcastip_address.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/broadcastip_address.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[10. TTL과 단편화]]></title><description><![CDATA[인터넷은 라우터와 DNS의 집합체임.Router의 역할은 라우터 테이블을 보고 패킷을 포워딩하는 것. (물류센터, 택배 기사 역할)
Router에서 Router로 이동하는 걸 Hop(깡총)이라고 함.
Hop을 하게 되면 TTL 값이 1씩 감소함.
Time To Live
IP 패킷 수명을 제한하는 메커니즘
라우터를 통과할 때마다 TTL 값 1씩 감소
수명을 제한 하지 않는다면 패킷이 네트워크를 무한 순회 -&gt; 좀비 패킷
대부분 패킷의 최대 사이즈 (MTU = 1500 bytes)임. 간혹 서로 다른 네트워크 구간의 MTU 차이가 발생할 수 있음 (어떤 건 1400bytes, 1500 bytes) 이럴 때 패킷을 보내기 위해 쪼개는 걸 단편화라고 함.
쪼개진 단편들은 수신자(Endpoint)에서 조립함.
단편화된 패킷은 각각 다른 경로로 전송될 수 있음 (TTL이 만료되어 폐기 가능성 있음)
단편화는 비효율적 -&gt; 처음부터 패킷을 보낼 때 하향 표준화해서 보내는 방법도 있음(처음부터 작은 사이즈 패킷을 보냄)
VPN 터널링 기술에서 단편화 발생할 가능성 높음
]]></description><link>network/10.-ttl과-단편화.html</link><guid isPermaLink="false">Network/10. TTL과 단편화.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[11. 인터넷 자동 설정 - DHCP]]></title><description><![CDATA[인터넷을 사용하려면 해야할 게 있음.
IP 주소
Subnet mask
Gateway IP
DNS 서버
일반 사용자는 이러한 설정을 하지 않음. 그럼 누가 해주나?DHCP가 해준다. Dynamic Host Configuration Protocol 기능 IP 주소 할당: 네트워크에 연결된 장치에 고유한 IP 주소를 자동으로 할당
서브넷 마스크 제공: IP 네트워크의 범위를 정의하는 서브넷 마스크를 제공
기본 게이트웨이 설정: 로컬 네트워크 외부와 통신하기 위한 게이트웨이 주소를 제공
DNS 서버 정보: 도메인 이름을 IP 주소로 변환하는 DNS 서버의 주소를 제공 DHCP는 내가 사용할 위의 네가지 것들을 DHCP 서버가 알려주는 것임 DHCP 작동 과정 클라이언트가 네트워크에 연결되면 DHCP 서버를 찾아야함 -&gt; 브로드캐스트
DHCP 서버가 위의 정보들을 보내줌 (IP주소, 서브넷마스크 등등)
클라이언트가 수락하고 요청 보냄
DHCP 서버가 최종 승인함. 즉 DHCP 서버는 주소값을 관리하는 pool이라고 할 수 있음 DHCP는 브로드캐스트 도메인에 묶여있음. 브로드캐스트 도메인: 브로드캐스트 패킷이 도달할 수 있는 네트워크 범위 DHCP 브로드 캐스트 메세지는 Gateway를 넘을 수 없음. DHCP는 기본적으로 로컬 브로드캐스트 도메인 내에서 작동하며, 브로드캐스트 트래픽은 일반적으로 라우터를 통과X 라우터는 주로 다른 네트워크 범위로 트래픽을 이동 시키는데 사용.
같은 네트워크면 ARP or 스위치나 허브를 통해 직접 통신 ]]></description><link>network/11.-인터넷-자동-설정-dhcp.html</link><guid isPermaLink="false">Network/11. 인터넷 자동 설정 - DHCP.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[12. ARP]]></title><description><![CDATA[Address Resolution Protocol
브로드 캐스팅
IP 주소로 게이트웨이의 MAC 주소를 알아내려할 때 활용.
DHCP로 먼저 게이트웨이의 IP를 알고 ARP Request를 보내고 Reply로 게이트웨이의 MAC 주소를 얻음
왜? 인터넷을 연결하기 위해서는 게이트웨이의 MAC 주소를 알아야함.인터넷 저 너머의 호스트(네이버 같은)에 접속할 때 L2 수준의 Frame에서 Header에 MAC 주소가 적혀있다. Packet에는 네이버의 IP가 적혀있겠지만, Header의 도착 정보에는 Gateway의 MAC 주소가 적혀있음.]]></description><link>network/12.-arp.html</link><guid isPermaLink="false">Network/12. ARP.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[13. Ping과 RTT]]></title><description><![CDATA[
Ping은 RTT(Round To Time)를 측정할 목적으로 사용되는 프로그램임
핑은 ICMP 프로토콜을 이용해서 RTT를 측정함.
Dos 공격용을 악용되기도 함.
]]></description><link>network/13.-ping과-rtt.html</link><guid isPermaLink="false">Network/13. Ping과 RTT.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[14. TCP와 UDP 개요]]></title><description><![CDATA[
TCP는 연결 개념이 있음
TCP는 기본적으로 Client / Server가 있음.
Client는 연결을 시도하는 주체.
PID를 가진 프로세스가 Socket를 오픈함. 운영체제가 TCP 포트를 열어줌Server는 연결을 기다리는 객체
Socket을 오픈함. 운영체제가 TCP 포토를 열어놓고 대기함 (Listen)즉 연결하기 위해서는 서버의 IP 주소와 포트 번호를 알아야함.연결대기 상태도 아닌데, TCP 쪽에서 연결하자고 오면 운영체제 수준에서 연결을 못받아준다는 응답을 보내줌.]]></description><link>network/14.-tcp와-udp-개요.html</link><guid isPermaLink="false">Network/14. TCP와 UDP 개요.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[15. TCP 연결 과정]]></title><description><![CDATA[
3-way handshaking
통신되는 데이터 단위는 segment
클라이언트에서 랜덤 sequence number를 SYN으로 서버에 보냄
서버는 이를 받고 받은 숫자에 + 1을 더해 Ack르 클라에 보냄
또한 서버는 랜덤 sequence number를 SYN으로 보낸다.
클라는 Ack와 서버의 seq number을 받고 연결되었다고 판단함
또한 클라는 서버의 seq number에 + 1을 더해 ack를 보냄
서버는 이를 받고 연결되었다고 판단
TCP 연결 과정에서
Sequence number 교환
정책 교환: Maximum segment size (MSS) 사이즈가 다르다면 클라가 서버에 맞춤 ]]></description><link>network/15.-tcp-연결-과정.html</link><guid isPermaLink="false">Network/15. TCP 연결 과정.md</guid><pubDate>Tue, 05 Nov 2024 12:10:31 GMT</pubDate></item><item><title><![CDATA[u2_soundtype]]></title><description><![CDATA[<img src="images/u2_soundtype.png" target="_self">]]></description><link>images/u2_soundtype.html</link><guid isPermaLink="false">images/u2_soundtype.png</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/u2_soundtype.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/u2_soundtype.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[foldering_to_be]]></title><description><![CDATA[<img src="images/foldering_to_be.png" target="_self">]]></description><link>images/foldering_to_be.html</link><guid isPermaLink="false">images/foldering_to_be.png</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/foldering_to_be.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/foldering_to_be.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[graphic_pipeline]]></title><description><![CDATA[<img src="images/graphic_pipeline.png" target="_self">]]></description><link>images/graphic_pipeline.html</link><guid isPermaLink="false">images/graphic_pipeline.png</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/graphic_pipeline.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/graphic_pipeline.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01. 기본]]></title><description><![CDATA[
GL과 윈도우 시스템(OS가 아님 창을 여는)은 같이 가야함
윈도우
윈도우 시스템은 각 OS에 종속되어 있음
X윈도우 (리눅스), MS 윈도우(MS), Cocoa 윈도우(애플)
멀티플랫폼을 지원하는게 좋음 -&gt; freeglut 등등 라이브러리가 나왔으나 현재는 GLFW (그래픽 라이브러리 프레임워크) 사용
GLEW: OpenGL Extension
편의를 위한 추가 기능
<a data-tooltip-position="top" aria-label="https://www.glfw.org/download.html%EC%97%90%EC%84%9C" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/download.html%EC%97%90%EC%84%9C" target="_self">https://www.glfw.org/download.html에서</a> 프리 컴파일드 바이너리 다운로드 64bit압축을 풀면 있는 Include 폴더 안에 있는 GLFW 폴더와 자신의 컴파일러에 맞는 폴더를 찾아야함.
ex) 비쥬얼 스튜디오 2022는 lib-vc2022비쥬얼 스튜디오가 설치되어 있는 폴더에서 컴파일러 폴더 찾기ex) C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\XX.YY.ZZZZZ경로 안에 있는 Include에 GLFW 복붙
lib\x64\ 에 static library 3개 (glfw3.lib, glfw3_mt.lib, glfw3dll.lib) 복붙
bin\Hostx64\x64 에 dynamic library (glfw3.dll) 복붙
설치 완료.테스트로 300 x 300 윈도우 생성#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glfw3.lib")
#include &lt;stdio.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300; int main(void) { // start GLFW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, "Hello GLFW", NULL, NULL); glfwMakeContextCurrent(window); // main loop while (!glfwWindowShouldClose(window)) { glfwPollEvents(); } // done glfwTerminate(); return 0;
}
Run 할 때, Config를 Release, x64로 변경하고 Run C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\XX.YY.ZZZZZ경로 안에 있는 Include에 GLEW 복붙
lib\x64\ 에 static library (lib) 복붙
bin\Hostx64\x64 에 dynamic library (dll) 복붙
다운로드 된 파일 중 glewinfo.exe 클릭 -&gt;glewinfo.txt 생성glewinfo는 지원하는 opengl 버전, 함수가 적혀 있음visualinfo.ext 클릭 -&gt; visualinfo.txt 생성
visualinfo는 opengl extension 리스트와 가능한 프레임버퍼 설정 적혀있음// HelloGLEW.cpp : This file contains the 'main' function. Program execution begins and ends there.
// #include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib")
#include &lt;stdio.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300; int main() { // start GLFW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, "Hello GLEW", NULL, NULL); glfwMakeContextCurrent(window); // start GLEW glewInit(); // checking OpenGL version (optional) const char* strVersion = (const char*)(glGetString(GL_VERSION)); printf("version = %s\n", strVersion); fflush(stdout); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
}
<br><img alt="glew32_install_error.png" src="images/glew32_install_error.png" target="_self">위 같은 오류가 뜨는 이유는 운영체제가 DLL 파일을 못 찾는 경우에 발생glew32.dll, glfw3.dll를 C:Windws/System32에 붙여 넣으면 해결됨GLAD는 Multi-language GL/GLX/WGL loader - generator의 약자임.
OpenGL 함수 포인터를 로드하고 관리하는 데 사용<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://glad.dav1d.de" target="_self">https://glad.dav1d.de</a> 에 접속하고 버전 선택하고 generateinclude 안에 있는 두 폴더 glad, KHR은 위에서 GLEW, GLFW 설치한 것처럼 복붙src에 있는 glad.c는 내 c++ 프로젝트에 복붙해서 사용]]></description><link>graphics/opengl/01.기본/01.-기본.html</link><guid isPermaLink="false">graphics/opengl/01.기본/01. 기본.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/glew32_install_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glew32_install_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용]]></title><description><![CDATA[윈도우 시스템 추상화기능
초기화
윈도우 관리 윈도우 생성 / 파괴 callback registration 다양한 콜백 제공
마우스, 키보드, 스크린 등의 이벤트 처리 기능 대표 함수 void glfwInit() void glfwTerminate() GLFWwindow glfwCreateWindow(int width, int height, const char title, GLFWmonitor monitor, GLFWwindow share); 윈도우와 이것과 연관된 OpenGL context 생성하는 함수
context는 현재 OpenGL state와 internal variables임 void glfwMakeContextCurrent(GLFWwindow* win); 앞으로 모든 gl 명령어는 지정한 window에 적용하겠다. int glfwWindowShouldClose(GLFWwindow* win); void glfwPollEvents(); 현재 어떤 이벤트들이 발생했는지 체크 void glfwSwapBuffers(GLFWwindow* win); 윈도우 화면 업데이트 좌표계 윈도우 시스템 좌표계 프레임버퍼 / 픽셀 = 2차원 배열
integer 좌표 사용
upper-left cornet에 원점 (오른쪽: x축 양수, 아래쪽: y축 양수) 3D 그래픽스 좌표계 수학에서 사용하는 3차원 좌표계
float 좌표 사용
오른손 좌표계 GLFW의 보일러 플레이트...
glfwInit();
GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, "Hello GLFW", NULL, NULL);
glfwMakeContextCurrent(window); // prepare initial setting for gl
glewInit(); // glew init
...
// // main loop
while (!glfwWindowShouldClose(window)) { // draw ... draw an image ... //GLFW actions - update glfwSwapBuffers(win); glfwPollEvents();
}
// done
glfwTerminate();
return 0;
... ]]></description><link>graphics/opengl/01.기본/02.-콜백함수와-컬러-기초-이론-glfw-개요-및-사용.html</link><guid isPermaLink="false">graphics/opengl/01.기본/02. 콜백함수와 컬러 기초 이론 - GLFW 개요 및 사용.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate></item><item><title><![CDATA[03. 콜백함수와 컬러 기초 이론 - Callback 함수]]></title><description><![CDATA[
전체 윈도우를 그려야하는 상황일 때 콜됨
윈도우가 resized 될 때
iconified 되고, 화면에 re-mapped 될 때
콜백 함수를 만들 때 아래 형태로 만들어야함.typedef void (*GLFWwindowrefreshfun)(GLFWwindow* win);
// win은 refresh될 윈도우임.
win에 콜백 함수 등록을 하는 함수GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* win, GLFWwindowrefreshfun func);
func가 NULL이면 current callback function은 제거된다.// HelloRefreshCallback.cpp : This file contains the 'main' function. Program execution begins and ends there.
// #include "GL/glew.h"
#include "GLFW/glfw3.h" #pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib") #include &lt;iostream&gt;
#include &lt;string.h&gt; const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300;
const unsigned int WIN_X = 100; // window position in pixels, (X, Y) const unsigned int WIN_Y = 100; // 등록할 콜백 함수
void refreshFunc(GLFWwindow* window) { printf("refresh called\n"); fflush(stdout); // 설정된 컬러로 화면을 지움 glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW action - update glfwSwapBuffers(window);
} int main(int argc, char* argv[])
{ // get your program name
#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\') + 1);
#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);
#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare - callback 등록 glfwSetWindowRefreshCallback(window, refreshFunc); // 화면을 지울 때 어떤 색깔로 지울지 설정함. glClearColor(0.5F, 0.8F, 0.8F, 1.0F); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
}
OpenGL: state machineOpenGL 내부 변수:GLclampf colorClearValue[4]; // RGBA 값
효율성을 높이기 위해, 명령어 큐에 기록하고 return
실행은 명령어 큐에서 지연 실행함
OpenGL 응용 프로그램 - 명령어 큐 (지연 실행) - OpenGL rendering pipelinedelayed execution 관련함수
void glFlush(); OpenGL 명령 큐를 flush
주의할점: 대부분은 바로 실행되지만, 일부는 시간이 더 필요할 수 있음. void glFinish(); OpenGL 명령어 큐를 flush하고 모두 완료되는 것을 확인 후에 return
주의할 점: 시간이 오래 걸릴 수도 있음 두 함수 다 명령어 큐에 있는 걸 다 업데이트 하기 때문에 명령어 큐가 전체 비워짐 -&gt; 내가 글리길 원하는 그림을 실행하면 바로 그릴 수 있음. 다만 명령어 큐를 다 비워야하기 때문에 약간의 시간지연이 발생등록할 함수 typedeftypedef void(*GLFWkeyfun)(GLFWwindow* win, int key, int scancode, int action, int mods);
parameter
win: 윈도우
key: keyboard key
scancode: system specific scancode -&gt; 사용하지 않음
action: GLFW_PRESS, GLFW_RELEASE, GLFW_REPEAT
mods: modifier keys (GLFW_MOD_SHIFT, CONTROL, ALT, SUPER)
해당하는 윈도우에 함수 등록GLFWkeyfun glfwSetKeyCallback(GLFWwindow* win, GLFWkeyfun func);
함수에 null을 넣으면 함수 등록 취소.예시.
CTRL + SHIFT + 'C' 인 경우
key: 'C'
mods: GLFW_MOD_SHIFT | GLFW_MOD+CONTROL
action: GLFW_PRESS (GLFW_RELEASE 이벤트도 발생하긴 함) #include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib")
#pragma warning(disable: 4711 4710 4100)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; // for strrchr() const unsigned int WIN_W = 300; // window size in pixels, (Width, Height)
const unsigned int WIN_H = 300;
const unsigned int WIN_X = 100; // window position in pixels, (X, Y) const unsigned int WIN_Y = 100; void refreshFunc(GLFWwindow* window) { // refresh glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW action glfwSwapBuffers(window);
} void keyFunc(GLFWwindow* window, int key, int scancode, int action, int mods) { switch (key) { case GLFW_KEY_ESCAPE: if (action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } break; }
} int main(int argc, char* argv[]) { // get your program name
#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\') + 1);
#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);
#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare glfwSetWindowRefreshCallback(window, refreshFunc); glfwSetKeyCallback(window, keyFunc); glClearColor(0.933F, 0.769F, 0.898F, 1.0F); // main loop while (! glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
} GLFW 함수 설명
void glfwSetWindowShouldClose(GLFWwindow* win, int value);
// 특정 윈도우의 close flag를 설정할 수 있음 int glfwWindowShouldClose(GLFWwindow* win);
// 특정 윈도우의 close flag를 리턴함.
// return 하는 값이 0이 아니면 윈도우를 close 해야하는 상황
]]></description><link>graphics/opengl/01.기본/03.-콜백함수와-컬러-기초-이론-callback-함수.html</link><guid isPermaLink="false">graphics/opengl/01.기본/03. 콜백함수와 컬러 기초 이론 - Callback 함수.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate></item><item><title><![CDATA[04. 컬러 기초이론]]></title><description><![CDATA[모든 색을 Red, Green, Blue를 조정해서 만들 수 있음.
컬러모델 컴퓨터 / 소프트웨어에서 컬러를 표현하는 방법
다양한 모델: RGB, CMY(잉크), grayscale ... color gamut (컬러 개멋), 색 영역 특정 컬러 모델에서 표현 가능한 모든 색상 영역 Color cube, Color solid 3원색을 쓰는 컬러모델에서
Color gamut은 cube 정육면체 형태 <img alt="rgb_color_model.png" src="images/rgb_color_model.png" target="_self"><br><img alt="cmy_model.png" src="images/cmy_model.png" target="_self"> RGB color system 가산 색계 - 더할 수록 밝아짐
모니터, LCD 형광물질로 RGB 색상 컴퓨터 그래픽스의 주된 관심사 CMY color system 감산 색계 - 더할 수록 어두워짐
프린터, 인쇄용 두 모델은 서로 변환 가능함 <br><img alt="rgb_cmy_conversion.png" src="images/rgb_cmy_conversion.png" target="_self">]]></description><link>graphics/opengl/01.기본/04.-컬러-기초이론.html</link><guid isPermaLink="false">graphics/opengl/01.기본/04. 컬러 기초이론.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/rgb_color_model.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rgb_color_model.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. 컬러 이미지 저장 방식]]></title><description><![CDATA[
이미지 -&gt; (색깔 있는) 사각형의 2차원 배열
픽셀 pixel (= picture element)로 프레임버퍼를 표현함 컬러 심도 (색 깊이), bit depth 픽셀 당 몇 bit를 사용할 것인가 (메모리 비용) 인간의 시각은 200단계 색상 차이를 인식 그래서 256 즉 8bit를 사용하는 것이 일반적 <img alt="bw_grayscale.png" src="images/bw_grayscale.png" target="_self"><br><img alt="3colorchannel.png" src="images/3colorchannel.png" target="_self">
gray scale을 확장함 rgb 픽셀 값을 그레이스케일 형태로 저장
red 채널만 뽑아서, g 채널만, b 채널만 3개의 그레이스케일 이미지 저장
합성 -&gt; 컬러 이미지 <br><img alt="color_image.png" src="images/color_image.png" target="_self">
color image 한 픽셀마다 3개의 채널을 사용함
각 채널마다 8비트로 저장
그러면 한 픽셀당 24bit 사용 -&gt; 24bit 컬러 모델 각 픽셀마다 3개의 채널을 가지는 것을 Direct Color System이라고 부름 그래픽 카드 내부 구조 framebuffer: 각 픽셀마다 3 채널을 사용 (rgb)
각 채널마다 n bit 할당: - 총 2^3n Color
3n = 8, 12, 24, 30 .... 사용 True Color System 3n = 24 -&gt; 현재 가장 많이 사용 HDRI = high dynamic range imaging 3n = 30 ]]></description><link>graphics/opengl/01.기본/05.-컬러-이미지-저장-방식.html</link><guid isPermaLink="false">graphics/opengl/01.기본/05. 컬러 이미지 저장 방식.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/bw_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bw_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[06. RGBA 컬러 모델]]></title><description><![CDATA[ True Color System with alpha channel 4n = 32
픽셀당 4byte -&gt; (R, G, B, A)
0~255 사이의 정수 OpenGL은 float 사용 void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
<img alt="color_vs_grayscale.png" src="images/color_vs_grayscale.png" target="_self">흑백 -&gt; 컬러는 이론상 불가능하지만, 수요가 있다보니 수작업으로 작업했음.
요즘은 인공지능을 도입해서 변환하고 있음.<br><img alt="grey_to_color_using_ai.png" src="images/grey_to_color_using_ai.png" target="_self">
키보드 콜백 등록 q w e - &gt; 각각 r g b 값 높임
a s d -&gt; 각각 r g b 값 낮춤 // ChangeColor.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#pragma comment(lib, "opengl32.lib")
#pragma comment(lib, "glew32.lib")
#pragma comment(lib, "glfw3.lib")
#pragma warning(disable: 4711 4710 4100)
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; const unsigned int WIN_W = 300;
const unsigned int WIN_H = 300;
const unsigned int WIN_X = 100;
const unsigned int WIN_Y = 100; GLfloat clr[4] = { 0.933F, 0.769F, 0.898F, 1.0F }; void refresh_callback(GLFWwindow* window);
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods); void refresh_callback(GLFWwindow* window)
{ glClear(GL_COLOR_BUFFER_BIT); glFinish(); glfwSwapBuffers(window);
} void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{ switch (key) { case 'Q': clr[0] += 0.01F; if (clr[0] &gt; 1.0F) clr[0] = 1.0F; break; case 'W': clr[1] += 0.01F; if (clr[1] &gt; 1.0F) clr[1] = 1.0F; break; case 'E': clr[2] += 0.01F; if (clr[2] &gt; 1.0F) clr[2] = 1.0F; break; case 'A': clr[0] -= 0.01F; if (clr[0] &lt; 0.0F) clr[0] = 0.0F; break; case 'S': clr[1] -= 0.01F; if (clr[1] &lt; 0.0F) clr[1] = 0.0F; break; case 'D': clr[2] -= 0.01F; if (clr[2] &lt; 0.0F) clr[2] = 0.0F; break; case GLFW_KEY_ESCAPE: if (action == GLFW_PRESS) { glfwSetWindowShouldClose(window, GL_TRUE); } break; } glClearColor(clr[0], clr[1], clr[2], clr[3]);
} int main(int argc, char* argv[])
{ // get your program name
#if defined(_WIN32) || defined(_WIN64) char* win_name = (strrchr(argv[0], '\\') == NULL) ? argv[0] : (strrchr(argv[0], '\\') + 1);
#else // Unix, Linux, MacOS char* win_name = (strrchr(argv[0], '/') == NULL) ? argv[0] : (strrchr(argv[0], '/') + 1);
#endif // start GLFW &amp; GLEW glfwInit(); GLFWwindow* window = glfwCreateWindow(WIN_W, WIN_H, win_name, NULL, NULL); glfwSetWindowPos(window, WIN_X, WIN_Y); glfwMakeContextCurrent(window); glewInit(); // prepare glfwSetWindowRefreshCallback(window, refresh_callback); glfwSetKeyCallback(window, key_callback); glClearColor(clr[0], clr[1], clr[2], clr[3]); // main loop while (!glfwWindowShouldClose(window)) { // draw glClear(GL_COLOR_BUFFER_BIT); glFinish(); // GLFW actions glfwSwapBuffers(window); glfwPollEvents(); } // done glfwTerminate(); return 0;
}
]]></description><link>graphics/opengl/01.기본/06.-rgba-컬러-모델.html</link><guid isPermaLink="false">graphics/opengl/01.기본/06. RGBA 컬러 모델.md</guid><pubDate>Mon, 26 Aug 2024 13:37:17 GMT</pubDate><enclosure url="images/color_vs_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/color_vs_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[var_error]]></title><description><![CDATA[<img src="images/var_error.jpg" target="_self">]]></description><link>images/var_error.html</link><guid isPermaLink="false">images/var_error.jpg</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/var_error.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/var_error.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[pso]]></title><description><![CDATA[<img src="images/pso.png" target="_self">]]></description><link>images/pso.html</link><guid isPermaLink="false">images/pso.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/pso.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/pso.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[foldering_as_is]]></title><description><![CDATA[<img src="images/foldering_as_is.png" target="_self">]]></description><link>images/foldering_as_is.html</link><guid isPermaLink="false">images/foldering_as_is.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/foldering_as_is.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/foldering_as_is.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02]]></title><description><![CDATA[스탠드얼론: 로컬 플레이어클라이언트: 프록시만 보여주는 리슨 서버: 로컬 플레이어를 서버에 직접 배치, 자기 자신도 플레이어임데디케이티드서버: 로컬 플레이어 없음. 대규모 멀티플레이 게임에 사용리슨서버 예시: 스타크래프트 정도? 서버와 클라가 결합리슨서버 구동방식
로그인 플로우 리슨서버가 될 호스트가 스탠드얼론으로 게임모드 + 플레이어컨트롤러 생성
게임 서비스 시작 (스탠드얼론 -&gt; 리슨서버로 변경)
클라이언트가 리슨서버에게 요청
리슨 서버의 콘텐츠가 클라이언트에게 콘텐츠 복제 게임모드의 주요함수
PreLogin: 클라이언트의 접속 요청을 처리하는 함수 - 받아들일까 말까 (서버에서는 이 과정 없음)
Login: 접속을 허용한 클라에 대응하는 플레이어 컨트롤러 만듬
PostLogin: 플레이어 입장을 위해 플레이어에 필요한 기본 설정을 모두 마무리함
StartPlay: 게임 시작 지시
BeginPlay: 게임이 시작할 때 레벨에 있는 모든 액터에서 호출하는 함수
클라이언트에 게임모드가 없음 그럼 어떻게 게임 시작?
-&gt; 게임 스테이트 엑터를 사용함 (서버와 클라 둘 다 존재)게임모드가 StartPlay() -&gt; 게임스테이트한테 명령 내림 -&gt; HandleBeginPlay() // 이건 서버로직임
OnRep_ReplicatedHasBegunPlay()는 클라가 호출함]]></description><link>ue/network-프레임워크/02.html</link><guid isPermaLink="false">UE/Network 프레임워크/02.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[03. 커넥션과 오너십]]></title><description><![CDATA[
원격 엑터 초기화 이해
네트워크 처리 방식
오너십 개념 게임과 무관한 액터 설정 초기화 -&gt; PostInitializeComponents
원격 클라에서 네트워크 관련 설정 초기화 -&gt; PostNetInit
게임 진행에 필요한 초기화 -&gt; BeginPlay
네트워크 통신을 담당하는 주요 클래스
PlayerController: 네트워크 통신에 접근 가능한 게임 내 대표 엑터
UNetConnection: 주고 받는 패킷 데이터의 인코딩, 디코딩, 네트워크 통신량 조절, 채널 관리
UNetDriver: 로우 레벨에서의 소켓 관리와 패킷 처리 및 네트워크 통신 설정
넷드라이버는 다수의 커넥션을 관리하고, 서버와 클라이언트에 따라 다르게 동작함.
클라이언트에서의 넷드라이버는 항상 하나의 서버 커넥션을 가진다.
서버에서의 넷드라이버는 다수의 클라이언트 커넥션을 가진다.'GameMode PostLogin()에서 다수의 클라이언트 커넥션을 확인할 수 있었고,void AABGameMode::PostLogin(APlayerController* NewPlayer)
{ AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("Begin")); Super::PostLogin(NewPlayer); UNetDriver* NetDriver = GetNetDriver(); if (NetDriver) { if (NetDriver-&gt;ClientConnections.Num() == 0) { AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("No Client Connection")); } else { for (const auto&amp; Connection : NetDriver-&gt;ClientConnections) { AB_LOG(LogABNetwork, Log, TEXT("Client Connection: %s"), *Connection-&gt;GetName()); } } } else { AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("No NetDriver")); } AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("End"));
}
PlayerController PostNetInit()에서 서버 커넥션을 확인할 수 있었다.
(네트워크로부터 속성 값을 전달받은 상황이기 떄문에 PostNetInit에서 확인할 수 있었다.)void AABPlayerController::PostNetInit()
{ AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("Start")); Super::PostNetInit(); UNetDriver* NetDriver = GetNetDriver(); if (NetDriver) { AB_LOG(LogABNetwork, Log, TEXT("Server Connection: %s"), *NetDriver-&gt;ServerConnection-&gt;GetName()); } else { AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("No NetDriver")); } AB_LOG(LogABNetwork, Log, TEXT("%s"), TEXT("End"));
} 아래와 같은 작업을 거침 커넥션: 모든 데이터를 전달하는 네트워크 통로
패킷: 네트워크를 통해 전달되는 단위 데이터. 숫자 혹은 문자로 구성
채널: 구분된 데이터를 전달하는 논리적인 통로(음성, 액터 정보 etc ..)
번치: 채널의용도에 맞게 묶인 데이터 데이터 통신을 관리하기 위한 대표 액터 - 플레이어 컨트롤러 커넥션을 담당하는 대표 액터는 커넥션에 대한 오너십을 가진다고 표현 어떤 액터가 통신을 하기 위해서는 자신을 소유한 액터가 커넥션을 소유하고 있어야함.
일반적으로 플레이어 컨트롤러는 넷커넥션을 소유하고 있음.
넷커넥션도 플레이어 컨트롤러를 소유하고 있음.
AACtor::GetNetConnection()
APlayerController::GetNetConnection()
PostLogin이 시작된 후 빙의가 시작됨LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Start
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner: No Owner
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner : BP_ABPlayerController_C_0
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy End
LogABNetwork: [SERVER] AABPlayerController::OnPossess End
Player 액터는 슈퍼 호출 이전에는 오너가 설정되어 있지 않지만, 이후에 오너가 컨트롤러로 설정됨클라이언트를 추가하면LogABNetwork: [SERVER] AABGameMode::PreLogin Begin
LogABNetwork: [SERVER] AABGameMode::PreLogin End
LogABNetwork: [SERVER] AABGameMode::Login Begin
LogABNetwork: [SERVER] AABPlayerController::PostInitializeComponents Start
LogABNetwork: [SERVER] AABPlayerController::PostInitializeComponents End
LogABNetwork: [SERVER] AABGameMode::Login End
LogABNetwork: [SERVER] AABGameMode::PostLogin Begin
LogABNetwork: [SERVER] AABPlayerController::OnPossess Start
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Start
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner: No Owner
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy Owner : BP_ABPlayerController_C_1
LogABNetwork: [SERVER] AABCharacterPlayer::PossessedBy End
LogABNetwork: [SERVER] AABPlayerController::OnPossess End
LogABNetwork: [SERVER] AABGameMode::PostLogin Client Connection: IpConnection_1
LogABNetwork: [SERVER] AABGameMode::PostLogin End
LogABNetwork: [Client0] AABPlayerController::PostInitializeComponents Start
LogABNetwork: [Client0] AABPlayerController::PostInitializeComponents End
LogABNetwork: [Client0] AABPlayerController::PostNetInit Start
LogABNetwork: [Client0] AABPlayerController::PostNetInit Server Connection: IpConnection_0
LogABNetwork: [Client0] AABPlayerController::PostNetInit End
역시 오너가 설정되지만 서버에서만 오너가 설정 로그가 찍힘
클라이언트에서도 오너가 설정되어야 함 -&gt; PostNetInit()에서 오너가 설정될거라고 예상플레이어는 언제 오너가 바뀔까? 플레이어는 스스로 빙의를 하지 않음.
클라이언트에서는 빙의가 일어나지 않음. OnPossess가 호출되지 않음플레이어가 가지고 있는 오너의 값이 복제가 됨OnRep_Owner()에 의해서 오너값이 동기화가 됨플레이어가 복제될 때 클라이언트의 플레이어도 복제가 되겠지만, 서버의 플레이어도 복제가 되어야함 서버의 플레이어는 오너가 리플리케이션 되지 않는 상태로 초기화가 됨.하지만 클라이언트는 서버에서 생성된 플레이어 오너값이 복제가 되면서 OnRep_Owner()가 호출됨.]]></description><link>ue/network-프레임워크/03.-커넥션과-오너십.html</link><guid isPermaLink="false">UE/Network 프레임워크/03. 커넥션과 오너십.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[grey_to_color_using_ai]]></title><description><![CDATA[<img src="images/grey_to_color_using_ai.png" target="_self">]]></description><link>images/grey_to_color_using_ai.html</link><guid isPermaLink="false">images/grey_to_color_using_ai.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/grey_to_color_using_ai.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/grey_to_color_using_ai.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rgb_cmy_conversion]]></title><description><![CDATA[<img src="images/rgb_cmy_conversion.png" target="_self">]]></description><link>images/rgb_cmy_conversion.html</link><guid isPermaLink="false">images/rgb_cmy_conversion.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/rgb_cmy_conversion.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rgb_cmy_conversion.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rgb_color_model]]></title><description><![CDATA[<img src="images/rgb_color_model.png" target="_self">]]></description><link>images/rgb_color_model.html</link><guid isPermaLink="false">images/rgb_color_model.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/rgb_color_model.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/rgb_color_model.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[color_vs_grayscale]]></title><description><![CDATA[<img src="images/color_vs_grayscale.png" target="_self">]]></description><link>images/color_vs_grayscale.html</link><guid isPermaLink="false">images/color_vs_grayscale.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/color_vs_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/color_vs_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[color_image]]></title><description><![CDATA[<img src="images/color_image.png" target="_self">]]></description><link>images/color_image.html</link><guid isPermaLink="false">images/color_image.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/color_image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/color_image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bw_grayscale]]></title><description><![CDATA[<img src="images/bw_grayscale.png" target="_self">]]></description><link>images/bw_grayscale.html</link><guid isPermaLink="false">images/bw_grayscale.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/bw_grayscale.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bw_grayscale.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cmy_model]]></title><description><![CDATA[<img src="images/cmy_model.png" target="_self">]]></description><link>images/cmy_model.html</link><guid isPermaLink="false">images/cmy_model.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/cmy_model.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cmy_model.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3colorchannel]]></title><description><![CDATA[<img src="images/3colorchannel.png" target="_self">]]></description><link>images/3colorchannel.html</link><guid isPermaLink="false">images/3colorchannel.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/3colorchannel.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/3colorchannel.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[UGameplayStatics]]></title><description><![CDATA[UGameplayStatics는 Unreal Engine에서 제공하는 유틸리티 클래스로, 게임플레이와 관련된 다양한 정적(static) 함수들을 포함하고 있습니다. 이 클래스는 게임 개발 시 자주 사용되는 여러 기능들을 쉽게 접근할 수 있게 해줍니다. 주요 기능들은 다음과 같습니다:
게임 관리: GetGameMode, GetGameState, GetGameInstance 등을 통해 현재 게임의 주요 객체들에 접근
OpenLevel을 통해 새로운 레벨 로드 플레이어 관리: GetPlayerController, GetPlayerCharacter, GetPlayerPawn 등을 통해 플레이어 관련 객체에 접근
CreatePlayer를 통해 새로운 플레이어 생성 액터 관리: SpawnActor를 통해 새로운 액터 스폰
GetAllActorsOfClass를 통해 특정 클래스의 모든 액터 찾기 사운드 및 오디오: PlaySound2D, PlayDialogueAtLocation 등을 통해 사운드 재생 시간 관리: GetTimeSeconds, GetRealTimeSeconds 등을 통해 게임 시간 정보 얻기 저장 및 로드: SaveGameToSlot, LoadGameFromSlot 등을 통해 게임 저장 및 로드 물리 및 추적: LineTraceSingleByChannel 등을 통해 물리적 충돌 검사 UI 및 HUD: GetPlayerCameraManager를 통해 카메라 관리자에 접근
ProjectWorldToScreen을 통해 3D 위치를 2D 스크린 좌표로 변환 디버깅: PrintString을 통해 화면에 디버그 메시지 출력 이러한 기능들을 통해 UGameplayStatics는 게임 개발 과정에서 자주 필요한 작업들을 편리하게 수행할 수 있게 해줍니다. 특히 이 클래스의 함수들은 대부분 정적이므로, 객체를 생성하지 않고도 직접 호출할 수 있어 사용이 간편합니다.]]></description><link>ue/ugameplaystatics.html</link><guid isPermaLink="false">UE/UGameplayStatics.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[UMG 클래스에 Delegate 추가하기]]></title><description><![CDATA[
목표: UMultiLineEditableTextBox에 FOnFocusReceviced와 FOnFocusLost를 구현하기
UMultiLineEditableTextBox은 SMultiLineEditableTextBox를 래핑하고 있다. SMultiLineEditableTextBox는 SMultiLineEditableText를 내부적으로 사용하고 있다. 이벤트 전파 체인 이해 따라서 SMultiLineEditableText - &gt; SMultiLineEditableTextBox -&gt; UMultiLineEditableTextBox 체인을 따라 포커스 이벤트가 전파된다. 각 단계에서 처리하고 상위 레벨로 전달함. SMultiLineEditableText 수정 실제 텍스트 편집 기능 담당
포커스 이벤트가 발생하는 가장 하위 레벨
Slate Event 추가
OnFocusReceived와, OnFocusLost 델리게이트를 추가 (.h에)
cpp에서 construct()에서 값 할당 OnFocusReceivedDelegate = InArgs._OnFocusReceivedDelegate;
OnFocusLostDelegate = InArgs._OnFocusLostDelegate; SWidget Interface의 OnFocusReceived, OnFocusLost 오버라이딩 후에 그곳에서 이벤트 Execute 하기 virtual FReply OnFocusReceived(const FGeometry&amp; MyGeometry, const FFocusEvent&amp; InFocusEvent) override;
virtual void OnFocusLost(const FFocusEvent&amp; InFocusEvent) override; SMultiLineEditableTextBox 수정 SMultiLineEditableText를 포함하는 컨테이너 역할
SMultiLineEditableText의 포커스 이벤트를 받아 상위로 전달
UMultiLineEditableTextBox와 직접 연결되는 Slate 레벨의 위젯 UMultiLineEditableTextBox 수정 UMG 레벨의 위젯으로 BP에서 사용 가능
SMultiLineEditableTextBox의 포커스 이벤트를 받아 BP 이벤트로 변환 캡슐화와 책임 분리: 각 레벨의 위젯이 자신의 역할에 맞는 기능만 담당합니다. SMultiLineEditableText는 실제 편집 기능을, SMultiLineEditableTextBox는 컨테이너 역할을, UMultiLineEditableTextBox는 UMG 연동을 담당 유연성: 각 레벨에서 포커스 이벤트를 처리할 수 있어, 필요에 따라 다양한 방식으로 대응할 수 있음 일관성: 언리얼 엔진의 기존 위젯 구조와 일관성을 유지 가능. 다른 위젯들도 비슷한 구조로 이벤트를 처리. 확장성: 나중에 추가적인 기능이나 이벤트가 필요할 때 각 레벨에서 쉽게 확장할 수 있음. 블루프린트 지원: UMultiLineEditableTextBox에서 UPROPERTY와 UFUNCTION을 사용하여 블루프린트에서도 이 이벤트를 쉽게 사용할 수 있음. ]]></description><link>ue/umg-클래스에-delegate-추가하기.html</link><guid isPermaLink="false">UE/UMG 클래스에 Delegate 추가하기.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[datahandle_row_result]]></title><description><![CDATA[<img src="images/datahandle_row_result.png" target="_self">]]></description><link>images/datahandle_row_result.html</link><guid isPermaLink="false">images/datahandle_row_result.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/datahandle_row_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/datahandle_row_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[usermode_kernalmode]]></title><description><![CDATA[<img src="images/usermode_kernalmode.png" target="_self">]]></description><link>images/usermode_kernalmode.html</link><guid isPermaLink="false">images/usermode_kernalmode.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/usermode_kernalmode.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/usermode_kernalmode.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[packet]]></title><description><![CDATA[<img src="images/packet.png" target="_self">]]></description><link>images/packet.html</link><guid isPermaLink="false">images/packet.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/packet.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/packet.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[data_transfer_struct]]></title><description><![CDATA[<img src="images/data_transfer_struct.png" target="_self">]]></description><link>images/data_transfer_struct.html</link><guid isPermaLink="false">images/data_transfer_struct.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/data_transfer_struct.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/data_transfer_struct.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02. L2]]></title><description><![CDATA[NIC + (L2) Frame + LAN card + MACNIC = Network Interface Card .
랜(LAN (Local Area Network))카드랑 같음.
NIC은 HW이면 MAC주소를 갖는다. MAC주소는 NIC의 식별자임.Packet: L2 수준에서 언급하는 인터넷에서의 단위
L2 수준의 데이터 단위는 프레임L2 Acess Switch라고 불림
End - point와 직접 연결되는 스위치
MAC 주소를 근거로 스위칭
랜 케이블이 연결되고 정상 작동한다(녹색불) - Link up
랜 케이블이 연결이 빠졌다 - Link down호스트에 랜 케이블을 꽂았는데 상위 L3로 나아가는 것 - 업 링크
쉽게 생각하면 L2 Access 스위치를 위한 스위치
VLAN(Virtual LAN) 기능 제공
Unicast는 하나에 알리는 것 -&gt; 효율 높
Broadcast는 전체에 알리는 것 -&gt; 효율 떨어짐Broadcast의 주소라는 특별한 주소가 존재함 (MAC, IP 둘다 존재)MAC은 48Bit로 이루어져있는데, 모든 비트가 1이면 그게 바로 MAC의 브로드캐스트 주소임
FF:FF:FF:FF:FF:FFL2 수준에서의 데이터 단위가 프레임이라고 했는데 프레임에는 헤더가 있음
헤더에는 주소 두개가 있음 출발지, 목적지만약 목적지가 FF:FF:FF:FF:FF:FF다? 그럼 브로드캐스팅 한다는거겠지?브로드캐스팅은 매우 값 비싼 행동임 일단 한 호스트가 브로드캐스팅이 되면 브로드캐스팅 끝날 때까지 통신을 못함 -&gt; 그러니까 브로드캐스팅은 최소화 해야함예시)
L브로드캐스팅의 범위를 축소하면 됨
브로드 캐스팅 범위는 IP 주소상에서 어떤 레인지로 제한
정확한 개념은 아니지만 LAN은 물리적으로 설명 가능 (랜 카드, 무선신호 등) L2까지 커버할 수 있음WAN은 주로 인터넷인데 이것들부터는 실체가 존재하지 않는 Logical(virtual)임 L3부터는 소프트웨어 영역임]]></description><link>network/02.-l2.html</link><guid isPermaLink="false">Network/02. L2.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[03. L3]]></title><description><![CDATA[
Host의 식별자
32bit 주소체계
ex) 192.168.0.10 ( 8bit * 4 = 32bit) 앞 24 bit는 Network ID
뒤 8 bit는 Host ID Packet 이라고하면 L3 IP Packet을 떠올리자.
Header와 Payload (Header에는 출발지(src) 목적지(dst) 정보가 있음)로 구성
Header + Payload 의 최대 크기 = MTU MTU는 보통 1500byte임 마트료시카 인형을 떠올리자
L2 Frame은 = Header + Payload
L2의 Payload에 L3 Packet(Header + Payload)가 있음
L3의 Payload에 L4의 Header + Payload가 있겠지?
]]></description><link>network/03.-l3.html</link><guid isPermaLink="false">Network/03. L3.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[04. 패킷의 생성과 전달]]></title><description><![CDATA[<img alt="packet.png" src="images/packet.png" target="_self">상황: 철수가 영희에게 책을 택배로 전달하기 원함.
철수, 영희: Process
책: Data
택배: Packet
택배 기사: Gateway
송장: Packet Header src: IPv4
dst: IPv4
이름: 영희 (port) 집: Host
]]></description><link>network/04.-패킷의-생성과-전달.html</link><guid isPermaLink="false">Network/04. 패킷의 생성과 전달.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/packet.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/packet.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. 계층별 데이터 단위]]></title><description><![CDATA[User Mode
Process: 크롬 같은 데이터를 Write, Read함
Socket: 유저 모드에서 TCP에 W/R 하는 인터페이스 (파일) 데이터 덩어리 (Stream) 관리함 Kernel mode (OS) TCP 데이터 단위: Segment
데이터 한번에 받는 최대치: MSS (Maximum Segment Size)
Stream을 분할해서 Segment로 만듬 (Segmentation) IP 데이터 단위: Packet
데이터 한번에 받는 최대치: MTU (보통 1500bytes) L2 (Driver) 데이터 단위: Frame ]]></description><link>network/05.-계층별-데이터-단위.html</link><guid isPermaLink="false">Network/05. 계층별 데이터 단위.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[06. TCP IP 송수신 구조]]></title><description><![CDATA[<img alt="data_transfer_struct.png" src="images/data_transfer_struct.png" target="_self">A.bmp 파일을 서버에서 다운로드 받는 상황을 가정 서버 사이드 Process에서 HDD / SDD에 있는 A.bmp를 Copy 함 -&gt; Process의 버퍼 위에 올라감 Process는 이를 Socket을 이용해서 I/O Buffer에 Copy 함. (Send) 이때의 데이터 덩어리를 Stream 이라고함 Stream을 분해해서 Segment로 만듦 Sement를 Packet으로 만듦 (Encapsulation) Packet을 Frame 만든 (Encapsulation) 후에 전송 시작 Frame은 수시로 바뀜 (내용물인 Packet은 유지됨) 클라이언트 사이드에서 L2 단계에서 Frame으로 전달 받음 Decapsulation -&gt; Packet을 얻음 Decapsulation -&gt; Segment을 얻음 L4 TCP (Network) 단계에서 Segment를 Stream으로 변환 후에, 이를 I/O 버퍼에 채움 애플리케이션은 I/O buffer에 있는 데이터 덩어리를 Read(Receive)함. 이렇게 데이터를 송수신 하다가, 서버는 클라이언트가 데이터를 잘 받았는지 기다리기 때문에
서버는 어느 순간 데이터를 보내지 않고 Acknowledgement를 기다림 (wait for ACK)클라이언트가 Server에 ACK# (number) + 여유 버퍼 (window size) 보냄(데이터를 잘 받았으니 다음 거 보내달라는 요청) 그러면 서버사이드는 다시 미리 준비된 패킷을 클라이언트에게 보냄.이러한 순서를 반복함.
Loss - 데이터 유실 (Network 이슈)
Re-transmission -&gt; ACK 중복 (네트워크 or 엔드포인트 이슈)
Out of order - 순서가 이상함 Ex. 1 -&gt; 2 -&gt; 4 -&gt; 3 (보통 네트워크 이슈)
Zero Window - I/O 버퍼 여유 공간 없음 (엔드포인트 이슈)
TCP 보고 한번 더 보자]]></description><link>network/06.-tcp-ip-송수신-구조.html</link><guid isPermaLink="false">Network/06. TCP IP 송수신 구조.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/data_transfer_struct.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/data_transfer_struct.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bpgi_onbeginplay]]></title><description><![CDATA[<img src="images/bpgi_onbeginplay.png" target="_self">]]></description><link>images/bpgi_onbeginplay.html</link><guid isPermaLink="false">images/bpgi_onbeginplay.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/bpgi_onbeginplay.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bpgi_onbeginplay.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[wbp_ui_transition]]></title><description><![CDATA[<img src="images/wbp_ui_transition.png" target="_self">]]></description><link>images/wbp_ui_transition.html</link><guid isPermaLink="false">images/wbp_ui_transition.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/wbp_ui_transition.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/wbp_ui_transition.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01. Network]]></title><description><![CDATA[L7 - Http
L6 - 안중요
L5 - SSL (TLS)
L4 - TCP / UDP
L3 - 인터넷
L2 - 이더넷
L1 - X 물리적인 영역MAC: L2 계층 (이더넷)의 식별자 - 즉 랜카드(NIC)의 식별자IP주소: L3 계층 (인터넷)의 식별자 - 즉 호스트의 식별자Port 번호: 관점에 따라 식별할 수 있음 L2 계층: 인터페이스 식별자 L3, L4: Service 식별자 (네트워크 수준)
* 엔드포인트: Process 식별자정의: 네트워크에 연결된 컴퓨터Host를 지칭할 때 둘로 나눔 Switch: Network 그 자체를 이루는 Host (인프라) Router
IPS .. End-Point: 인프라를 써먹는 이용 주체 클라이언트
서버
Peer 비유 패킷: 자동차
네트워크: 고속도로망
스위치(라우터): 교차로
인터페이스를 선택한다 (스위칭) -&gt; 교차로에서 경로 선택
이정표: 라우팅테이블 용어가 아래처럼 만들어짐
Mac 주소로 스위칭한다 -&gt; L2 스위치
Http 정보로 스위치한다 -&gt; L7 스위치비용이 낮은쪽으로 패킷이 이동함.
비용은 Matric이라 함]]></description><link>network/01.-network.html</link><guid isPermaLink="false">Network/01. Network.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[Common_ui_plugin]]></title><description><![CDATA[<img src="images/common_ui_plugin.png" target="_self">]]></description><link>images/common_ui_plugin.html</link><guid isPermaLink="false">images/Common_ui_plugin.png</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate><enclosure url="images/common_ui_plugin.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/common_ui_plugin.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[UI 애니메이션]]></title><description><![CDATA[언리얼엔진은 UMG에서 각 UI Component에 대해서 애니메이션을 설정할 수 있음UI Component의 종류에 따라 제공하는 애니메이션이 다름.Border의 경우 Content Color and Opacity와 Transform 등 같은 요소 애니메이션을 제공함.Image 같은 경우는 Brush.Brush.Material와 같은 머터리얼을 이용한 애니메이션을 제공함.머터리얼을 이용하면 단순한 색상이나 이미지 이상의 복잡한 시각 효과를 UI 요소에 적용할 수 있음.머터리얼을 이용한 애니메이션 예시
동적인 색상 변화
텍스처 블렌딩
애니메이션 효과
특수 셰이더 효과
UI 전환을 만들수도 있음.
페이드 인/아웃 효과
디졸브 전환
색상 변화를 통한 상태 표시 Blend Type은 머티리얼이 다른 머티리얼이나 배경과 어떻게 상호작용 하는지를 정의함
Blend Type은 전환효과의 시각적 특성에 큰 영향을 줌.
세가지 타입이 존재 Additive: 머티리얼의 색상 값을 기존 배경에 더합니다.
주로 밝은 효과나 빛나는 요소를 추가할 때 사용
글로우 효과나 하이라이트 애니메이션에 적합
Ex. 버튼에 마우스를 올렸을 때 발생하는 글로우 효과 Additive from Base: 기본 색상(Base Color)을 시작점으로 사용
머티리얼의 색상이 기본 색상에서 시작하여 추가되는 방식으로 블렌딩
기존 UI 요소에 점진적으로 밝아지는 효과를 줄 때 유용
Ex. UI 패널이 점점 밝아지는 강조 효과 Absolute: 머티리얼의 색상을 있는 그대로 표시
배경이나 다른 요소와의 블렌딩 없이 머티리얼의 색상이 그대로 적용
완전히 불투명한 UI 요소나 배경을 덮는 전체 화면 효과에 사용
Ex. 전체 화면 페이드 인/아웃 전환 효과 두 키프레임 사이의 값을 어떻게 계산할지 결정. 총 세가지 타입. Linear: 선형 보간
Constant: 다음 키 프레임까지 값 유지
Cubic: 부드러운 곡선 사용 즉 Linear, Constant인 경우에는 Tangent가 필요 없음. Cubic인 경우 부드러운 곡선 보간을 한다는 것인데 부드러운 곡선을 어떻게 제어하냐 그 방식이 바로 Tangent임
키프레임 사이의 Interpolation 방식을 결정
Interpolation(보간)이란? 데이터 지점들 사이의 새로운 데이터 지점을 구하는 방법 다음과 같은 옵션이 존재 (Smart) Auto: 시스템이 자동으로 가장 적절한 탄젠트를 계산
부드러운 애니메이션에 적합하지만, 세밀한 제어는 어려움 Linear: 키프레임 사이를 직선으로 연결
움직임이 일정하고 기계적인 느낌을 줌
예시 UI 요소가 1초 동안 100%에서 200%로 커지는 애니메이션
Linear Tangent: 0.5초 지점에서 정확히 150% 크기가 됨 Constant: 키프레임 사이에 변화가 없음. 다음 키프레임에서 갑자기 변함
순간적인 변화나 디지털 효과에 유용 User: 사용자가 직접 탄젠트를 조절할 수 있음
가장 세밀한 제어가 가능하지만, 설정에 시간이 걸림 Break: 입력(In)과 출력(Out) 탄젠트를 독립적으로 조절 가능
복잡한 움직임을 만들 때 유용함 양수 값: 커브가 키프레임에서 위로 올라감
음수 값: 커브가 키프레임에서 아래로 내려감
0: 커브가 키프레임에서 평평해짐
값의 크기에 따른 영향: 높은 값 급격한 변화
애니메이션이 빠르게 시작하거나 끝남 낮은 값 부드러운 변화
애니메이션이 천천히 시작하거나 끝남
느린 가속 또는 감속 효과 Arrive Tangent 키프레임에 도착할 때의 탄젠트 값 Leave Tangent 키프레임에서 탈출할 때의 탄젠트 값 ]]></description><link>ue/ui-애니메이션.html</link><guid isPermaLink="false">UE/UI 애니메이션.md</guid><pubDate>Sun, 25 Aug 2024 07:41:57 GMT</pubDate></item><item><title><![CDATA[inc_support]]></title><description><![CDATA[<img src="images/inc_support.png" target="_self">]]></description><link>images/inc_support.html</link><guid isPermaLink="false">images/inc_support.png</guid><pubDate>Thu, 01 Aug 2024 11:20:21 GMT</pubDate><enclosure url="images/inc_support.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/inc_support.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[whoami]]></title><description><![CDATA[<img src="images/whoami.png" target="_self">]]></description><link>images/whoami.html</link><guid isPermaLink="false">images/whoami.png</guid><pubDate>Thu, 01 Aug 2024 11:20:21 GMT</pubDate><enclosure url="images/whoami.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/whoami.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이분탐색 & 파라메트릭 서치]]></title><description><![CDATA[이분 탐색(Binary Search)은 정렬된 배열에서 특정 값을 찾는 효율적인 알고리즘
시간 복잡도는 O(log n)으로, 선형 검색보다 훨씬 빠릅니다.이분 탐색의 기본 원리는 다음과 같습니다:
배열의 중간 원소를 선택
중간 원소와 찾고자 하는 값을 비교
찾고자 하는 값이 중간 원소보다 작으면 왼쪽 부분 배열을 탐색하고, 크면 오른쪽 부분 배열을 탐색
찾고자 하는 값을 찾을 때까지 또는 더 이상 탐색할 수 없을 때까지 이 과정을 반복
#include &lt;iostream&gt;
#include &lt;vector&gt; int binarySearch(const std::vector&lt;int&gt;&amp; arr, int target) { int left = 0; int right = arr.size() - 1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; // 타겟을 찾았을 때 인덱스 반환 } else if (arr[mid] &lt; target) { left = mid + 1; // 오른쪽 부분 배열 탐색 } else { right = mid - 1; // 왼쪽 부분 배열 탐색 } } return -1; // 타겟을 찾지 못했을 때
} int main() { std::vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11, 13, 15}; int target = 7; int result = binarySearch(arr, target); if (result != -1) { std::cout &lt;&lt; "타겟 " &lt;&lt; target &lt;&lt; "은 인덱스 " &lt;&lt; result &lt;&lt; "에 있습니다." &lt;&lt; std::endl; } else { std::cout &lt;&lt; "타겟 " &lt;&lt; target &lt;&lt; "을 찾을 수 없습니다." &lt;&lt; std::endl; } return 0;
}
파라메트릭 서치(Parametric Search)는 최적화 문제를 해결하는 알고리즘 기법입니다. 주로 이분 탐색(Binary Search)을 응용하여 연속적인 값에 대한 결정 문제를 해결하는 데 사용됩니다.파라메트릭 서치의 주요 특징:
최적화 문제를 결정 문제로 변환: "최댓값을 찾아라" 같은 최적화 문제를 "이 값이 가능한가?" 같은 결정 문제로 바꿉니다.
이분 탐색 활용: 가능한 해의 범위를 이분 탐색으로 좁혀가며 최적해를 찾습니다.
연속적인 값에 적용: 정수뿐만 아니라 실수 값에 대해서도 사용할 수 있습니다.
효율성: O(log N) 시간 복잡도로 최적해를 찾을 수 있습니다.
파라메트릭 서치의 일반적인 절차:
문제의 답이 될 수 있는 범위를 정합니다.
그 범위의 중간값에 대해 결정 문제를 해결합니다.
결과에 따라 탐색 범위를 반으로 줄입니다.
원하는 정확도에 도달할 때까지 2-3 과정을 반복합니다.
파라메트릭 서치는 다양한 최적화 문제에 적용할 수 있습니다. 예를 들어, 특정 조건을 만족하는 최대 또는 최소값을 찾는 문제, 이진 탐색으로 해결할 수 있는 결정 문제 등에 활용됩니다.]]></description><link>algorithm/study/이분탐색-&amp;-파라메트릭-서치.html</link><guid isPermaLink="false">Algorithm/Study/이분탐색 &amp; 파라메트릭 서치.md</guid><pubDate>Mon, 29 Jul 2024 11:50:10 GMT</pubDate></item><item><title><![CDATA[누적합 알고리즘]]></title><description><![CDATA[누적합(prefix sum) 알고리즘은 배열의 부분합을 빠르게 계산하는 데 사용되는 기법
주어진 배열의 각 위치까지의 원소들의 합을 미리 계산해 놓는 방식
원본 배열: A[1], A[2], ..., A[n]
누적합 배열: S[i] = A[1] + A[2] + ... + A[i]
시간 복잡도 전처리: O(n)
구간 합 쿼리: O(1) 특정 구간 [L, R]의 합을 S[R] - S[L-1]로 O(1) 시간에 계산 가능
]]></description><link>algorithm/study/누적합-알고리즘.html</link><guid isPermaLink="false">Algorithm/Study/누적합 알고리즘.md</guid><pubDate>Mon, 29 Jul 2024 11:29:59 GMT</pubDate></item><item><title><![CDATA[pso_data]]></title><description><![CDATA[<img src="images/pso_data.png" target="_self">]]></description><link>images/pso_data.html</link><guid isPermaLink="false">images/pso_data.png</guid><pubDate>Mon, 01 Jul 2024 12:57:39 GMT</pubDate><enclosure url="images/pso_data.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/pso_data.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[collectpso]]></title><description><![CDATA[<img src="images/collectpso.png" target="_self">]]></description><link>images/collectpso.html</link><guid isPermaLink="false">images/collectpso.png</guid><pubDate>Mon, 01 Jul 2024 12:57:39 GMT</pubDate><enclosure url="images/collectpso.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/collectpso.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS_2]]></title><description><![CDATA[<img src="images/bfs_2.png" target="_self">]]></description><link>images/bfs_2.html</link><guid isPermaLink="false">images/BFS_2.png</guid><pubDate>Sun, 30 Jun 2024 16:24:17 GMT</pubDate><enclosure url="images/bfs_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bfs_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS_1]]></title><description><![CDATA[<img src="images/bfs_1.png" target="_self">]]></description><link>images/bfs_1.html</link><guid isPermaLink="false">images/BFS_1.png</guid><pubDate>Sun, 30 Jun 2024 16:22:59 GMT</pubDate><enclosure url="images/bfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/bfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DFS_2]]></title><description><![CDATA[<img src="images/dfs_2.png" target="_self">]]></description><link>images/dfs_2.html</link><guid isPermaLink="false">images/DFS_2.png</guid><pubDate>Sun, 30 Jun 2024 16:08:37 GMT</pubDate><enclosure url="images/dfs_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/dfs_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DFS_1]]></title><description><![CDATA[<img src="images/dfs_1.png" target="_self">]]></description><link>images/dfs_1.html</link><guid isPermaLink="false">images/DFS_1.png</guid><pubDate>Sun, 30 Jun 2024 16:06:32 GMT</pubDate><enclosure url="images/dfs_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/dfs_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[subset_graph]]></title><description><![CDATA[<img src="images/subset_graph.png" target="_self">]]></description><link>images/subset_graph.html</link><guid isPermaLink="false">images/subset_graph.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/subset_graph.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/subset_graph.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_4]]></title><description><![CDATA[<img src="images/greedy_4.png" target="_self">]]></description><link>images/greedy_4.html</link><guid isPermaLink="false">images/greedy_4.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_3]]></title><description><![CDATA[<img src="images/greedy_3.png" target="_self">]]></description><link>images/greedy_3.html</link><guid isPermaLink="false">images/greedy_3.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_2]]></title><description><![CDATA[<img src="images/greedy_2.png" target="_self">]]></description><link>images/greedy_2.html</link><guid isPermaLink="false">images/greedy_2.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[greedy_1]]></title><description><![CDATA[<img src="images/greedy_1.png" target="_self">]]></description><link>images/greedy_1.html</link><guid isPermaLink="false">images/greedy_1.png</guid><pubDate>Mon, 24 Jun 2024 15:05:49 GMT</pubDate><enclosure url="images/greedy_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/greedy_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_9]]></title><description><![CDATA[<img src="images/cpp_9.png" target="_self">]]></description><link>images/cpp_9.html</link><guid isPermaLink="false">images/cpp_9.png</guid><pubDate>Sun, 16 Jun 2024 08:56:39 GMT</pubDate><enclosure url="images/cpp_9.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_9.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_8]]></title><description><![CDATA[<img src="images/cpp_8.png" target="_self">]]></description><link>images/cpp_8.html</link><guid isPermaLink="false">images/cpp_8.png</guid><pubDate>Sun, 16 Jun 2024 08:56:32 GMT</pubDate><enclosure url="images/cpp_8.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_8.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_7]]></title><description><![CDATA[<img src="images/cpp_7.png" target="_self">]]></description><link>images/cpp_7.html</link><guid isPermaLink="false">images/cpp_7.png</guid><pubDate>Sun, 16 Jun 2024 08:34:17 GMT</pubDate><enclosure url="images/cpp_7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_7.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_6]]></title><description><![CDATA[<img src="images/cpp_6.png" target="_self">]]></description><link>images/cpp_6.html</link><guid isPermaLink="false">images/cpp_6.png</guid><pubDate>Sun, 16 Jun 2024 07:00:10 GMT</pubDate><enclosure url="images/cpp_6.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_6.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_5]]></title><description><![CDATA[<img src="images/cpp_5.png" target="_self">]]></description><link>images/cpp_5.html</link><guid isPermaLink="false">images/cpp_5.png</guid><pubDate>Sun, 16 Jun 2024 06:44:01 GMT</pubDate><enclosure url="images/cpp_5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_5.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_4]]></title><description><![CDATA[<img src="images/cpp_4.png" target="_self">]]></description><link>images/cpp_4.html</link><guid isPermaLink="false">images/cpp_4.png</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate><enclosure url="images/cpp_4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_3]]></title><description><![CDATA[<img src="images/cpp_3.png" target="_self">]]></description><link>images/cpp_3.html</link><guid isPermaLink="false">images/cpp_3.png</guid><pubDate>Sun, 16 Jun 2024 06:40:40 GMT</pubDate><enclosure url="images/cpp_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Invalidation Box]]></title><description><![CDATA[Invalidation Box는 언리얼 엔진 4의 UMG(언리얼 모션 그래픽) UI 시스템에서 사용하는 위젯입니다. UI의 렌더링과 성능을 최적화하는 데 사용됩니다. Invalidation Box의 주요 기능은 자식 위젯의 렌더링을 캐시하는 것입니다. Invalidation Box 내부의 자식 위젯이 변경될 때, Invalidation Box는 전체 UI가 아닌 변경된 부분만 다시 렌더링하여 성능을 향상시킵니다.
성능 최적화: 자식 위젯의 렌더링을 캐시함으로써 드로우 콜 및 업데이트 수를 줄여 성능을 향상시킵니다. 특히 복잡한 UI에서 효과적입니다. 효율적인 리드로잉: 변경이 발생할 때 영향을 받은 부분만 다시 그리므로 불필요한 계산과 렌더링 과정을 최소화합니다. CPU 사용량 감소: 드로우 콜이 줄어들고 업데이트 빈도가 낮아져 CPU 사용량이 크게 감소하여 게임이나 애플리케이션이 더 부드럽게 실행됩니다. 복잡한 UI: 많은 요소가 자주 업데이트되는 UI의 경우, Invalidation Box로 감싸면 리렌더링 범위를 제한하여 성능 향상을 얻을 수 있습니다.
정적인 콘텐츠: 자주 변경되지 않는 UI 섹션에 Invalidation Box를 사용하면 초기 렌더링을 캐시하여 중복 렌더링 사이클을 방지할 수 있습니다.
동적인 요소: 동적인 요소에서도 콘텐츠의 작은 부분만 변경되는 경우, Invalidation Box가 필요한 부분만 업데이트하여 성능을 최적화할 수 있습니다. UI에 추가: UMG 위젯 팔레트에서 Invalidation Box를 드래그하여 UI 계층 구조에 추가합니다.
위젯 래핑: 최적화하려는 위젯을 Invalidation Box 내부에 배치합니다.
설정 조정: 필요에 따라 Invalidation Box 설정을 조정합니다. 기본적으로 자식 위젯을 올바르게 무효화하고 캐시하지만, 특정 성능 요구 사항에 따라 세부 조정이 가능합니다.
테스트 및 프로파일링: 언리얼 엔진의 프로파일링 도구를 사용하여 UI에서 성능 향상을 테스트하고 확인합니다. 필요에 따라 조정합니다.
]]></description><link>ue/invalidation-box.html</link><guid isPermaLink="false">UE/Invalidation Box.md</guid><pubDate>Wed, 12 Jun 2024 13:16:00 GMT</pubDate></item><item><title><![CDATA[cpp_2]]></title><description><![CDATA[<img src="images/cpp_2.png" target="_self">]]></description><link>images/cpp_2.html</link><guid isPermaLink="false">images/cpp_2.png</guid><pubDate>Sun, 09 Jun 2024 07:33:07 GMT</pubDate><enclosure url="images/cpp_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_1]]></title><description><![CDATA[<img src="images/cpp_1.png" target="_self">]]></description><link>images/cpp_1.html</link><guid isPermaLink="false">images/cpp_1.png</guid><pubDate>Sun, 09 Jun 2024 07:30:07 GMT</pubDate><enclosure url="images/cpp_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cpp_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bool vs uint8]]></title><description><![CDATA[Unreal Engine의 리플렉션 시스템에서 bool 대신 uint8을 사용하는 것은 주로 효율성과 일관성을 위한 선택입니다. 여기에는 몇 가지 상세한 이유가 있습니다:
메모리 효율성: C++에서 bool 타입은 일반적으로 1바이트를 차지합니다. 하지만, 이는 표준에 의해 보장되는 것은 아닙니다. 따라서, 다른 컴파일러나 플랫폼에서 bool의 크기가 달라질 수 있습니다. uint8은 명확하게 1바이트 크기를 갖기 때문에 플랫폼 간 일관성을 보장합니다. 이러한 일관성은 특히 크로스-플랫폼 게임 개발에 있어 중요합니다.
리플렉션과 직렬화: Unreal Engine의 리플렉션 시스템은 객체의 프로퍼티를 자동으로 식별하고 처리하는 데 사용됩니다. 이 시스템은 uint8과 같은 명확하게 정의된 크기를 가진 데이터 타입을 더 잘 처리할 수 있습니다. 이는 직렬화(데이터를 네트워크를 통해 전송하거나 디스크에 저장하는 과정)에서 중요합니다. bool이 다른 크기를 가질 수 있다면, 직렬화 과정에서 데이터의 정확한 해석이 어려울 수 있습니다.
비트 필드 사용: Unreal Engine은 종종 비트 필드를 사용하여 메모리 사용을 최적화합니다. uint8은 이러한 목적으로 사용하기에 적합한 타입입니다. 비트 필드에서 각 비트는 별도의 플래그나 설정을 나타낼 수 있으며, 이는 bool보다 메모리를 더 효율적으로 사용하는 방법입니다.
컴파일러 최적화: 일부 컴파일러는 bool 타입을 특별히 최적화하지 않을 수 있습니다. uint8은 보다 일반적인 데이터 타입이므로, 컴파일러에 따라 bool보다 더 효율적으로 처리될 수 있습니다.
확장성: bool은 단순히 참/거짓만을 나타내지만, uint8을 사용하면 추가적인 정보를 동일한 메모리 공간에 저장할 수 있습니다. 예를 들어, 여러 상태나 모드를 나타내는데 uint8이 더 유용할 수 있습니다.
네, C++ 표준에서 bool 타입의 정확한 크기는 명시하지 않고 있습니다. 표준은 단지 bool이 최소 1바이트를 차지해야 한다고 규정할 뿐입니다. 이는 bool이 다른 컴파일러나 아키텍처에서 다른 크기를 가질 수 있음을 의미합니다.예를 들어, 대부분의 현대 컴파일러와 플랫폼에서 bool은 1바이트를 차지합니다. 이는 bool을 효율적으로 처리하기 위한 최소 크기입니다. 그러나 특정 시스템이나 컴파일러 최적화 설정에 따라 bool이 더 큰 메모리 공간을 차지할 수도 있습니다. 예를 들면:
일부 오래된 또는 특수한 시스템: 이러한 시스템에서 bool은 1바이트보다 큰 크기를 가질 수 있습니다. 예를 들어, 일부 구형 컴퓨터 아키텍처에서는 1바이트보다 큰 단위로 메모리를 관리하는 경우가 있었습니다.
최적화 목적: 컴파일러는 때때로 메모리 접근 속도를 개선하기 위해 bool의 크기를 늘릴 수 있습니다. 예를 들어, 특정 프로세서 아키텍처에서는 더 큰 단위의 메모리 접근이 더 효율적일 수 있어, bool을 그 크기에 맞춰 조정할 수 있습니다.
특정 컴파일러 설정: 개발자가 특정 컴파일러 옵션을 사용해 bool의 크기를 조절할 수도 있습니다. 이런 경우는 드물지만, 성능 최적화나 특정 하드웨어 요구 사항에 의해 발생할 수 있습니다.
이러한 상황에서 bool의 크기가 1바이트가 아닐 수 있으므로, 크로스-플랫폼 애플리케이션 개발 시 bool의 크기에 대해 가정하지 않는 것이 중요합니다. 대신, 명시적인 크기를 갖는 타입(예: uint8_t)을 사용하는 것이 더 안전합니다.]]></description><link>ue/bool-vs-uint8.html</link><guid isPermaLink="false">UE/bool vs uint8.md</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate></item><item><title><![CDATA[enum vs enum class]]></title><description><![CDATA[C++에서 enum class와 enum은 둘 다 열거형 타입을 정의하는데 사용되지만, 몇 가지 중요한 차이점이 있습니다. 스코프(Scope) 및 이름 충돌: enum: 전통적인 enum은 스코프가 제한되지 않습니다. 이는 enum의 각 값이 열거형 이름 없이 직접 접근될 수 있다는 것을 의미합니다. 이것은 다른 enum과의 이름 충돌을 야기할 수 있습니다.
enum class: C++11에서 도입된 enum class는 강화된 스코프 규칙을 가집니다. 여기서 각 값은 열거형의 이름을 통해서만 접근할 수 있습니다. 이는 이름 충돌을 방지하고 코드의 명확성을 높입니다. 타입 안정성(Type Safety): enum: 기본적인 enum은 기본 정수 타입으로 암시적으로 변환될 수 있으며, 이는 타입 안전성 문제를 일으킬 수 있습니다.
enum class: enum class는 더 엄격한 타입 안전성을 제공합니다. 이는 enum class 값을 그들의 열거형 타입이 아닌 다른 타입으로 암시적으로 변환하는 것을 방지합니다. 기본 타입 지정: enum: 전통적인 enum은 컴파일러에 의해 결정되는 정수 타입을 사용합니다.
enum class: enum class에서는 개발자가 기본 타입을 명시적으로 지정할 수 있습니다 (예: enum class MyEnum : uint8_t { ... }). 포워딩(Forward Declaration): enum: 전통적인 enum은 크기가 고정되어 있지 않기 때문에, 포워드 선언이 제한적입니다.
enum class: enum class는 포워드 선언이 가능하며, 이는 열거형의 크기가 명시적으로 정의될 때 유용합니다. 결론적으로, enum class는 더 나은 스코프 관리, 타입 안전성 및 명확성을 제공하는 반면, 전통적인 enum은 구버전의 코드와의 호환성과 간결한 문법을 제공합니다.]]></description><link>ue/enum-vs-enum-class.html</link><guid isPermaLink="false">UE/enum vs enum class.md</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate></item><item><title><![CDATA[ble_configuration]]></title><description><![CDATA[<img src="images/ble_configuration.png" target="_self">]]></description><link>images/ble_configuration.html</link><guid isPermaLink="false">images/ble_configuration.png</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate><enclosure url="images/ble_configuration.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_configuration.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Mac에서 UE4 엔진 소스 빌드 시 유의사항]]></title><description><![CDATA[TL ;DR
언리얼 깃헙에서 브랜치 4.27plus를 받아서 빌드하기. 그리고 윈도우에서 remote 빌드 거는 게 더 합리적인 것 같음. 어차피 Objc 자동완성 사용 불가능UE4 4.27.2 버전을 사용해서 tag가 4.27.2 버전을 다운로드 받음<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release" target="_self">https://github.com/EpicGames/UnrealEngine/tree/4.27.2-release</a>
<br>
Install&nbsp;<a data-tooltip-position="top" aria-label="https://mac.github.com/" rel="noopener nofollow" class="external-link is-unresolved" href="https://mac.github.com/" target="_self">GitHub for Mac</a>&nbsp;then&nbsp;<a data-tooltip-position="top" aria-label="https://guides.github.com/activities/forking/" rel="noopener nofollow" class="external-link is-unresolved" href="https://guides.github.com/activities/forking/" target="_self">fork and clone our repository</a>. To use Git from the Terminal, see the&nbsp;<a data-tooltip-position="top" aria-label="https://help.github.com/articles/set-up-git/" rel="noopener nofollow" class="external-link is-unresolved" href="https://help.github.com/articles/set-up-git/" target="_self">Setting up Git</a>&nbsp;and&nbsp;<a data-tooltip-position="top" aria-label="https://help.github.com/articles/fork-a-repo/" rel="noopener nofollow" class="external-link is-unresolved" href="https://help.github.com/articles/fork-a-repo/" target="_self">Fork a Repo</a>&nbsp;articles. If you'd rather not use Git, use the 'Download ZIP' button on the right to get the source directly. <br>
Install the latest version of&nbsp;<a data-tooltip-position="top" aria-label="https://itunes.apple.com/us/app/xcode/id497799835" rel="noopener nofollow" class="external-link is-unresolved" href="https://itunes.apple.com/us/app/xcode/id497799835" target="_self">Xcode</a>. Open your source folder in Finder and double-click on&nbsp;Setup.command&nbsp;to download binary content for the engine. You can close the Terminal window afterwards.
If you downloaded the source as a .zip file, you may see a warning about it being from an unidentified developer (because .zip files on GitHub aren't digitally signed). To work around it, right-click on Setup.command, select Open, then click the Open button. In the same folder, double-click&nbsp;GenerateProjectFiles.command. It should take less than a minute to complete. Load the project into Xcode by double-clicking on the&nbsp;UE4.xcworkspace&nbsp;file. Select the&nbsp;ShaderCompileWorker&nbsp;for&nbsp;My Mac&nbsp;target in the title bar, then select the 'Product &gt; Build' menu item. When Xcode finishes building, do the same for the&nbsp;UE4&nbsp;for&nbsp;My Mac&nbsp;target. Compiling may take anywhere between 15 and 40 minutes, depending on your system specs. After compiling finishes, select the 'Product &gt; Run' menu item to load the editor. MacOS에서 언리얼 엔진 소스 설치시 (4.27.2) 버그Setup.command를 클릭하면 디펜던시 설정을 함 근데remote server error가 발생함.(403)Checking dependencies...
Updating dependencies: 0% (0/63485)...<br>
Failed to download '<a rel="noopener nofollow" class="external-link is-unresolved" href="http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94" target="_self">http://cdn.unrealengine.com/dependencies/UnrealEngine-12372779-e1515af26c634d2a8ade60b1afd1f065/01bb78539fc8dda386d45f9b5615f9a1e8ca5d94</a>': The remote server returned an error: (403) Forbidden. (WebException)<br>이 경우에 Engine/Build/Commit.gitdeps.xml을&nbsp;&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/EpicGames/UnrealEngine/tree/4.26/Engine/Build" target="_self">https://github.com/EpicGames/UnrealEngine/tree/4.26/Engine/Build</a>&nbsp;버전의 Engine/Build/Commit.gitdeps.xml으로 교체해주면 Setup.command를 해결할 수 있음.<br>참고:&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/carla-simulator/carla/issues/6486" target="_self">https://github.com/carla-simulator/carla/issues/6486</a><br><img alt="GitHub" src="https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">GitHub<br><a data-tooltip-position="top" aria-label="https://github.com/carla-simulator/carla/issues/6486" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/carla-simulator/carla/issues/6486" target="_self">Unreal Setup.bat (failed to download error) · Issue #6486 · carla-simulator/carla</a>&nbsp;(51kB)ShaderCompileWorker 빌드 시에 아래와 같은 버그가 발생<br><img alt="var_error.jpg" src="images/var_error.jpg" target="_self">Xcode가 빌드할 때 컴파일 옵션을 좀 더 타이트하게 잡아서 발생 하는 이슈
컴파일러에게 -Wno-unused-but-set-variable 설정을 하면 해결할 수 있음. UE4는 씨샾 코드를 빌드하기 때문에 { 언리얼 엔진 경로 }/Source/Programs/UnrealBuildTool/Platform/Mac/MacToolChain.cs에서GetCompileArguments_Global 함수를 찾아서 Result가 선언된 다음 라인에 코드를 작성하면 됨	Result += " -Wno-unused-but-set-variable";
여기까지 하면 ShaderCompileWorker 빌드 성공할 수 있음이제 UE4 빌드를 해야 하는데 info.plist가 없어서 빌드 실패하는 이슈가 발생이것은 UE4 Project - Build Setting에서 UE4GENERATE_INFOPLIST_FILE 옵션을 YES로 설정하기Engine/Plugins/Media/BinkMedia/Source/SDK/lib/BinkUnrealMac.a가 없다는 이슈가 발생/Users/choeseung-in/Downloads/UnrealEngine-4.27.2-release/clang:1:1: no such file or directory: '/Users/choeseung-in/Downloads/UnrealEngine-4.27.2-release/Engine/Plugins/Media/BinkMedia/Source/SDK/lib/BinkUnrealMac.a'이건 해당 경로에 static library가 없다는 이슈다.
Setup.command와 GenerateProjectFiles.command 과정은 디펜던시를 설정하고 다운로드 해와서 필요한 경로에 넣는 역할인데 이 부분이 잘못 되어서 그런 것으로 추정된다.
그래서 Issue를 찾아보던 중에 branch에 4.27 plus가 있는 것을 발견하였고 계속 유지보수가 이뤄지고 있어서 다시 엔진 소스를 받아서 실행하니 빌드를 할 수 있었다.]]></description><link>ue/mac에서-ue4-엔진-소스-빌드-시-유의사항.html</link><guid isPermaLink="false">UE/Mac에서 UE4 엔진 소스 빌드 시 유의사항.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://slack-imgs.com/?c=1&amp;o1=wi32.he32.si&amp;url=https%3A%2F%2Fa.slack-edge.com%2F80588%2Fimg%2Funfurl_icons%2Fgithub.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[glew32_install_error]]></title><description><![CDATA[<img src="images/glew32_install_error.png" target="_self">]]></description><link>images/glew32_install_error.html</link><guid isPermaLink="false">images/glew32_install_error.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/glew32_install_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/glew32_install_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[serial]]></title><description><![CDATA[<img src="images/serial.png" target="_self">]]></description><link>images/serial.html</link><guid isPermaLink="false">images/serial.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/serial.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/serial.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동기, 비동기]]></title><description><![CDATA[Concurrency allows us to execute different tasks at the same time, or it appears to us at the same time.
CPU는 Time Slicing과 Context Switching으로 Concurrency를 달성
CPU는 각 task가 처리되는 시간을 정확히 예상할 수 없음 그러므로, 하나씩 TimeSlicing과 Context Switching을 통해서 task를 처리함
즉 작업을 분산하자가 목표임iOS에서 Concurrency를 달성하는 법
Manual Thread Creation (직접 쓰레드 생성)
class Thread: NSObject { } // https://developer.apple.com/documentation/foundation/thread GCD ( Grand Central Dispatch) <a data-tooltip-position="top" aria-label="https://developer.apple.com/documentation/DISPATCH" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.apple.com/documentation/DISPATCH" target="_self">GCD</a>&nbsp;is a queue-based API that allows executing closures on worker's pools in the FIFO (First in first out) order.
FIFO Order로 Task를 수행함
추상화 → 쓰레드를 얼마나 사용하고 있는 지 같은 것들을 신경쓰지 않아도 됨 (세부구현요소 배제)
order와 manner로 Data Consistent를 달성할 수 있음. → Data Consistency를 저해하는 요소 - Deadlock, Race Conditon.
그러니까 iOS에서는 Queue에 잘 넣으면 쓰레드에 알아서 넣어줌. 언리얼에도 있을까? TGraph 같은 거 있던데
우리가 해야할 것은 Queue 잘 보내는 것(직접적으로 쓰레드를 관리하지 않음)
Serial Queue - one task at a time
<br><img alt="serial.png" src="images/serial.png" target="_self">
Concurrent Queue - multiple tasks at a time<br>
<img alt="concurrent.png" src="images/concurrent.png" target="_self"> Synchronous 다른 execution이 완료 되기전까지 현재 쓰레드를 Block 함. Asynchronous 현재 스레드를 Block 하지 않고, 다른 some task later, simultaneously하게 execution 함.
asynchronous를 사용하면 program이 즉시 block에서 빠져나감 Main Queue
따로 큐를 지정하지 않으면 Main Queue에서 돌아감
시리얼 큐임
task가 synchronous 하게 실행됨
UI를 update 하는 큐임 Single Serial Queue with Multiple Asynchronous Dispatch. 시리얼 큐안에서 async execution만 존재하면 serial Order를 따른다. Single Serial Queue with Multiple Asynchronous Dispatch &amp; Synchronous codes. 시리얼 큐이기 때문에 line by line으로 코드를 읽음
sync는 block 하고 async는 제어권을 넘겨줌 Single Concurrent Queue with Multiple Asynchronous Dispatch. 런할 때마다 바뀜. Single Concurrent Queue with Multiple Asynchronous and Synchronous Dispatch. 가장 헷갈리는 예임
모두 다 4개의 task를 concurrent 큐에다가 넣고, 두번째는 sync 나머지를 async일 때 3번째랑, 4번째는 무조건 두번째 코드가 다 끝난 이후에 나옴. 왜냐하면 첫번째 큐가 들어가고 탈출하고, 두번째 큐가 들어가는데 여기에서 블락됨 다만, concurrent 큐라서 두번째 task와 첫번째 task가 실행될 수 있음. 두번째 task가 끝나면 세,네번째 task 가능. a Serial Queue alongside a Concurrent Queue with Multiple Asynchronous Dispatch. 랜덤하게 나올 수 있으나 Serial 1, 2, 3의 순서는 지켜져야 한다.(연속은 안해도 됨) SerialQueue에서 sync와 async의 차이점 let queue = DispatchQueue(label: "com.example.serialQueue")
queue.async { print("Async task 1")
}
queue.async { print("Async task 2")
}
print("Outside of queue")
결과Async task 1
Outside of queue
Async task 2
let queue = DispatchQueue(label: "com.example.serialQueue")
queue.sync { print("Async task 1")
}
queue.sync { print("Async task 2")
}
print("Outside of queue")
Async task 1
Async task 2
Outside of queue
동기는 일의 제어권을 꽉 잡고 있음. (흔히 Block 한다고 함)
비동기는 일의 제어권을 넘겨줌동기와 비동기는 제어권을 넘겨주냐, 넘겨주지 않느냐로 판단하는 것
MainQueue에서 sync 사용금지
현재 큐에서 sync로 작업을 보내지 말자 DispatchQueue.global().async { DispatchQueue.global().sync { }
} // 오래 걸리는 함수
public func tiltShift(image: UIImage?) -&gt; UIImage? { guard let image = image else { return nil } sleep(1) let mask = topAndBottomGradient(size: image.size) return image.applyBlur(radius: 6, maskImage: mask) } func asyncTiltShift(_ inputImage: UIImage?, runQueue: DispatchQueue, completionQueue: DispatchQueue, completion: @escaping (UIImage?, Error?) -&gt; ()) { runQueue.async { var error: Error? error = .none let outputImage = tiltShift(image: inputImage) completionQueue.async { completion(outputImage, error) } }
} // 사용 예시 let imageNames = ["dark_road_small", "train_day", "train_dusk", "train_night"]
let images = imageNames.compactMap { UIImage(named: "\($0).jpg") } // 변형한 이미지 저장하기 위한 배열 생성 var tiltShiftedImages = [UIImage]() // 동시큐 만들기 let workerQueue = DispatchQueue(label: "com.inflearn.concurrent", attributes: .concurrent) let appendQueue = DispatchQueue(label: "com.inflearn.append.serial") for image in images { asyncTiltShift(image, runQueue: workerQueue, completionQueue: appendQueue) { image, error in guard let image = image else { return } tiltShiftedImages.append(image) } }
]]></description><link>ios/동기,-비동기.html</link><guid isPermaLink="false">iOS/동기, 비동기.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/serial.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/serial.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[concurrent]]></title><description><![CDATA[<img src="images/concurrent.png" target="_self">]]></description><link>images/concurrent.html</link><guid isPermaLink="false">images/concurrent.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/concurrent.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/concurrent.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Orientation]]></title><description><![CDATA[Project - Target - General - Deployment Info에서 iPhone Orientation을 체크 / 체크해제를 할 수 있다.이것을 체크 하게 되면 동일한 효과를 얻는다.
// AppDelegate.swift func application( _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow? ) -&gt; UIInterfaceOrientationMask { return // 체크한 항목들 } supportedInterfaceOrientations를 지정하면 아이폰에서 '자동 화면 회전'을 설정한 경우 아이폰을 어떻게 잡고 있느냐에 따라서 해당하는 InterfaceOrientation으로 화면이 회전 된다. LandscapeRight로 고정을 했는데 SFSafariViewController에서 애플로그인을 하고 돌아온 다음에 화면이 Portrait이 되는 경우가 있다고 함. AppDelegate에 접근해서 InterfaceOrientation을 LandscapeRight로 다시 변경하면 된다. // AppDelegate.swift
import UIKit
@main class AppDelegate: UIResponder, UIApplicationDelegate { @objc var allList: UIInterfaceOrientationMask = .portrait func application( _ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow? ) -&gt; UIInterfaceOrientationMask { return allList } } Swift private func rotate() { let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene (UIApplication.shared.delegate as! AppDelegate).allList = .landscapeRight if #available(iOS 16.0, *) { debugPrint("above 16.0") windowScene?.requestGeometryUpdate(.iOS(interfaceOrientations: .landscapeRight)) self.setNeedsUpdateOfSupportedInterfaceOrientations() } else { debugPrint("below 16.0") let value = UIDeviceOrientation.landscapeRight.rawValue UIDevice.current.setValue(value, forKey: "orientation") } }
Objective-C- (void)rotate:(UIButton *)button { AppDelegate *appDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate]; UIInterfaceOrientationMask e = UIInterfaceOrientationMaskLandscapeRight; appDelegate.allList = e; NSNumber *value = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeRight]; [[UIDevice currentDevice] setValue:value forKey:@"orientation"]; }
샘플 프로젝트에서 SFSafariViewController에서 돌아올 때 화면 전환이 되는 버그를 재현할 순 없었지만 화면 전환은 위의 코드를 사용 했을 때 쉽게 바꿀 수 있었다. 주의해야할 점은 AppDelegate에 있는 supportedInterfaceOrientationsFor를 먼저 바꿔주고 setValue를 하거나 화면 업데이트를 해줘야 한다는 점이다.그리고 추가적으로 UIInterfaceOrientation과 UIInterfaceOrientationMask 차이점이다.
UIInterfaceOrientation is Constants that specify the orientation of the app's user interface.
UIInterfaceOrientation는 enum value이고 App의 user interface라고 한다.
UIInterfaceOrientationMask is Constants that specify a view controller’s supported interface orientations.
UIInterfaceOrientationMask ViewController의 interface orientation이라고 한다.UIInterfaceOrientation은 처음 앱의 interface orientation이고 최상위 뷰컨트롤러인 UIWindowScene의 interface orientation이다. UIViewController에서 UIInterfaceOrientation인 interfaceOrientation은 deprecated여서 사용할 수 없고 아래처럼 windowScene에서 접근할 수 있다. read-only value라 바꿀 순 없다.let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene windowScene.interfaceOrientation 이러한 interfaceOrientation을 바꾸기 위해서 사용하는게 바로 UIInterfaceOrientationMask다.
UIInterfaceOrientationMask는 바꿀 방향을 표시하는 bitmask다. SDK에게 어떤 방향으로 바꿀거에요. 라고 알려줄 때 사용하는 프로퍼티다. 그리고 화면 전환을 하면 된다.여담으로 이건 버그인 것 같은데, AppDelegate에서 supportedInterfaceOrientationsFor에서 portrait를 제외하면 추후 화면전환을 사용할 수 없다. ]]></description><link>ios/orientation.html</link><guid isPermaLink="false">iOS/Orientation.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[allpublic]]></title><description><![CDATA[<img src="images/allpublic.png" target="_self">]]></description><link>images/allpublic.html</link><guid isPermaLink="false">images/allpublic.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/allpublic.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/allpublic.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[immutable_mutable]]></title><description><![CDATA[<img src="images/immutable_mutable.png" target="_self">]]></description><link>images/immutable_mutable.html</link><guid isPermaLink="false">images/immutable_mutable.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/immutable_mutable.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/immutable_mutable.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[removedinternal]]></title><description><![CDATA[<img src="images/removedinternal.png" target="_self">]]></description><link>images/removedinternal.html</link><guid isPermaLink="false">images/removedinternal.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/removedinternal.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/removedinternal.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Network Timeout UnitTest]]></title><description><![CDATA[서버 통신을 담당하는 NetworkManager에서 Timeout Error를 시뮬레이팅 하는 법은URLProtocol을 Confirm하고, Error를 Response로 넘겨주는 방식으로 처리하는 것이 간편
class TimeoutURLProtocol: URLProtocol { override class func canInit(with request: URLRequest) -&gt; Bool { return true } override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest { return request } override func startLoading() { // Introduce a delay (simulating a timeout) DispatchQueue.global().asyncAfter(deadline: .now() + 3.0) { // Respond with an error self.client?.urlProtocol(self, didFailWithError: NSError(domain: NSURLErrorDomain, code: NSURLErrorTimedOut, userInfo: nil)) self.client?.urlProtocolDidFinishLoading(self) } } override func stopLoading() { // Clean up or additional actions, if needed }
}
그런 다음에 test code 안에서, URLSessionConfiguration이 protocol을 컨펌함func testURLSessionTimeout() { let expectation = XCTestExpectation(description: "Time out expectation") let config = URLSessionConfiguration.ephemeral config.protocolClasses = [TimeoutURLProtocol.self] // Timeout Interval, 단위는 seconds config.timeoutIntervalForRequest = 3 let session = URLSession(configuration: config, delegate: nil, delegateQueue: nil) let task = session.dataTask(with: url) { data, response, error in if let error = error { // Time out error print("Error: \(error)") // Error 발생 기대 충족 expectation.fulfill() return } guard let data = data else { let noDataError = NSError() // No Data Error return } // Success, There is Data. print(data) } task.resume() wait(for: [expectation], timeout: 4) } 그러면 TimeoutURLProtocol, config.timeoutIntervalForRequest과 wait()을 통해서 타임아웃 에러를 시뮬레이팅할 수 있음.]]></description><link>ios/network-timeout-unittest.html</link><guid isPermaLink="false">iOS/Network Timeout UnitTest.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[Objective - C]]></title><description><![CDATA[#import &lt;Foundation/Foundation.h&gt; @interface Vehicle : NSObject { // Declare Member variable int wheels; int seats;
} - (int) wheels;
- (int) seats;
- (void) setWheels:(int) w; - (void) setSeats:(int) s; - (void) print; @end @implementation Vehicle - (int)wheels { return wheels
} - (int)seats { return seats
} - (void)setWheels:(int)w { wheels = w;
} - (void)setSeats:(int)s { seats = s;
} - (void)print { NSLog(@"Vehicle have %i wheels and %i seats.", wheels, seats);
} @end // 대괄호는 메세지를 구분해주는 기호
// [Receiver message] 형식 int main(int argc, const char * argv[]) { @autoreleasepool { // vehicle을 alloc 하고 init 하라 Vehicle* vehicle = [[Vehicle alloc] init]; [vehicle setWheels: 4]; [vehicle setSeats: 2]; [vehicle print]; NSLog(@"wheels: %i, seats: %i", [vehicle wheels], [vehicle seats]); } return 0; }
Objective-C 는 선언과 구현이 분리되어 있음@interface ~ @end는 선언부임
@implementation ~@end는 구현부임[ ] 대괄호는 message를 구분하는 기호로 주로 사용됨. [Receiver Message] 형식임. 그리고 멤버 메서드는 message의 일종임. getter setter를 이용할 때도 초기 버전에는 리시버 메세지 형식을 그대로 따라야 했으나, 지금은 Dot 접근도 가능함 getter 구현시에 관행적으로 get을 붙이지 않는다. getWheels(X) -&gt; wheels(O)
getter, setter를 매번 구현하는 것은 귀찮음. getter setter를 지우고 선언부 member method 영역에 @property로 선언하는 것으로 대체할 수 있음. 그리고 @property로 사용하면 멤버 변수 선언을 생략해도 됨만약, @property 선언만 하고 멤버변수를 선언하지 않았을 때 객체 내부에서 해당 변수를 사용하기 위해서는 _ 을 붙여줘야함. @property를 선언한 변수는 내부적으로 _\name 으로 선언되기 때문내부에서도 같은 이름을 사용하고 싶으면 @synthesize를 사용해야함.
@interface Vehicle : NSObject { // 생략 가능! // int wheels; // int seats; } @property int wheels;
@property int seats; @end @implementation Vehicle
@synthesize seats; - (void)print { NSLog(@"Vehicle have %i wheels and %i seats.", _wheels, seats);
} @end int main(int argc, const char * argv[]) { @autoreleasepool { // vehicle을 alloc 하고 init 하라 Vehicle* vehicle = [[Vehicle alloc] init]; [vehicle setWheels: 4]; [vehicle setSeats: 2]; vehicle.wheels = 4; vehicle.seats = 2; [vehicle print]; NSLog(@"wheels: %i, seats: %i", [vehicle wheels], [vehicle seats]); NSLog(@"wheels: %i, seats: %i", vehicle.wheels, vehicle.seats); } return 0; } 다른 언어와 다르게 함수를 선언할 때 Arguement를 나누는 기준이 콜론(:)이다.// 2개의 인자를 가진 함수
- (void) setWheels:(int)w Seats:(int)s; // 호출할 때 [vehicle setWheels:4 Seats:2]; if, else if, else, switch문 대부분의 언어와 똑같음.
for, while문도 마찬가지NSString과 NSMutableString이 있음. 둘 다 객체 타입NSString과 NSMutableString의 차이점은 자기 자신을 바꿀 수 있냐임.
NSString은 append, insert 같은 함수가 없음. 자신은 변화 불가능이니까String 초기화시 alloc과 init을 이용하고 @""를 이용해 값을 넣을 수 있음
보통 바로 NSString* varname = @""; 로 바로 초기화함.
int main(int argc, const char * argv[]) { @autoreleasepool { NSString* str = [[NSString alloc]init]; str = @"This is NSString"; NSString* str2 = [[NSString alloc]initWithString:@"This is NSString"]; NSLog(@"str: %@", str); NSLog(@"str: %@", str2); // immutable class - 자기 자신은 변화를 못하기 때문에 새로 할당해야함. NSString* result; // substringFromIndex result = [str substringFromIndex:6]; NSLog(@"result: %@", result); // substringToIndex result = [str substringToIndex:6]; NSLog(@"result: %@", result); // method chaining result = [[str substringToIndex:11 ] substringFromIndex:8]; NSLog(@"result: %@", result); //substringWithRange result = [[str substringWithRange:NSMakeRange(8, 3)] lowercaseString]; NSLog(@"result: %@", result); result = [[str substringWithRange:NSMakeRange(8, 3)] uppercaseString]; NSLog(@"result: %@", result); // NSMutableString - 자기 자신 수정 가능, 할당해서 사용해야함 string처럼 =@""로 불가 NSMutableString* mstr = [NSMutableString stringWithString:str]; NSLog(@"mstr: %@", mstr); [mstr appendString:@ " and NSMutableString"]; NSLog(@"mstr: %@", mstr); [mstr insertString:@"Mutable" atIndex:8]; NSLog(@"mstr: %@", mstr); } return 0; }
NSMutableString은 무조건 할당해서 사용해야한다. NSString처럼 =@""로 사용하면 아래처럼 경고를 주고 NSMutableString 메서드를 사용하게 되면 런타임에서 에러가 발생한다.
<img alt="immutable_mutable.png" src="images/immutable_mutable.png" target="_self">]]></description><link>ios/objective-c.html</link><guid isPermaLink="false">iOS/Objective - C.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/immutable_mutable.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/immutable_mutable.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Swift, Objective - C interoperability]]></title><description><![CDATA[Objective - C는 아직도 시장에서 꽤 큰 점유율을 가지고 있음
Swift와 C++의 interoperability 가능 (WWDC23 - Mix Swift and C++) 신기능이라 아직 레퍼가 부족?Swift 코드베이스에 Objc 쓰기 -&gt; Objective-C Bridging Header
Objc 코드베이스에 Swift 쓰기 -&gt; public과 open 키워드가 있는 객체들 자동으로 헤더로 생성framework를 개발할 때 공개해야할 API를 잘 설정해야함.Swift 코드 베이스에서 Objc를 사용할 것. 프레임워크 내부에서 ObjC API를 보고 사용할 수 있지만 이 프레임워크를 사용하는 외부는 Objc 코드를 볼 수 있음엄브렐라 헤더에 Objc 해더를 임포트하고 Build phrase에서 public으로 바꾸기그런 다음에 xcframework로 뽑기
## Framework 아카이브 - iphoneOS
xcodebuild archive -project ObjcIntoSwiftFramework.xcodeproj \
-scheme ObjcIntoSwiftFramework \
-sdk iphoneos \
-destination "generic/platform=iOS" \
-archivePath archives/ObjcIntoSwiftFramework-iOS.xcarchive ## Framework 아카이브 - iphone simulator
xcodebuild archive -project ObjcIntoSwiftFramework.xcodeproj \
-scheme ObjcIntoSwiftFramework \
-sdk iphonesimulator \
-destination "generic/platform=iOS Simulator" \
-archivePath archives/ObjcIntoSwiftFramework-iOS_Simulator.xcarchive ## xcframework 추출
xcodebuild -create-xcframework \
-archive archives/ObjcIntoSwiftFramework-iOS.xcarchive -framework ObjcIntoSwiftFramework.framework \
-archive archives/ObjcIntoSwiftFramework-iOS_Simulator.xcarchive -framework ObjcIntoSwiftFramework.framework \
-output xcframeworks/ObjcIntoSwiftFramework.xcframework
xcframework을 확인 해보면 헤더에 모든 헤더가 노출되어 있음<img alt="allpublic.png" src="images/allpublic.png" target="_self">이제 해야할 것은 xcframework에서 internal objective - c 헤더를 제거하는 것 이를 위해서엄블레라 헤더에서 Internal 주석 이하 모두 삭제xcframework 경로를 파라미터로 받는 스크립트를 실행해서 처리함#! /bin/sh -e # # removeInternalHeaders.sh # ## 1 XCFRAMEWORK_DIR=$1 INTERNAL_MARK="__INTERNAL__" ## 2 function removeInternalHeadersInUmbrellaHeader { local framework_name="$(basename $1 .framework)" local headers_dir="$1/Headers" local umbrella_header_file="$headers_dir/$framework_name.h" local internal_mark_found=false local internal_headers=() ## 2.1 while read -r line; do if $internal_mark_found; then if [[ $line == "#import"* ]]; then local filename=$(sed 's/.*\"\(.*\)\".*/\1/' &lt;&lt;&lt; $line) internal_headers[${#internal_headers[@]}]=$filename fi elif [[ $line == *$INTERNAL_MARK* ]]; then internal_mark_found=true fi done &lt; $umbrella_header_file ## 2.2 echo "${#internal_headers[@]} files will be removed" for filename in ${internal_headers[@]}; do local file="$headers_dir/$filename" if [ -f "$file" ]; then rm $file echo "Removed file: $file" else echo "Tried to remove file but it does not exist: $file" fi done ## 2.3 sed -i "" '/'$INTERNAL_MARK'/,$d' $umbrella_header_file } ## 3 for directory in ${XCFRAMEWORK_DIR}/**/*.framework; do [ -d "$directory" ] || continue removeInternalHeadersInUmbrellaHeader $directory done # $HOME = 내 Users Path
$ ./removeInternalHeaders.sh $HOME/Labs/ObjcIntoSwiftFramework/xcframeworks/ObjcIntoSwiftFramework.xcframework
결과<br><img alt="removedinternal.png" src="images/removedinternal.png" target="_self"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.fleksy.com/blog/developing-an-ios-framework-in-unison-with-swift-objective-c/" target="_self">https://www.fleksy.com/blog/developing-an-ios-framework-in-unison-with-swift-objective-c/</a>]]></description><link>ios/swift,-objective-c-interoperability.html</link><guid isPermaLink="false">iOS/Swift, Objective - C interoperability.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/allpublic.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/allpublic.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[framework_path]]></title><description><![CDATA[<img src="images/framework_path.png" target="_self">]]></description><link>images/framework_path.html</link><guid isPermaLink="false">images/framework_path.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/framework_path.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/framework_path.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hostapp_file]]></title><description><![CDATA[<img src="images/hostapp_file.png" target="_self">]]></description><link>images/hostapp_file.html</link><guid isPermaLink="false">images/hostapp_file.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/hostapp_file.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/hostapp_file.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[sandbox_error]]></title><description><![CDATA[<img src="images/sandbox_error.png" target="_self">]]></description><link>images/sandbox_error.html</link><guid isPermaLink="false">images/sandbox_error.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/sandbox_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/sandbox_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[simulator_device_error]]></title><description><![CDATA[<img src="images/simulator_device_error.png" target="_self">]]></description><link>images/simulator_device_error.html</link><guid isPermaLink="false">images/simulator_device_error.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/simulator_device_error.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/simulator_device_error.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fatframework_path]]></title><description><![CDATA[<img src="images/fatframework_path.png" target="_self">]]></description><link>images/fatframework_path.html</link><guid isPermaLink="false">images/fatframework_path.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/fatframework_path.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/fatframework_path.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[aggregate]]></title><description><![CDATA[<img src="images/aggregate.png" target="_self">]]></description><link>images/aggregate.html</link><guid isPermaLink="false">images/aggregate.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/aggregate.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/aggregate.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_4]]></title><description><![CDATA[<img src="images/slate_arcitecture_4.png" target="_self">]]></description><link>images/slate_arcitecture_4.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_4.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_OVERVIEW_1]]></title><description><![CDATA[<img src="images/slate_overview_1.png" target="_self">]]></description><link>images/slate_overview_1.html</link><guid isPermaLink="false">images/SLATE_OVERVIEW_1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_overview_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_overview_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_OVERVIEW_2]]></title><description><![CDATA[<img src="images/slate_overview_2.png" target="_self">]]></description><link>images/slate_overview_2.html</link><guid isPermaLink="false">images/SLATE_OVERVIEW_2.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_overview_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_overview_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_3]]></title><description><![CDATA[<img src="images/slate_arcitecture_3.png" target="_self">]]></description><link>images/slate_arcitecture_3.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_3.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_1]]></title><description><![CDATA[<img src="images/slate_arcitecture_1.png" target="_self">]]></description><link>images/slate_arcitecture_1.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SLATE_ARCITECTURE_2]]></title><description><![CDATA[<img src="images/slate_arcitecture_2.png" target="_self">]]></description><link>images/slate_arcitecture_2.html</link><guid isPermaLink="false">images/SLATE_ARCITECTURE_2.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_arcitecture_2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_arcitecture_2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slate Overview]]></title><description><![CDATA[Slate&nbsp;is a completely custom and platform agnostic user interface framework that is designed to make building the user interfaces for tools and applications such as Unreal Editor, or in-game user interfaces, fun and efficient. It combines a declarative syntax with the ability to easily design, lay out, and style components that allows for easily creating and iterating on UIs.The Slate UI solution makes it extremely easy to put together graphical user interfaces for tools and applications and iterate on them quickly.Slate의 선언적 구문을 사용하면 프로그래머가 간접 계층을 추가하지 않고도 UI 구축에 액세스할 수 있습니다. 새 위젯을 선언하고 생성하는 프로세스를 단순화하기 위해 완전한 매크로 세트가 제공됩니다.SLATE_BEGIN_ARGS( SSubMenuButton ) : _ShouldAppearHovered( false ) {} /** The label to display on the button */ SLATE_ATTRIBUTE( FString, Label ) /** Called when the button is clicked */ SLATE_EVENT( FOnClicked, OnClicked ) /** Content to put in the button */ SLATE_NAMED_SLOT( FArguments, FSimpleSlot, Content ) /** Whether or not the button should appear in the hovered state */ SLATE_ATTRIBUTE( bool, ShouldAppearHovered )
SLATE_END_ARGS()
// Add a new section for static meshes
ContextualEditingWidget-&gt;AddSlot()
.Padding( 2.0f )
[ SNew( SDetailSection ) .SectionName("StaticMeshSection") .SectionTitle( LOCTEXT("StaticMeshSection", "Static Mesh").ToString() ) .Content() [ SNew( SVerticalBox ) + SVerticalBox::Slot() .Padding( 3.0f, 1.0f ) [ SNew( SHorizontalBox ) + SHorizontalBox::Slot() .Padding( 2.0f ) [ SNew( SComboButton ) .ButtonContent() [ SNew( STextBlock ) .Text( LOCTEXT("BlockingVolumeMenu", "Create Blocking Volume") ) .Font( FontInfo ) ] .MenuContent() [ BlockingVolumeBuilder.MakeWidget() ] ] ] ]
];
위의 코드는 아래 UI를 만든다.<img alt="SLATE_OVERVIEW_1.png" src="images/slate_overview_1.png" target="_self">Styles can be created and applied to the various parts of a widget. This makes it easy to iterate on the look of the components in the UI, as well as share and reuse styles. 스타일을 생성하여 위젯의 다양한 부분에 적용할 수 있습니다. 이를 통해 UI의 구성 요소 모양을 쉽게 반복할 수 있을 뿐만 아니라 스타일을 공유하고 재사용할 수도 있습니다.// Tool bar
{ Set( "ToolBar.Background", FSlateBoxBrush( TEXT("Common/GroupBorder"), FMargin(4.0f/16.0f) ) ); Set( "ToolBarButton.Normal", FSlateNoResource() ); // Note: Intentionally transparent background Set( "ToolBarButton.Pressed", FSlateBoxBrush( TEXT("Old/MenuItemButton_Pressed"), 4.0f/32.0f ) ); Set( "ToolBarButton.Hovered", FSlateBoxBrush( TEXT("Old/MenuItemButton_Hovered"), 4.0f/32.0f ) ); // Tool bar buttons are sometimes toggle buttons, so they need styles for "checked" state Set( "ToolBarButton.Checked", FSlateBoxBrush( TEXT("Old/MenuItemButton_Pressed"), 4.0f/32.0f, FLinearColor( 0.3f, 0.3f, 0.3f ) ) ); Set( "ToolBarButton.Checked_Hovered", FSlateBoxBrush( TEXT("Old/MenuItemButton_Hovered"), 4.0f/32.0f ) ); Set( "ToolBarButton.Checked_Pressed", FSlateBoxBrush( TEXT("Old/MenuItemButton_Pressed"), 4.0f/32.0f, FLinearColor( 0.5f, 0.5f, 0.5f ) ) ); // Tool bar button label font Set( "ToolBarButton.LabelFont", FSlateFontInfo( TEXT("Roboto-Regular"), 8 ) );
}
SNew( SBorder )
.BorderImage( FEditorStyle::GetBrush( "ToolBar.Background" ) )
.Content()
[ SNew(SHorizontalBox) // Compile button (faked to look like a multibox button) +SHorizontalBox::Slot() [ SNew(SButton) .Style(TEXT("ToolBarButton")) .OnClicked( InKismet2.ToSharedRef(), &amp;FKismet::Compile_OnClicked ) .IsEnabled( InKismet2.ToSharedRef(), &amp;FKismet::InEditingMode ) .Content() [ SNew(SVerticalBox) +SVerticalBox::Slot() .Padding( 1.0f ) .HAlign(HAlign_Center) [ SNew(SImage) .Image(this, &amp;SBlueprintEditorToolbar::GetStatusImage) .ToolTipText(this, &amp;SBlueprintEditorToolbar::GetStatusTooltip) ] +SVerticalBox::Slot() .Padding( 1.0f ) .HAlign(HAlign_Center) [ SNew(STextBlock) .Text(LOCTEXT("CompileButton", "Compile")) .Font( FEditorStyle::GetFontStyle( FName( "ToolBarButton.LabelFont" ) ) ) .ToolTipText(LOCTEXT("CompileButton_Tooltip", "Recompile the blueprint")) ] ] ]
]
The Slate Widget Reflector provides a means of debugging and analyzing the UI and associated code. This helps track down bugs and undesirable behavior as well as profile and optimize your user interface. 슬레이트 위젯 리플렉터는 UI 및 관련 코드를 디버깅하고 분석하는 수단을 제공합니다. 이는 버그와 바람직하지 않은 동작을 추적하고 사용자 인터페이스를 프로파일링하고 최적화하는 데 도움이 됩니다.슬레이트를 사용하기 위해서 아래 모듈을 설정해줘야 한다.<br><img alt="SLATE_OVERVIEW_2.png" src="images/slate_overview_2.png" target="_self">]]></description><link>ue/slate-overview.html</link><guid isPermaLink="false">UE/Slate Overview.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/slate_overview_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/slate_overview_1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Slate Widget Examples]]></title><description><![CDATA[ IsEnabled - This will specify whether or not the widget is able to be interacted with. If it is disabled, it will be greyed out. 위젯이 상호작용할 수 있는지 여부를 지정합니다. 비활성화된 경우 회색으로 표시됩니다. ToolTip - This will specify what kind of custom SToolTip widget will be used for this widget's tool tip. If not specified, it will not appear. 이 위젯의 ​​도구 설명에 사용할 사용자 정의 SToolTip 위젯의 종류를 지정합니다. 지정하지 않으면 나타나지 않습니다. ToolTipText - This will specify what kind of text will show up as a simple tooltip for this widget's tool tip. If not specified, or if the ToolTip attribute was used, it will not appear. 이 위젯의 ​​도구 설명에 대한 간단한 도구 설명으로 표시할 텍스트 종류를 지정합니다. 지정하지 않거나 ToolTip 속성을 사용한 경우에는 표시되지 않습니다. Cursor - This will specify what cursor will appear while the mouse is hovering over this widget. 이는 마우스가 이 위젯 위에 있는 동안 어떤 커서가 나타날지 지정합니다. Visibility 다음 인수는 모든 단일 위젯에 있는 것은 아니지만 대부분의 위젯에 있습니다.
Text - This will specify the text that this widget will have, if applicable.
Content - This will specify what widget should be placed in the content section of the widget, if applicable.
ReadOnly - This will prevent this widget from being editable if&nbsp;true.
Style - This will specify the style of images or text font used by the widget. How this is applicable varies by widget.
Padding - The padding of a widget amount of spacing in slate units around the left, top, right, and bottom parts of the widget within its parent. These can be specified as a single value for all four parts, or as a horizontal and vertical value, or as four separate values.
HAlign - The horizontal alignment of content within the widget.
VAlign - The vertical alignment of content within the widget.
The visibility of a widget determines how the widget will appear, as well as its interactivity.
위젯의 가시성에 따라 위젯이 표시되는 방식과 상호작용성이 결정됩니다. Visible (Default) - The widget will appear normally. 위젯이 정상적으로 나타납니다. Collapsed - The widget will not be visible and will take up no space in the layout. It will not be interactive. 위젯은 표시되지 않으며 레이아웃에서 공간을 차지하지 않습니다. 인터렉션형이 아닙니다. Hidden - The widget will not be visible, but will take up space in the layout. It will not be interactive. 위젯은 표시되지 않지만 레이아웃에서 공간을 차지합니다. 인터렉션형이 아닙니다. HitTestInvisible - Visible to the user, but only as art. It will not be interactive. 사용자에게 표시되지만 아트로만 표시됩니다. 대화형이 아닙니다. SelfHitTestInvisible - Same as HitTestInvisible, but does not apply to child widgets. HitTestInvisible과 동일하지만 하위 위젯에는 적용되지 않습니다. HAlign_Fill/VAlign_Fill HAlign_Left VAlign_Top HAlign_Center/VAlign_Center HAlign_Right VAlign_Bottom ]]></description><link>ue/slate-widget-examples.html</link><guid isPermaLink="false">UE/Slate Widget Examples.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[Navigation System]]></title><description><![CDATA[인공지능이 Path Finding을 해서 레벨을 탐색할 수 있음. 시스템은 레벨의 충돌 지오메트리로부터 내비게이션 메시를 생성하고 메시를 타일로 나눕니다. 그런 다음 이러한 타일은 다각형으로 분할되어 에이전트가 목적지로 이동할 때 사용하는 그래프를 형성합니다. 각 다각형에는 에이전트가 전체 최저 비용으로 최적의 경로를 결정하는 데 사용하는 비용이 할당됩니다.내비게이션 시스템에는 정적, 동적 및 동적 수정자 전용의 세 가지 생성 모드가 포함되어 있습니다. 이 모드는 프로젝트에서 내비게이션 메시가 생성되는 방식을 제어하고 필요에 맞는 다양한 옵션을 제공합니다.시스템은 또한 에이전트를 위한 두 가지 회피 방법, 즉 RVO(Reciprocal Velocity Obstacles)와 Detour Crowd Manager(우회 군중 관리자)를 제공합니다. 이러한 방법을 사용하면 에이전트는 게임 플레이 중에 동적 장애물과 다른 에이전트를 탐색할 수 있습니다.]]></description><link>ue/navigation-system.html</link><guid isPermaLink="false">UE/Navigation System.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[PhysX iOS 빌드]]></title><description><![CDATA[cd {EngineSource 디렉토리}/Engine/Source/ThirdParty/PhysX3/Lib/IOS
nm libPxFoundation.a <img alt="symbol_result.png" src="images/symbol_result.png" target="_self">커스텀한 엔진 심볼 확인 불가 -&gt; 커스텀한 PhysX lib .a overwrite 해야함. PhysX 빌드 CMake Version: 3.28.0 (minimum: 3.0)
XCode: 14.1
MacOS: Ventura 13.3.1(a)
Machine: Apple M1 Ultra Environment - Add EntryName: GW_DEPS_ROOT
Value: {PhysX Path} - 주의사항: PhysX3.4 아님 PxShared도 가지고 있는 Root 폴더<br><img alt="cmake_setting.png" src="images/cmake_setting.png" target="_self">Configure - Generate - Open Project
(Configure 할 때, output 폴더에 CMakeCache 있으면 지울 것 캐싱되어서 안바뀔 수도 있음)Xcode 프로젝트가 열렸으면 타겟 All_BUILD로 변경 Edit 스킴을 눌러서 release, debug 각 config에 맞는 걸로 바꾼 후 실행하면 .a들 뽑힘. (PhysX3.4와 PxShared 라이브러리들)<br><img alt="change_scheme.png" src="images/change_scheme.png" target="_self">해당 폴더로 가서 libPxFoundationDEBUG.a $ nm libPxFoundationDEBUG.a
<br><img alt="symbol_find_result.png" src="images/symbol_find_result.png" target="_self">뽑은 라이브러리들(PhysX3.4, PxShared) 엔진소스/ThirdParty/PhysX3/Lib/IOS로 가서 덮어쓰기]]></description><link>ue/physx-ios-빌드.html</link><guid isPermaLink="false">UE/PhysX iOS 빌드.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/symbol_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/symbol_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unreal Engine만의 기본 타입이 있는 이유와 문자열]]></title><description><![CDATA[ 언리얼 엔진에서 int32와 같은 언리얼 엔진 데이터형이 따로 있는 이유는 다양한 플랫폼에 대응하기 때문이다.
언리얼은 문자 인코딩 방식 UTF-16을 사용하고 있음. 이것도 역시 다양한 플랫폼을 위해서..
윈도우는 CP949를 사용해서 언리얼엔진에서 한글 사용시 깨진다. 소스코드를 UTF-8로 저장하면 한글 제대로 나온다.유니코드를 위한 언리얼 표준 Character 타입은 TCHAR이다.
언리얼 엔진에서 문자열을 사용할 때 TEXT 매크로를 사용해 생성하고 다뤄야한다.
TEXT 매크로로 감싸면 TCHAR 배열로 만들어짐!FString은 단순하게 TCHAR를 가르키고 있는 포인터임. 그래서 FString을 출력하고 싶으면 디레퍼런스 연산자 *를 사용해야함.FString을 자르거나, 찾거나 등 문자열을 다루는 함수들은 내부적으로 FCString으로 타입이 변환한 후 처리된다. 이는 저수준의 C 함수를 사용해야하기 때문이다. 실제로 Atoi나 Atof 같은 함수를 사용하기 위해서는 FCString을 이용한다. #include "MyGameInstance.h"
void UMyGameInstance::Init()
{ Super::Init(); TCHAR LogCharArray[] = TEXT("Hello World"); UE_LOG(LogTemp, Log, TEXT("%s"), LogCharArray); FString LogCharString = LogCharArray; UE_LOG(LogTemp, Log, TEXT("%s"), *LogCharString); const TCHAR* LongCharPtr = *LogCharString; UE_LOG(LogTemp, Log, TEXT("%s"), LongCharPtr); TCHAR* LogCharDataPtr = LogCharString.GetCharArray().GetData(); UE_LOG(LogTemp, Log, TEXT("%s"), LogCharDataPtr); TCHAR LogCharArrayWithSize[100]; FCString::Strcpy(LogCharArrayWithSize, LogCharString.Len(), *LogCharString); UE_LOG(LogTemp, Log, TEXT("%s"), LogCharArrayWithSize); // Find, Slice if (LogCharString.Contains(TEXT("World"), ESearchCase::IgnoreCase)) { int32 Index = LogCharString.Find(TEXT("World"),ESearchCase::IgnoreCase); FString EndString = LogCharString.Mid(Index); UE_LOG(LogTemp, Log, TEXT("Find Test: %s"), *EndString); } FString Left, Right; if (LogCharString.Split(TEXT(" "), &amp;Left, &amp;Right)) { UE_LOG(LogTemp, Log, TEXT("%s and %s"), *Left, *Right); } // Int, Float -&gt; String int IntValue = 32; float FloatValue = 3.141592; // 스트링으로 전환 FString FloatIntString = FString::Printf(TEXT("Int: %d, Float: %f"), IntValue, FloatValue); FString FloatString = FString::SanitizeFloat(FloatValue); FString IntString = FString::FromInt(IntValue); UE_LOG(LogTemp, Log, TEXT("%s"), *FloatIntString); UE_LOG(LogTemp, Log, TEXT("Int:%s, Float:%s"), *IntString, *FloatString); int32 IntValueFromString = FCString::Atoi(*IntString); float FloatValueFromString = FCString::Atof(*FloatString); FString FloatIntFromString = FString::Printf(TEXT("Int: %d, Float: %f"), IntValueFromString, FloatValueFromString); UE_LOG(LogTemp, Log, TEXT("%s"), *FloatIntFromString); // FNAME // 에셋관리를 위한 것 // 대소문자 구분 x // 한번 선언되면 바꿀 수 없음 key로 만들어짐 Key - Vlaue // 팁 // 위의 코드는 overhead 발생 -&gt; 아래코드 staticonyonce를 이용하기 for (int i = 0; i &lt; 10000; ++i) { FName SerachInNamePool = FName(TEXT("pelvis")); const static FName StaticOnlyOnce(TEXT("pelvis")); } ]]></description><link>ue/unreal-engine만의-기본-타입이-있는-이유와-문자열.html</link><guid isPermaLink="false">UE/Unreal Engine만의 기본 타입이 있는 이유와 문자열.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[아틀라스]]></title><description><![CDATA[-&gt; 여러개의 작은 이미지나 텍스쳐를 큰 이미지 파일로 만드는 것장점
드로우콜 감소 - 여러개의 텍스쳐를 개별적으로 불러오는 것 대신 한번에 불러오니까 드로우 콜 감소시킬 수 있음
메모리 사용 최적화 - 텍스처를 개별적으로 불러올 때 발생할 수 있는 메모리 낭비를 없애줌
텍스처 스위칭 감소 - 동일한 드로우콜 내에서 다른 텍스처로 스위칭하는데 비용이 드는데 이 과정을 없앰
배치처리 효율화 - 비슷한 유형의 많은 객체가 동일한 텍스처 아틀라스를 사용하는 경우, 이들을 함께 그룹화하여 배치 처리할 수 있습니다. 이는 렌더링 효율성을 높이고, CPU와 GPU 사이의 복잡한 상호작용을 줄일 수 있습니다.
실제로 UMG에 생 이미지를 사용해서 3개의 이미지를 만든다면 Draw Call 3이고 Atlas를 사용하면 Draw Call이 1임.단점
여러개의 텍스처를 하나의 아틀라스로 묶어야 하기 때문에 공격적인 압축이 필요함. 이는 세부 디테일이 흐려질수도 있음(화질 깨질 수도 있음)
모든 텍스처가 동일한 해상도를 공유하기 때문에, 고해상도는 해상도를 낮춰야할 가능성이 있음
사용되지 않는 부분의 아틀라스는 리소스 낭비
큰 텍스처 아틀라스를 메모리에 로드할 때 각각 개별 로드하는 것보다 로드시간이 길 수 있음
텍스처 스트리밍(MipMap) 동적으로 텍스처를 로드하고 언로드할 때 오바헤드가 있을 수 있음 UVMapping의 유연성- 텍스처 아틀라스를 사용하면, 개별 텍스처에 대한 UV 매핑을 조정하여 다양한 텍스처 조각을 사용할 수 있습니다. 이는 다양한 비주얼 효과를 생성하거나, 다양한 객체에 동일한 텍스처 아틀라스를 다르게 적용하여 리소스를 절약할 수 있는 방법을 제공합니다.
아트 워크플로우 개선 - 아티스트들은 텍스처 아틀라스를 사용하여 텍스처 작업을 보다 효율적으로 관리할 수 있습니다. 특히, 게임 내에서 다양한 요소들이 비슷한 텍스처 스타일을 공유할 때, 아틀라스 하나를 업데이트함으로써 여러 개체의 비주얼을 일관되게 유지할 수 있습니다.
텍스처를 Create Sprite -&gt; Sprite 클릭 -&gt; Atlas Group에 넣기밉맵은 동일한 텍스처의 여러 사전 계산된 버전을 작은 해상도로 점차 줄여 가며 저장하는 기법을 말합니다. 이렇게 하면, 3D 환경 내에서 물체가 더 멀리 있을 때, 더 작은 해상도의 텍스처를 사용하여 렌더링할 수 있습니다.
성능 향상: 더 작은 해상도의 텍스처를 사용하면, 그래픽 처리 장치(GPU)의 부담이 줄어들어 렌더링 성능이 향상됩니다. 멀리 있는 객체에 고해상도 텍스처를 사용하는 것은 메모리와 처리 능력을 낭비하기 때문에, 밉맵을 사용하면 이러한 자원을 효율적으로 사용할 수 있습니다.
시각적 품질 향상: 밉맵을 사용하면 텍스처의 해상도가 뷰포트와의 거리에 따라 동적으로 조정되므로, 텍스처 앨리어싱(계단 현상)이나 모아레 패턴 같은 시각적 아티팩트를 줄일 수 있습니다. 멀리 있는 객체에 대해 더 낮은 해상도의 텍스처를 사용함으로써, 더 부드럽고 자연스러운 이미지를 생성할 수 있습니다.
미리 준비된 다양한 해상도 이미지를 준비하는 것객체가 화면에서 멀어질수록 이미지의 해상도를 동적으로 조절하여 사용
가까이 -&gt; 고해상도
멀리 -&gt; 저해상도밉맵은 언리얼엔진4에서는 텍스쳐가 Power of two인 경우에 자동으로 생성된다. 아닌 경우는 자동생성 안해준다. 그런데 5에서는 자동 생성해준다.여담으로 텍스쳐 압축기술인 DXT5는 Power of four인 경우에 적용된다.
따라서 텍스쳐 크기는 안전하게 Power of two를 유지하는 것이 좋다.같은 이미지를 사용하는 UMG가 있을 때 아틀라스를 사용하는 것이 합리적이다. Draw Call을 줄여준다.
Draw Call이 뭐야?
Draw Call을 수동으로 부를 수 있을까?
Draw Call이 적으면 무조건 좋은거야?
UMG를 사용할 때 Draw Call을 줄이기 위해서 어떤 작업들을 해야할까?
아틀라스를 사용하면 그러면 Draw Call이 1 보장되겠네? <a rel="noopener nofollow" class="external-link is-unresolved" href="https://drehzr.tistory.com/666" target="_self">https://drehzr.tistory.com/666</a> - 밉맵
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://coding-hell.tistory.com/78" target="_self">https://coding-hell.tistory.com/78</a> - 언리얼 UI 최적화하기
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.nullbus.net/94" target="_self">https://blog.nullbus.net/94</a> - UMG Draw Call 분석하기
]]></description><link>ue/아틀라스.html</link><guid isPermaLink="false">UE/아틀라스.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[symbol_find_result]]></title><description><![CDATA[<img src="images/symbol_find_result.png" target="_self">]]></description><link>images/symbol_find_result.html</link><guid isPermaLink="false">images/symbol_find_result.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/symbol_find_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/symbol_find_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[symbol_result]]></title><description><![CDATA[<img src="images/symbol_result.png" target="_self">]]></description><link>images/symbol_result.html</link><guid isPermaLink="false">images/symbol_result.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/symbol_result.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/symbol_result.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cmake_setting]]></title><description><![CDATA[<img src="images/cmake_setting.png" target="_self">]]></description><link>images/cmake_setting.html</link><guid isPermaLink="false">images/cmake_setting.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/cmake_setting.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/cmake_setting.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[change_scheme]]></title><description><![CDATA[<img src="images/change_scheme.png" target="_self">]]></description><link>images/change_scheme.html</link><guid isPermaLink="false">images/change_scheme.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/change_scheme.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/change_scheme.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[NativizedAssets]]></title><description><![CDATA[<img src="images/nativizedassets.png" target="_self">]]></description><link>images/nativizedassets.html</link><guid isPermaLink="false">images/NativizedAssets.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/nativizedassets.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/nativizedassets.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[object_file_header]]></title><description><![CDATA[<img src="images/object_file_header.png" target="_self">]]></description><link>images/object_file_header.html</link><guid isPermaLink="false">images/object_file_header.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/object_file_header.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/object_file_header.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[printf]]></title><description><![CDATA[<img src="images/printf.png" target="_self">]]></description><link>images/printf.html</link><guid isPermaLink="false">images/printf.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/printf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/printf.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Build System]]></title><description><![CDATA[
Source 폴더 -&gt; Unreal Build Tool (C#) -&gt; 각 플랫폼 컴파일러 실행
실제 Build를 하는 것은 C#으로 진행함 그래서 닷넷을 설치하는 것Source 폴더 구조Source
- Module 폴더 (보통 Project 이름)
- 소스코드(.h, .cpp)
- {모듈이름}.Build.cs
- 타겟 설정 파일: 전체 솔루션이 다룰 빌드 대상 지정
&gt; {프로젝트 이름}.Target.cs: 게임 빌드 설정
&gt; {프로젝트 이름}Editor.Target.cs: 에디터 빌드 설정Build.cs는 모듈마다 들어가는 모듈 설정 파일모듈.cpp, 모듈.cpp로 지정매크로를 이용해서 모듈의 뼈대를 제작
IMPLEMENT_MODULE: 일반 모듈
IMPLEMENT_GAME_MODULE: 게임 모듈
IMPLEMENT_PRIMARY_GAME_MODULE: 주 게임 모듈
외부로 공개할 클래스 선언에는 {모듈이름}_DLL 매크로를 붙임
Build.cs에서 참조 관계 설정
서브 모듈을 플러그인으로 분리할 수 있음]]></description><link>ue/build-system.html</link><guid isPermaLink="false">UE/Build System.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[executable_file_structure]]></title><description><![CDATA[<img src="images/executable_file_structure.png" target="_self">]]></description><link>images/executable_file_structure.html</link><guid isPermaLink="false">images/executable_file_structure.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/executable_file_structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/executable_file_structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[build_process]]></title><description><![CDATA[<img src="images/build_process.png" target="_self">]]></description><link>images/build_process.html</link><guid isPermaLink="false">images/build_process.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/build_process.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/build_process.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_inprogress]]></title><description><![CDATA[<img src="images/ebtnode_result_inprogress.png" target="_self">]]></description><link>images/ebtnode_result_inprogress.html</link><guid isPermaLink="false">images/ebtnode_result_inprogress.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_inprogress.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_inprogress.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_type]]></title><description><![CDATA[<img src="images/ebtnode_result_type.png" target="_self">]]></description><link>images/ebtnode_result_type.html</link><guid isPermaLink="false">images/ebtnode_result_type.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_type.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_type.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_failed]]></title><description><![CDATA[<img src="images/ebtnode_result_failed.png" target="_self">]]></description><link>images/ebtnode_result_failed.html</link><guid isPermaLink="false">images/ebtnode_result_failed.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_failed.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_failed.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ebtnode_result_aborted]]></title><description><![CDATA[<img src="images/ebtnode_result_aborted.png" target="_self">]]></description><link>images/ebtnode_result_aborted.html</link><guid isPermaLink="false">images/ebtnode_result_aborted.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ebtnode_result_aborted.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ebtnode_result_aborted.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Navigation]]></title><description><![CDATA[<img src="images/navigation.png" target="_self">]]></description><link>images/navigation.html</link><guid isPermaLink="false">images/Navigation.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/navigation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/navigation.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GameFlowChart]]></title><description><![CDATA[<img src="images/gameflowchart.png" target="_self">]]></description><link>images/gameflowchart.html</link><guid isPermaLink="false">images/GameFlowChart.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/gameflowchart.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/gameflowchart.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Blendspace]]></title><description><![CDATA[<img src="images/blendspace.png" target="_self">]]></description><link>images/blendspace.html</link><guid isPermaLink="false">images/Blendspace.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/blendspace.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/blendspace.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-gatt-structure]]></title><description><![CDATA[<img src="images/ble-gatt-structure.png" target="_self">]]></description><link>images/ble-gatt-structure.html</link><guid isPermaLink="false">images/ble-gatt-structure.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-gatt-structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-gatt-structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-l2cap]]></title><description><![CDATA[<img src="images/ble-l2cap.png" target="_self">]]></description><link>images/ble-l2cap.html</link><guid isPermaLink="false">images/ble-l2cap.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-l2cap.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-l2cap.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-link-layer]]></title><description><![CDATA[<img src="images/ble-link-layer.png" target="_self">]]></description><link>images/ble-link-layer.html</link><guid isPermaLink="false">images/ble-link-layer.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-link-layer.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-link-layer.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-connection]]></title><description><![CDATA[<img src="images/ble-connection.png" target="_self">]]></description><link>images/ble-connection.html</link><guid isPermaLink="false">images/ble-connection.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-connection.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-connection.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-connection 1]]></title><description><![CDATA[<img src="images/ble-connection-1.png" target="_self">]]></description><link>images/ble-connection-1.html</link><guid isPermaLink="false">images/ble-connection 1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-connection-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-connection-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-data-exchange]]></title><description><![CDATA[<img src="images/ble-data-exchange.png" target="_self">]]></description><link>images/ble-data-exchange.html</link><guid isPermaLink="false">images/ble-data-exchange.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-data-exchange.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-data-exchange.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-attribute-table]]></title><description><![CDATA[<img src="images/ble-attribute-table.png" target="_self">]]></description><link>images/ble-attribute-table.html</link><guid isPermaLink="false">images/ble-attribute-table.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-attribute-table.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-attribute-table.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-conn-fig-1]]></title><description><![CDATA[<img src="images/ble-conn-fig-1.png" target="_self">]]></description><link>images/ble-conn-fig-1.html</link><guid isPermaLink="false">images/ble-conn-fig-1.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-conn-fig-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-conn-fig-2]]></title><description><![CDATA[<img src="images/ble-conn-fig-2.png" target="_self">]]></description><link>images/ble-conn-fig-2.html</link><guid isPermaLink="false">images/ble-conn-fig-2.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-conn-fig-2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble-conn-fig-3]]></title><description><![CDATA[<img src="images/ble-conn-fig-3.png" target="_self">]]></description><link>images/ble-conn-fig-3.html</link><guid isPermaLink="false">images/ble-conn-fig-3.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble-conn-fig-3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble-conn-fig-3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ble_host_controller]]></title><description><![CDATA[<img src="images/ble_host_controller.png" target="_self">]]></description><link>images/ble_host_controller.html</link><guid isPermaLink="false">images/ble_host_controller.png</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="images/ble_host_controller.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;images/ble_host_controller.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>