<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 1 at column 892: Input is not proper UTF-8, indicate encoding !
Bytes: 0x1D 0xEC 0x9D 0xB4
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[psychehose.github.io]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>psychehose.github.io</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 06 Jan 2025 15:13:45 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 06 Jan 2025 15:11:20 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Missing required module 'RxCocoaRuntime'에 대한 고찰 - SPM과 UnitTest에서의 오류]]></title><description/></item><item><title><![CDATA[62. Unique Paths]]></title><description><![CDATA[There is a robot on an&nbsp;m x n&nbsp;grid. The robot is initially located at the&nbsp;top-left corner&nbsp;(i.e.,&nbsp;grid[0][0]). The robot tries to move to the&nbsp;bottom-right corner&nbsp;(i.e.,&nbsp;grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.Given the two integers&nbsp;m&nbsp;and&nbsp;n, return&nbsp;the number of possible unique paths that the robot can take to reach the bottom-right corner.The test cases are generated so that the answer will be less than or equal to&nbsp;2 * 109.Example 1:<img alt="robot_maze.png" src="images/robot_maze.png" target="_self">Input: m = 3, n = 7
Output: 28Example 2:Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner 1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down#include &lt;vector&gt; class Solution {
public: int uniquePaths(int m, int n) { // dp 초기화 std::vector&lt;std::vector&lt;int&gt;&gt; dp(m, std::vector&lt;int&gt;(n,1)); for (std::vector&lt;std::vector&lt;int&gt;&gt;::size_type r = 1; r &lt; dp.size(); ++r) { for (std::vector&lt;int&gt;::size_type c = 1; c &lt; dp[r].size(); ++c) { dp[r][c] = dp[r-1][c] + dp[r][c-1]; } } return dp[m-1][n-1]; }
};
]]></description><link>algorithm/blind75/62.-unique-paths.html</link><guid isPermaLink="false">Algorithm/blind75/62. Unique Paths.md</guid><pubDate>Sun, 05 Jan 2025 10:22:11 GMT</pubDate><enclosure url="images/robot_maze.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/robot_maze.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[robot_maze]]></title><description><![CDATA[<img src="images/robot_maze.png" target="_self">]]></description><link>images/robot_maze.html</link><guid isPermaLink="false">images/robot_maze.png</guid><pubDate>Sun, 05 Jan 2025 08:12:34 GMT</pubDate><enclosure url="images/robot_maze.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/robot_maze.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[70. Climbing Stair]]></title><description><![CDATA[You are climbing a staircase. It takes&nbsp;n&nbsp;steps to reach the top.Each time you can either climb&nbsp;1&nbsp;or&nbsp;2&nbsp;steps. In how many distinct ways can you climb to the top?Example 1:Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1 step + 1 step
2 steps
Example 2:Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1 step + 1 step + 1 step
1 step + 2 steps
2 steps + 1 step
Constraints:
1 &lt;= n &lt;= 45
점화식으로 해결class Solution {
public: int climbStairs(int n) { if (n == 1) return 1; std::vector&lt;int&gt; dp { 1, 2 }; dp.reserve(n); for (int i = 2; i &lt; n; ++i) { dp.push_back(dp[i-1] + dp[i-2]); } return *(dp.end() - 1); }
};
]]></description><link>algorithm/blind75/70.-climbing-stair.html</link><guid isPermaLink="false">Algorithm/blind75/70. Climbing Stair.md</guid><pubDate>Fri, 03 Jan 2025 16:39:39 GMT</pubDate></item><item><title><![CDATA[Visitor Pattern]]></title><description><![CDATA[기존의 SFML에서는 멤버 변수 sf::Event::EventType을 확인해서 각 이벤트를 처리 했었다. 내가 사용하는 3.0 버전에서는 이벤트를 visitor를 이용해서 처리 한다. Visitor 패턴은 객체 구조와 처리를 분리하는 디자인 패턴. 즉 '다른 클래스에 있는 알고리즘을 가져와서 실행할 수 있게 해주는 패턴'임 // 기존 방식 (이제 지원하지 않음)
if (event.type == sf::Event::Closed) { window.close();
} // Visitor 패턴 사용 (새로운 방식)
event.visit([&amp;window](const sf::Event::Closed&amp;) { window.close();
}); 컴파일 타임 검사: 잘못된 이벤트 타임에 접근하는 것을 방지하고 타입 불일치 오류를 컴파일 단계에서 발견할 수 있다. 기존의 방식을 사용하면 아래처럼 런타임에서 에러를 잡을 수 있다.
// 기존
if (event.type == sf::Event::MouseMoved) { // 실수로 KeyPressed의 데이터를 사용하려고 하면... bool isShiftPressed = event.key.shift; // 잘못된 메모리 접근
} // visitor
event.visit([](const sf::Event::MouseMoved&amp; mouse) { // mouse.position만 사용할 수 있음 // 다른 이벤트의 멤버는 접근 불가능
}); 코드 가독성: 중첩 if문, switch문 없음. 각 이벤트 타입별 처리가 원활
유지보수 좋음: 기존 코드 수정하지 않고 새로운 핸들러 추가가 쉬움
sf:Event 클래스를 확인하면 클래스 내에 struct으로 각 이벤트가 정의 되어 있다. 그리고 내부 변수에 private로 m_data를 가지고 있다.
이 m_data의 타입은 std::variant&lt;Closed, Resized, FocusLost, /*...*/ &gt; 이다.std::variant는 여러 타입 중 하나를 저장할 수 있는 type-safe union이다. 그렇다면 어떻게 SFML에서 m_data와 visit을 통해서 이벤트를 처리할까?이를 이해하기 위해 먼저 std::variant와 std::visit의 관계와 사용법에 대해 알아야만 한다.// 기본구조 // Variant: 여러 타입 중 하나를 저장할 수 있는 컨테이너
std::variant&lt;A, B, C&gt; data;
// Visitor: variant에 저장된 데이터를 처리하는 방법
auto visitor = [](const auto&amp; value) { /* 처리 로직 */ }; // 동작 방식
// 1. variant가 데이터 저장
std::variant&lt;int, std::string&gt; data = 42;
// 2. visitor가 데이터 처리
std::visit([](const auto&amp; value) { using T = std::decay_t&lt;decltype(value)&gt;; if constexpr (std::is_same_v&lt;T, int&gt;) { std::cout &lt;&lt; "정수 처리: " &lt;&lt; value &lt;&lt; std::endl; } else if constexpr (std::is_same_v&lt;T, std::string&gt;) { std::cout &lt;&lt; "문자열 처리: " &lt;&lt; value &lt;&lt; std::endl; }
}, data);
using T = std::decay_t&lt;decltype(value)&gt; 에서 decltype(value)는 value의 정확한 타입을 추론하고 std::decay_t는 참조와 const를 제거한 순수한 타입을 얻는다. 위 코드에서 const int&amp;는 int로 변환된다.이렇게 얻은 타입 T로 컴파일 타임에 타입 체크를 수행한다.if constexpr (std::is_same_v&lt;T, int&gt;) { // int 타입일 때의 처리
}
else if constexpr (std::is_same_v&lt;T, std::string&gt;) { // string 타입일 때의 처리
}
위의 예시와 같이std::variant 과 std::visit를 이용하면 컴파일 타임에서 안전하게 타입을 추론할 수 있고 각 타입마다 처리를 하기 용이 해진다는 장점을 알 수 있다.Window::pollEvnet() 를 호출하면 m_data가 변경된다.//SFML Event 내부 구현
template &lt;typename TEventSubtype&gt; Event::Event(const TEventSubtype&amp; eventSubtype)
{ static_assert(isEventSubtype&lt;TEventSubtype&gt;, "TEventSubtype must be a subtype of sf::Event"); if constexpr (isEventSubtype&lt;TEventSubtype&gt;) m_data = eventSubtype;
}
// SFML Event 내부 구현
class Event {
public: // visitor 패턴을 이용한 이벤트 처리 template &lt;typename T&gt; auto visit(T&amp;&amp; visitor) const { // visitor는 람다함수 or 함수 객체 return std::visit(std::forward&lt;T&gt;(visitor), m_data); }
};
여기에서 Visitor 패턴의 핵심 동작이 일어난다. Event::visit 함수는 std::visit의 단순 래퍼다.
std::forward&lt;T&gt;를 통해 visitor (람다나 함수 객체) 를 perfect 전달한다. 따라서 m_data와 visitor를 통해서 각 이벤트에 대해서 처리를 할 수 있게 된다.void Simulator::handleEvents() {
if (auto event = window.pollEvent()) { event-&gt;visit([this](const auto&amp; e) { using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }); }
}
이 코드가 실행될 때 내부적으로 아래와 같은 과정이 일어난다.
람다 함수가 Event::visit에 전달
Event::visit은 람다 함수를 std::visit으로 전달
std::visit은 m_data에 저장된 실제 타입을 확인하고 람다를 호출 한다.
이걸 좀 풀어서 설명하면 아래처럼 코드가 실행되는 것이다.std::visit( [this](const auto&amp; e) { // 여기서 e는 variant에 저장된 실제 타입의 참조 using T = std::decay_t&lt;decltype(e)&gt;; if constexpr (std::is_same_v&lt;T, sf::Event::Closed&gt;) { window.close(); } else if constexpr (std::is_same_v&lt;T, sf::Event::KeyPressed&gt;) { if (e.code == sf::Keyboard::Key::X) { window.close(); } } }, m_data // variant 객체 전달
);
struct EventVisitor { Simulator&amp; simulator; // 참조를 저장 // 특정 이벤트용 처리기 void operator()(const sf::Event::Closed&amp; event) { simulator.window.close(); } void operator()(const sf::Event::KeyPressed&amp; event) { ... } // 다른 모든 이벤트를 처리하는 템플릿 template&lt;typename T&gt; void operator()(const T&amp; event) {}
};
void Simulator::handleEvents() { if (auto event = window.pollEvent()) { event-&gt;visit(EventVisitor{*this}); }
} 객체를 만들고 operator()를 구현하면 객체를 함수처럼 사용할 수 있다.EventVisitor visitor; visitor(something);
내부적으로는 위의 람다 함수의 경우와 사실 거의 같다. 람다 함수 대신에 함수 객체를 넘겨주는 것이 차이점이다. 그리고 기본적으로 std::visit은 variant에 저장된 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다
event-&gt;visit(EventVisitor{*this}); 호출 한다.
Event::visit은 std::visit에 함수 객체와, m_data를 전달한다.
std::visit은 m_data(variant)를 실제 타입을 확인해서 그 타입에 맞는 operator를 호출한다.
]]></description><link>golf-simulator/visitor-pattern.html</link><guid isPermaLink="false">Golf Simulator/Visitor Pattern.md</guid><pubDate>Fri, 03 Jan 2025 15:33:44 GMT</pubDate></item><item><title><![CDATA[Resume]]></title><description><![CDATA[Not Yet..]]></description><link>hose/resume/resume.html</link><guid isPermaLink="false">Hose/Resume/Resume.canvas</guid><pubDate>Tue, 31 Dec 2024 09:30:05 GMT</pubDate></item><item><title><![CDATA[ Home]]></title><description><![CDATA[개발을 진행하면서 공부하는 내용을 포스팅 합니다.
Clang++
Vision
Robotics
Game Engine
Graphics C++, Swift, Objective-C, RxSwift Git, Perforce, Jenkins
Unreal Engine CMake Email: <a data-tooltip-position="top" aria-label="mailto:psychehose@gmail.com" rel="noopener nofollow" class="external-link" href=".html" target="_self">psychehose@gmail.com</a>
<br>GitHub: <a data-tooltip-position="top" aria-label="https://github.com/psychehose" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose" target="_self">psychehose</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 31 Dec 2024 09:29:18 GMT</pubDate></item><item><title><![CDATA[Modeling]]></title><description><![CDATA[수학을 배운 경험이 있다면 x^2&nbsp; + y^2 = 1 형태의 식을 본 적이 있을 것이다. 이러한 형태를 음함수라고 하는데 GPU는 음함수를 잘 처리하지 못한다. 그러면 어떻게 하느냐? 평면의 점을 샘플링해서 Polygon Mesh로 만든다. (샘플링을 한다는 것은 정점과, 법선 벡터를 잘 뽑는 것을 의미한다.)어떤 물체가 있고 이를 잘 샘플링해서 폴리곤 메쉬로 만들었다. 이렇게 만들어진 메쉬를 컴퓨터(?)는 어떻게 저장을 하는 지 알아보자.<img src="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">t1, t2, t3라는 삼각형 메쉬가 존재한다. 이를 메모리에 저장을 하는 방법은 간단하다. 좌표를 그냥 배열에 때려넣으면 된다. 때려 넣고 나니 문제점이 있는 것 같다.&nbsp; vertex array를 보면 중복되는 것이 많다는 것을 알 수 있다. 낭비가 심하다. 그래서 위와 같이 저장하지 않는다. 문제를 해결하기 위해 인덱스를 추가해 보자.<br><img src="https://blog.kakaocdn.net/dn/bB6wFv/btstk41D2xI/WHrJSexTiosKNTGHhMQe40/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">각 정점들에 index를 줘서 해결하면 더 빠르게 처리할 수 있다.3ds Max와 같은 모델링 프로그램을 이용해서 export를 하면 .obj 파일을 얻을 수 있다. 간단한 구를 모델링해서 export를 해서 열면 어떤 데이터가 들어 있을까?구는 26개의 정점과 48개의 삼각형으로 이뤄져 있다.<br><img src="https://blog.kakaocdn.net/dn/d3DpsC/btstkTy9Ufk/3TFup6zSfeHakZy5345wc1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">v는 Vertex를 의미하고, 숫자는 순서대로 x, y, z이다.vn는 Vertex Noraml을 의미하고 숫자는 순서대로 x, y, z이다.f는 face를 의미하고 v // vn 을 의미한다. (구는 v와 vn이 1:1로 대응하지만, 직육면체와 같은 입체에서는 vn이 중복될 수 있다.)<br><img src="https://blog.kakaocdn.net/dn/1Vyde/btsth6yLCPq/GbVkDxpfn73pFLdUo44HZ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">.obj를 Import 하게 되면 메모리는 위와 같이 저장된다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.kocw.net/home/search/kemView.do?kemId=1349173" target="_self">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>]]></description><link>graphics/modeling.html</link><guid isPermaLink="false">graphics/Modeling.md</guid><pubDate>Tue, 31 Dec 2024 06:02:33 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/YrGkD/btstmtNqVn8/aYD2GrUzEEMsCpUlJ2Ws71/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[컴퓨터 그래픽스 기초와 수학]]></title><description><![CDATA[컴퓨터 그래픽스는 3D 인풋을 받아 2D 공간에 표현하는 것에 대한 학문이다.컴퓨터 그래픽스의 Production는 5단계로 나눌 수 있다.<img src="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Modeling은 Polygon Mesh로 형태를 만드는 작업과 질감 처리 같은 Texture를 만드는 작업을 말한다.Rigging은 뼈대를 만들고 Polygon Mesh와 관계를 만드는 작업을 말한다.Animation은 Rigging를 통해 만들어진 관계들을 시퀀스로 만들어 실제로 움직이는 것처럼 보이게 만드는 작업이다.Rendering은 3차원에 있는 Scene을 2차원 Scene으로 나타내는 과정이다. 여기에서 중요한 이슈는 텍스쳐와 빛을 처리하는 것이다.Post-Processing는 후처리를 해서 좀 더 사실적으로 보이게 하는 작업이다. 필수 작업은 아니다.1번 ~ 3번의 작업은 그래픽 아티스트가 작업하고 4번 ~ 5번은 컴퓨터 프로그램이 처리한다.<br><img src="https://blog.kakaocdn.net/dn/mFeAO/btstpF7SkJM/2hgcK3ZnsHKFQ7ORXIcLN1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">일반적으로 게임의 하단에 Unity와 Unreal과 같은 게임엔진이 있고 게임 엔진에서 Graphics API를 사용한다. Graphics API에는 DirectX, Vulkan, OpenGL, Metal 등이 있다. Graphics API는 GPU를 구동하기 위한 추상화 되어 있는 인터페이스다.그래픽스 분야에서는 기본적으로 선형대 수학을 정말 많이 사용하는 것 같다.&nbsp;Line, Ray, and Linear Interpolation<br><img src="https://blog.kakaocdn.net/dn/QVQu5/btstqsArCYv/IB9YYR1LMmXpo37iJ5BsY0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">t의 범위에 따라서 p(t)를 부르는 이름이 달라진다.t의 범위가 -inf &lt; t &lt; inf 인 경우 Infinite linet의 범위가 0 &lt;= t &lt; inf 인 경우 Rayt의 범위가 0 &lt;= t &lt;= 1 인 경우 Line segmentp(t)에 대한 식을 풀어쓰면 Line segment는 p0과 p1의 Line interpolation과 대응한다는 것을 알 수 있다.<br><img src="https://blog.kakaocdn.net/dn/bTDV50/btstpCQPsfu/XuWI7yGFk88ChA1GK782NK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이것이 의미하는 바는 p0와 p1 사이에 위치하는 값을 양 끝점의 값으로 추정할 수 있다는 것이다.(선형보간법)<br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.kocw.net/home/search/kemView.do?kemId=1349173" target="_self">http://www.kocw.net/home/search/kemView.do?kemId=1349173</a>]]></description><link>graphics/컴퓨터-그래픽스-기초와-수학.html</link><guid isPermaLink="false">graphics/컴퓨터 그래픽스 기초와 수학.md</guid><pubDate>Tue, 31 Dec 2024 06:01:51 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bBPUjo/btstlik4nbr/Kw4fxnSsRX0tyLTSNoUq41/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LINQ]]></title><description><![CDATA[Swift에서&nbsp; map(), filter() 같은&nbsp;고차함수를 많이 사용했었어요. C#으로 처음 PS를 풀 때 map을 사용하고 싶어서 c# map function으로 구글링 했을 때&nbsp; LINQ의 Select() 메서드를 사용하라고 하더군요. 'Select이 뭐지?' 했는데 데이터베이스 시간에 SQL로 열심히 실습할 때 나오는 그 select가 동일합니다. 그럼 LINQ가 뭘까요?LINQ는 Language-Integrated Query의 준말로 C#에서 직접 쿼리 기능을 통합하는 방식을 기반으로 하는 기술 이름이에요. 일반적으로 쿼리는 특수화된 쿼리 언어로 표현되어요. 예를 들면 관계형 데이터베이스에서는 SQL, XML에서는 XQuery가 사용됩니다. 그래서 하나의 형식을 사용할 때마다 하나의 쿼리 언어를 학습할 필요가 생기는 거죠. 그래서 LINQ가 등장하게 되었어요. LINQ는 다양한 데이터 소스 및 다양한 형식에 사용할 수 있는 일관된 모델을 제공합니다. 모든 형식에서 같은 방식으로 데이터를 쿼리하고 변환할 수 있게 됩니다.&nbsp;LINQ는 쿼리군요.&nbsp; 그럼 쿼리는 무엇일까요?&nbsp;
쿼리는 데이터 소스에서 검색할 데이터 및 반환된 데이터에 필요한 모양과 구성을 설명하는 지침 집합이다.
쉽게 풀면 쿼리는 데이터 소스에서 데이터를 검색(추출)하는 식입니다. (쿼리를 통해 검색된 결과가 아님을 주의)C#에서 쿼리(LINQ)를 어떻게 이용할 수 있을까요?&nbsp; LINQ는 세가지 작업으로 구성됩니다!1.&nbsp; 데이터 소스 가져오기 쿼리 만들기 쿼리 실행 데이터 소스는 말 그대로 우리가 쿼리하고 싶은 데이터 모음입니다. 단 쿼리 변수의 타입이&nbsp;IEumerable 또는 IQueryable이므로 이것을 두 타입 중 하나를 컨펌해야만 합니다.&nbsp;List와 Array와 같은 컬렉션 타입은 IEnumerable을 컨펌하고 있기 때문에 데이터 소스로 사용할 수 있어요. 또 관계형 데이터 베이스나, XML과 같은 것들을 IEumerable 또는 IQueryable로 로드를 하거나 맵핑을 해서 데이터 소스로 사용할 수 있습니다.// Array int[] numbers = new int[7] { 0,1,2,3,4,5,6 }; IEumerable&lt;int&gt; numQuery = from number in numbers where (number % 2) == 0 select number;
// LINQ to XML
// Create a data source from an XML document.
// using System.Xml.Linq;
XElement contacts = XElement.Load(@"c:\myContactList.xml"); IQueryable&lt;Contract&gt; contractQuery = from contract in contracts where ... select ...
// LINQ to SQL Mapping Northwnd db = new Northwnd(@"c:\northwnd.mdf"); // Query for customers in London.
IQueryable&lt;Customer&gt; custQuery = from cust in db.Customers where cust.City == "London" select cust;
이제 쿼리 변수를 만들겠습니다.쿼리 변수를 만드는 방법은 두가지가 있습니다. 쿼리 구문을 이용해서! 메서드 구문을 이용해서! 그럼 1번 2번을 두개 다 연습을 해볼게요. 연습을 하기 전에 데이터 소스를 먼저 만들어줍시다.// Teacher.cs public class Teacher
{ public string Name { get; set; } public int ID { get; set; } public decimal Salary { get; set; } public Teacher(string name, int id, decimal salary) { Name = name; ID = id; Salary = salary; }
} // Student.cs public class Student
{ public string Name { get; set; } public int ID { get; set; } public List&lt;int&gt; scroes { get; set; } public Student(string name, int id, List&lt;int&gt; scroes) { Name = name; ID = id; this.scroes = scroes; }
} // Program.cs namespace TestLINQ
{ class Program { static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); } public static void SeedData(List&lt;Student&gt; students, List&lt;Teacher&gt; teachers) { List&lt;Student&gt; _students = new List&lt;Student&gt;() { new Student("김수로", 0, new() { 90, 95,70,50, 87}), new Student("박혁거세", 1, new() { 80, 45,95,80, 75}), new Student("이은혜", 2, new() { 83, 63,89,93, 63}), new Student("이근왕", 3, new() { 55, 77,77,31, 90}), new Student("선우현", 4, new() { 100, 15,25,36, 57}), }; foreach (var s in _students) { students.Add(s); } List&lt;Teacher&gt; _teachers = new List&lt;Teacher&gt;() { new Teacher("김철수", 5, 10000), new Teacher("이진혜", 6, 20000), new Teacher("김왕심", 7, 30000), new Teacher("박수빈", 8, 40000), new Teacher("손을왕", 9, 50000), }; foreach (var t in _teachers) { teachers.Add(t); } } }
}
혹시 SQL을 사용한 경험이 있으신가요?SQL처럼 select where from을 이용해서 쿼리 하는 방식이 쿼리 구문을 이용하는 방법입니다. SQL과 차이점이라면 순서가 반대라는 것!쿼리 구문은 아래와 같은 형식을 가집니다.
쿼리 구문은 반드시 from절로 시작해야 함
쿼리 구문은 반드시 select절 또는 group절로 끝나야 함.
첫 번째 from절과 마지막 select절 또는 group절 사이에 where, orderby, join, let절과 추가 from절들이 하나 이상 들어갈 수 있음.
첫 번째 예시는 첫번째 시험에서 90점 이상을 맞은 학생들을 검색하는 쿼리 변수를 만들게요. static void Main(string[] args) { List&lt;Student&gt; students = new List&lt;Student&gt;(); List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;(); SeedData(students, teachers); IEnumerable&lt;Student&gt; notLessThan90 = from student in students where (student.scroes[0] &gt;= 90) select student; Console.WriteLine("첫번째 시험에서 90점 이상 맞은 학생들"); foreach (Student student in notLessThan90) { Console.WriteLine("{0}, {1}", student.Name, student.scroes[0]); }
쿼리 구문을 이용하면 상당히 직관적으로 데이터를 추출할 수 있네요. 기본적인 구조는 이해하는데 문제가 없을 것 같아요.추가로 정렬을 의미하는 orderby도 한번 사용해 볼게요. Student에서 성이 이씨인 사람들을 뽑을건데 ID를 내림차순으로 정렬해보도록 하겠습니다. IEnumerable&lt;Student&gt; descendingByID = from student in students where (student.Name[0].ToString() == "이") orderby student.ID descending select student; Console.WriteLine("학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬"); foreach (Student student in descendingByID) { Console.WriteLine("{0}, {1}", student.Name, student.ID); }
되게 간단하네요.&nbsp; 마지막으로 select 대신에 group을 한번 사용해볼게요.Student 리스트에서 성으로 그룹핑을 하겠습니다. Console.WriteLine("학생들의 성으로 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstName= from student in students group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstName) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } Console.WriteLine("학생들의 성으로 내림차순으로 정렬 및 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescending= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescending) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } }
보시다시피 group을 사용하면 IGrouping을 반환해서 네스트 타입이 되네요. 일일이 타입을 적어주는 게 불편한 경우도 있죠. 그런 경우에는 암묵적 형식인 var 키워드를 사용해도 됩니다. var groupByFirstNameDescending2= from student in students orderby student.Name[0].ToString() descending group student by student.Name[0].ToString(); foreach (var group in groupByFirstNameDescending2) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } }
위에서 쿼리를 쿼리 구문을 이용해서 작성해 봤어요.&nbsp;쿼리 구문은 코드를 컴파일할 때 .NET CLR(공용 언어 런타임)에 대한 메서드 호출로 변환해야 합니다. 이러한 메서드 호출은&nbsp;Where,&nbsp;Select,&nbsp;GroupBy,&nbsp;Join,&nbsp;Max,&nbsp;Average&nbsp;등과 같은 표준 쿼리 연산자를 호출한다고 하네요. 따라서 우리는 쿼리 구문 대신 메서드 구문을 사용하여 연산자를 직접 호출할 수도 있어요.쿼리 구문과 메서드 구문은 의미상 동일하지만, 쿼리 구문이 더 간단하고 읽기 쉽다고 생각하는 사람이 많다고 합니다. 저도 쿼리 구문이 더 읽기가 쉬웠어요. 그러나 일부 쿼리는 메서드 호출로 표현해야 합니다. 예를 들어 필터를 하는 쿼리에서 요소 개수 또는 최댓값등을 얻으려면 메서드 호출을 사용해야 해요. 따라서 LINQ 쿼리를 작성하기 시작한 경우에도 쿼리 및 쿼리 식 자체에서 메서드 구문을 사용하는 방법을 잘 알고 있으면 유용합니다.위에서 쿼리 구문으로 작성한 쿼리를 메서드 문법으로 작성해 볼게요. // 메서드 구문 이용 Console.WriteLine("메서드 구문 이용해서"); IEnumerable&lt;Student&gt; notLessThan90Method = students.Where(student =&gt; student.scroes[0] &gt;= 90); Console.WriteLine("첫번째 시험에서 90점 이상 맞은 학생들"); foreach (Student student in notLessThan90Method) { Console.WriteLine("{0}, {1}", student.Name, student.scroes[0]); } IEnumerable&lt;Student&gt; descendingByIDMethod = students.Where(student =&gt; student.Name[0].ToString() == "이").OrderByDescending(student =&gt; student.ID); // from student in students // where (student.Name[0].ToString() == "이") // orderby student.ID descending // select student; Console.WriteLine("학생들중 이씨인 사람들 뽑아 ID를 내림차순으로 정렬"); foreach (Student student in descendingByIDMethod) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } Console.WriteLine("학생들의 성으로 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameMethod = students.GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } } Console.WriteLine("학생들의 성으로 내림차순으로 정렬 및 그룹화"); IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; groupByFirstNameDescendingMethod = students.OrderByDescending(student =&gt; student.Name[0].ToString()) .GroupBy(student =&gt; student.Name[0].ToString()); foreach (IGrouping&lt;string, Student&gt; group in groupByFirstNameDescendingMethod) { Console.WriteLine(group.Key); foreach (var student in group) { Console.WriteLine("{0}, {1}", student.Name, student.ID); } }
마지막으로 Concat() 메서드를 이용해서 학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID를 추출하겠습니다. Console.WriteLine("학생 리스트와 선생님 리스트를 합쳐서 홀수인 ID"); var oddIDInTeacherAndStudent = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)); foreach (var id in oddIDInTeacherAndStudent) { Console.WriteLine(id); }
위에서 쿼리 변수를 열심히 만들어서 출력해 봤는데요. 항상 맨 밑에 foreach가 존재합니다. 쿼리 변수는 사실 결과 데이터를 가지고 있지 않아요. 그저 명령만을 가지고 있습니다.&nbsp; 실제로 데이터를 얻기 위해서는 쿼리 실행을 해줘야 합니다. 쿼리 실행 하는 법은 foreach를 사용해서 루프를 돌게 하면 되겠습니다.즉시 실행을 하기 위해서는 Count(), Average(), Max() 등 결과를 얻기 위해 foreach를 암묵적으로 사용하는 메서드 문법을 사용하거나, ToList, ToArray 같은 것을 사용해서 결과를 바로 캐시 하는 방법을 사용하면 됩니다. var oddIDCount = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).Count(); Console.WriteLine(oddIDCount); var oddIDList = students.Where(student =&gt; student.ID % 2 == 0).Select(x =&gt; x.ID) .Concat(teachers.Where(teacher =&gt; teacher.ID % 2 == 0).Select(x =&gt; x.ID)).ToList(); Console.WriteLine(String.Join(" ", oddIDList));
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/LINQ_Practice" target="_self">https://github.com/psychehose/LINQ_Practice</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/" target="_self">https://learn.microsoft.com/ko-kr/dotnet/csharp/linq/</a>]]></description><link>csharp/linq.html</link><guid isPermaLink="false">csharp/LINQ.md</guid><pubDate>Tue, 31 Dec 2024 06:01:06 GMT</pubDate></item><item><title><![CDATA[28. Plate Pick up Objects]]></title><description><![CDATA[Player가 그릇에 KitchenObject를 두는 로직을 구현하도록 하겠습니다.제약사항은 다음과 같습니다.
같은 KitchenObject가 들어가면 안됨
Valid한 KitchenObject만 들어가야함
가능한 경우는 두 가지입니다. 첫 번째는 ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직입니다. 두 번째는 ClearCounter에 KitchenObject(그릇 제외)가 놓여져 있고, Player가 들고 있는 그릇에 놓는 로직입니다.ClearCounter에 그릇이 놓여져 있고 Player가 KitchenObject(그릇 제외)를 놓는 로직부터 구현 하겠습니다.PlateKitchenObject 스크립트를 생성합니다. 이는 KitchenObject를 상속합니다. Plate Prefab에 스크립트를 넣고 레퍼런스로 Scriptable Object를 넣습니다.<img src="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">// ClearCouter.cs public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject() is PlateKitchenObject) { // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter plateKitchenObject.AddIngredient(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
여기에서 제약조건을 추가해야 합니다. - 이미 가지고 있는 타입인 경우에 어떠한 액션도 일어나지 않게 하겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlateKitchenObject : KitchenObject
{ private List&lt;KitchenObjectSO&gt; kitchenObjectSOArray; private void Awake() { kitchenObjectSOArray = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (kitchenObjectSOArray.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOArray.Add(kitchenObjectSO); return true; } } }
ClearCounter에 있는 함수 AddIngredienet를 TryAddIngredent로 리팩토링 하겠습니당// ClearCouter.cs if (player.GetKitchenObject() is PlateKitchenObject)
{ // Player is holding plate -&gt; Logic PlateKitchenObject plateKitchenObject = player.GetKitchenObject() as PlateKitchenObject; // Kitchen Object holded by ClearCounter if(plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); }
}
제약조건 추가하기 - 유효한 KitchenObject만 넣을 수 있게 할게요
토마토슬라이스
치즈슬라이스
빵
양배추 슬라이스
익힌 고기패티
탄 고기패티
public class PlateKitchenObject : KitchenObject { [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOList; }
<br><img src="https://blog.kakaocdn.net/dn/cj2Xuj/btssACqprSj/ONuQLp1IF5IhnmfiTsAgDk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlateKitchenObject : KitchenObject
{ [SerializeField] private List&lt;KitchenObjectSO&gt; validKitchenObjectSOListy; private List&lt;KitchenObjectSO&gt; kitchenObjectSOList; private void Awake() { kitchenObjectSOList = new List&lt;KitchenObjectSO&gt;(); } public bool TryAddIngredient(KitchenObjectSO kitchenObjectSO) { if (!validKitchenObjectSOListy.Contains(kitchenObjectSO)) { return false; } if (kitchenObjectSOList.Contains(kitchenObjectSO)) { // Already has this type return false; } else { kitchenObjectSOList.Add(kitchenObjectSO); return true; } } }
코드 리팩토링을 진행할게요. KitchenObject에&nbsp; TryGetPlate 메서드를 만들어서 이것을 사용하도록 할게요. plateKitchenObject를 얻기 위해서 GetKitchenObject를 호출하고 as를 이용해서 타입캐스팅을 하는데 이것을 더 안전하게 하기 위해서 out parameter를 이용하도록 하겠습니다.// KitchenObject.cs
public bool TryGetPlate(out PlateKitchenObject plateKitchenObject) { if (this is PlateKitchenObject) { plateKitchenObject = this as PlateKitchenObject; return true; } else { plateKitchenObject = null; return false; } }
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
ClearCounter에서 열심히 만든 부분을 StoveCounter, CuttingCounter에도 똑같이 적용하도록 하겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter, IHasProgress
{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } // State Machine 초기화 state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter, IHasProgress
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler OnCut; private int cuttingProgress; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgress = 0; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgress++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnCut?.Invoke(this, EventArgs.Empty); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax }); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgress) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }
}
이제는 ClearCounter에 그릇이 놓여져 있고 그릇에 KitchenObject를 위치시키는 로직을 짜도록 하겠습니다.ClearCounter가 HasKitchenObject가 true인 경우에서 Player가 KitchenObject를 가지고 있지만 그릇이 아닌 경우에서 ClearCounter가 그릇을 가지고 있는 경우를 생각하면 됩니다. 말로 전달하니 조금 복잡한 것 같네요.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { // There is kitchen object here if (player.HasKitchenObject()) { // Player is carrying something. if (player.GetKitchenObject().TryGetPlate(out PlateKitchenObject plateKitchenObject)) { // Player is holding plate -&gt; Logic // Kitchen Object holded by ClearCounter if (plateKitchenObject.TryAddIngredient(GetKitchenObject().GetKitchenObjectSO())) { GetKitchenObject().DestroySelf(); } } else { // Player is not holding plate but something else if (GetKitchenObject().TryGetPlate(out plateKitchenObject)) { // There is Plate in Clear Counter if (plateKitchenObject.TryAddIngredient(player.GetKitchenObject().GetKitchenObjectSO())) { player.GetKitchenObject().DestroySelf(); } } } } else { // Player is not carrying anything GetKitchenObject().SetKitchenObjectParent(player); } } }
}
&nbsp;끝!]]></description><link>unity/28.-plate-pick-up-objects.html</link><guid isPermaLink="false">Unity/28. Plate Pick up Objects.md</guid><pubDate>Tue, 31 Dec 2024 06:00:03 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/wEEFa/btssvXhzrZn/0hm8dJDRjYc7vO0TF6pGCk/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[27. Plates Counter]]></title><description><![CDATA[접시가 생성되는 PlatesCounter를 만들어봅시다. Prefab을 만들어줍시다.스크립트를 생성합니다. PlatesCounter는 일정 시간이 흐르면 접시가 하나씩 생성되고 이미 존재한다면 그 위에 쌓아야 합니다.Plates Scriptable Object (기존에 만든 KitchenObjectSO로), Plate Object를 생성합니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; } } }
}
Visual을 담당하는 스크립트도 만듭시다. 왜냐하면 그릇을 쌓아야 하기 때문입니다. 따라서, Visual에는 TopPoint와 그릇 Visual Prefab을 알고 있어야겠죠?using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab;
}
<img src="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 PlatesCounter에서 이벤트 핸들러를 만들고 Invoke를 해줍시다. 그런 다음에 Visual에서 리슨 해주면 되겠네요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; private float spawnPlateTimer; private float spawnPlateTimerMax; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); }
}
근데 뭔가 잘못된 거 같아요. 그릇들을 쌓으려면 그릇 List를 가지고 있어야하고 Vector를 높이는 코드가 없어요. 처리 ㄱㄱusing System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }
}
여기까지 하면 그릇을 추가하면 슉슉하고 올라갑니다. 이제 플레이어가 그릇을 가져가는 코드를 작성합시다. PlatesCounter에서 Remove 이벤트 핸들러를 만들어주고&nbsp;Interact가 발생하면&nbsp;&nbsp;이를 Invoke하면 되겠죠?using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO plateKitchenObjectSO; public event EventHandler OnPlateSpawned; public event EventHandler OnPlateRemoved; private float spawnPlateTimer; private float spawnPlateTimerMax = 4f; private int platesSpawnedAmount; private int platesSpawnedAmountMax = 4; private void Update() { spawnPlateTimer += Time.deltaTime; if (spawnPlateTimer &gt; spawnPlateTimerMax) { spawnPlateTimer = 0f; if (platesSpawnedAmount &lt; platesSpawnedAmountMax) { platesSpawnedAmount++; OnPlateSpawned?.Invoke(this, EventArgs.Empty); } } } public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player is empty Handed if (platesSpawnedAmount &gt; 0) { // There is at least one plate here platesSpawnedAmount--; KitchenObject.SpawnKitchenObject(plateKitchenObjectSO, player); // Update Visual OnPlateRemoved?.Invoke(this, EventArgs.Empty); } } }
}
비쥬얼에서 그릇 가져가는 이벤트를 리스닝 합시다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class PlatesCounterVisual : MonoBehaviour
{ [SerializeField] private PlatesCounter platesCounter; [SerializeField] private Transform counterTopPoint; [SerializeField] private Transform plateVisualPrefab; private List&lt;GameObject&gt; plateVisualGameObjectList; private void Awake() { plateVisualGameObjectList = new List&lt;GameObject&gt;(); } private void Start() { platesCounter.OnPlateSpawned += PlatesCounter_OnPlateSpawned; platesCounter.OnPlateRemoved += PlatesCounter_OnPlateRemoved; } private void PlatesCounter_OnPlateRemoved(object sender, EventArgs e) { GameObject gameObject = plateVisualGameObjectList[plateVisualGameObjectList.Count - 1]; plateVisualGameObjectList.Remove(gameObject); Destroy(gameObject); } private void PlatesCounter_OnPlateSpawned(object sender, EventArgs e) { Transform plateVisualTransform = Instantiate(plateVisualPrefab, counterTopPoint); float plateOffsetY = .1f; plateVisualTransform.localPosition = new Vector3(0, plateOffsetY * plateVisualGameObjectList.Count, 0); plateVisualGameObjectList.Add(plateVisualTransform.gameObject); }
}
]]></description><link>unity/27.-plates-counter.html</link><guid isPermaLink="false">Unity/27. Plates Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:59:01 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bM3h4h/btssvfv038x/0BIuGowfld7CwhbL9Ti9Y0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[26. Stove Counter]]></title><description><![CDATA[고기를 굽는 StoveCounter를 만들어봅시다. 역시 Prefab을 먼저 만들어야 합니다. StoveCounter는 익히기 전 익힌 후의 오브젝트 input, output이 있기 때문에 Scriptable Object Script를 만들겠습니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class FryingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public float fryingTimerMax;
}
이제 고기 상태에 따라 Meet Uncooked, Cooked, Burned의 Scriptable Object와 Prefab을 만듭시다.<img src="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bagZDK/btssAHL3PhM/rXjdwUtJkw8eAJT6pyGOr0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cx1MPZ/btssk1SBRSJ/VBwrujauNrjjP9KSciFCPk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/cSdtLN/btssBZyGhGf/JruIsm7eW6zkIP6BxFqlzK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">StoveCounter 스크립트를 만들고 SerializedField를 만들어줍시다. 그런 다음에 유니티로 돌아가서 레퍼런스를 넣어줍시다.public class StoveCounter : BaseCounter
{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray;
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; private float fryingTimer; private FryingRecipeSO fryingRecipeSO; private void Update() { if (HasKitchenObject()) { fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { Debug.Log("Fried"); fryingTimer = 0f; GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); } Debug.Log(fryingTimer); } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; }
}
위 코드는 문제가 발생 합니다. 시간은 계속 흐르기 때문에 오브젝트(고기)가 사라지고 output 오브젝트가 계속 새로 생깁니다. 이 문제를 해결하기 위해서 State Machine 개념을 도입해야 합니다. 처리하기 쉽게 Enum을 사용하도록 합시다. 그리고 State에 Burned도 있기 때문에 유사하게 Burning SO도 만듭시다.[CreateAssetMenu()]
public class BurningRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public float burningTimerMax;
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ private enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
StoveCounter에 Animation을 넣읍시다. StoveCounterVisual 스크립트를 생성할게요using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounterVisual : MonoBehaviour
{ [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; [SerializeField] private StoveCounter stoveCounter;
}
StoveCounter에서 EventHandler를 만들고 Invoke 할게요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter
{ public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
StoveCounterVisual에서 이벤트를 리슨 하는 코드를 작성!using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounterVisual : MonoBehaviour
{ [SerializeField] private StoveCounter stoveCounter; [SerializeField] private GameObject stoveOnGameObject; [SerializeField] private GameObject particlesGameObject; private void Start() { stoveCounter.OnStateChanged += StoveCounter_OnOnStateChanged; } private void StoveCounter_OnOnStateChanged(object sender, StoveCounter.OnStateChangedEventArgs e) { bool showVisual = e.state == StoveCounter.State.Frying || e.state == StoveCounter.State.Fried; stoveOnGameObject.SetActive(showVisual); particlesGameObject.SetActive(showVisual); }
}
ProgressBar를 만듭시다. 전에 CuttingCounter에서 만든 거와 동일해요 그래서 재사용 가능using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public interface IHasProgress
{ public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged; public class OnProgressChangedEventArgs: EventArgs { public float progressNormalized; }
}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private GameObject hasProgressGameObject; [SerializeField] private Image barImage; private IHasProgress hasProgress; private void Start() { hasProgress = hasProgressGameObject.GetComponent&lt;IHasProgress&gt;(); if (hasProgress == null) { Debug.LogError("GameObject " + hasProgressGameObject + " does not have a component that implements IHasProgress"); } hasProgress.OnProgressChanged += HasProgress_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void HasProgress_OnProgressChanged(object sender, IHasProgress.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }
}
StoveCounter에서 Confirm 합시다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class StoveCounter : BaseCounter, IHasProgress
{ public event EventHandler&lt;IHasProgress.OnProgressChangedEventArgs&gt; OnProgressChanged; public event EventHandler&lt;OnStateChangedEventArgs&gt; OnStateChanged; public class OnStateChangedEventArgs : EventArgs { public State state; } public enum State { Idle, Frying, Fried, Burned } [SerializeField] private FryingRecipeSO[] fryingRecipeSOArray; [SerializeField] private BurningRecipeSO[] burningRecipeSOArray; private State state; private float fryingTimer; private float burningTimer; private FryingRecipeSO fryingRecipeSO; private BurningRecipeSO burningRecipeSO; private void Start() { state = State.Idle; } private void Update() { if (HasKitchenObject()) { switch (state) { case State.Idle: break; case State.Frying: fryingTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); if (fryingTimer &gt; fryingRecipeSO.fryingTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(fryingRecipeSO.output, this); state = State.Fried; burningTimer = 0f; burningRecipeSO = GetBurningRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); } break; case State.Fried: burningTimer += Time.deltaTime; OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = burningTimer / burningRecipeSO.burningTimerMax }); if (burningTimer &gt; burningRecipeSO.burningTimerMax) { GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(burningRecipeSO.output, this); state = State.Burned; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } break; case State.Burned: break; } } } public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be fried player.GetKitchenObject().SetKitchenObjectParent(this); fryingRecipeSO = GetFryingingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); state = State.Frying; fryingTimer = 0f; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = fryingTimer / fryingRecipeSO.fryingTimerMax }); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); state = State.Idle; OnStateChanged?.Invoke(this, new OnStateChangedEventArgs { state = state }); OnProgressChanged?.Invoke(this, new IHasProgress.OnProgressChangedEventArgs { progressNormalized = 0f }); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); return fryingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { FryingRecipeSO fryingRecipeSO = GetFryingingRecipeSOWithInput(inputKitchenObjectSO); if (fryingRecipeSO != null) { return fryingRecipeSO.output; } else { return null; } } private FryingRecipeSO GetFryingingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (FryingRecipeSO fryingRecipeSO in fryingRecipeSOArray) { if (fryingRecipeSO.input == inputKitchenObjectSO) { return fryingRecipeSO; } } return null; } private BurningRecipeSO GetBurningRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (BurningRecipeSO burningRecipeSO in burningRecipeSOArray) { if (burningRecipeSO.input == inputKitchenObjectSO) { return burningRecipeSO; } } return null; }
}
끝!]]></description><link>unity/26.-stove-counter.html</link><guid isPermaLink="false">Unity/26. Stove Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:58:13 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/859KI/btssB0dixgx/qofCKT7qYqYJfwQzrlzxMK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[25. Trash Counter]]></title><description><![CDATA[어떤 오브젝트도 버릴 수 있는 TrashCounter를 만듭시다.TrashCounter Prefab을 먼저 만들기_BaseCounter -&gt; Create Prefab Variant -&gt; TrashCounter로 네이밍프리팹에 들어가서 TrashCounter_Visual 넣고 복사해서 Selected로 네이밍 합니다.&nbsp; 그런 다음에 Selected에 SelectedCounter 스크립트를 넣어주기 그리고 Mesh 설정, Scale 1.01배 설정 등 귀찮은 작업들을 해줍시다.<img src="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Script를 생성합니다. 로직은 매우 단순해요. 인터렉트가 발생하면 플레이어가 가지고 있는 오브젝트를 없애면 되겠습니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class TrashCounter : BaseCounter { public override void Interact(Player player) { if (player.HasKitchenObject()) { player.GetKitchenObject().DestroySelf(); } }
}
<br><img src="https://blog.kakaocdn.net/dn/cwFk56/btsshrj0wKp/CjAEbaE6rG0AbuggrFQKGk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/25.-trash-counter.html</link><guid isPermaLink="false">Unity/25. Trash Counter.md</guid><pubDate>Tue, 31 Dec 2024 05:57:18 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/RQoee/btsshn2ZnsC/stSl6XzdYoM3wEGqPryWP1/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[24. Look At Camera]]></title><description><![CDATA[오브젝트마다 사용자에게 어떻게 보여줘야 할지 다른 경우가 있습니다. 이것을 일일이 설정하면 코드가 복잡해질 거예요. 이를 스크립트로 만들어서 필요한 경우 스크립트를 넣어서 핸들링하는 방법을 알아볼게요.LookAtCamera 스크립트를 생성할게요.using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine; public class LookAtCamera : MonoBehaviour
{ [SerializeField] private Mode mode; private enum Mode { LookAt, LookAtInverted, CameraForward, CameraForwardInverted } private void LateUpdate() { switch (mode) { case Mode.LookAt: // 예전에는 Camera.main이 캐시되지 않아서 배드 퍼포먼스여서 사용하지 않았으나 지금은 디폴트로 캐시되어서 사용 transform.LookAt(Camera.main.transform); break; case Mode.LookAtInverted: Vector3 dirFromCamera = transform.position - Camera.main.transform.position; transform.LookAt(transform.position + dirFromCamera); break; case Mode.CameraForward: transform.forward = Camera.main.transform.forward; break; case Mode.CameraForwardInverted: transform.forward = -Camera.main.transform.forward; break; } }
}
위처럼 enum으로 상태를 관리해줄게요. LookAt은 오브젝트가 카메라를 바라봅니다. (메인 카메라가 중앙에 있다면, 중앙을 향해서)LookAtInverted는 카메라를 바라보는 것은 같은데 좌우가 뒤집힙니다. CamerarForward는 메인 카메라 방향을 바라보지만, 기울어지지 않습니다. 역시 CameraForwardInverted는 좌우가 반전됩니다.유니티에서 오브젝트에 스크립트를 추가한 후에 설정해서 사용하면 됩니다.<img src="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/24.-look-at-camera.html</link><guid isPermaLink="false">Unity/24. Look At Camera.md</guid><pubDate>Tue, 31 Dec 2024 05:56:59 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bEcqIw/btsrYUSGloL/8hcn2UK8kyXKGbKNgv4XCk/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[23. Cutting Progress, World Canvas]]></title><description><![CDATA[이번에는 재료들을 컷할 때 몇 번 액션을 줘야 하는지 정하고 Cutting Counter 위에 프로그레스바를 넣을 거예요.토마토는 3번, 치즈는 3번, 양배추는 5번 F키를 눌러서 잘라줘야 합니다.원재료가 있고 이를 컷팅했을 때 Sliced 재료가 되어야 하니까 Scriptable Object를 만들어서 관리하는 게 좋아요.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class CuttingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output; public int cuttingProgressMax;
}
<img src="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Cutting Counter에 가서 로직을 작성해 볼까요? cuttingProgress라는 이름으로 int인 프로퍼티를 만들고 Player가 CuttingCounter에 원재료를 올려놓으면 0으로 초기화해줍니다. 그리고 F키를 눌러 InteractAlternate를 하게 되면 cuttingProgress를 높이면 되겠습니다.그 외 코드들은, CuttingRecipeSO의 input인 토마토, 치즈, 양배추만 컷팅 카운터에 올릴 수 있게 하는 코드입니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; private int cuttingProgess; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); cuttingProgess = 0; } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut cuttingProgess++; CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); if (cuttingRecipeSO.cuttingProgressMax &lt;= cuttingProgess) { KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(GetKitchenObject().GetKitchenObjectSO()); GetKitchenObject().DestroySelf(); KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); return cuttingRecipeSO != null; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(inputKitchenObjectSO); if (cuttingRecipeSO != null) { return cuttingRecipeSO.output; } else { return null; } } private CuttingRecipeSO GetCuttingRecipeSOWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO; } } return null; }
}
그리고 [SerializedField]로 설정했기 때문에 유니티에서 꼭 레퍼런스를 지정해 주세요.<br><img src="https://blog.kakaocdn.net/dn/EHheN/btsrNBG5Htz/5kSMlkvN7e2r0aa6DSXp41/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CuttingCounter 하위에 Empty Object를 만들고, Render Mode를 World Space로 바꿔줍시다. Rect Transform에서 Position과 width, height를 다 0으로 설정합시다. 그리고 프로그레스 바를 어디에다가 띄울지 위치를 대충 결정해 주면 됩니다. 그런 다음에 하위에 Image를 만들게요.Image를 눌러서 Color를 정해주고 Source 이미지에 White 1x1을 넣어주세요.<br><img src="https://blog.kakaocdn.net/dn/u82GH/btsrSKXRW5u/LN0bud5Z4lOEzRdYJkIYFK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Image type을 정해줍시다.Image Type에는 아래 4종류가 있습니다.
Simple
Tiled
Sliced
Filled
저는 Filled를 선택할게요. Fill Amount를 조정하면 아까 위에서 설정한 Source Image(하얀색)에서 우리가 설정한 색깔(노란색)로 변합니다. 1이면 전체가 노란색으로 채워집니다. 노란색으로 채우는 방법도 여러 가지입니다. Fill Method에서 Horizontal로 설정하면 왼쪽에서부터 가로로 채워집니다.<br><img src="https://blog.kakaocdn.net/dn/sqVRe/btsrSM2rv0c/rM2KN55cTnmJ1whSzup6Lk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/GCYaK/btsrYVRyRXh/qsaIsO3P6wNKrV18kv5Atk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">위처럼 백그라운드 설정하기 위해서 먼저 Bar를 복사하고 이름을 Background로 짓습니다. 그런 다음에 Simple로 바꾸고 색깔을 검은색으로 하면 됩니다. 여기에서 중요한 것이 Bar보다 위에 위치시켜야 한다는 점입니다. 순서대로 그리기 때문입니다.Background에 아웃라인을 좀 더 주고 명확하게 하고 싶어서 컴포넌트를 추가하겠습니다.<br><img src="https://blog.kakaocdn.net/dn/AIGG7/btsrIb9Pm3Z/4S8qXoMIqZOHhTziVLSPQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">CuttingCounter에서 ProgressUI를 분리하는 것이 더 깔끔하기 때문에 스크립트를 생성하고 ProgressBarUI로 이름 짓겠습니다. 스크립트를 ProgressBarUI에 어태치 해주세요.SerializedField로 CuttingCounter, Image를 선언하고 유니티에서 레퍼런스를 지정해 줍시다.public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image image;
}
CuttingCounter에서 이벤트로 ProgressBarUI에 이벤트를 넘겨줘야 하기 때문에 CuttingCounter에서 EventHandler를 만들고, 명확하게 몇 번 컷팅했는 지를 보내야 하기 때문에, EventArgus도 만들어줘야 합니다. 그런 다음에 InteractAlternate에서 Invoke 해주면 되겠죠?CuttingCounter.cs
// ...
public event EventHandler&lt;OnProgressChangedEventArgs&gt; OnProgressChanged;
public class OnProgressChangedEventArgs: EventArgs
{ public float progressNormalized;
} //... // CuttingCounter.cs (InteractAlternate 메서드 안) CuttingRecipeSO cuttingRecipeSO = GetCuttingRecipeSOWithInput(GetKitchenObject().GetKitchenObjectSO()); OnProgressChanged?.Invoke(this, new OnProgressChangedEventArgs
{ progressNormalized = (float) cuttingProgress / cuttingRecipeSO.cuttingProgressMax
});
이벤트를 Invoke 하는 코드를 만들었으니, ProgressBarUI에서 이벤트를 리스닝하는 코드를 작성하면 되겠습니다.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI; public class ProgressBarUI : MonoBehaviour
{ [SerializeField] private CuttingCounter cuttingCounter; [SerializeField] private Image barImage; private void Start() { cuttingCounter.OnProgressChanged += CuttingCounter_OnProgressChanged; barImage.fillAmount = 0f; Hide(); } private void CuttingCounter_OnProgressChanged(object sender, CuttingCounter.OnProgressChangedEventArgs e) { barImage.fillAmount = e.progressNormalized; if (e.progressNormalized == 0f || e.progressNormalized == 1f) { Hide(); } else { Show(); } } private void Hide() { gameObject.SetActive(false); } private void Show() { gameObject.SetActive(true); }
}
이제 마지막으로 Cutting 애니메이션을 넣도록 하겠습니다.CuttingCounter에서 OnCut이라는 이벤트 핸들러를 만들고 역시 InteracteAlternate()에서 Invoke 해줍시다.public event EventHandler OnCut; OnCut?.Invoke(this, EventArgs.Empty);
CuttingCounterVisual 스크립트를 만들어줄게요.public class CuttingCounterVisual : MonoBehaviour { [SerializeField] private CuttingCounter cuttingCounter; private Animator animator; private const string CUT = "Cut"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { cuttingCounter.OnCut += CuttingCounter_OnCut; } private void CuttingCounter_OnCut(object sedner, System.EventArgs e) { animator.SetTrigger(CUT); } }
SerializedField를 선언했으면? 당연히 레퍼런스를 넣어줘야겠죠? 끝!<br><img src="https://blog.kakaocdn.net/dn/lpEMX/btsrSNNNpx1/JXtASI1Rj7lKfM41TlNWJK/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/23.-cutting-progress,-world-canvas.html</link><guid isPermaLink="false">Unity/23. Cutting Progress, World Canvas.md</guid><pubDate>Tue, 31 Dec 2024 05:56:38 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bHoGJy/btsrNnITVGn/VhNp49vAKf17R78SjQF9B0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[22. Cutting Recipe SO]]></title><description><![CDATA[지난번에 언급했던 문제점!하드코딩 되어있기 때문에 어떤 재료든 컷팅하며 슬라이스 토마토가 되어있는 이슈를 해결하도록 하겠습니다.각각 종류에 맞는 슬라이스로 만드는 것이 목표입니다.Scriptable Object를 이용해서 해결해봅시다. 고고대력 흐름은 CuttingRecipeSO를 만들어서 Input과 outpt으로 원재료 -&gt; 슬라이스로 다루는 것입니다.Input - 토마토, 치즈, 양배추Output - 토마토 슬라이스, 치즈 슬라이스, 양배추 슬라이스제약조건도 추가해줘야 합니다. 이미 잘린 것은 또 자를 수 없기 때문에요먼저 CuttingRecipeSO 스크립트를 만듭시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; [CreateAssetMenu()]
public class CuttingRecipeSO : ScriptableObject
{ public KitchenObjectSO input; public KitchenObjectSO output;
}
유니티에서 노가다를 통해서 프리팹과 SO를 만듭시다. 처음엔 드래그 앤 드랍 싫고 그랬는데 익숙해지면 소소한 재미가 있더라고요.KitchenObjectSO - 치즈슬라이스랑, 캐비지 슬라이스 만들기KitchenObject - 치즈 슬라이스, 캐비지 슬라이스 만들기CuttingRecipeSO - 토마토,치즈,캐비지 만들기<img src="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 CuttingCounter에서 로직 구현을 할 차례예요.시리얼라이즈드 필드로 CuttingRecipeSO를 배열로 들고 있어야하고, KitchenObjectSO를 리턴하는 메서드가 필요하겠네요.그리고 이미 잘린 것은 또 못자르게 로직을 구현합시다.&nbsp;간단하게 CuttingCounter가 가지고 있는 KitchenObject가 루프를 돌아서 이게 Recipe의 Input과 같으면, 잘라주면 됩니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private CuttingRecipeSO[] cuttingRecipeSOArray; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying if (HasRecipeWithInput(player.GetKitchenObject().GetKitchenObjectSO())) { // Player is carrying something can be cut player.GetKitchenObject().SetKitchenObjectParent(this); } } else { // Player is not carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject() &amp;&amp; HasRecipeWithInput(GetKitchenObject().GetKitchenObjectSO())) { // There is Kitchen Object here AND it can be cut KitchenObjectSO outputKitchenObjectSO = GetOutputForInput(kitchenObject.GetKitchenObjectSO()); kitchenObject.DestroySelf(); // Cutting KitchenObject.SpawnKitchenObject(outputKitchenObjectSO, this); } } private bool HasRecipeWithInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return true; } } return false; } private KitchenObjectSO GetOutputForInput(KitchenObjectSO inputKitchenObjectSO) { foreach (CuttingRecipeSO cuttingRecipeSO in cuttingRecipeSOArray) { if (cuttingRecipeSO.input == inputKitchenObjectSO) { return cuttingRecipeSO.output; } } return null; }
}
마지막으로 유니티로 돌아가서 시리얼라이즈드 필드에 아래처럼 SOArray 레퍼런스를 잘 넣어주면 끝!<br><img src="https://blog.kakaocdn.net/dn/MeJop/btsqYqfsKQm/cI5DI71dFiLKeLt6TObc11/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/22.-cutting-recipe-so.html</link><guid isPermaLink="false">Unity/22. Cutting Recipe SO.md</guid><pubDate>Tue, 31 Dec 2024 05:55:48 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/mgwAL/btsqZzQjQBT/GJs0tuDeNMlEe8ZilvrSkk/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[21. Cutting Counter, Interact Alternate]]></title><description><![CDATA[이번에는 CuttingCounter를 만들게요!플레이어는 Cutting Counter에서 치즈, 토마토, 양배추를 놓고 자를 수 있어요. 그래서 놓고 드는 인터렉트 말고 다른 인터렉트가 필요할 거예요!프리팹을 먼저 만들게요. _BaseCounter를 선택하고 Prefab Variant를 클릭해서 만들어줍시다. 그리고 비주얼 넣고, 선택되었을 때 처리를 하면 되겠죠? 스크립트도 만들어서 어태치 하고 BaseCounter를 상속하게 합니다.그리고 유니티로 돌아와서 레퍼런스를 넣어줍시다. 처음에 할 때 이 과정이 복잡했는데, 이제는 조금 익숙해져서 다행이네요. 역시 반복이 답이제 자르는 인터렉트 키를 만들어봅시다.Input System에서 열고 InteractAlternate 추가하고 F로 설정! Save Asset 누르는 거 잊지 말기<img src="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Input System에서 액션을 만들어줬기 때문에 이것을 등록하고 구현해야겠죠? 이미 구현한 Interact처럼 하면 됩니다.
GameInput.cs에 등록
Player가 Interact를 하기 때문에 Player.cs에서 등록 및 구현
BaseCounter에서 구현
코드를 작성해 봅시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using UnityEngine.InputSystem; public class GameInput : MonoBehaviour { public EventHandler OnInteractAction; // 새로 구현한 곳 public EventHandler OnInteractAlternateAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Subscribe 코드 playerInputActions.Player.Interact.performed += Interact_performed; playerInputActions.Player.InteractAlternate.performed += InteractAlternateOnperformed; }
// 새로 구현한 곳 private void InteractAlternateOnperformed(InputAction.CallbackContext obj) { OnInteractAlternateAction?.Invoke(this, EventArgs.Empty); } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }
}
Player.cs에 추가합시다.private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction;
// 새로 추가됨 gameInput.OnInteractAlternateAction += OnInteractAlternateAction; }
// 새로 추가됨 private void OnInteractAlternateAction(object sender, EventArgs e) { if (selectedCounter != null) { selectedCounter.InteractAlternate(this); } }
BaseCounter에 구현을 하러 갑시다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void InteractAlternate(Player player) { Debug.LogError("InteractAlternate.Interact();"); } public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
이제 CuttingCounter에서 overriding을 구현해야 해요. 그전에 Cutting을 했을 때 원래 있던 KitchenObject가 새로운 KitchenObject(Ex: 토마토 -&gt; 잘린 토마토)로 변해야므로 새로운 KitchenObjectSO와 KitchenObject를 만들겠습니다.일단 바로 추가할 수 있는 Destory()를 먼저 구현할게요(토마토 -&gt; 잘린 토마토인 경우 토마토 객체를 먼저 없애줘야 하므로)using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError("IKitchenObjectParent already has kitchen object"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; } // 새로 추가된 부분 public void DestroySelf() { kitchenObjectParent.ClearKitchenObject(); Destroy(gameObject); }
}
잘린 토마토 슬라이스 Scriptable Object와 프리팹을 유니티에서 만듭시다.<br><img src="https://blog.kakaocdn.net/dn/0QIKK/btsqYZ9QisQ/e0ETQgs7TAA2kRdfLderD0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">다 만든 다음에, CuttingCounter 코드를 작성 ㄱㄱusing System.Collections;
using System.Collections.Generic;
using UnityEngine; public class CuttingCounter : BaseCounter
{ [SerializeField] private KitchenObjectSO cuttingKitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player is carrying player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Player is carrying } } else { if (player.HasKitchenObject()) { // Player가 is not carrying anythinh } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } } public override void InteractAlternate(Player player) { if (HasKitchenObject()) { // There is Kitchen Object here kitchenObject.DestroySelf(); // Cutting Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); } }
}
코드에서, 다음 두 라인이 CuttingCounter.cs와 ContainerCounter.cs에서 공통적으로 사용됩니다. 따라서 리펙토링 대상이겠죠? 고고Transform kitchenObjectTransform = Instantiate(cuttingKitchenObjectSO.prefab);
kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player);
KitchenObject.cs에서 static 메서드로 만들어줍시다.public static KitchenObject SpawnKitchenObject(KitchenObjectSO kitchenObjectSO, IKitchenObjectParent kitchenObjectParent) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); KitchenObject kitchenObject = kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;(); kitchenObject.SetKitchenObjectParent(kitchenObjectParent); return kitchenObject; }
// ContainerCounter.cs
public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 KitchenObject.SpawnKitchenObject(kitchenObjectSO, player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }
마지막으로 Cutting Counter에 시리얼라이즈드 필드를 사용했으니 유니티에서 레퍼런스(만들어 놓은 Tomato Slice SO)를 넣어주면 끝!여기까지 하면, 토마토를 자르면 잘린 토마토가 되는 걸 확인할 수 있어요. 근데 치즈를 잘라도 잘린 토마토가 나오기 때문에 다음에 이 문제를 해결하도록 하겠습니다!]]></description><link>unity/21.-cutting-counter,-interact-alternate.html</link><guid isPermaLink="false">Unity/21. Cutting Counter, Interact Alternate.md</guid><pubDate>Tue, 31 Dec 2024 05:55:05 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bdxlul/btsq2jFl4IZ/g0k04DNflNHdwiLoYbXus0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[20. Player Pick Up & Drop Object]]></title><description><![CDATA[이번에는 Player가 ContainerCounter에서 Object를 꺼내서 ClearCounter에 놓았다 들었다 하는 것을 구현할게요.public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!HasKitchenObject()) { if (player.HasKitchenObject()) { // Player가 가지고 있음 player.GetKitchenObject().SetKitchenObjectParent(this); } else { // Nothing } } else { if (player.HasKitchenObject()) { // Player가 가지고 있으면 아무것도 해선 안됨 } else { // Player에 손에 들게 해야함 GetKitchenObject().SetKitchenObjectParent(player); } } }
}
컨터이너에서 오브젝트를 꺼내고, 바로 컨테이너에서 인터렉트를 할 시에 에러가 발생해야 해요. 왜냐하면 플레이어가 오브젝트를 들고 있지 않을 때만 인터렉트를 해야 하기 하기 때문이에요.using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { if (!player.HasKitchenObject()) { // Player가 아무것도 들고 있지 않을 때 interact 하기 Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); } }
}
현재는 KitchenObject가 Tomato, CheeseBlock만 존재합니다. Bread와, Cabbage를 추가하고 이것들을 담는 Prefab들을 유니티에만 들게요.각각 KitchenObjectSO와, KitchenObject, ContainerPrefab을 만들고 씬에 배치하면 끝!<img src="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/20.-player-pick-up-&amp;-drop-object.html</link><guid isPermaLink="false">Unity/20. Player Pick Up &amp; Drop Object.md</guid><pubDate>Tue, 31 Dec 2024 05:54:14 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/ckiXLd/btsqYpOk2kL/87TQpkAwplqmGErcc8vAQ1/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[19. Container Counter와 상속]]></title><description><![CDATA[이번에는 물건을 꺼내오는 Container Counter를 구현할 거예요.이 게임에는 다양한 종류의 Counter가 존재합니다. 그래서 BaseCounter를 만들고 구체적인 카운터가 Base를 상속받게 하는 것이 좋습니다.프리팹도 베이스를 만들어 놓으면 프리팹을 정말 빠르게 만들 수 있습니다. 그래서 프리팹부터 만들어보도록 하겠습니다._BaseCounter로 이름 짓고 프리팹을 열어 CounterTopPoint를 넣어줍니다.<img src="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">_BaseCounter을 이용해서 ClearCounter 프리팹을 만들어볼게요.우클릭하고 Prefab Variant를 클릭합시다.<br><img src="https://blog.kakaocdn.net/dn/bjcUyF/btsqZvNH1vT/kKOpjwB2mkbPMhWrqC1pUK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러고나서 기존의 ClearCounter에 들어있는 Selected, ClearCounter_Visual을 복붙하고 스크립트를 잘 넣으면 됩니다.기존의 ClearCounter는 지워주면 되겠죠?<br><img src="https://blog.kakaocdn.net/dn/bMMeIK/btsqYP0df5o/et5dTWLLgxjIwzdMF1F2Bk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 _BaseCounter를 이용해서 ContainerCounter 프리팹을 만들게요.프리팹을 만들 때 설정해줘야 하는 건 다음과 같아요.
Visual Prefab(Asset) 끌당하기
복사해서 Selected 만들기
선택되었을 때, 하위 MeshRender 설정하기
Rendering 버그가 안 나게 선택되었을 때, Scale 전체 1.01로 수정하기
SelectedCounter에 스크립트 넣어주기
다 적용하면 아래처럼 사진처럼 됩니다.<br><img src="https://blog.kakaocdn.net/dn/dfUG6B/btsqXSQNHDr/d8M2SSux89DATZXuCm9KZK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 ContainerCounter 스크립트를 만든 다음 어태치 하고 코드를 작성할게요.public class ContainerCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool hasKitchenObject() { return kitchenObject != null; }
}
시리얼라이즈드필드 변수를 썼으니 어떻게 해야 된다? 유니티에서 레퍼런스를 추가해야 한다!&nbsp;추가 ㄱㄱ<br><img src="https://blog.kakaocdn.net/dn/biz7BP/btsqYZolSGD/qL5RsQqPyqQej5xaKm1AKK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 BaseCounter 스크립트를 만들어서 구체적인 Counter들의 부모로 사용할 거예요.public class BaseCounter : MonoBehaviour { public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); }
} 그런 다음에 Player.cs에서 ClearCounter를 BaseCounter로 변경
Container의 SelectedCounter를 설정해 볼까요. 현재는 SelectedCounterVisual이 시리얼라이즈 필드로 ClearCounter를 가지고 있는데 BaseCounter로 변경하고 그리고 GameObject는 Array로 바꿉시다.public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private BaseCounter baseCounter; [SerializeField] private GameObject[] visualGameObjectArray; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == baseCounter) { Show(); } else { Hide(); } } private void Show() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(true); } } private void Hide() { foreach (GameObject visualGameObject in visualGameObjectArray) { visualGameObject.SetActive(false); } }
}
시리얼라이즈드 필드를 바꿨으니 각각 프리팹의 Selected로 가서 레퍼런스를 다시 넣어줍시다.<br><img src="https://blog.kakaocdn.net/dn/bDYQ2I/btsqZgwz8EM/N0rgbcuxLhfrPAlFeWOu61/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/dWVoRR/btsqYpOi57P/vrQg3yTGe27xekzOSR59bK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드 겹치는 부분인 IKitchenObjectParent도 Base로 뺄게요.public class BaseCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private Transform counterTopPoint; protected KitchenObject kitchenObject; public virtual void Interact(Player player) { Debug.LogError("BaseCounter.Interact();"); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
public class ContainerCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); }
}
public class ClearCounter : BaseCounter { [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { }
}
상속을 하니까 코드 라인이 눈에 띄게 줄어들었네요.이제 ContainerCounter에 Animation을 넣어볼게요. Animator를 이용하면 되겠죠?먼저 ContainerCounter에서 인터렉트가 발생했을 때 ContainerCounterVisual에 이벤트를 넘겨주게 코드를 작성합시다.public class ContainerCounter : BaseCounter { public event EventHandler OnPlayerGrabbedObject; [SerializeField] private KitchenObjectSO kitchenObjectSO; public override void Interact(Player player) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(player); OnPlayerGrabbedObject?.Invoke(this, EventArgs.Empty); }
}
CountainerCounterVisual 스크립트를 생성하고 이벤트를 리스닝하는 코드를 작성하면 됩니다.public class CountainerCounterVisual : MonoBehaviour { [SerializeField] private ContainerCounter containerCounter; private Animator animator; private const string OPEN_CLOSE = "OpenClose"; private void Awake() { animator = GetComponent&lt;Animator&gt;(); } private void Start() { containerCounter.OnPlayerGrabbedObject += ContainerCounter_OnPlayerGrabbedObject; } private void ContainerCounter_OnPlayerGrabbedObject(object sedner, System.EventArgs e) { animator.SetTrigger(OPEN_CLOSE); } }
시리얼라이즈드 필드를 사용했으니 아래처럼 CotainerCounter_Visual에 레퍼런스를 넣고 구현을 마무리하면 되겠습니다! 끝<br><img src="https://blog.kakaocdn.net/dn/xiUU3/btsqYUHgX9Z/AKB4OKNI7LX6LecrI2CqgK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/19.-container-counter와-상속.html</link><guid isPermaLink="false">Unity/19. Container Counter와 상속.md</guid><pubDate>Tue, 31 Dec 2024 05:53:57 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/bOu4hG/btsq1FV4Tag/NIW3RY79kmqMpRdI6ULWn0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[18. Player Pick up, CSharp Interfaces]]></title><description><![CDATA[카운터들이 키친 오브젝트를 가지고 있는 경우도 있지만, 플레이어가 키친 오브젝트를 가지고 있는 경우도 있겠죠? 이를 Interface를 이용해서 리팩토링 하면 됩니다!인터페이스 스크립트를 만들게요.public interface IKitchenObjectParent { public Transform GetKitchenObjectFollowTransform(); public KitchenObject GetKitchenObject(); public void SetKitchenObject(KitchenObject kitchenObject); public void ClearKitchenObject(); public bool HasKitchenObject(); }
이렇게 만들면, KitchenObject가 ClearCounter를 가지고 있는 것 아니라 IKitchenObjectParent를 프로퍼티로 가지게 합니다. 수정을 해볼까요?public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private IKitchenObjectParent kitchenObjectParent; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public IKitchenObjectParent GetKitchenObjectParent() { return kitchenObjectParent; } public void SetKitchenObjectParent(IKitchenObjectParent kitchenObjectParent) { if (this.kitchenObjectParent != null) { this.kitchenObjectParent.ClearKitchenObject(); } this.kitchenObjectParent = kitchenObjectParent; if (kitchenObjectParent.HasKitchenObject()) { Debug.LogError("IKitchenObjectParent already has kitchen object"); } kitchenObjectParent.SetKitchenObject(this); transform.parent = kitchenObjectParent.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }
}
부모가 될 수 있는 ClearCounter로 가서 IKitchenObjectParent를 컨펌할게요. 그리고 인터렉트를 할 때, Clear Counter가 들고 있는 Kitchen Object의 부모를 Player로 바꿔줘야 하기 때문에 Interact의 파라미터에 Player가 필요해요.&nbsp;public class ClearCounter : MonoBehaviour, IKitchenObjectParent { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; public void Interact(Player player) { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetKitchenObjectParent(this); } else { // Player가 오브젝트를 잡게함 kitchenObject.SetKitchenObjectParent(player); } } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
}
Player도 IKitchenObjectParent를 컨펌합시다! 아직 플레이어는 ClearCounter가 가지고 있는 counterTopPoint (물건을 놓는 위치) 같은 것이 없어요. 이것을 SerializedField로 Transform kitchenObjectHoldPoint로 이름 짓고 Player 하위에 빈 객체를 하나 만들고 아래처럼 위치를 잡아줄게요. 그리고 Player Scirpt의 kitchenObjectHoldPoint에 레퍼런스로 넣어주면 되겠죠?<img src="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public class Player : MonoBehaviour, IKitchenObjectParent { public static Player Instance { get; set; } public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } private bool isWalking; private Vector3 lastInteractDir; private ClearCounter selectedCounter; private KitchenObject kitchenObject; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; [SerializeField] private LayerMask counterLayerMask; [SerializeField] private Transform kitchenObjectHoldPoint; private void Awake() { if (Instance != null) { Debug.LogError("Player가 한명보다 많습니다."); } Instance = this; } private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { if (selectedCounter != null) { selectedCounter.Interact(this); } } private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; // 회전을 부드럽게 하는 lerp, slerp transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // Implement: IKitchenObjectParent public Transform GetKitchenObjectFollowTransform() { return kitchenObjectHoldPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; } }
Interface를 이용한 리팩토링을 완료했어요. 이제 플레이어가 카운터에 있는 키친 오브젝트를 들 수 있게 되었습니다.]]></description><link>unity/18.-player-pick-up,-csharp-interfaces.html</link><guid isPermaLink="false">Unity/18. Player Pick up, CSharp Interfaces.md</guid><pubDate>Tue, 31 Dec 2024 05:53:02 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/MHBbV/btspGK7yUnL/ATNFhsFhtXkzcq8TDFAwPK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[13. Clear Counter - RayCast로 객체와 인터렉트하기]]></title><description><![CDATA[Empty Object(ClearCounter)를 생성하고 Prefab Asset(ClearCounter_Visual)을 만든 오브젝트에 끌어당겨 넣습니다.비주얼과 로직을 분리해야 하기 때문에 ClearCounter에 로직을 넣고 _Visual에는 UI 관련된 것을 넣습니다.따라서 ClearCounter에 ClearCounter.cs를 추가하고 Box Colider를 설정하고 크기는 Visual과 맞춥니다.그런 다음에 Player.cs를 작성할 것입니다.using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class Player : MonoBehaviour { private bool isWalking; [SerializeField] private float moveSpeed = 7f; [SerializeField] private GameInput gameInput; private void Update() { HandleMovement(); HandleInteractions(); } public bool IsWalking() { return isWalking; } private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float interactDistance = 2f; if (Physics.Raycast(transform.position, moveDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log("-"); } } private void HandleMovement() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); float moveDistance = Time.deltaTime * moveSpeed; float playerRadius = .7f; float playerHeight = 2f; bool canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDir, moveDistance ); if (!canMove) { // 움직일 수 없을 때 // X 축으로만 누를 때 Vector3 moveDirX = new Vector3(moveDir.x, 0, 0).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirX, moveDistance ); if (canMove) { moveDir = moveDirX; } else { // x축으로 움직일 수 없음 // z축 으로 움직임 시도 Vector3 moveDirZ = new Vector3(0,0,moveDir.z).normalized; canMove = !Physics.CapsuleCast( transform.position, transform.position + Vector3.up * playerHeight, playerRadius, moveDirZ, moveDistance ); if (canMove) { moveDir = moveDirZ; } else { // 어떤 방향으로도 이동 불가 } } } if (canMove) { transform.position += moveDir * moveDistance; } isWalking = moveDir != Vector3.zero; float rotationSpeed = 10f; transform.forward = Vector3.Slerp(transform.forward, moveDir, Time.deltaTime * rotationSpeed); }
}
Parameter에 out이 들어가는 경우는 일종의 콜백으로 생각하면 될 것 같습니다.위의 코드를 실행하면, 멈춰있을 때 이벤트가 발생하지 않아 인터렉션을 할 수가 없는 이슈가 있습니다. 그 이유는 HandleInteractions()에서 멈춰있을 때 moveDir이 0이기 때문입니다. 이것을 클래스 프로퍼티로 가지고 있으면 이슈를 해결할 수 있습니다.
// Player.cs // 클래스 프로퍼티로 가지고 있기
private Vector3 lastInteractDir; // ... /// private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { Debug.Log(raycastHit.transform); } else { Debug.Log("-"); } }
그리고 만든 Object Instance를 다음에 다른 인스턴스를 빠르게 생성하기 위해서 파일창으로 드래그 앤 드롭을 해서 Object Prefab으로 만듭니다.<img src="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Interact를 하기 위해서는 플레이어가 객체를 Identifying 할 수 있어야 합니다. 이때 유니티에서 제공하는 tag를 사용할 수 있으나, 코드에서 컴포넌트를 얻어서 처리하는 것이 더욱 효과적인 방법인 것 같습니다. Try-를 이용하면 null 체크까지 진행할 수 있습니다. 이제 HandleInteractions()을 수정하겠습니다.// Player.cs // ... // private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }
RayCast를 사용할 때 매개변수에 layerMask를 쓸 수 있습니다. 이것을 설정하면 Player의 rayCast가 반응하는 Layer들을 설정할 수 있게 됩니다.&nbsp; Counter layer를 Counters라고 만들고 Counter의 Layer를 Counters로 설정하겠습니다.<br><img src="https://blog.kakaocdn.net/dn/XC2Hp/btso8z4Fejb/nHJTV998t8IKb312TzGJQ0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/ct99it/btso09muO2Z/GdpNRfT1HIXmhhynng9EUk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그런 다음에 Player.cs에서 SerializeField를 설정합시다.// Player.cs [SerializeField] private LayerMask counterLayerMask;
그러고나서 유니티로 돌아와 Player 인스턴스를 클릭하고 Inspector에서 SerializeField를 설정하면 끝입니다.<br><img src="https://blog.kakaocdn.net/dn/RaakV/btso12gk3LK/UQmJClmkttamek63c4N8F0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 Player는 아래처럼 Layer가 Counters로 설정된 오브젝트에만 인터렉트를 하게 됩니다!<br><img src="https://blog.kakaocdn.net/dn/D96LV/btso7R5xiII/WZahA3bPsoVxmdF6R2L0K1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/13.-clear-counter-raycast로-객체와-인터렉트하기.html</link><guid isPermaLink="false">Unity/13. Clear Counter - RayCast로 객체와 인터렉트하기.md</guid><pubDate>Tue, 31 Dec 2024 05:52:25 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/smVIS/btso92Fvym8/NfLEVA6E2TKPJN5Ry26OxK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[14. Interact Action Events]]></title><description><![CDATA[Player가 Object에 갔을 때 Interact를 하는 것을 개발하겠습니다.&nbsp;Input System 열어서 Actions에 Interact를 생성하고 'E'를 바인딩합시다.<img src="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이벤트의 흐름은 아래와 같아요.
GameInput -&gt; Player -&gt; ClearCounter
먼저 GameInput.cs를 열어 코드를 작성해 볼까요? 어떻게 구현하면 될까요?Input System에서 Interact가 발생했을 때 알아채기 위해서 우리는 이 이벤트를 리스닝하고 있어야 합니다. 그러고 나서 이 이벤트가 발생했다는 사실을&nbsp; Player에게 보내야 해요. 따라서 EventHandler를 프로퍼티로 가지고 있어야 하고, Input System에서 오는 Interact를 리스닝하고 액션이 들어왔을 때 EventHandler를 통해 이벤트를 보내주는 함수를 구현하면 됩니다.&nbsp;public class GameInput : MonoBehaviour { // Event를 넘겨주는 객체 public EventHandler OnInteractAction; private PlayerInputActions playerInputActions; private void Awake() { playerInputActions = new PlayerInputActions(); playerInputActions.Player.Enable(); // Listening playerInputActions.Player.Interact.performed += Interact_performed; } private void Interact_performed(UnityEngine.InputSystem.InputAction.CallbackContext obj) { //OnInteractAction이 Null일 수 있기 때문에 Invoke를 사용한다. OnInteractAction?.Invoke(this, EventArgs.Empty); } public Vector2 GetMovementVectorNormalized() { Vector2 inputVector = playerInputActions.Player.Move.ReadValue&lt;Vector2&gt;(); inputVector = inputVector.normalized; return inputVector; }
}
Player.cs에서 OnInteractAction을 리스닝하면 됩니다.// Player.cs // GameInput.cs에서 발생하는 OnInteractAction을 리스닝 하기 private void Start() { gameInput.OnInteractAction += GameInput_OnInteractAction; } private void GameInput_OnInteractAction(object sender, System.EventArgs e) { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { clearCounter.Interact(); } } }
유니티에서 이런 비동기 처리는 Event라는 것을 처리하는 것 같습니다. Swift는 클로저를 통해 제어권을 넘겨주는 방식이랑 상당히 유사한 것 같네요. 끝!]]></description><link>unity/14.-interact-action-events.html</link><guid isPermaLink="false">Unity/14. Interact Action Events.md</guid><pubDate>Tue, 31 Dec 2024 05:52:16 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/c8lceb/btsplbJWlTk/Vtgx6U1DizEDTVr69PSqcK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[15. Selected Counter Visual & Singleton Pattern]]></title><description><![CDATA[이번에는 오브젝트에 다가갈 때 UI를 업데이트하는 것을 구현했어요. UI 로직과 게임 로직은 분리하는 게 좋아요.SelectedCounterVisual 스크립트를 생성하고 공통적으로 적용해야 하기 때문에 ClearCounter Prefab을 열어줍니다. 그리고 ClearCounter_Visual을 복사해서 Selected로 이름을 바꿉시다. 그런 다음 Inspector에서 세 가지 과정을 완료하면 되어요.
CounterSelected로 Meterial 변경 (Selected 하위에 있는 컴포넌트들)
사이즈 변경 (사이즈가 같으면 발생하는 렌더링 버그가 있음)
SelectedCounterVisual 넣기
<img src="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/dNulJo/btspE3SQKsU/H3PrGoAKCMIhBuYF9d6Tgk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/XdXso/btspNP0efBe/UfjgVYsPfcUiLcY4MY1QCK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 코드를 작성하고, SerializeField를 만들어서 레퍼런스를 넣어줍시다!흐름은 Player가 Object에 다가간다. -&gt; Selected Counter Visual을 업데이트해준다. 그러면 Player.cs에 다음과 같은 코드를 작성하면 되어요. 그리고 아직은 1인용 게임이기 때문에 Player는 인스턴스는 무조건 하나일 수밖에 없어서 싱글톤으로 만들면 됩니다.// Player.cs
public event EventHandler&lt;OnSelectedCounterChangedEventArgs&gt; OnSelectedCounterChanged; public class OnSelectedCounterChangedEventArgs: EventArgs { public ClearCounter selectedCounter; } // Single 톤으로 만들어야하니까 public static Player Instance { get; private set; } private void Awake() { if (Instance != null) { Debug.LogError("Player가 한명보다 많습니다."); } Instance = this; } private void SetSelectedCounter(ClearCounter selectedCounter) { this.selectedCounter = selectedCounter; OnSelectedCounterChanged?.Invoke(this, new OnSelectedCounterChangedEventArgs { selectedCounter = selectedCounter }); } // 수정
private void HandleInteractions() { Vector2 inputVector = gameInput.GetMovementVectorNormalized(); Vector3 moveDir = new Vector3(inputVector.x, 0f, inputVector.y); if (moveDir != Vector3.zero) { lastInteractDir = moveDir; } float interactDistance = 2f; if (Physics.Raycast(transform.position, lastInteractDir, out RaycastHit raycastHit, interactDistance, counterLayerMask)) { if (raycastHit.transform.TryGetComponent(out ClearCounter clearCounter)) { SetSelectedCounter(clearCounter); } else { SetSelectedCounter(null); } } else { SetSelectedCounter(null); } }
이제 Visual을 업데이트를 하는 코드를 작성합시다!// SelectedCounterVisual.cs public class SelectedCounterVisual : MonoBehaviour { [SerializeField] private ClearCounter clearCounter; [SerializeField] private GameObject visualGameObject; private void Start() { Player.Instance.OnSelectedCounterChanged += Player_OnSelectedCounterChanged; } private void Player_OnSelectedCounterChanged(object sender, Player.OnSelectedCounterChangedEventArgs e) { if (e.selectedCounter == clearCounter) { Show(); } else { Hide(); } } private void Show() { gameObject.SetActive(true); } private void Hide() { gameObject.SetActive(false); }
}
이때 좀 주의할 점이 있는데 이벤트 등록을 Start()에서 하는 것입니다. Awake()에서 등록을 하게 되면 에러가 발생할 수 있습니다.왜냐하면 Player.cs에서 Instance를 Awake()에서 만들기 때문에 순서가 보장되지 않을 수 있기 때문입니다.따라서! 반드시 Start()에서 이벤트 등록을 해줍시다.이제 다시 유니티로 돌아가 [SerializeField]에 알맞는 레퍼런스를 넣어줄까요?<br><img src="https://blog.kakaocdn.net/dn/cveG34/btspOyYfvgw/91xl8AZvUZ4XgWtzWGXch0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bfZ78Q/btspCnqqB3Z/sYY06RxUirfT2CRaSdoMQK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/d2OVRZ/btspGLxv4Oz/1AVqaYIqCEan1owh9eTlt1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/bUh0Ao/btspRinhPFO/4mvrstPKOfYh7zouWBcz10/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/lF40S/btspFM4lwGY/uYgrQlWSSg8EzynxPNt201/img.gif" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>unity/15.-selected-counter-visual-&amp;-singleton-pattern.html</link><guid isPermaLink="false">Unity/15. Selected Counter Visual &amp; Singleton Pattern.md</guid><pubDate>Tue, 31 Dec 2024 05:52:04 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/di4qoz/btspxqubWQE/sy4PSjSX6vd09JyJRMDOsK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[16. Kitchen Object, Scriptable Object]]></title><description><![CDATA[Clear Counter에는 음식을 올려놓을 수 있어요. Clear Counter에 객체를 올려놓는 것을 개발하겠습니다.먼저 올려놓을 객체들을 Prefab으로 만듭니다. KitchenObjects 폴더에 만들어줄게요. 그런 다음에, ClearCounter 스크립트를 열고다음 코드를 작성합니다.public class ClearCounter : MonoBehaviour { [SerializeField] private Transform tomatoPrefab; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform tomatoTransform = Instantiate(tomatoPrefab, counterTopPoint); tomatoTransform.localPosition = Vector3.zero; }
}
Interact()가 호출되면 Log를 띄우고 토마토를 Clear Counter 위에 올려놓을 거예요. 이제 유니티로 돌아가서 설정한 SerializeField에 레퍼런스를 넣겠습니다.<img src="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">그러면 인터렉트를 하게 되면 토마토가 슉하고 올라갈 거예요. 근데 Clear Counter 위에는 토마토도 올라갈 수 있지만 다양한 것들도 올라갈 수 있어요. 그래서 이것을 Scriptable Object로 감싸고, 안에 멤버 변수로 Prefab을 가지고 있다면 코드를 공통화할 수 있어요.Scriptable Object를 만듭시다.[CreateAssetMenu()]
public class KitchenObjectSO : ScriptableObject { public Transform prefab; public Sprite sprite; public string objectName;
}
유니티로 돌아가서 확인해 보면 Create Kitchen Object SO라는 것이 생겼을 거예요. Tomato와, CheeseBlock을 만듭니다.<br><img src="https://blog.kakaocdn.net/dn/Bgna7/btspCllNj6o/lrnpl70tqht3IeX3Ev4Ptk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">ClearCounter.cs를 수정해 볼까요?public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; }
}
이렇게 하면 끝입니다.근데 kitchenObjectTransform에서 해당하는 KitchenObjectSO를 얻을 수 있을까요? 바로 얻을 수 없습니다. 이것 역시 스크립트를 이용해야 하는데 Scriptable Object에는 Script를 드래그 앤 드롭할 수 없습니다. 그래서 KitchenObject 스크립트를 만들어서 Prefab에 넣어야 합니다. 뭔가 쓰고 보니 말이 좀 헷갈리네요.<br><img src="https://blog.kakaocdn.net/dn/pp8fj/btspRh2ZVw7/OflwT6hlZfzIauDyiRsKDK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; }
}
즉 여러 KitchenObject&nbsp;(Tomato, Cheese etc..)를&nbsp;사용하는 곳 일종의 Type Erasing을 하는 곳에서는 Scriptable Object를 사용해서 관리하고 유니티에서 프리팹으로 KitchenObject에 Scriptable Object 레퍼런스를 넣어주면 되겠습니다.public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; public void Interact() { Debug.Log("Interact"); Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.localPosition = Vector3.zero; // KitchenObject로 Scriptable Object를 얻을 수 있음! Debug.Log(kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().GetKitchenObjectSO().objectName); }
}
]]></description><link>unity/16.-kitchen-object,-scriptable-object.html</link><guid isPermaLink="false">Unity/16. Kitchen Object, Scriptable Object.md</guid><pubDate>Tue, 31 Dec 2024 05:51:53 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/cqN78I/btspBADp70n/TkIxV6uiEQUAQK6oiDLsRK/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[17. Kitchen Object Parent]]></title><description><![CDATA[플레이어나 Counter들은 Kitchen Object를 가지고 있을 수 있어요.(플레이어는 Kitchen Object를 들 수 있고, Counter는 위에 Kitchen Object를 올릴 수 있습니다.) 이것을 Parent라고 할게요. 나중에 Interface를 이용해서 바꾸겠지만 지금은 Kitchen Object의 부모는 Clear Counter라고 가정하고 코드를 작성할게요.플레이어가 키친 오브젝트를 들고 있고 ClearCounter에 가서 ClearCounter의 Interact() 코드를 호출할 거예요. 이때 Clear Counter가 자식을 가지고 있으면 (즉 키친 오브젝트가 올려져 있으면) 아무것도 처리하지 않고, 자식을 가지고 있지 않으면 Kitchen Object를 자식으로 만들면 되겠네요.그리고 KitchenObject에서 부모를&nbsp; SetClearCounter로 설정하면 되어요. 그리고 키친오브젝트의 부모를 Set할 때 부모의 UI를 업데이트를 하면 됩니다. 비주얼 업데이틀 어떻게 하면 될까요? 부모의 Top인 CounterTopPoint에 올려놓으면 됩니다. 그리고 여기에서 부모의 메서드인 SetKitchenObject를 해주면 될 거예요. (부모의 자식은 나다.)public class ClearCounter : MonoBehaviour { [SerializeField] private KitchenObjectSO kitchenObjectSO; [SerializeField] private Transform counterTopPoint; private KitchenObject kitchenObject; private void Update() { } public void Interact() { if (kitchenObject == null) { Transform kitchenObjectTransform = Instantiate(kitchenObjectSO.prefab, counterTopPoint); kitchenObjectTransform.GetComponent&lt;KitchenObject&gt;().SetClearCounter(this); } else { Debug.Log(kitchenObject.GetClearCounter()); } } public Transform GetKitchenObjectFollowTransform() { return counterTopPoint; } public KitchenObject GetKitchenObject() { return kitchenObject; } public void SetKitchenObject(KitchenObject kitchenObject) { this.kitchenObject = kitchenObject; } public void ClearKitchenObject() { this.kitchenObject = null; } public bool HasKitchenObject() { return kitchenObject != null; }
이제 KitchenObject로 가서 SetClearCounter()를 구현합시다.public class KitchenObject : MonoBehaviour { [SerializeField] KitchenObjectSO kitchenObjectSO; private ClearCounter clearCounter; public KitchenObjectSO GetKitchenObjectSO() { return kitchenObjectSO; } public ClearCounter GetClearCounter() { return clearCounter; } public void SetClearCounter(ClearCounter clearCounter) { if (this.clearCounter != null) { this.clearCounter.ClearKitchenObject(); } this.clearCounter = clearCounter; if (clearCounter.hasKitchenObject()) { Debug.LogError("clear counter already has kitchen object"); } clearCounter.SetKitchenObject(this); transform.parent = clearCounter.GetKitchenObjectFollowTransform(); transform.localPosition = Vector3.zero; }
}
]]></description><link>unity/17.-kitchen-object-parent.html</link><guid isPermaLink="false">Unity/17. Kitchen Object Parent.md</guid><pubDate>Tue, 31 Dec 2024 05:51:36 GMT</pubDate></item><item><title><![CDATA[캐릭터 움직임과 Time.deltaTime]]></title><description><![CDATA[이번에는 유니티를 이용해 WASD로 움직이는 캐릭터를 만들어봅시다.Unity Project 3D URP로 생성해요.<img src="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">공허한 화면을 뒤로한 채 Hierarchy에서 오른쪽 클릭 후 3D Object -&gt; Plane을 눌러서 생성합시다. 이름을 Floor로 해줄게요그런 다음에, Inspector 창에서, Scale을 5, 5, 5로 Position과 Rotation을 0, 0, 0으로 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/bgttrZ/btsn6GSp3Nd/jRc4YxJMqApLlhmuq8I6O0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하이어러키 창에서 메인 카메라를 클릭한 다음 인스펙터창에서 Position, Rotation, Scale을 아래처럼 설정합니다.<br><img src="https://blog.kakaocdn.net/dn/AjHWa/btsn9Tizkle/7XvsKtRoy95S7IjBmF8cd1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">하이어러키 창에서 Create Empty를 만들고 이름을 Player로 합시다. 그리고 만든 Player 하위에 3D Object - Capsule을 생성합니다. 이렇게 하는 이유는 뷰 로직과 동작 로직을 분리하기 위해서예요.Player 오브젝트의 Position과 Rotation은 0,0,0 Scale은 1,1,1으로 설정하고 PlayerVisual(하위에 만든 캡슐)은 Postion (0,1,0) Rotation은 0,0,0, Scale은 1,1,1로 설정해 주세요.<br><img src="https://blog.kakaocdn.net/dn/RqMrq/btsn8pI3tFB/SnaoJYXV9i7IINUlK9jrO1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/cBgb5p/btsn7trHo5k/ibnoMMkaaZStsV2b9Jpaek/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Project 창에서 Asset 폴더 아래에 Script 폴더를 만들고 그곳에 C# Script를 만들고 파일을 Player 오브젝트에 드래그 앤 드롭합니다.그런 다음에 Asset - Open C# Project를 클릭합니다.<br><img src="https://blog.kakaocdn.net/dn/TaZwr/btsn8pI31yr/M7jSrnckR44FD7Tkg4yU70/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">using System.Collections;
using System.Collections.Generic;
using UnityEngine; public class Player : MonoBehaviour { [SerializeField] private float moveSpeed = 7f; private void Update() { Vector2 inputVector = new Vector2(0, 0); if (Input.GetKey(KeyCode.W)) { inputVector.y += 1; } if (Input.GetKey(KeyCode.A)) { inputVector.x -= 1; } if (Input.GetKey(KeyCode.S)) { inputVector.y -= 1; } if (Input.GetKey(KeyCode.D)) { inputVector.x += 1; } inputVector = inputVector.normalized; Vector3 moveDir = new Vector3(inputVector.x, 0, inputVector.y); transform.position += moveDir * moveSpeed * Time.deltaTime; }
}
좌표 시스템이 평소 학교에서 배웠던 거랑 일치하지 않을 수 있어요. 그리고 게임 엔진마다 축이 조금씩 상이하더라고요.&nbsp; 제가 공부할 때는 Right Handed를 많이 사용했는데, 유니티는 Left Handed라고 합니다. 아래 그림 참고 하시면 될 것 같아요.<br><img src="https://blog.kakaocdn.net/dn/TIRvR/btsn8lfDOKD/RL0AI3d1kyNgGDFcfsrZSk/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">코드 자체는 별 게 없는 것 같아요. 조금 특징적인 것에 대해서만 알면 될 것 같습니다.inputVector = inputVector.normalized;
왜 inputVector를 정규화를 할까요? 왜냐하면, Vector는 속력이 아닌 속도를 나타내기 때문입니다. 만약 정규화를 하지 않았을 때, 대각선으로 이동한다면 inputVector의 값은 (1,1)이 될 거예요. 그러면 벡터의 길이 (스칼라) 값은 1.414...이 되기 때문에 대각선으로 이동할 때 더 빠른 속도로 이동하게 됩니다. 즉 동일한 속도가 보장이 되지 않게 됩니다. 이러한 이유로 정규화를 통해서 방향만을 얻고, 이동 속도는 변수로 곱해서 처리하는 것이 일반적인 것 같습니다.transform.position += moveDir * moveSpeed * Time.deltaTime;
위 코드에서 속력과 방향에 Time.deltaTime를 곱하고 있습니다. 왜 그럴까요? 이것을 알기 위해서는 Frame(프레임)과 FPS에 대해 먼저 알아야 합니다.동영상은 정지된 여러 장의 사진으로 구성되어 있고, 우리는 이 사진이 빠르게 변하는 것을 움직이는 것으로 보게 됩니다. 여기에서 이 정지된 사진을 프레임이라고 합니다. FPS는 Frame Per seconds의 준말로 1초당 몇 장의 사진이 변하는가입니다. 60 FPS면 1초당 연속하는 60장의 사진을 보는 것이라고 이해하면 될 것 같아요. 그래서 FPS는 성능에 비례합니다. (고사양 컴퓨터면 더 높고, 더 낮은 사양이면 더 낮습니다.)유니티에서 Update() 메서드는 1 프레임을 주기로 호출됩니다. 만약 위의 코드에서 Time.deltaTime이 없다면, 어떻게 될까요? 고사양의 컴퓨터를 가진 사람은 더 빨리 이동할 것입니다. 저사양의 컴퓨터를 가진 사람은 더 느리게 이동할 테고요. 이러한 차이를 보정하기 위해서 바로 Time.deltaTime을 곱하는 것입니다.&nbsp;유니티에서 Time.deltaTime의 정의는&nbsp;The interval in seconds from the last frame to the current one입니다.&nbsp;즉 현재 프레임과 이전 프레임의 시간 간격을 의미하게 되는 거예요. 따라서 고사양의 컴퓨터는 deltaTime의 값은 작을 테고, 저사양의 컴퓨터의 값은 더 높게 됩니다.&nbsp;고사양 컴퓨터는 60 fps가 나오고, 저사양의 게임은 30fps가 나온다고 가정하면, 아래와 같이 1 프레임당 시간 간격, 즉 deltaTime을 구할 수 있습니다.30fps = 1 / 30 = 0.03333333360fps = 1 / 60 = 0.01666666이때 Update 코드를 생각해봅시다. Update 코드는 1 프레임에 한번 호출된다고 했으니까,&nbsp;저사양 컴퓨터: (moveDir moveSpeed 0.3333333) * 30 만큼 이동 (30프레임)고사양 컴퓨터: (moveDir moveSpeed 0.016666666) * 60 만큼 이동 (60프레임)의 값은 같게 됩니다.그래서, Time.deltaTime로 컴퓨터 사양에 따른 이동을 보정할 수 있게 됩니다.캐릭터 이동을 구현할 때, GetKey를 이용해 구현하는 것보다, Input System이라는 package를 이용해서 구현하는 것이 확장하기 더 좋아요. 절대 Input System Package를 이용하세요!<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose/Ex_Collision_Detection" target="_self">https://github.com/psychehose/Ex_Collision_Detection</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://m.blog.naver.com/destiny9720/221411002215?view=img_1" target="_self">https://m.blog.naver.com/destiny9720/221411002215?view=img_1</a>&nbsp;<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization" target="_self">https://ko.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-magnitude-normalization</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://windeva.tistory.com/840" target="_self">https://windeva.tistory.com/840</a>]]></description><link>unity/캐릭터-움직임과-time.deltatime.html</link><guid isPermaLink="false">Unity/캐릭터 움직임과 Time.deltaTime.md</guid><pubDate>Tue, 31 Dec 2024 05:49:28 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/LQB5d/btsn6JuOaJp/TvEG2Tak3NZ7KqEo55x7f0/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Glow Effect 만들기]]></title><description><![CDATA[게임을 만들어보고 싶어서, 요즘 유니티를 공부하고 있어요.게임을 하다 보면 반짝거리는 물체들이 많이 있는데, 이 반짝거리는 효과를 어떻게 만드는지 공부해 보고 정리해 봤습니다.&nbsp;Glow Effect를 만들기 위해서 4가지가 성립해야 합니다.
Shader - Emission에서 Color가 검은색이 아니고, Intensity &gt; 0 이어야 합니다.
Post Processing Bloom (Intensity와 Threshold 세팅)
Render Pipeline Asset에서 HDR 체크
Camera에서 Rendering - Post Processing 체크
먼저 3D Object 구를 만든 다음에 이 구에 적용한 Material을 만듭시다.<img src="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/digjIe/btsnTEeToHv/SEV8Xa8MbugddHdz7EcIT0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">만든 Material을 구에 드래그 앤 드랍 해줍시다. 구 오브젝트를 선택하고 오른쪽 Inspector에서 Surface Inputs - Emission을 체크하고 색깔(검은색 X)을 지정하고 intensity를 0보다 높게 설정하면 1번 과정은 끝입니다. 그러면 구에 색깔이 있을 거예요.intensity를 엄청 높여도 Render Pipeline Asset이 HDR 옵션이 해제되어 있다면 Glow Effect는 나타나지 않을 거예요. 만약 나타난다면 HDR 옵션이 체크되어 있는 겁니다.<br><img src="https://blog.kakaocdn.net/dn/rYlDe/btsnTDfYB5N/KTQwg2cdfH6vEaKk9GTnR0/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">이제 Post Processing 옵션을 가지고 있는 Object를 만들 거예요. Create Empty 하고 이름을 변경합시다. 그런 다음에 아래처럼 Add Componet를 눌러서 Volume을 추가합시다.<br><img src="https://blog.kakaocdn.net/dn/cAcJUG/btsnSXFAZ5U/Uirq8dXFSglHSBkO8vArnK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/ME19w/btsnFK8UrKr/uTAOWh6GYcHtVmySaBjv61/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://blog.kakaocdn.net/dn/EykhQ/btsnEXAV6i8/qMLIiOvafOxKXXFoe67ye1/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Volume에서 Profile 칸이 아마 비워져 있을 텐데, New를 클릭해서 새로 생성한 뒤에, Add Override를 눌러서 Post Processing - Bloom을 클릭합니다. 그리고 Threshold를 설정하고 Intensity를 설정하면 됩니다. 이때 Threshold는 최솟값이에요. Intensity보다 작아야 작동합니다. Intensity는 Glow Effect의 강함입니다. 저는 Intensity를 1로 설정하겠습니다. 아직도 역시 효과가 없을 거예요!이제 URP에서 HDR 옵션을 체크해 주면 Glow Effect가 적용됩니다.<br><img src="https://blog.kakaocdn.net/dn/yWAiA/btsnF6Ya6uR/KmEDRHvcznviMUYwbWb2fK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">근데 한 가지 문제점이 있는데 씬 뷰에서는 적용되는데 게임 뷰에서 적용이 안될 수도 있습니다. (아래사진 왼쪽). Camera를 클릭해서 Rendering - Post Processing을 체크하면 게임 뷰에서도 적용(아래사진 오른쪽)됩니다.<br><img src="https://blog.kakaocdn.net/dn/bFAcJS/btsnLvJE7ic/KLNSIRJlE4hBxymlgALJVK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><img src="https://blog.kakaocdn.net/dn/bg7pfi/btsnHRsEeVi/k0CzMQSMCyd2nV873aYKqK/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">단순 Glow Effect 뿐만 아니라 더 다양한 Effect를 적용하고 싶을 때 (예를 들면 캐릭터를 클릭했을 때 외곽선 하이라이팅 하고 싶은 경우)는 Unity에서 제공하는 Shader Graph를 사용하면 된다고 하네요. 다음에 기회가 되면 다뤄보도록 하겠습니다~<br>&nbsp;<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=bkPe1hxOmbI" target="_self">https://www.youtube.com/watch?v=bkPe1hxOmbI</a>]]></description><link>unity/glow-effect-만들기.html</link><guid isPermaLink="false">Unity/Glow Effect 만들기.md</guid><pubDate>Tue, 31 Dec 2024 05:48:39 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/ba0EHV/btsnF4MPmE9/aTlmEzy2uGUFIFEi65BrL1/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵)]]></title><description><![CDATA[컬렉션은 내장된 배열과 튜플 타입과는 다르게 힙에 저장됩니다. 이것은 데이터량이 런타임에서 변경될 수 있다는 뜻입니다. 러스트 표준 라이브러리가 제공하는 컬렉션은 다음과 같습니다.
sequence 타입: Vec, VecDeque, LinkedList
map 타입: HashMap, BTreeMap
Sets 타입: HashSet, BTreeSet
Misc 타입: BinaryHeap
그중에서 자주 사용되는 세 가지 컬렉션을 알아보겠습니다.
Vec는 여러 개의 값을 서로 붙어 있게 저장합니다.
String은 문자의 모음입니다.
HashMap은 키-값으로 저장합니다.
let v: Vec&lt;i32&gt; = Vec::new();
벡터는 제네릭을 이용해서 구현되어있습니다. 그래서 어떠한 종류의 값도 저장할 수 있습니다.let v = vec![1,2,3];
let v = Vec::from([1,2,3,4]);
let v = vec![0; 5]; // [0,0,0,0,0]
초기값이 있는 벡터를 생성하는 것은 흔한 일이기 때문에 러스트에서는 vec! 매크로를 제공하고 있습니다. Vec의 static method인 from을 이용해서도 배열을 생성할 수 있습니다. 길이가 n인 배열을 생성하고 0으로 초기화할 수 있습니다.let mut v = Vec:new();
v.push(5);
v.push(6);
v.push(7);
v.pop();
v.pop(); // insert(index, value)
// remove(index)
v.insert(1,4)
v.remove(1) // let mut vec = vec![1, 2, 3];
let mut vec2 = vec![4, 5, 6];
vec.append(&amp;mut vec2);
assert_eq!(vec, [1, 2, 3, 4, 5, 6]);
assert_eq!(vec2, []);
컬렉션 변수에 대해서 그 변수가 담고 있는 값이 변경되게 하려면 mut 키워드를 사용합니다. push &amp; pop을 사용해서 벡터 값을 자료구조 스택처럼 사용할 수 있습니다.특정한 인덱스에 값을 넣고 빼기 위해서는 insert &amp; remove를 사용하면 됩니다. Insert &amp; remove는 인덱스를 직접 사용하기 때문에 인덱스 범위를 넘어가면 패닉을 일으키게 됩니다.배열과 배열의 연산에는 append를 이용합니다. 특이한 점이 append를 하게 되면 추가 하는 항목들이 있는 배열에서 요소들이 사라집니다.let v = vec![1, 2, 3, 4, 5]; let third: i32 = v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
벡터 요소를 읽기 위해서는 []과 get 함수를 이용하는 방법입니다. []를 이용하는 경우 존재하지 않는 요소를 참조하게 되면 패닉을 일으키게 되겠죠?get 함수를 사용하면 벡터 범위를 벗어난 인덱스를 사용하면 퍄닉 없이 None이 반환됩니다.let v = vec![100, 32, 57];
for i in &amp;v { println!("{}", i);
} /// let mut v = vec![100, 32, 57];
for i in &amp;mut v { *i += 50;
}
인덱스를 명시하지 않아도, Swift나 Python처럼 반복문을 돌면서 요소에 접근할 수 있습니다. 요소들을 변경시키길 원한다면 역참조연산자(*)를 사용하면 됩니다.String은 문자들의 모음입니다. 러스트에서 스트링은 세 가지 특징적인 개념을 가집니다.
에러를 꼭 명시해줘야 합니다.
복잡한 데이터 구조를 가지고 있습니다.&nbsp;
UTF-8이라는 점입니다.
let mut s = String::new();
// let data = "initial contents";
let s = data.to_string(); // the method also works on a literal directly:
let s = "initial contents".to_string(); let s = String::from("initial contents");
스트링 생성은 String 타입의 new() 정적 메소드를 이용해서 할 수 있습니다. 그리고 스트링 리터럴(&amp;str)을 생성하고. to_string() 메서드를 이용해서 생성할 수도 있습니다.let mut s = String::from("foo");
s.push_str("bar"); let mut s1 = String::from("foo");
let s2 = "bar"; // 참조자를 사용하기 때문에 소유권을 넘기지 않음.
s1.push_str(&amp;s2);
println!("s2 is {}", s2);
스트링에 스트링을 추가하기 위해서 push_str 메소드를 사용할 수 있습니다.&nbsp; 문자 한 개를 추가하길 원하면 push() 메서드를 사용할 수 있습니다.&nbsp;let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &amp;s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요 연산자를 이용해서 문자열끼리 접합할 수 있습니다. 위의 코드를 보면 let s3 = s1 + &amp;s2; 입니다. s1에는 참조자가 붙지 않고 s2에 참조자가 붙어 있는 것을 볼 수 있는데요. 이것은 스트링에서 + 연산자는 add 메서드를 이용하기 때문입니다.
fn add(self, s: &amp;str) -&gt; String {
add()를 자세하게 보고 s3의 코드를 보면 조금 당황할 수도 있습니다. 왜냐하면, add의 파라미터는 &amp;str 타입인데 &amp;s2의 타입은 &amp;String이기 때문입니다. 하지만 컴파일러는 이를 컴파일 할 수 있습니다. 왜 그럴까요? &amp;String인자는 &amp;str로 강제될 수 있기 때문입니다. 이를 러스트에서는 역참조 강제(deref coercion)라고 합니다.위에서 보듯 +의 동작은 다루기가 불편한 것처럼 보입니다. 어떤 것은 String이고, 붙여지는 건 &amp;str인 것처럼요. 왜냐하면 이는 소유권에 대해서 더 신경을 써야한다는 것을 의미하니까요. 그래서 러스트는 format! 매크로를 제공합니다. 이를 이용하면 어떠한 파라미터의 소유권도 가져오지 않고 보기 쉽게 스트링을 합칠 수 있습니다.&nbsp;let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe"); let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
// let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe"); let s = format!("{}-{}-{}", s1, s2, s3);
let s1 = String::from("hello");
let h = s1[0];
다른 언어처럼 스트링에 인덱스로 접근하고 싶습니다. 위의코드는 컴파일이 될까요? 접근하면 어떻게 될까요? 러스트에서 스트링 인덱스 접근은 지원하지 않습니다. 이것을 이해하기 위해서 스트링이 어떻게 메모리에 저장되는지 확인해봐야 합니다.String은 Vec을 감싼 것입니다.&nbsp;let len = String::from("Hola").len(); // 1 let len = String::from("Здравствуйте").len(); len은 4입니다. 이건 4byte 길이라는 뜻입니다.
len은 24입니다. 글자는 12개지만, 이 문자 각각의 유니코드 스칼라 값이 2입니다. 12* 2 = 24
이 말은 스트링의 바이트들 안의 인덱스는 유니코드 스칼라 값과 항상 대응되지 않는다는 것을 의미합니다.그리고 인덱스 연산은 언제나 상수 시간에 실행될 것으로 기대를 받는데, String으로 그러한 성능을 보장하는 것은 불가능입니다. 왜냐하면 스트링 내에 얼마나 많은 문자가 있는지 알아내기 위해 시작지점부터 인덱스로 지정된 곳까지 살펴봐야 하기 때문입니다.만약 스트링 슬라이스를 만들기 위하고 인덱스를 사용하길 원한다면 구체적으로 지정해야 합니다.let hello = "Здравствуйте"; let s = &amp;hello[0..4]; // Зд
// let s = &amp;hello[0..1]; // 패닉 발생!
반복문을 돌면서 바이트에 관계 없이 유니코드 스칼라 값(글자)에 대한 연산을 하길 원하면 chars를 사용하면 됩니다.for c in "नमस्ते".chars() { println!("{}", c);
} for b in "नमस्ते".bytes() { println!("{}", b);
}
즉 유효한 유니코드 스칼라 값이 하나 이상의 바이트로 구성될지도 모른다는 것을 확실히 기억해야만 합니다.''use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); // let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50]; let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
추가적으로 튜플의 벡터에 대해 collect 메서드를 사용해서 생성할 수 있습니다collect 메소드는 데이터를 모아서 컬렉션 타입으로 만들어줍니다.let field_name = String::from("Favorite color");
let field_value = String::from("Blue"); let mut map = HashMap::new();
map.insert(field_name, field_value);
insert 할 때, field_name과 field_value의 소유권은 map으로 이동합니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); let team_name = String::from("Blue");
let score = scores.get(&amp;team_name);
..use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50); for (key, value) in &amp;scores { println!("{}: {}", key, value);
}
반목문 접근은 다른 컬렉션과 마찬가지로 &amp;를 이용해서 접근할 수 있습니다.use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25); println!("{:?}", scores);
위의 코드는 키에 대한 값이 있어도 덮었어 집니다.&nbsp;만약 키에 할당된 값이 없을 경우에만 삽입하고 싶으면 다음 entry API를 이용하면 됩니다.entry의 리턴 값은 Enum 타입 Entry인데 있는지 없는 지를 반환합니다.Entry의 or_insert 메소드는 해당 키가 존재하는 경우는 Entry 키에 대한 값을 반환하고 아닌 경우에는 새 값을 삽입하고 수정된 Entry에 대한 값을 반환합니다.se std::collections::HashMap; let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10); scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50); println!("{:?}", scores);
이걸로 러스트의 콜렉션 타입 중 가장 자주 쓰이는 Vec, String, HashMap에 대해 알아보았습니다.]]></description><link>rust/rust-기초-컬렉션(벡터,-스트링,-해쉬맵).html</link><guid isPermaLink="false">rust/Rust 기초 - 컬렉션(벡터, 스트링, 해쉬맵).md</guid><pubDate>Tue, 31 Dec 2024 05:47:06 GMT</pubDate></item></channel></rss>