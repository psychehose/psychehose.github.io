<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 148 at column 369: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[psychehose.github.io]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>psychehose.github.io</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 07 Aug 2025 05:48:05 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 07 Aug 2025 05:46:37 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[vtableoperation]]></title><description><![CDATA[<img src="images/vtableoperation.png" target="_self">]]></description><link>images/vtableoperation.html</link><guid isPermaLink="false">images/vtableoperation.png</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate><enclosure url="images/vtableoperation.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/vtableoperation.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cpp_memory_struct]]></title><description><![CDATA[<img src="images/cpp_memory_struct.png" target="_self">]]></description><link>images/cpp_memory_struct.html</link><guid isPermaLink="false">images/cpp_memory_struct.png</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate><enclosure url="images/cpp_memory_struct.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="images/cpp_memory_struct.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[VSync (수직 동기화)]]></title><description><![CDATA[화면이 Frame을 받을 준비가 되면 GPU에게 V-Sync를 보내고 GPU는 프레임을 화면에 전달순서
화면(Display)은 한 프레임을 완전히 보여준 뒤, 다음 프레임을 받을 준비가 되면 V-Sync 신호를 보냄
엔진(GPU)은 이 신호를 받아야만 비로소 자신이 그려놓은 새 프레임을 화면에 전달
GPU는 더블 버퍼링 기술을 이용함. 더블 버퍼링이란 GPU는 메모리에 최소 두개의 그림판, 프레임 버퍼를 가진다는 것을 의미함.
프론트버퍼: 화면에 직접 연결된 버퍼로 우리가 볼 수 있음
백 버퍼: GPU가 다음에 보여줄 프레임을 그리는 작업 공간으로 우리가 볼 수 없음. 렌더링 작업은 여기에서 발생 사용자가 화면 (프론트 버퍼)을 보는 동안 GPU는 백버퍼에서 다음 프레임을 준비함. GPU가 백 버퍼에 다 그리면 V-Sync 신호를 기다림
V-Sync 신호 발생
Buffer Swap / Flip (버퍼 교체) 백 버퍼는 프론트 버퍼가 되고 프론트 버퍼는 백버퍼가 됨.
데이터 복사가 아닌 포인터를 변경하기 때문에 매우 빠름 인풋 랙 (Input Lag)
최대 성능 확인
인풋 랙은 V-Sync의 "기다리는 특성 때문에 발생한다.
[사용자 액션]: 사용자가 마우스를 클릭하여 총을 쏨 (시간: 0ms)
[GPU 렌더링]: GPU가 총을 쏘는 장면을 백 버퍼에 즉시 그리기 시작함 (완료까지 5ms 소요, 총 시간: 5ms)
[V-Sync의 대기]:&nbsp;문제 발생함. GPU는 그림을 다 그렸지만, 아직 화면의 V-Sync 신호가 오지 않았음. 다음 신호는 16.67ms 시점에 올 예정. GPU는&nbsp;약 11ms를 아무것도 안 하고 기다려야 합니다.
[버퍼 교체]: V-Sync 신호가 오자, GPU가 백 버퍼를 프론트 버퍼로 교체(총 시간: 16.67ms)
[화면 표시]: 사용자는 마우스를 클릭한 지 약 16.67ms 후에야 총알이 나가는 것을 보게됨. 화면 찢어짐 화면 업데이트보다 GPU가 프레임을 그리는 속도가 더 빠름
윗부분은 이전 프레임, 아랫부분은 새로 그린 프레임
화면의 중간에 가로로 선이 그어진 것처럼 위아래가 어긋남
<img alt="Screen Tearing" src="https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 버벅거림 Stutter GPU가 너무 느리게 그려서 프레임 완성이 안되어 있음, 그러면 디스플레이는 이전 페이지를 한번 더 보여줌 (프레임 드랍)
사용자는 순간적으로 화면이 멈칫 Jank GPU가 프레임을 그리는 속도가 일정하지 않는 경우
사용자는 애니메이션이 부드럽게 이어지지 않고 뚝뚝 끊기거나 울렁거리는 것처럼 보임 ]]></description><link>graphics/이론/vsync-(수직-동기화).html</link><guid isPermaLink="false">graphics/이론/VSync (수직 동기화).md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate><enclosure url="https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/0/03/Tearing_%28simulated%29.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Scaffold vs Builder]]></title><description><![CDATA[build 함수에서 어떤 경우에는 Scaffold를 리턴하고 어떤 경우에는 다른 Builder들을 리턴하는 경우가 있다. build 함수에서 위젯을 리턴할 때 위젯의 역할이 무엇인가에 따라 무엇을 리턴할 지에 대해 결정해야함.Scaffold는 하나의 완전한 화면, 페이지를 구성할 때 최상위 위젯으로 사용됨. Scaffold를 반환한다는 것은 하나의 페이지를 만들겠다와 똑같은 말로 받아들여도 됨.주요역할은 머티리얼 디자인의 기본 레이아웃 구조 제공 (appBar, body, floatingActionButton, drawer 등)
화면 전체의 배경색, 상태표시줄과의 상호작용 등 페이지 수준의 시각적 요소를 관리함.
body는 그중&nbsp;가장 크고 핵심적인 메인 콘텐츠 영역을 담당@override Widget build(BuildContext context) { return Scaffold( backgroundColor: Colors.grey[100], appBar: AppBar( // ... app bar ... ), body: FadeTransition( opacity: _fadeAnimation, child: Padding( padding: const EdgeInsets.all(16.0), child: GridView.builder( gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, crossAxisSpacing: 16, mainAxisSpacing: 16, childAspectRatio: 0.75, ), itemCount: _cards.length, itemBuilder: (context, index) { return AnimationCardWidget(cardItem: _cards[index], index: index); }, ), ), ), ); }
}
보면 body에 Fade바로 위 부모 위젯의 context가 필요할 때 사용함Scaffold( body: Builder( // 이 builder는 Scaffold의 자식 위치에 있으므로, // 새로운 'context'를 통해 위로 올라가 Scaffold를 찾을 수 있습니다. builder: (context) { return ElevatedButton( onPressed: () =&gt; Scaffold.of(context).openDrawer(), child: Text('Drawer 열기'), ); }, ),
)
애니메이션은 60fps라서 전체 페이지를 60번씩 다시 그린다는 것은 리소스 낭비임. Animation Builder는 특정한 부분만 효율적으로 애니메이션을 하는 최적화 도구임. 애니메이션 값이 변경될 때마다 전체가 아닌 builder 함수 내부의 위젯들만 다시 그린다. // _scaleAnimation이 변경될 떄 Transform.scale 위젯을 다시 그림 @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _scaleAnimation, builder: (context, child) { return Transform.scale( scale: _scaleAnimation.value, child: GestureDetector( onTap: () {} // ...
ListView.builder( itemCount: 1000, // 아이템이 1000개라도 itemBuilder: (context, index) { // 이 코드는 화면에 보이는 몇 개의 아이템에 대해서만 실행됩니다. return ListTile(title: Text('Item $index')); },
)
부모 위젯이 제공하는 공간을 알아내고 그 크기에 따라 다른 UI를 보여주고 싶을 때 사용함. 반응형 UI를 만들 때의 핵심LayoutBuilder( builder: (context, constraints) { // constraints 객체에 최대/최소 너비와 높이 정보가 들어있습니다. if (constraints.maxWidth &gt; 600) { return WideLayout(); // 넓은 화면용 레이아웃 } else { return NarrowLayout(); // 좁은 화면용 레이아웃 } },
)
네트워크 통신이나 데이터베이스 조회처럼 완료되는 데 시간이 걸리는 비동기 작업의 결과를 UI에 표시할 때 사용FutureBuilder( future: http.get(url), // 이 Future가 완료되기를 기다립니다. builder: (context, snapshot) { if (snapshot.hasData) { return Text('성공: ${snapshot.data}'); // 성공 } else if (snapshot.hasError) { return Text('에러: ${snapshot.error}'); // 에러 } return CircularProgressIndicator(); // 로딩 중 },
)
일회성이 아닌 지속적으로 들어오는 데이터를 처리할 때 사용. 주로 채팅 앱, 주식 시세 추적, 위치 추적등 실시간으로 UI가 업데이트 되어야 하는 상황에 적합함StreamBuilder( stream: myChatRoom.messagesStream, // 메시지 스트림을 구독합니다. builder: (context, snapshot) { if (snapshot.hasData) { // 새 메시지가 올 때마다 이 부분이 다시 빌드됩니다. return ListView.builder(...); } return Text('메시지 기다리는 중...'); },
)
]]></description><link>flutter/scaffold-vs-builder.html</link><guid isPermaLink="false">flutter/Scaffold vs Builder.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[StatefulWidget 생명주기]]></title><description><![CDATA[class MainPage extends StatefulWidget { const MainPage({super.key, required this.title}); final String title; @override State&lt;MainPage&gt; createState() =&gt; _MainPageState();
} 위젯 생성: 파라미터로 title을 받아서 위젯 생성 State 생성: 프레임워크가 override 된 createState() 메서드로 `State' 객체를 생성함 initState(): 최초의 초기화 장소, 위젯 생성 후 build() 메서드가 호출 되기전에 실행됨. 위젯이 화면에 보이기 전에 필요한 모든 사전 작업 처리 컨트롤러 초기화
리스너 등록
데이터 로딩 UI 구축: State의 build() 가 호출되어 UI 그림 상태변화: setState()가 호출되면 build() 호출되어서 UI 업데이트 일어남 dispose(): 리소스 정리, 메모리 누수 방지
State 객체가 위젯 트리에서 영구적으로 제거될 때 한번 호출됨. initState랑 쌍이라고 할 수 있음
initState에서 설정한 리소스 정리하는 곳 ]]></description><link>flutter/statefulwidget-생명주기.html</link><guid isPermaLink="false">flutter/StatefulWidget 생명주기.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[TickerProviderStateMixin]]></title><description><![CDATA[TickerProviderStateMixin는 애니메이션을 만들기 위해 필요한 기능Mixin이란?
Dart 언어의 특징 중 하나로, 클래스에 특정 기능을 섞어 넣는(mix-in) 방법
상속과 비슷하지만 여러 Mixin을 하나의 클래스에 적용할 수 있어 유연
TickerProvider의 역할은?
AnimationController은 Tick을 받아서 애니메이션의 각 프레임을 업데이트함.
TickerProvider는 Ticker를 제공하는 역할
TickerProviderStateMixin는 무엇?
StatefulWidget의 State 클래스에서 AnimationController를 쉽게 사용할 수 있도록 제공되는 Mixin
Mixin을 with 키워드로 추가하면 State가 Ticker를 제공할 수 있음
위젯이 화면에서 사라질 때 Ticker를 정리해서 메모리 누수 방지
SingleTickerProviderStateMixin
TickerProviderStateMixin 경량화된 버전
State에서 단 하나의 Animation Controller를 사용할 수 있음.
가볍고 리소스 소모 적음
]]></description><link>flutter/tickerproviderstatemixin.html</link><guid isPermaLink="false">flutter/TickerProviderStateMixin.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[0. setup]]></title><description><![CDATA[vscode를 이용해서 설치
플러터 익스텐션 설치
command + shift + p
flutter 검색
Flutter: New Project 선택
Download SDK 선택 후 위치는 ~/Develop으로 지정
$ flutter doctor -v
찾을 수 없는 명령어면 환경변수에 지정$ echo 'export PATH=$PATH:~/Develop/flutter/bin' &gt;&gt; ~/.zshrc
그런 다음에 flutter doctor -v를 하면 플러터 개발시 필요한 도구들을 알려줌.그에 맞게 업데이트 하거나 설치를 하면 됨.나 같은 경우는 CocoaPods의 버전을 업데이트 (1.12.1 -&gt; 1.16.2)로 해줘야하고, 안드로이드 툴체인을 설치 해야한다.나는 예전에 cocoapods을 설치했을 때 homebrew를 이용해서 설치했기 때문에 homebrew를 통해서 업그레이드 했다.$ brew upgrade cocoapods
안드로이드 툴체인은 안드로이드 스튜디오를 다운로드 하고 아래 구성요소를 설치하면 됨
Android SDK Platform, API 35.0.2
Android SDK Command-line Tools
Android SDK Build-Tools
Android SDK Platform-Tools
Android Emulator
]]></description><link>flutter/0.-setup.html</link><guid isPermaLink="false">flutter/0. setup.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[Animation]]></title><description><![CDATA[
late AnimationController _animationController;
late Animation&lt;double&gt; _fadeAnimation; _animationController = AnimationController( duration: const Duration(milliseconds: 1000), vsync: this, ); _fadeAnimation = Tween&lt;double&gt;(begin: 0.0, end: 1.0).animate( CurvedAnimation(parent: _animationController, curve: Curves.easeInOut), ); _animationController.forward();
AnimationController는 애니메이션의 전반적인 제어를 담당함.AnimationController
duration
시작 (forward), 중지 (stop), 반복(repeat), 역재생(reverse) 등
vsync: 애니메이션이 화면의 새로고침 주기에 맞춰 실행되도록 동기화하는 역할
없는 경우 버벅임, 부자연스러울 수 있음
this를 사용하기 위해서 with TickerProviderStateMixin가 필요 Animation 객체
실제로 어떤 값이 변할지를 정의하는 추상화된 객체
CurvedAnimation
애니메이션에 속도감을 부여함
parent를 지정해줘야함. (어떤 제어를 받을 지)
begin:0.0, end: 1.0 이라는 건 처음 상태를 0으로 설정하고 끝을 1.0으로 설정하겠다는 것
Curve 종류 (In은 가속, Out은 감속으로 생각하면 됨) easeInOut :애니메이션이 천천히 시작해서 중간에 가속 끝날 때 다시 천천히 멈추는 것
easeIn: 점점 빠르게
easeOut: 점점 느리게
bound: 통통 튀는 효과
etc.. ]]></description><link>flutter/animation.html</link><guid isPermaLink="false">flutter/Animation.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[AppBar]]></title><description><![CDATA[Scaffold 위젯의 appBar 속성에 설정되어 화면 상단의 앱바를 구성함.예시appBar: AppBar( // 1. 타이틀 설정 title: const Text( 'Card Collection', style: TextStyle(fontWeight: FontWeight.bold), ), // 2. 배경색 backgroundColor: Colors.white, // 3. 전경색 (아이콘, 텍스트 기본 색상) foregroundColor: Colors.black87, // 4. 그림자 깊이 elevation: 0, // 5. 오른쪽 액션 버튼들 actions: [ IconButton(onPressed: () {}, icon: const Icon(Icons.search)), IconButton(onPressed: () {}, icon: const Icon(Icons.filter_list)), ],
),
다양한 속성 제공을 하는데 잘 이용하면 거의 모든 디자인 구현 가능함. 왼쪽 영역 (Leading Area) leading: 제목 영역 왼쪽에 표시되는 위젯 (보통 뒤로가기 버튼 넣음)
automaticallyImplyLeading: leading 위젯을 자동으로 추가할지 결정하는 bool 값
기본 값 true, 다른화면에서 현재 화면으로 이동했을 때 자동으로 뒤로가기 버튼 생성해줌 제목 영역 (title area) title: 제목 영역에 표시되는 위젯 (보통 Text 넣음)
centerTitle: 제목을 가운데로 정렬할 지 결정하는 bool 값 (안드로이드 기본 값: false, iOS: true)
titleSpacing: 제목 주변의 수평 간격(여백)을 조절함. titleSpacing: 0인 경우 제목 왼쪽의 여백을 없애는 거임. 레이아웃 및 크기: 앱 바의 전체적인 구조와 크기 변경 toolbarHeight: 앱 바의 기본 높이 조절 기본값(56.0)
bottom: 앱 바의 메인 영역 바로 아래에 위젯 추가 주로 Tab을 넣어서 탭 레이아웃을 만들 때 사용하는듯
bottom에 위젯을 넣는다면 그 만큼 높이가 늘어남 고급 효과 및 스타일 flexibleSpace: 앱 바의 배경 영역을 채우는 위젯
주로 스크롤과 함께 동적으로 변하는 배경(예시: 이미지가 점점 작아지는 효과)를 만들 때 FlexibleSpaceBar 위젯과 함께 사용됨 shape: 앱 바의 모양을 사각형이 아닌 다른 형태로 바꿀 수 있음
systemOverlayStyle: 앱바 위에 있는 디바이스 상태 표시줄 스타일을 제어함
예시 flexibleSpace: FlexibleSpaceBar( title: Text("Parallax Effect"), background: Image.network( 'https://picsum.photos/400/200', fit: BoxFit.cover, ),
), // 앱 바 하단 모서리를 둥글게 깎기
shape: RoundedRectangleBorder( borderRadius: BorderRadius.vertical( bottom: Radius.circular(30), ),
), // 앱 바가 어두워서 상태 표시줄 아이콘을 밝게 만들어야 할 때
systemOverlayStyle: SystemUiOverlayStyle.light,
]]></description><link>flutter/appbar.html</link><guid isPermaLink="false">flutter/AppBar.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[Build Context]]></title><description><![CDATA[Flutter 앱 위젯 트리 구조로 이뤄져있음. BuildContext는 이 트리 안에서 현재 위젯이 어디에 위치하고 있는지에 대한 정보를 담고 있는 객체임. 즉 위젯 트리내에 존재하는 주소 정보라고 생각하면 될 듯build()에서 BuildContext 파라미터가 필요한 이유는 이 주소에서의 Widget을 그려야하기 때문이라고 생각하면 됨.주로 위젯 트리를 거슬러 올라가서 조상을 찾아 필요한 정보를 얻는데 사용된다.
Theme(테마) 정보 얻기
Color primaryColor = Theme.of(context).primaryColor; 다른 페이지로 이동하기
Navigator.of(context).push(MaterialPageRoute(builder: (context) =&gt; CountPage())); Scaffold의 기능 사용하기 (SnackBar, Drawer 등)
ScaffoldMessenger.of(context).showSnackBar( SnackBar(content: Text('안녕하세요!'))
);
context는 위치에 따라 다르다것을 주의해야함. BuildContext는 특정 위젯의 build 메서드에 의해 생성된 위젯의 것임.@override
Widget build(BuildContext context) { // 이 context는 Scaffold를 만드는 위젯의 것. // 아직 Scaffold가 트리에 존재하지 않음. return Scaffold( body: ElevatedButton( onPressed: () { // 이 context를 사용하면 조상 중에 Scaffold를 찾을 수 없어 에러 발생! ScaffoldMessenger.of(context).showSnackBar(...); }, child: Text('Show SnackBar'), ), );
} // 올바른 코드 @override
Widget build(BuildContext context) { return Scaffold( body: Builder( // 이 builder는 Scaffold의 자식으로 실행되므로, 새로운 context를 가짐. builder: (BuildContext innerContext) { return ElevatedButton( onPressed: () { // 이 innerContext는 Scaffold보다 아래에 있으므로, // 조상을 거슬러 올라가 Scaffold를 찾을 수 있음! ScaffoldMessenger.of(innerContext).showSnackBar(...); }, child: Text('Show SnackBar'), ); }, ), );
}
]]></description><link>flutter/build-context.html</link><guid isPermaLink="false">flutter/Build Context.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[GridView]]></title><description><![CDATA[GridView는 화면에 보이는 아이템만 동적으로 생성하여 그리드 형태로 보여주는 위젯임. scrollDirection Axis.vertical
Axis.horizontal padding: 그리드 전체의 바깥 쪽에 여백을 줌
physics: 스크롤 동작 방식 설정 BoundingScrollPhysics() : 스크롤 끝에서 튕기는 효과 (iOS 기본)
ClampingScrollPhysics(): 스크롤 끝에서 멈추는 효과 (안드로이드 기본)
NeverScrollablePhysics(): 스크롤 막음 shrinkWrap: GridView를 Column이나 ListView 같은 다른 스크롤 위젯 안에 넣을 때 true로 설정해야함.
이 속성은 GridView가 자신의 콘텐츠 크기만큼만 공간을 차지하게 만들어 스크롤 충돌 문제를 해결함. true로 설정한 경우 성능 저하 가능성이 있어서 필요한 경우에만 사용해야함 GridView.builder
GridView.count
GridView.extent
GridView.custom
리스트에 수백, 수천 개의 아이템이 있더라도 현재 화면에 보이는 부분과 곧 보이게 될 일부만 미리 그려서 가장 효율적임.GridView.builder( // 1. 그리드 레이아웃을 정의하는 속성 gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, // 가로(교차축)에 2개의 아이템을 배치 crossAxisSpacing: 16, // 아이템 간의 가로 간격 mainAxisSpacing: 16, // 아이템 간의 세로 간격 childAspectRatio: 0.75, // 아이템의 가로/세로 비율 (가로 1 : 세로 1.33) ), // 2. 전체 아이템의 개수 itemCount: _cards.length, // 3. 각 아이템을 어떻게 그릴지 정의하는 함수 itemBuilder: (context, index) { return AnimationCardWidget(cardItem: _cards[index], index: index); },
) gridDelegate: 그리드 내 아이템들의 레이아웃을 결정하는 역할 SliverGridDelegateWithFixedCrossAxisCount: 교차 축에 고정된 개수의 아이템을 배치하는 방식 itemBuilder에서 context가 의미하는건 GridView 위젯 내에서 앞으로 생성될 각 아이템이 위치할 자리의 BuildContext임. 가장 간단한 방법이다. 표시할 아이템 개수가 적고 정해져있을 때, 간단하게 그리드를 만들고 싶을 때 사용함. childern 속성에 위젯 리스트를 직접 전달하기 때문에 모든 아이템을 미리 생성한다. 그래서 아이템이 너무 많다면 성능 저하가 발생한다.GridView.count( crossAxisCount: 3, // 한 줄에 3개의 아이템을 배치 children: &lt;Widget&gt;[ Icon(Icons.home), Icon(Icons.search), Icon(Icons.settings), Icon(Icons.person), Icon(Icons.camera), Icon(Icons.mail), ],
)
반응형 레이아웃을 구현할 때 주로 사용됨. maxCrossAxisExtent 속성을 이용해서 각 아이템의 최대 너비 (or 높이)를 설정한다. count와 마찬가지로 childern을 통해서 위젯 리스트를 직접 전달한다.반응형의 이점과 builder의 아이템 성능적 이점을 모두 얻으려면 builder에서 gridDelegate를 SliverGridDelegateWithMaxCrossAxisExtent로 설정하면 됨.GridView.extent( maxCrossAxisExtent: 200, // 각 아이템의 최대 너비를 200으로 제한 children: &lt;Widget&gt;[ // ... 위젯 리스트 ],
)
위의 생성자들로 구현하기 어렵고 복잡한 커스텀된 그리드 레이아웃이 필요할 때 사용된다. 특징은 gridDelegate와 childrenDelegate를 직접 구현해야 한다.. childrenDelegate은 아이템을 생성하고 관리하는 방식을 완전히 제어할 수 있게 해준다.]]></description><link>flutter/gridview.html</link><guid isPermaLink="false">flutter/GridView.md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[iOS (1)]]></title><description><![CDATA[(a) iOS 앱의 라이프사이클 상태들(Not Running, Inactive, Active, Background, Suspended)을 설명하고, 각 상태에서 주의해야 할 점을 말해주세요.(b) 앱이 백그라운드로 전환될 때 시스템이 자동으로 정지시키는 것들이 있는데, 어떤 것들이 있고 이를 어떻게 대응해야 하나요?(c) 앱이 백그라운드/포그라운드 전환될 때 Observable 스트림 관리에서 주의할 점이 있나요? (a) iOS 앱 라이프사이클 상태 Not Running 앱이 아예 실행되지 않은 상태
메모리에 로드되지 않음 Inactive 앱이 포그라운드에 있지만 이벤트를 받지 않음
전화가 오거나, Control Center 열 때 잠깐 거치는 상태
주의점: 애니메이션이나 타이머 일시정지 Active 앱이 포그라운드에서 정상 실행 중
사용자 이벤트를 받을 수 있는 상태 Background 앱이 백그라운드에서 실행 중
제한된 시간(보통 30초)만 코드 실행 가능
주의점: UI 업데이트 금지 Suspended 백그라운드에 있지만 코드 실행 안 함
메모리는 유지되지만 CPU 사용 안 함
주의점: 언제든 메모리에서 제거될 수 있음 (b) 백그라운드에서 자동 정지되는 것들
타이머
애니메이션
네트워크 요청 (일부)
(c) 스트림 관리하기
백그라운드/포그라운드 전환 UI, 애니메이션, 주기적으로 실행하는 것들 (폴링) 중지, 재시작
포그라운드 전환시 데이터 새로고침하기 (사용자 경험 up)
타이머 pause / resume
sizeThatFits()은 필요한 경우에 셀의 적절한 크기를 리턴하는 함수이다. flex.layout(mode: .adjustHeight) 에서 높이만 계산하고 TableView에 적절한 높이를 제공한다.그런 다음에 layoutSubviews()에서는 실제 서브뷰들을 배치한다.Q. sizeThatFits()에서 pinLayout을 이용해서 고정하는 이유너비를 고정해야 FlexLayout이 정확한 높이를 계산하기 때문이다. // 예시: 긴 텍스트가 있는 라벨
nameLabel.text = "아주 긴 이름이 들어가서 여러 줄로 표시될 수 있는 텍스트"
nameLabel.numberOfLines = 0
이 경우에 Label이 몇 줄로 표시 될 지 모르기 때문에 정확한 높이 계산이 불가능하기 때문이다.]]></description><link>interview_practice/ios-(1).html</link><guid isPermaLink="false">Interview_practice/iOS (1).md</guid><pubDate>Thu, 07 Aug 2025 05:44:51 GMT</pubDate></item><item><title><![CDATA[Hash Table]]></title><description/></item><item><title><![CDATA[ Home]]></title><description><![CDATA[ 금융공학과 소프트웨어공학을 전공하며 쌓은 수학적, 논리적 사고를 바탕으로 iOS 개발을 시작했습니다. 저는 시스템 설계와 구현에 강점이 있으며, 새로운 기술 도입에 적극적입니다. iOS 개발과 Android / iOS SDK - 언리얼엔진 플러그인 개발을 해왔습니다. 현재는 크로스플랫폼 (Windows, Android, iOS)을 타겟으로 하는 골프공 물리 시뮬레이터 개발과 스윙 모션 영상 처리를 개발 하고 있습니다.
C++ CMake - ⭐⭐⭐
OpenCV - ⭐⭐⭐ Swift Objective C RxSwift - ⭐⭐⭐⭐
Metal - ⭐⭐
Java Android - ⭐⭐
Unreal Engine - ⭐⭐
Git Perforce Helix Core -⭐⭐⭐
Qt - ⭐⭐⭐
⭐⭐⭐⭐: 전문적 활용 - 심화 문제 해결 및 최적화 가능
⭐⭐⭐ : 실무 활용 - 일상적 개발 업무 수행 가능
⭐⭐: 기본 활용 - 이해 및 참고 자료를 통한 구현 가능
Graphics
Robotics
Computer Vision C++ 물리 라이브러리 리팩토링 (윈도우 Legacy C / C++ -&gt; 크로스플랫폼 Modern C++ ) 골프공 물리 Simulator 개발, Qt, OpenGL, Metal) iOS: SwiftUI, Combine, Metal, MVMM (Front: Full Swift Native)
Android, Linux, Windows: Qt 크로스플랫폼 비디오 캡쳐 라이브러리 개발 (OpenCV) 안드로이드 / iOS 네이티브 라이브러리 개발 및 언리얼엔진 통합
+ 언리얼엔진 클라이언트 개발 및 언리얼 인사이트를 활용한 게임 최적화 경험
+ 브랜치 머지 전략 수립과 코드 리뷰 문화 도입 등을 통해 개발 문화를 정착 핀테크 기업에서 iOS 개발자로 근무하며 블록딜 및 비상장주식 플랫폼 개발을 주도 펀드고 앱 : 기획/디자인 단계부터 참여하며 모든 피쳐 개발을 담당 제이스톡 앱 : Modular Architecture를 바탕으로 비상장주식 거래 플랫폼을 개발 + 회사 내 프로젝트를 위한 인앱결제, 네트워크, 유저 정보, OAuth 모듈을 개발 및 CI/CD 배포 환경을 구축 Role - iOS Developer lead
20th SOPT 앱잼(3주 장기 해커톤) Project Init ~ AppStore 배포 종료 (22.11 ~ 24.07)
MVVM, RxSwift, ReactorKit, xcframework, fastlane
SPM을 이용한 일부 부분 모듈화
iOS 4명 - 기획 1명 - 디자인 1명 - 서버 2명 - 안드로이드 4명 Role - iOS Developer
무중력지대 씨앗프로젝트
Project Init ~ AppStore 배포 종료(20.09 ~ 22.08)
MVVM, RxSwift, Moya, `Socket' iOS 3명 - 기획 2명 - 디자인 1명 - 서버 2명 16th SOPT 앱잼 (3주 장기 해커톤) Project Init ~ AppStore 배포 종료 (20.08 ~ 23.04)
MVC , YPImagePicker …
iOS 5명 - 기획 2명 - 디자인 1명 - 서버 1명 - 안드로이드 3명
MAU: 225명
전체 유저: 1,295명 / 고양이: 1,523마리 / 리뷰: 11,169개
아주대학교 금융공학과 전공, 소프트웨어학과 복수전공
딥러닝 컴퓨터 비전 완벽 가이드 - 인프런
Qt 프로그래밍 1편 - 인프런
SOPT 창업동아리 26th iOS 파트 수료2023 let us: Go! Summer 찍먹톤 최우수상 (2023.06)
SOPT 창업동아리 20th 앱잼 대상 (2022.08)
SOPT 창업동아리 16th 앱잼 최우수상 (2020.08)Glitch Hackathon - Near Rust SDK 사용 Project (2023.05)
Email: <a data-tooltip-position="top" aria-label="mailto:psychehose@gmail.com" rel="noopener nofollow" class="external-link" href=".html" target="_self">psychehose@gmail.com</a>
<br>GitHub: <a data-tooltip-position="top" aria-label="https://github.com/psychehose" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/psychehose" target="_self">psychehose</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 18 Jun 2025 13:04:50 GMT</pubDate></item></channel></rss>