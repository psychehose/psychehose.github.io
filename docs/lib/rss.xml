<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[psychehose.github.io]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>psychehose.github.io</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 29 Dec 2024 18:52:20 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 29 Dec 2024 18:52:20 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[1. BLE]]></title><description><![CDATA[ 
 <br>Bluetooth Low Energy (BLE)<br>
<br>WPAN 기술의 일종
<br>Bluetooth 4.0부터 저전력 프로토콜 지원
<br>Bluetooth 5.0부터 확장 기능 제공
<br>BD/EDR과의 차이점<br>
<br>BD/EDR은 데이터 전송 속도와 연속성에 초점 
<br>BLE는 전력 소모를 줄이는 것에 초점
<br>BLE는 대량의 정보를 빠르게 전송하는 것보다 소량의 정보를 주기적으로 또는 간헐적으로 보내는 시스템에 적합한 기술<br>응용 분야 - 헬스케어, 무선 센서 네트워크]]></description><link>ble/1.-ble.html</link><guid isPermaLink="false">BLE/1. BLE.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate></item><item><title><![CDATA[2. BLE 프로토콜 스택]]></title><description><![CDATA[ 
 <br>BLE stack은 BLE 디바이스의 구조를 나타냄.<br>블루투스 표준에서 정의하고 있는 LE 모드로 동작하는 디바이스가 갖춰야 하는 기능들을 포함하고 있다.<br><img alt="host_controller.png" src="/ble/image/host_controller.png"><br>스택은 Host와 Controller로 구성 되어 있음 (Host는 아이폰, Controller는 애플워치, 에어팟 등등)<br><br>
<br>신호를 송수신하기 위한 하드웨어로 구성
<br>2.4 GHZ ISM 주파수 대역에서 동작
<br>GFSK, FHSS 방식으로 데이터 송수신
<br>주파수 영역 일부를 40개의 구간으로 나누어 신호를 주고 받음 - 각 구간을 채널이라고 함
<br><br>
<br>PHY와 직접적으로 상호 작용하는 레이어
<br>하드웨어와 소프트웨어 사이에서 동작함
<br>하드웨어와 연결되어 BLE 디바이스 간의 연결을 직접적으로 관리
<br>암호, 연결 상태 및 채널 업데이트 등의 역할 수행
<br><img alt="ble-link-layer.png" src="/ble/image/ble-link-layer.png">!<br>BLE 디바이스는 LL에서 하나의 상태로 동작함<br>
<br>Standby
<br>Advertising
<br>Scanning
<br>Initiating
<br>Connected
<br><img alt="ble-connection 1.png" src="/ble/image/ble-connection-1.png"><br>두 개의 BLE 디바이스가 연결을 할 때의 동작 모습<br>이러한 BLE 연결 과정은 GAP에 의해 관리됨<br><br>
<br>Host와 Controller가 분리되어 있는 경우 두 모듈 사이의 상호작용을 담당
<br><br>
<br>상위 레이어 (GATT / GAP) 하위 레이어 사이의 상호작용 담당
<br>BLE 패킷에 데이터를 포함하거나, 추출하는 역할
<br>// 상위 레이어와 하위 레이어는 BLE 패킷으로 데이터를 송수신 함<br><img alt="ble-l2cap.png" src="/ble/image/ble-l2cap.png"><br><br>
<br>Security Manager는 자주 연결하는 디바이스 (Peer) 사이의 보안 코드 (Key)를 관리 배포하는 역할
<br><br>
<br>서버와 클라이언트 사이의 데이터 교환에 대한 규칙
<br>데이터 교환의 주체
<br>정보를 가지고 있는 Device를 GATT server
<br>요청하는 디바이스를 GATT client
<br><br>
<br>연결 및 Advertising 동작을 관리하는 최상위 레이어
<br>각 디바이스의 LL 상태를 결정
<br>서로 다른 BLE 디바이스 사이의 상호 작용을 관리하는 모듈
<br>GAP는 동작 상태 중 하나를 가짐
<br><br>
<br>Broadcaster
<br>Observer
<br>Peripheral
<br>Central
<br>Peripheral (주변기기 - 에어팟과 같은)로 동작하는 디바이스는 LL에서 Advertising 상태를 유지함 일반적으로 Advertising에서 디바이스 이름과 간단한 정보만을 송신한다. 그리고 이러한 Peripheral 디바이스를 Scanning 해서 연결까지 가능한 디바이스를 Central(중앙장치)로서 동작하는 디바이스라고 함.<br>Peripheral 디바이스가 연결 과정 없이 Advertising 동작을 수행하는 경우 이러한 디바이스를 Broadcater라고 한다. 이 때 이름 이외에도 실질적인 데이터를 실어서 전송 이러한 장치를 비콘이라고 부름<br>역시 Central 디바이스가 연결 과정 없이 Scanning 동작만을 수행할 때 Observer라고 일컫고 일반적으로 Advertising 패킷 내의 데이터를 타겟으로 하므로 비콘 신호를 수신할 때 사용한다.]]></description><link>ble/2.-ble-프로토콜-스택.html</link><guid isPermaLink="false">BLE/2. BLE 프로토콜 스택.md</guid><pubDate>Sun, 29 Dec 2024 17:46:51 GMT</pubDate><enclosure url="ble/image/host_controller.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;ble/image/host_controller.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. BLE ATT, GATT]]></title><description><![CDATA[ 
 <br>ATT는 서버와 클라이언트 사이의 데이터 교환에 대한 규칙이다. 데이터 교환은 ATT를 기반으로 이뤄지고 각각의 데이터 구조는 GATT에 의해 정의 된다.<br><br>GATT에 의해 정의되는 데이터 구조는 Service와 Characteristic으로 표현된다.<br><img alt="ble-gatt-structure.png" src="/ble/image/ble-gatt-structure.png"><br>Service는 characteristic의 집합이고 데이터들은 Characteristic에 의해 정의된다.<br>이러한 Service와 Characteristic은 attribute 라는 최소 데이터 유닛에 의해 정의된다. 이러한 attribute에 대한 것들은 attribute table 내에 저장된다.<br>attribute는 type (uuid), handle, permission에 대한 정보를 포함<br><img alt="ble-attribute-table.png" src="/ble/image/ble-attribute-table.png"><br>각 행은 하나의 attribute를 나타냄<br>handle은 attribute의 주소 값에 해당<br>
permission에 service 또는 characteristic의 접근 권한에 대한 정보 저장<br>
UUID는 고유 식별자<br><img alt="ble-data-exchange.png" src="/ble/image/ble-data-exchange.png"><br>데이터를 가지고 있는 디바이스가 GATT Server<br>
요청하는 쪽이 GATT client]]></description><link>ble/3.-ble-att,-gatt.html</link><guid isPermaLink="false">BLE/3. BLE ATT, GATT.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="ble/image/ble-gatt-structure.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;ble/image/ble-gatt-structure.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4. BLE 디바이스 연결]]></title><description><![CDATA[ 
 <br><br>GAP periphral로 동작하는 디바이스에서 advertising 함 Device Name, Mac Address, TxPower 등과 같은 간단한 정보를 GAP Central로 동작하는 근처 BLE 디바이스에 알리는 동작이다.<br>PHY의 40개 채널 중 3개 (37 ~ 39)를 이용하고 각 채널은 2.4 GHz 대역 중에서도 Wifi 간섭이 가장 적을 것을 예상되는 주파수를 중심 주파수로 가짐<br><img alt="ble-conn-fig-1.png" src="/ble/image/ble-conn-fig-1.png"><br><br>GAP Central로 동작하는 디바이스는 BLE 무선 연결을 위해 근처에 연결 가능한 디바이스가 있는지 찾는다. 즉 근처에 Advertising 하고 있는 디바이스를 탐색하는 작업이다. Scanning도 advertising 채널(37 ~ 39) 에 대해 수행한다.<br><img alt="ble-conn-fig-2.png" src="/ble/image/ble-conn-fig-2.png"><br>peripheral 디바이스는 한 번에 3개의 채널을 advertising 하고 central 디바이스는 일정 간격으로 하나의 채널을 scanning 한다.<br>주요 scanning parameter는 scan interval, scan window가 있다.<br>
scan interval은 scanning 시작시간 사이의 간격을 정의한다.<br>scan window는 한 채널에서 실제로 scanning 하는 구간을 정의한다.<br>advertising 채널과 scanning 채널이 일치하는 경우에만&nbsp;Scanner&nbsp;에서 advertising 데이터를 수신할 수 있으며, advertising 시간은 수 ms 인 반면&nbsp;Scanner&nbsp;에서는 수십에서 수백 ms 동안 scanning 동작을 수행한다. 따라서,&nbsp;Scanner&nbsp;에서는 기본적으로&nbsp;Advertiser&nbsp;에 비해 보다 많은 양의 전류를 소비하게 된다.<br><br><img alt="ble-conn-fig-3.png" src="/ble/image/ble-conn-fig-3.png"><br>peripheral 디바이스에서 advertising 직후 해당 채널의 신호를 수신하는 시간을 갖는다. peripheral 디바이스에서 advertising 주기와 scanning 주기가 겹치는 시점에 채널을 통해서 central 디바이스의 연결 요청 신호 (CREQ: connection request)를 수신하게 되면 무선 연결이 시작된다. 무선 연결이 시작되고나서 먼저 본격적인 데이터 교환 전에 하드웨어 단에서 필요한 파라미터를 포함한 연결 파라미터를 주고 받는다. 또 이 시점에 연결 주기, 타임아웃 시간 등을 정보를 주고 받고 이 파라미터는 대부분 central 디바이스가 결정한다.<br>
다만 peripheral 디바이스도 연결 파라미터를 제안할 수 있다. 제안할 수 있는 항목은 아래와 같다.<br>
<br>minimum connection interval
<br>maximum connection interval
<br>slave latency
<br>connection supervision timeout
<br>advertising 채널을 제외한 37개 채널을 이용해 FHSS 방식으로 데이터를 주고 받는다.<br>연결파라미터에 대한 추가<br>connection interval은 BLE 패킷을 주고 받는 시간 간격이다.<br>
connection supervision timeout은 BLE 디바이스가 연결된 상태에서 얼마 동안 패킷을 교환하지 못할 때 연결을 끊을 것일지 판단하는 값이다.<br>slave latency BLE 디바이스가 무선을 연결된 상태에서의 패킷 교환 주기는 최대 4초이다. 그런데 slava latency 파라미터를 사용하면 연결 주기를 늘릴 수 있다. 무선 연결을 유지하기 위해 교환하는 더미 패킷을 몇 번까지 무시할 것인지 결정하는 파라미터이다.<br>예를 들면  Slave latency 를 이용하면&nbsp;GAP peripheral&nbsp;디바이스에 전송할 유효한 데이터가 없는 경우,&nbsp;GAP central&nbsp;디바이스에 더미 패킷을 전송하는 과정을 건너뛸 수 있고, 따라서 불필요한 전력 소모를 줄일 수 있게 된다. 만약 connection interval 값을 4 secs 로 설정하고, slave latency 를 2 로 설정하는 경우, 유효한 데이터가 없는 상황에서는&nbsp;GAP peripheral&nbsp;디바이스의 더미 패킷 전송을 두 번 스킵할 수 있으므로 연결 주기가 12 secs 정도가 되는 셈이다.]]></description><link>ble/4.-ble-디바이스-연결.html</link><guid isPermaLink="false">BLE/4. BLE 디바이스 연결.md</guid><pubDate>Tue, 19 Mar 2024 13:33:29 GMT</pubDate><enclosure url="ble/image/ble-conn-fig-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;ble/image/ble-conn-fig-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5. BLE 적용]]></title><description><![CDATA[ 
 <br><br>
<br>FSeonsorManager는&nbsp;C++ 싱글톤임
<br>FSeonsorManager는&nbsp;GFlexTcpSocketConnection을 프로퍼티로 가지고 있음
<br>외부에서 FSensorManager의 멤버 함수를 통해서&nbsp;GFlexTcpSocketConnection의 멤버 함수를 실행함
<br>센서는&nbsp;GFlexTcpSocketConnection에서 값을 받고&nbsp;FSensorManager의&nbsp;ThrowBallBySensor(SensorShotData); 을 통해서 외부코드 (UI)에게 브로드캐스트함
<br>BLE는 기본적으로 TCP와 같은 명령어를 공유하며 같은 로직을 가지고 있음. 따라서 TCP 로직을 크게 벗어나지 않으나, 몇가지 예외사항 (퍼팅 센서)이 존재한다.<br><br>
<br>GFlexTcpSocketConnection처럼 로직을 구성하는&nbsp;UBLEConnection 클래스가 있음
<br>BLEConnection은 게임 라이프 사이클에서 계속 살아있어야 하기 때문에 싱글톤으로 만들어야함 -&gt; 언리얼엔진에서 제공하는 Subsystem을 이용해서 UU2BLESystem 만듬
<br>UU2BLESystem는 내부적으로 BLEConnection을 프로퍼티로 가지고 있고 BLEConnection에 있는 함수를 래핑해서 사용함
<br>외부 (UI 로직)에서&nbsp;BLEConnection 함수들을 UU2BLESystem를&nbsp;통해서 호출하고 BLEConnection에서&nbsp;FSeonsorManager의&nbsp;ThrowBallBySensor()를 통해서 값을 브로드캐스팅 해줘야함.
<br><img alt="구성.png" src="/ble/image/구성.png"><br><br>

#pragma once  
  
#include "CoreMinimal.h"  
#include "U2Define.h"  
#include "Subsystems/GameInstanceSubsystem.h"  
#include "Sensor/NetworkConnectionInterface.h"  
#include "Sensor/U2SensorInterface.h"  
#include "U2BLESystem.generated.h"  
  
/**  
 *  
 */  
UCLASS()  
class U2CLIENT_API UU2BLESystem : public UGameInstanceSubsystem  
{  
	GENERATED_BODY()  
  
public:  
	UU2BLESystem();  
	virtual void Initialize(FSubsystemCollectionBase&amp; Collection) override;  
	virtual void Deinitialize() override;  
  
	UFUNCTION()  
		void ScanForAdvertisement();  
  
	UFUNCTION()  
		bool IsExistingConnectableRadar();  
  
	UFUNCTION()  
		bool IsExistingConnectablePutt();  
  
	/*  
	* Connect To Radar  
	*/  
	UFUNCTION()  
		void ConnectToServer();  
  
	/*  
	* Connect To Putt  
	*/  
	UFUNCTION()  
		void RequestConnectPuttingSensor();  
	/*  
	* Disconnect From Radar  
	*/  
	UFUNCTION()  
		void DisconnectFromServer();  
	/*  
	* Disconnect From Putt  
	*/  
	UFUNCTION()  
		void DisconnectFromPuttingSensor();  
  
	Sensor::ESensorConnectionState GetSensorConnectionState();  
	Sensor::ESensorConnectionState GetPuttingSensorConnectionState();  
  
	/*  
	*  
	*/  
	UFUNCTION()  
		void SubscribeCharacteristic(EBLEDeviceType DeviceType);  
  
	// FOR Test  
	UFUNCTION()  
		void SendMessageToServer(const FString&amp; InMessageString, EBLEDeviceType DeviceType);  
	//  
  
	UFUNCTION()  
		void SensorReady(EClubType InClubType, bool bInRightHand = true);  
  
private:  
	UPROPERTY() class UBLEConnection* BleConnection = nullptr;  

};
<br>Server가 의미하는 바는 Radar 센서를 의미하고 PuttingSensor는 Putt이다.&nbsp;<br><br>외부에서 BLE 기능을 이용할 때 아래와 같이 U2BLESystem을 이용한다.<br>UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;();
FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ConnectToServer();

<br>BLE를 이용하기 위해서는 스캔 - 연결 - Subscribe Characteristic - Write&nbsp;Characteristic를 순서대로 진행 해야 한다. 이 때&nbsp;'비동기적'으로 코드가 실행 되면&nbsp;안된다.&nbsp;또한 각 함수 call에&nbsp;딜레이가 있어야 한다.&nbsp;(매우 중요)<br>아래와 같이 타이머를 사용해서 동기적으로 코드를 실행 해야 한다. 안그러면 BLE는 명령어가 씹힌다. (자세한 예시는 U2UIWifi_Wave_play.cpp를 참고)<br>void UU2UIWifi_Wave_Play::OnClicked_btn_BLE_test()  
{  
	U2_LOG(BLE, Warning, TEXT("Connect To Server (Radar)"));  
  
	FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ScanForAdvertisement()
  
	// 싱글톤 객체라서 람다 사용 - CreateUObject 안됨  
	FTimerDelegate ConnectTimerDelegate = FTimerDelegate::CreateLambda([]() {  
		UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;();  
		if (GameInstance-&gt;BleSystem-&gt;IsExistingConnectableRadar())  
		{  
			FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ConnectToServer();  
		}  
		});  
  
	SetDelayAndCall(2.0f, ConnectTimerDelegate);  
  
	FTimerDelegate SubscribeTimerDelegate = FTimerDelegate::CreateLambda([]() {  
		UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;();  
  
		if (GameInstance-&gt;BleSystem-&gt;GetSensorConnectionState() == Sensor::ESensorConnectionState::WaitingResult)  
		{  
			FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;SubscribeCharacteristic(EBLEDeviceType::Radar);  
		}  
		});  
  
	SetDelayAndCall(5.0f, SubscribeTimerDelegate);  
}  
  
void UU2UIWifi_Wave_Play::OnClicked_btn_NetworkType()  
{  
	FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;ScanForAdvertisement();  
  
	FTimerDelegate ConnectTimerDelegate = FTimerDelegate::CreateLambda([]() {  
		UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;();  
		if (GameInstance-&gt;BleSystem-&gt;IsExistingConnectablePutt())  
		{  
			FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;RequestConnectPuttingSensor();  
		}  
		});  
  
	SetDelayAndCall(2.0f, ConnectTimerDelegate);  
  
	FTimerDelegate SubscribeTimerDelegate = FTimerDelegate::CreateLambda([]() {  
		UU2GSInstance* GameInstance = FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;();  
  
		if (GameInstance-&gt;BleSystem-&gt;GetPuttingSensorConnectionState() == Sensor::ESensorConnectionState::WaitingResult)  
		{  
			FU2EngineUtil::GetGameInstance&lt;UU2GSInstance&gt;()-&gt;BleSystem-&gt;SubscribeCharacteristic(EBLEDeviceType::Putt);  
		}  
		});  
	SetDelayAndCall(5.0f, SubscribeTimerDelegate);  
}
<br><br>
<br>U2SensorManager.cpp&nbsp;SetClub()
<br>U2GolfGameMode.cpp BindSensor()
<br><br>초기에 FSesnroManager에 GFlex처럼 프로퍼티로 달았는데 라이프 사이클 이슈 때문에 통합하지 못했음 -&gt; 추후 Subsystem으로 리팩토링 하고 공통으로 GFlex와, BLE를 관리하게 해야한다.]]></description><link>ble/5.-ble-적용.html</link><guid isPermaLink="false">BLE/5. BLE 적용.md</guid><pubDate>Sat, 04 May 2024 09:57:00 GMT</pubDate><enclosure url="ble/image/구성.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;ble/image/구성.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>