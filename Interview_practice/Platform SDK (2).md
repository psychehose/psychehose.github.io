#interview


Q. C++ SDK를 iOS/Android에서 사용할 때, 메모리 관리에서 주의해야 할 점은 무엇인가요? 특히 C++에서 할당한 메모리를 JNI나 Objective-C에서 해제할 때 문제가 될 수 있는 상황을 설명해주세요.

1.  힙 관리자의 차이 C++ runtime, JVM, iOS ARC가 각각 다른 메모리 관리자를 사용하기 때문에한쪽에서 할당한 메모리를 다른 쪽에서 해제하면 크래시가 발생합니다.

2. JNI에서는 Global/Local Reference 문제가 있습니다. C++에서 반환한 객체 포인터를 Java에서 오래 보관하려면 NewGlobalRef로 변환해야 하고, 사용 후 반드시 DeleteGlobalRef로 해제해야 합니다.

3. iOS에서는 ARC와의 충돌할 수 있습니다. C++에서 할당한 메모리를 Objective-C 객체로 래핑할 때 소유권이 불분명해질 수 있어요. 이런 경우 메모리를 할당할 때 unique_ptr로 선언해 메모리 소유권을 보장하고 콜백으로 값을 넘겨줄 때는 작은 객체라면 복사, 아닌 경우라면 shared_ptr을 사용합니다.


---

Q. Android JNI 개발에서 멀티스레딩을 다룰 때 주의사항이 있나요? 특히 C++ 스레드에서 Java 메서드를 호출할 때 어떤 문제가 발생할 수 있고, 어떻게 해결하셨나요?

JNIEnv 포인터가 스레드별로 고유하다는 점을 주의해야합니다. 한 스레드에서 받은 JNIEnv를 다른 스레드에서 사용하면 즉시 크래시가 발생합니다.

C++ 스레드에서 Java 호출 시 문제 C++에서 생성한 스레드는 기본적으로 JVM에 연결되어 있지 않습니다. 따라서 Java 메서드를 호출하려고 하면 JNIEnv를 얻을 수 없다'는 에러가 발생합니다.

따라서 Global Reference를 사용해서 Java 객체 참조를 안전하게 공유를 해야합니다. 하지만 멀티스레딩에서는 Global Reference만으로는 부족하고, 각 C++ 스레드에서 JNI 함수를 호출하려면 먼저 AttachCurrentThread로 JVM에 연결해서 JNIEnv를 얻어야 합니다. 그래서 보통 멀티 스레딩 환경이면 Global Reference + AttachCurrentThread 조합으로 사용합니다.

Q. iOS에서 ARC(Automatic Reference Counting)에 대해 설명해주세요. 그리고 ARC가 있음에도 불구하고 메모리 리크가 발생할 수 있는 상황과 이를 해결하는 방법을 설명해주세요.

ARC는 컴파일 타임에 retain/release 코드를 자동으로 삽입해서 reference count를 관리합니다.

arc는 객체를 참조하고 있는 수를 의미하고 객체를 참조하고 있는 수가 0이 되면 그 객체는 메모리에서 해제됩니다. 그래서 컴파일러가 해주니까 실제로 메모리를 할당하고 해제하는 작업을 할 필요가 없어지죠.

그럼에도 불구하고 메모리 리크가 발생할 수 있는 상황은 순환참조입니다. 주로 클로저를 이용해 콜백을 받을 때 발생하는데 클로저에서 현재 인스턴스를 접근하려면 캡쳐를 해야합니다. 이때 이 클로저에서 현재 인스턴스의 객체를 참조한다면, ref counting이 올라갑니다. 이 클로저 객체가 현재 인스턴스의 객체를 참조하게 되므로 순환참조가 발생합니다.

이 경우에 메모리 리크가 발생합니다. 이를 방지하기 위해서 weak 키워드를 넣으면 인스턴스 객체가 해제될 때 클로저 객체가 잡고 있는 걸 놓아주게 됩니다.
