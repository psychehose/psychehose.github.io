Gaame Loop는 게임이 종료될 때까지 무한히 반복되는 루프로

1. 입력 처리
2. 게임 상태 업데이트
3. 화면 렌더링

```cpp
while (game_is_running) {
    process_input();    // 입력 처리
    update_game();      // 게임 로직 업데이트
    render();          // 화면 렌더링
}
```

을 순차적으로 수행합니다.

입력 처리는 사용자의 입력을 수집하고 이벤트 큐에서 입력 이벤트를 처리하는 단계입니다. 그리고 게임 상태를 업데이트 하게 되는데 이 단계에서는 주로 물리 연산, 충돌 검사, AI 로직 실행, 게임 오브젝트들의 상태 변경과 같은 동작들을 수행하게 됩니다. 마지막으로 사용자에게 보여줄 화면을 렌더링 합니다.

게임엔진은 보통 성능을 높이기 위해서 멀티 스레드를 사용합니다. 게임 로직 스레드와 렌더 스레드로 분리가 되어 있으며 두 스레드 간의 동기화 문제를 해결하는 중요합니다.

동기화를 하기 위한 방법으로는 일반적으로 커맨드 버퍼 방식이 사용됩니다.

커맨드 버퍼 방식이란 한 스레드에서 실행할 작업들을 객체로 캡슐화하여 큐에 저장하고, 다른 스레드에서 순차적으로 실행하는 패턴입니다.

```cpp
class RenderCommandBuffer {
    std::queue<RenderCommand> commands;
    std::mutex command_mutex;
public:
    void AddCommand(const RenderCommand& cmd) {
        std::lock_guard<std::mutex> lock(command_mutex);
        commands.push(cmd);
    }
    
    void ExecuteCommands() {
        std::lock_guard<std::mutex> lock(command_mutex);
        while (!commands.empty()) {
            commands.front().Execute();
            commands.pop();
        }
    }
};

void GameThread() {
    while (running) {
        process_input();        // 입력 처리
        update_game_logic();    // 게임 로직
        
        prepare_render_data();  // 렌더링 데이터 준비
        
        // 렌더링 스레드에 명령 전송
        submit_render_commands();
    }
}

void RenderThread() {
    while (running) {
        execute_render_commands();  // 렌더링 실행
        present_frame();
    }
}
```

#### 참고
* Game Loop의 실행 빈도가 FPS임