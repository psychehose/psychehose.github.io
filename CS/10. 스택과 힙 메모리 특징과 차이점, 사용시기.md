
스택과 힙의 가장 큰 차이는 메모리 관리 방식과 생명주기입니다.

스택은 LIFO 구조로 관리되고, 함수 호출 시 자동으로 할당되고 반환 시 자동으로 해제됩니다. 스택 포인터를 조작하는 것만으로 할당/해제가 되니까 매우 빠릅니다. O(1)이죠. 하지만 크기가 제한적이고, 보통 몇 MB 정도만 사용할 수 있습니다. 스코프를 벗어나면 자동으로 소멸되기 때문에 함수 밖으로 포인터를 반환하면 안 됩니다. (new로 반환을 해서 리턴하게 되면 외부에서 수동 delete 해줘야함 안하면 누수,  아니면 스마트 포인터를 이용 이건 힙 할당은 이용하는거임)

```cpp
int* bad() {
  int x = 5;      // 스택에 할당된 지역변수
  return &x;      // &x를 반환 → 대상(x)이 사라진 후 호출자에 전해짐
}

int* good() {
  int* p = new int(5); // 힙에 할당
  return p;             // p(포인터 변수)도, *p(대상)도 함수 뒤에도 유효
}
```

힙은 프로그래머가 명시적으로 할당하고 해제해야 합니다. 크기 제한이 거의 없고, 프로그램 전체에서 접근 가능합니다. 하지만 메모리 관리자가 적절한 블록을 찾아야 하므로 할당/해제가 느립니다. 또한 단편화 문제가 발생할 수 있고, 메모리 누수의 위험이 있습니다.

사용 시기를 판단하는 기준은 이렇습니다. 크기를 컴파일 타임에 알 수 있고 작은 데이터는 스택을 사용합니다. 런타임에 크기가 결정되거나, 큰 데이터, 함수 스코프를 벗어나는 생명주기가 필요하면 힙을 사용합니다.

예를 들어 함수 내에서만 사용하는 작은 배열은 스택에, 사용자 입력에 따라 크기가 달라지는 동적 배열은 힙에 할당합니다. RAII 객체는 스택에 두고 내부적으로 힙을 관리하게 하는 것이 일반적인 패턴입니다.


#### 스택의 기본구조

스택은 높은 주소에서 낮은 주소로 성장하고, 두 개의 핵심 포인터가 관리함
* 스택 포인터: 현재 스택의 맨 위 (가장 최근 데이터)
* 프레임 포인터: 현재 함수의 스택 프레임 시작점


```
높은 주소 (0x1000)
┌─────────────────────┐
│   이전 함수의 데이터    │
├─────────────────────┤ ← 이전 FP
│   매개변수 (param)    │
├─────────────────────┤
│   반환 주소           │
├─────────────────────┤ ← 현재 FP (프레임 포인터)
│   이전 FP 저장        │
├─────────────────────┤
│   지역변수 1          │
├─────────────────────┤
│   지역변수 2          │
├─────────────────────┤ ← 현재 SP (스택 포인터)
│   (사용 가능 공간)     │
└─────────────────────┘
낮은 주소 (0x800)
```

```cpp
void functionA(int param) {
    int local1 = 10;
    int local2 = 20;
    functionB();
}

void functionB() {
    char arr[8];
    int value = 100;
}
```

```
주소     내용
0x1000  │ main의 스택 프레임 │
0x0FFC  │ functionA param   │
0x0FF8  │ A의 반환 주소      │ // functionA 호출
0x0FF4  │ 이전 FP           │ // FP는 이전 프레임포인터를 가리킴 (함수 리턴이 되면 돌아가야함)
0x0FF0  │ A의 local1        │
0x0FEC  │ A의 local2        │
0x0FE8  │ B의 반환 주소      │ // functionB 호출
0x0FE4  │ A의 FP 저장       │ ← 새로운 FP
0x0FE0  │ arr[0-3]          │
0x0FDC  │ arr[4-7]          │
0x0FD8  │ value = 100       │ ← SP
```



함수를 호출하게 되면 반환 받을 주소를 기입하고, 다음 주소에서 FP를 저장한다. 그리고 실행을 하면서 SP를 움직인다. (로컬 변수)

반환 주소는 SP 복원지점과 실행 위치인거다. 어느 반환을 받고 어느 코드로 돌아가서 계속 실행하지?의 기준이다.

FP 저장은 쉽게 세이브 포인트면서 함수 경계다. FP는 연결리스트처럼 되어 있어 이전으로 재귀형태로 돌아갈 수 있다.

즉 
- **반환 주소**: SP 복원과 코드 실행 재개를 위한 정보
- **FP 저장**: 함수 경계 표시와 이전 상태로의 세이브 포인트


#### 힙

1. malloc / new 로 데이터만큼 요청을 한다. 
2. 힙 관리자는 사용 가능한 블록을 검색하고 사용 가능한 블록을 찾는다.
3. 발견시에 블록을 실제 데이터 저장되는 곳과 메타데이터 저장되는 곳으로 분할한다. 
4. 메타데이터를 저장 한다
5. 할당된 메모리의 시작 주소를 반환한다.


할당 알고리즘을 통해 어떤 블록을 선택할지 결정한다.

1. First Fit - 요청된 크기보다 큰 첫 번째 자유 블록 사용
2. Best Fit - 요청된 크기에 가장 가까운 자유 블록 사용

메모리 해제 과정

1. 포인터 검증
2. 메타데이터 접근
3. 상태 변경 (할당 -> 할당 안됨)
4. 인근 블록 병합


```
해제 전:
┌─ 사용중(200) ─┬─ 해제할블록(400) ─┬─ 자유(100) ─┐
   
해제 후:
┌─ 사용중(200) ─┬─────── 자유(500) ──────────────┐
                    ↑ 인접한 자유 블록들을 병합
```

5. 자유 블록 리스트에 추가