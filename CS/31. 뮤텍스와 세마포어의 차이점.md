**뮤텍스와 세마포어는 동기화 목적은 같지만 사용 방식과 의미가 다릅니다.**

**뮤텍스는 상호 배제를 위한 잠금 메커니즘입니다.** 소유권 개념이 있어서, 잠근 스레드만이 해제할 수 있습니다. 이진 상태(잠김/해제)만 가지며, 한 번에 하나의 스레드만 임계 영역에 진입할 수 있습니다. 재진입 가능한 recursive_mutex도 있습니다.

**세마포어는 카운팅 기반의 신호 메커니즘입니다.** 소유권 개념이 없어 어떤 스레드든 신호를 보낼 수 있습니다. 카운터 값만큼의 스레드가 동시에 진입할 수 있어, 리소스 풀 관리에 적합합니다. 이진 세마포어는 뮤텍스와 유사하지만 소유권이 없다는 차이가 있습니다.

**사용 시나리오가 다릅니다.** 뮤텍스는 공유 데이터 보호에 사용합니다. 예를 들어 전역 변수나 공유 객체 접근을 직렬화합니다. 세마포어는 제한된 리소스 관리에 사용합니다. 데이터베이스 연결 풀이나 스레드 풀에서 동시 접근 수를 제한할 때 유용합니다.

**구현 수준의 차이도 있습니다.** 뮤텍스는 보통 유저 레벨에서 빠른 경로를 제공하고, 경합 시에만 커널로 전환됩니다. 세마포어는 일반적으로 시스템 콜을 통해 구현되어 오버헤드가 더 클 수 있습니다.

**실무에서는** 단순 상호 배제는 뮤텍스를, 생산자-소비자 패턴이나 리소스 카운팅은 세마포어를 사용합니다. C++ 표준 라이브러리는 mutex는 제공하지만 세마포어는 C++20부터 counting_semaphore로 제공됩니다.