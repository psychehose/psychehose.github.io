### 체이닝 방식

#### 장점
1. 로드 팩터 제한이 없음 - 이론적으로 무한정 아이템 저장
2. 삭제가 쉬움 (연결리스트에서 제거하면 됨)
3. 클러스터링 발생 X
#### 단점
1. 추가 메모리 오버헤드 (노드마다 포인터 저장)
2. 캐시 성능이 나쁨 (연결리스트를 사용하기 떄문에 캐시지역성 X)
3. 최악의 경우 O(n) 시간복잡도 - 계속 같은 버킷에 해싱되면 연결리스트 순회

### 오픈 어드레싱
#### 장점
1. 체이닝 대비 메모리 효율성
2. 캐시 친화성 (모든 데이터가 연속된 배열에 있어 캐시미스가 적고 포인터 오버헤드 X)
#### 단점
1. 삭제의 복잡성 (Tombstone)
2. 로드팩터 제한 높아지면 성능 급격히 저하
3. 클러스터링


클러스터링이란 연속된 슬롯들이 채워져서 덩어리를 형성하는 현상이다. 클러스터링이 발생하면 계속 프로빙 해야해서 성능이 저하된다.

오픈 어드레싱 방식은 삭제가 복잡하다. 실제 삭제가 발생하더라도 이 슬롯을 아예 비우는 것이 아닌 Tombstone으로 표시한다.

 그 이유는 뭐냐면

```
// 현재 상태
[A][B][C][D][ ][ ][ ][ ]
 0  1  2  3  4  5  6  7

// A, B, C는 모두 인덱스 0에 해싱되었다고 가정
// A → 0, B → 1, C → 2, D → 3 순서로 저장

// 만약 B를 단순히 삭제하면?
[A][ ][C][D][ ][ ][ ][ ]
 0  1  2  3  4  5  6  7
```

```cpp
bool search(char key) {
    size_t index = hash_function(key) % table_size;  // C 검색 시 index = 0
    
    while (table[index].is_occupied) {
        if (table[index].key == key) {
            return true;
        }
        index = (index + 1) % table_size;
    }
    return false;  // 빈 슬롯을 만나면 종료
}

// C를 검색할 때:
// index 0: A ≠ C, 다음으로
// index 1: 빈 슬롯! → 검색 종료 → C를 찾지 못함! (실제로는 index 2에 있음)
```

위의 상황에서 C를 검색할 때  index 2에 접근하지 못하고 index 1에서 검색을 종료해버린다. 그래서 배열을 완전히 비우지 않고 Tombstone 상태로 둠으로써 다음 데이터를 검색할 수 있게 해준다.

```cpp
enum SlotState { EMPTY, OCCUPIED, DELETED };

struct HashSlot {
    char key;
    string value;
    SlotState state;
};

void remove(char key) {
    size_t index = find_index(key);
    if (index != NOT_FOUND) {
        table[index].state = DELETED;  // 완전히 제거하지 않고 표시만
        // key와 value는 그대로 두거나 정리
    }
}

bool search(char key) {
    size_t index = hash_function(key) % table_size;
    
    while (table[index].state != EMPTY) {  // EMPTY일 때만 종료
        if (table[index].state == OCCUPIED && table[index].key == key) {
            return true;
        }
        index = (index + 1) % table_size;
    }
    return false;
}
```

```
// B 삭제 후
[A: OCCUPIED][B: DELETED][C: OCCUPIED][D: OCCUPIED][ : EMPTY]
      0            1           2            3         4

// 이제 C 검색 시:
// index 0: A ≠ C, 다음으로
// index 1: DELETED 상태, 건너뛰고 다음으로  
// index 2: C 발견! → 성공
```



Tombstone을 사용하긴 해야하는데 아래의 단점이 있다.

1. 삭제된 슬롯들이 계속 공간을 차지해서 메모리 낭비
2. 데이터를 가져올 떄 모든 슬롯들을 확인해야함

#### 오픈 어드레싱 성능 저하 완화
클러스터링과, 로드팩터 값에 따른 성능 저하는 로빈후드 해싱이나, 리해싱을 수행해서 성능 저하를 완화할 수 있다.

#### 해시 충돌 해결 선택 기준은?

메모리가 제한적이고 삭제가 적다 -> 오픈 어드레싱
데이터 크기가 가변적이고 삭제가 빈번 -> 체이닝
