
**C++11부터 표준 라이브러리에서 다양한 동기화 도구를 제공합니다.**

**뮤텍스(mutex)는 가장 기본적인 동기화 도구입니다.** 상호 배제를 보장하여 한 번에 하나의 스레드만 임계 영역에 접근할 수 있습니다. `lock_guard`나 `unique_lock`으로 RAII 패턴을 적용하면 데드락을 방지할 수 있습니다. `recursive_mutex`는 같은 스레드가 여러 번 잠글 수 있고, `timed_mutex`는 시간 제한을 설정할 수 있습니다.

**조건 변수(condition_variable)는 특정 조건을 기다리는 동기화입니다.** 생산자-소비자 패턴에서 유용합니다. wait()는 뮤텍스를 해제하고 대기하다가, notify를 받으면 다시 뮤텍스를 획득합니다. spurious wakeup 때문에 항상 while 루프로 조건을 재확인해야 합니다.

**원자적 연산(atomic)은 락 없는 동기화를 제공합니다.** 단순한 변수 접근이나 카운터에 효율적입니다. memory_order를 지정하여 메모리 순서를 제어할 수 있습니다. compare_exchange로 CAS(Compare-And-Swap) 연산을 수행하여 락 프리 자료구조를 구현할 수 있습니다.

**future/promise는 비동기 작업 결과를 전달합니다.** promise가 값을 설정하면 future를 통해 다른 스레드가 받을 수 있습니다. async()는 자동으로 future를 반환하여 비동기 작업을 간단히 처리합니다.

**실무 팁으로는,** 가능한 한 락의 범위를 최소화하고, 여러 락을 획득할 때는 항상 같은 순서로 획득하여 데드락을 방지합니다. 읽기가 많은 경우 shared_mutex(reader-writer lock)를 사용하고, 성능이 중요한 경우 lock-free 자료구조를 고려합니다.
