**데드락은 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한 대기하는 상태입니다.**

**데드락 발생의 네 가지 필요조건이 있습니다.** 상호 배제(자원을 한 번에 하나의 스레드만 사용), 점유 대기(자원을 가진 채 다른 자원 대기), 비선점(강제로 자원을 빼앗을 수 없음), 순환 대기(자원 요청이 순환 구조)입니다. 이 중 하나라도 깨면 데드락을 방지할 수 있습니다.

**가장 실용적인 방지 방법은 락 순서를 정하는 것입니다.** 모든 스레드가 같은 순서로 락을 획득하면 순환 대기가 발생하지 않습니다. 예를 들어 항상 뮤텍스 A를 먼저, B를 나중에 잠그도록 규칙을 정합니다.

**C++에서 제공하는 도구들이 있습니다.** `std::lock()`은 여러 뮤텍스를 데드락 없이 동시에 잠급니다. 내부적으로 try_lock을 사용하여 순서를 조정합니다. `std::scoped_lock`은 C++17에서 추가된 RAII 래퍼로, 여러 뮤텍스를 안전하게 관리합니다.

**타임아웃을 사용하는 방법도 있습니다.** `timed_mutex`로 일정 시간 후 포기하도록 하면 데드락을 감지하고 복구할 수 있습니다. 하지만 이는 데드락을 방지하는 것이 아니라 회피하는 것입니다.

**실무에서 적용하는 패턴은,** 락을 최소한으로 사용하고 락 없는 자료구조를 활용합니다. 트랜잭션 메모리나 액터 모델 같은 높은 수준의 동시성 모델을 고려합니다. 또한 thread sanitizer를 사용하여 데드락 가능성을 자동으로 감지합니다.