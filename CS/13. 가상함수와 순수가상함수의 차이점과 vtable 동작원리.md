
1. 가상함수의 필요성과 다형성
2. 순수가상함수와 추상클래스
3. vtable 매커니즘
4. 성능 고려사항

가상함수는 파생 클래스에서 재정의할 수 있는 함수로, 런타임에 실제 객체 타입에 따라 호출될 함수가 결정됩니다. 반면 순수가상함수는 구현이 없고 파생 클래스에서 반드시 구현해야하는 인터페이스입니다.

**순수가상함수를 포함한 클래스는 추상클래스가 되어** 인스턴스를 생성할 수 없습니다. 이는 인터페이스를 정의하고 파생 클래스가 반드시 특정 기능을 구현하도록 강제하는 설계 도구입니다.

vtable의 동작 원리를 설명드리면, 컴파일러는 가상함수를 가진 각 클래스마다 vtable이라는 함수 포인터 배열을 생성합니다. 객체가 생성되면 해당 객체는 자신의 클래스 vtable을 가리키는 vptr을 갖게된다.


```cpp
class Base {
public:
    virtual void virtualFunc() { /* … */ }
    void nonVirtualFunc() { /* … */ }
};
class Derived : public Base {
public:
    void virtualFunc() override { /* … */ }
};

Base* ptr = new Derived();
ptr->virtualFunc()을 호출한다고 가정
```

![[vtableoperation.png]]





예를 들어, `Base* ptr = new Derived()`에서 `ptr->virtualFunc()`를 호출하면 ptr이 가리키는 객체의 vptr을 통해 Derived 클래스의 vtable에 접근하고 해당 vtable에서 virtualFunc의 인덱스를 찾아 실제 Derived::virtualFunc()를 호출합니다. 이 과정은 두 번의 간접 참조를 거치므로 일반 함수 호출보다 약간의 오버헤드가 있습니다.

그래서 성능 측면에서 고려할 때, 성능이 중요한 작은 함수는 가상함수로 만들지 않는 것이 좋습니다.

