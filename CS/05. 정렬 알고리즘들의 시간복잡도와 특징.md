정렬 알고리즘은 크게 $O(n^2)$ 그룹과 O($n log n$) 그룹으로 나뉩니다.

버블 정렬은 인접한 요소를 비교해서 교환하는 방식으로 시간 복잡도가 $O(n^2)$로 느립니다. 다만 이미 정렬된 경우를 감지하면 $O(n)$에 끝낼 수 있고, 안정 정렬입니다.

* 안정 정렬이란 값이 같은 데이터들의 원래 순서가 정렬 후에도 그대로 유지되는 정렬 방식을 말함
* 순회에서 swap이 한번도 일어나지 않으면 정렬된 상태라고 판단하고 정렬 중지 -> $O(n)$ 

```cpp
void bubbleSort(std::vector<int>& vec) {
  int n = vec.size();

  for (int i = 0; i < n - 1; ++i) {
    bool swapped = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (vec[j] > vec[j + 1]) {
        std::swap(vec[j], vec[j + 1]);
        swapped = true;
      }
    }
    if (!swapped) break;
  }
}
```


선택 정렬은 최솟값을 찾아서 맨 앞으로 보내는 방식입니다. 시간 복잡도는 항상 $O(n^2)$입니다. 그리고
불안정 정렬입니다. 다만 최솟값을 찾아서 swap 하는 방식이라 공간 복잡도는 $O(1)$ 입니다.

```cpp
void selectionSort(std::vector<int>& vec) {
  int n = vec.size();

  for (int i = 0; i < n - 1; ++i) {
    int minIndex = i;

    for (int j = i + 1; j < n; ++j) {
      if (vec[j] < vec[minIndex]) {
        minIndex = j;
      }
    }
    std::swap(vec[i], vec[minIndex]);
  }
}
```


삽입 정렬은 카드를 정리하듯이 적절한 위치에 삽입하는 방식입니다. 거의 정렬된 데이터에서는 O(n)에 가까운 성능을 보여서, 작은 데이터나 부분적으로 정렬된 데이터에 효율적입니다.

퀵 정렬은 피벗을 기준으로 분할 정복하는 방식입니다. 평균 O(n log n)으로 매우 빠르고 캐시 효율이 좋지만, 최악의 경우 O(n²)가 될 수 있습니다. 피벗 선택이 중요하죠.

병합 정렬은 항상 O(n log n)을 보장하고 안정 정렬이지만, O(n)의 추가 메모리가 필요합니다. 외부 정렬이나 링크드리스트 정렬에 적합합니다.

힙 정렬도 항상 O(n log n)이고 제자리 정렬이지만, 캐시 효율이 나빠서 실제로는 퀵 정렬보다 느린 경우가 많습니다.