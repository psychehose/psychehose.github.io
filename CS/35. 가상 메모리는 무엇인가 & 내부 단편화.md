
가상메모리는 실제 물리 메모리(RAM)의 크기보다 더 큰 프로그램을 실행할 수 있도록 하는 메모리 관리 기법입니다. 컴퓨터가 가진 실제 메모리 용량 한계를 극복하고 각 프로세스에 독립적인 메모리 공간을 제공합니다.

가상 메모리는 페이징 기법을 사용해서 동작합니다.

1. 가상 주소 공간 할당: OS는 프로세스에 고유한 가상 주소 공간을 할당함
2. 페이징: 가상 주소 공간과 실제 물리 메모리는 `페이지`와 `프레임`이라는 고정된 크기의 블록을 나눔.
	* 페이지는 가상 메모리를 나누는 단위고, 프레임은 물리메모리를 나누는 단위임. 일반적으로 둘의 크기는 같음

3. 주소 변환: 프로그램이 특정 메모리 주소에 접근할 때 CPU는 가상 주소로 인식함. 따라서 가상 주소를 실제 물리 주소로 변환하는 과정이 필요함. 이 역할은 MMU (Memory Management Unit)가 담당함.



## 동작 방식

구체적으로 두가지 시나리오로 나눌 수 있습니다.

1. 정상적인 주소 변환
2. 페이지 폴트

### 정상적인 주소 변환 (CPU -> MMU -> RAM)

프로그램이 특정 메모리에 접근하면 CPU는 가상 주소를 MMU에 전달합니다. MMU는 내부의 캐시 저장소인 TLB (Translation Lookaside Buffer)를 확인합니다.

* TLB가 Hit인 경우 TLB에 가상 주소 - 물리 주소 쌍이 존재하므로 바로 물리 주소로 RAM에 접근합니다.
* TLB가 Miss인 경우 TLB에 정보가 없다면 페이지 테이블을 확인해야 합니다.

MMU는 RAM에 저장된 페이지 테이블을 참조해서 가상 주소를 물리 주소로 변환합니다. 

1. CPU가 전달한 가상 주소는 페이지 번호와 오프셋으로 구성되어 있는데 MMU는 이 페이지 번호를 인덱스로 사용하여 페이지 테이블에서 해당 프레임 번호를 찾음
2. 페이지 테이블에는 해당 페이지가 물리 메모리(RAM)에 있는 지 표시하는 Valid bit가 있는데 이 비트가 1이여야 함 (0이면 페이지 폴트 발생)

위의 과정을 거쳐서 MMU는 페이지 테이블에서 찾은 프레임 번호와 가상 주소의 오프셋을 결합해서 최종 물리 주소를 만듭니다. 이를 통해 RAM에 접근해 데이터를 읽거나 쓸 수 있습니다.

그리고 마지막으로 TLB를 갱신합니다.

### 페이지 폴트

페이지 테이블을 조회 했는데, 해당 페이지의 Valid Bit가 0인 경우 발생합니다. 즉 RAM에 필요한 페이지가 없는 경우에 발생합니다.

이 경우에 MMU는 CPU에 페이지 폴트 인터럽트를 발생시키라고 요청합니다. 그러면 CPU는 현재 실행하던 프로세스를 중단하고 현재상태를 PCB에 저장합니다. 그리고 운영체제의 페이지 폴트 핸들러 코드를 실행합니다.

OS는 폴트 원인을 분석합니다.
* 단순한 페이지 부재: 페이지가 디스크에 존재하지만 RAM에 로드 되지 않은 정상적인 경우 -> OS는 페이지 스와핑합니다.
* 잘못된 접근: 할당되지 않은 메모리 영역에 접근, 권한 없는 접근 등이라서 OS는 프로세스 강제 종료 (Segmentation Fault)

운영체제는 해당 페이지가 디스크의 스왑 영역 어디에 저장되어 있는지 찾고 RAM의 빈 프레임을 확보해야 합니다.

빈 프레임이 있다면 그걸 사용하고 없다면 페이지 교체 알고리즘 (LRU 같은)를 통해서 확보합니다. (만약 희생된 페이지가 RAM에서 변경된 적이 있다면 디스크의 스왑 영역에 변경된 내용을 기록 해야함. 변경되지 않았다면 생략 가능)

이제 확보된 RAM에 폴트가 발생한 페이지를 디스크로부터 로드하고 Valid bit를 1로 변경합니다. 운영 체제는 제어권을 CPU에게 넘깁니다.

CPU는 중단시켰던 프로세스의 상태를 복원하고 페이지 폴트를 유발했던 원래의 명령어를 다시 실행합니다. 

그러면 정상적인 주소변환을 할 수 있게 됩니다.

## 내부 단편화

가상 메모리 전략에서 내부 단편화 문제가 발생할 수 있습니다. 운영체제는 가상 메모리 시스템을 고정적인 크기를 가지는 페이징 방식을 사용하기 때문입니다. 

페이지의 크기를 4KB라고 가정하겠습니다.

만약 10KB 크기의 프로그램이 실행되면, OS는 페이지 크기가 4KB이므로 이 프로그램에 3개의 페이지를 할당합니다. 운영체제는 비어 있는 물리 메모리 프레임 3개를 찾아서 페이지들을 매핑합니다.

이 예시에서 내부 단편화가 2KB가 생깁니다.