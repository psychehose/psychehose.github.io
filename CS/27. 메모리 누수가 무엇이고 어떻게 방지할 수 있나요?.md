**메모리 누수는 할당된 메모리를 해제하지 않아 프로그램이 접근할 수 없는 메모리가 계속 늘어나는 현상입니다.**

가장 직접적인 원인은 new/malloc으로 할당한 메모리를 delete/free하지 않는 것입니다. 하지만 실무에서는 더 복잡한 상황에서 발생합니다. 예외 발생으로 delete가 실행되지 않거나, 조건부 반환으로 정리 코드를 건너뛰거나, 순환 참조로 shared_ptr이 해제되지 않는 경우가 있습니다.

**방지하는 가장 효과적인 방법은 RAII와 스마트 포인터 사용입니다.** unique_ptr이나 shared_ptr을 사용하면 자동으로 메모리가 관리됩니다. 원시 포인터는 소유권이 아닌 관찰 용도로만 사용해야 합니다.

**코딩 규칙으로는,** 모든 new에 대응하는 delete를 같은 스코프나 클래스에 작성합니다. 가능하면 make_unique, make_shared를 사용하여 new를 직접 호출하지 않습니다.

그리고 컨테이너에 포인터를 저장할 때 특히 주의해야 한다는 것입니다. 컨테이너를 clear()해도 포인터가 가리키는 메모리는 해제되지 않으므로, 스마트 포인터를 저장하거나 명시적으로 각 요소를 delete해야 합니다.

---

### 메모리 누수 정의

메모리 릭은 할당된 메모리에 대한 참조가 손실되어 더 이상 접근할 수 없지만 운영체제에서는 여전히 사용중인 것으로 표시되는 상태. 프로그램에서 동적으로 할당한 메모리를 사용한 후 적절히 해제하지 않아 발생한다.

```cpp
void memoryLeakExample() {
    int* ptr = new int(42);  // 메모리 할당
    // delete ptr;  // 이 줄이 없으면 메모리 릭
    return;  // ptr이 스택에서 사라지지만 힙 메모리는 남아있음
}
```

### 메모리 릭이 발생하는 주요 이유

#### 1. new / delete 불일치

```cpp
// 잘못된 예
int* arr = new int[100];
delete arr;  // delete[] 를 써야 함!

// 올바른 예
int* arr = new int[100];
delete[] arr;
```

#### 2.예외 상항에서의 메모리 누락

```cpp
void riskyFunction() {
    int* data = new int[1000];
    
    // 예외가 발생하면 delete가 실행되지 않음
    if (someCondition()) {
        throw std::runtime_error("Error occurred");
    }
    
    delete[] data;  // 예외 발생 시 실행되지 않음
}
```

#### 3. shared_ptr에서 순환참조

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;  // 순환 참조로 인한 릭
};
```

### 메모리 릭 방지

메모리 누수 타입에 따른 방지 방법은

1. new / delete 불일치 문제를 RAII 패턴으로 방지할 수 있음.
2. 예외 상황에서 메모리 누락 문제는 스마트 포인터 사용으로 방지할 수 있음. 예외 시 소멸자 호출
3. shared_ptr에서 순환참조 문제는 weak_ptr 사용으로 방지할 수 있음.
