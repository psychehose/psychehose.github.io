**메모리 누수는 할당된 메모리를 해제하지 않아 프로그램이 접근할 수 없는 메모리가 계속 늘어나는 현상입니다.**

가장 직접적인 원인은 new/malloc으로 할당한 메모리를 delete/free하지 않는 것입니다. 하지만 실무에서는 더 복잡한 상황에서 발생합니다. 예외 발생으로 delete가 실행되지 않거나, 조건부 반환으로 정리 코드를 건너뛰거나, 순환 참조로 shared_ptr이 해제되지 않는 경우가 있습니다.

**방지하는 가장 효과적인 방법은 RAII와 스마트 포인터 사용입니다.** unique_ptr이나 shared_ptr을 사용하면 자동으로 메모리가 관리됩니다. 원시 포인터는 소유권이 아닌 관찰 용도로만 사용해야 합니다.

**코딩 규칙으로는,** 모든 new에 대응하는 delete를 같은 스코프나 클래스에 작성합니다. 가능하면 make_unique, make_shared를 사용하여 new를 직접 호출하지 않습니다.

그리고 컨테이너에 포인터를 저장할 때 특히 주의해야 한다는 것입니다. 컨테이너를 clear()해도 포인터가 가리키는 메모리는 해제되지 않으므로, 스마트 포인터를 저장하거나 명시적으로 각 요소를 delete해야 합니다.