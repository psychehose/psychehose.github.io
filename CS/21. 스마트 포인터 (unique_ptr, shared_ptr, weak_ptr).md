
1. 각 스마트 포인터의 소유권 모델
2. 내부 구현 원리
3. 사용 시나리오와 주의점
4. 프로젝트 적용 사례

스마트 포인터는 RAII 원칙을 따라 자동 메모리 관리를 제공합니다.

**unique_ptr은 독점 소유권을 표현합니다.** 한 시점에 하나의 unique_ptr만이 객체를 소유할 수 있으며, 소유권은 move로만 이전됩니다. 오버헤드가 거의 없어 원시 포인터와 성능이 동일합니다. 소멸자에서 자동으로 delete를 호출하므로 예외 안전성을 보장합니다.

**shared_ptr은 공유 소유권을 표현합니다.** 여러 포인터가 같은 객체를 공유합니다. 내부에 제어블록을 별도로 할당해서 참조 카운터와 커스텀 삭제자를 저장합니다. 마지막 shared_ptr이 소멸될 때 delete를 호출되고 객체가 삭제됩니다. 따라서 약간의 메모리, 성능 오버헤드가 있습니다. 주로 옵저버 패턴, 콜백 함수에서 주로 사용됩니다.

**weak_ptr은 순환 참조를 방지하는 포인터입니다.** shared_ptr을 관찰하지만 참조 카운터를 증가시키지 않습니다.사용하려면 lock()으로 shared_ptr을 얻어야 하며, 이 과정에서 객체가 이미 삭제되었는지 확인합니다.트리 구조에서 자식 노드에서 부모 노드를 가리킬 때 weak_ptr을 사용하여 순환 참조를 방지합니다.

스마트 포인터를 사용할 때 make_shared, make_unique 함수를 이용해서 할당하는 것이 좋습니다. new와 스마트 포인터 생성 사이에서 예외가 생겨도 메모리 누수를 방지합니다. make_shared 같은 경우는 객체와 제어블록을 한 번에 할당해서 메모리와 성능의 이점을 누릴 수 있습니다.

