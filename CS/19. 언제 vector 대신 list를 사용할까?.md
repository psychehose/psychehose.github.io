
**실무에서 list를 선택하는 구체적인 상황을 말씀드리겠습니다.**

첫째, **중간** 삽입과 삭제가 매우 빈번하고 위치를 이미 알고 있을 때입니다. 예를 들어 텍스트 에디터에서 커서 위치에 문자를 삽입/삭제하는 경우, 커서를 iterator로 유지하면 O(1) 연산이 가능합니다. vector라면 매번 뒤쪽 요소들을 이동시켜야 해서 O(n)이 걸립니다.

둘째, 요소의 크기가 매우 크고 복사 비용이 높을 때입니다. vector는 재할당 시 모든 요소를 복사하거나 이동시켜야 하는데, 요소가 수 KB 이상이면 이 비용이 상당합니다. list는 재할당이 없고 각 요소가 독립적으로 할당됩니다.

셋째, 반복자 무효화를 피해야 할 때입니다. vector는 재할당이나 중간 삽입/삭제 시 반복자가 무효화되지만, list는 해당 요소를 직접 삭제하지 않는 한 반복자가 유효합니다. 멀티스레드 환경에서 한 스레드가 순회하는 동안 다른 스레드가 삽입할 때 유용합니다.

**하지만 주의할 점은,** 캐시 미스로 인한 성능 저하가 알고리즘 복잡도의 이점을 상쇄할 수 있다는 것입니다. 실제로 요소가 수천 개 이하라면 vector의 중간 삽입이 list보다 빠를 수 있습니다. 따라서 반드시 프로파일링을 통해 확인해야 합니다


#### 추가 설명

멀티 스레드 환경에서 반복자 무효화 회피

스레드 A가 `std::list<int>`를 순회하며 각 요소를 처리하는 동시에 다른 스레드 B가 새 요소를 삽입하거나 삭제를 한다고 가정한다.

std::vector인 경우에는 중간에 삽입, 삭제, 용량 재할당을 하게 되면 iterator가 무효화 되어 버린다.
그러면 A 쓰레드의 iterator가 유효하지 않아서 크래쉬가 발생한다.

list는 반복자를 무효화 하지 않기 때문에 크래쉬가 발생하지 않는다.