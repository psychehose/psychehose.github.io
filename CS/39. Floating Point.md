## Floating point의 메모리 구조

float는 4byte = 32bit다. 32개의 비트는 아래처럼 구성되어 있다.
* 1 비트: 부호비트
* 8 비트: 지수부
* 23 비트: 가수부 (fraction)

실제 값은
$$ (-1)^{\text{부호}} \times 1.\text{가수부} \times 2^{(\text{지수부} - 127)} $$
로 계산할 수 있다.

실제 값을 구할 때는 지수부를 저장할 때 127 편향값을 더하는 과정이 있어서 -127를 빼는 것이다.

먼저 부동소수점을 이진법으로 나타내는 방법을 알아야 한다. 간단하게 정수 부분과 소수 부분을 나누어 계산한 뒤 합친다. 십진수를 이진수로 나타내는 방법은 같다. 

1. 정수부는 몫이 0이 될 때까지 2로 나누면서 나머지를 역순으로
2. 소수부는 소수부가 0이 나올 때가지 2를 곱하면서 정수부를 순서대로

0.5를 이진수로 변환
1. 0.5 * 2 = 1.0 
2. 소수부가 0이 되었고  정수부를 순서대로 써준다. 따라서 `.1`

2 = $10_{(2)}$ , 0.5 = $0.1_{(2)}$  2.5 = 10.1$_{(2)}$

2.5

1. 2.5를 이진법으로 나타내면 10.1
2. 정규화하면 1.01 * 2^1 : 지수부는 1이지만 편향값 127을 더해서 128을 얻음

32bit 표현
* 1비트: 부호비트 0 (양수)
* 8비트: 지수부 128의 이진수 (10000000)
* 23비트: 가수부 - 01 000000000000000000000 ( 01 + 빈자리 0 21개)
* 결과: 0 10000000 01000000000000000000000

```cpp
0.25 + 0.25 == 0.5 true
0.1 + 0.2 == 0.3 false
```

01.과 0.3을 이진수로 변환을 하면 무한소수가 나온다. 그래서 이 값을 정확하게 저장하지 않고 근삿값으로 저장한다. 그래서 아래는 false다.

### floating point를 int로 캐스팅할 때 발생할 수 있는 문제점

* 소수점 이하 손실
* float이 int의  범위를 초과할 수 있음 (clang 17 기준으로 int max로 초기화 됨)

```cpp
#include <iostream>
#include <limits>
int main() {

  float float_a = std::numeric_limits<float>::max();
  int int_a = 0;

  std::cout << float_a << std::endl; // 3.40282e+38
  std::cout << int_a << std::endl; // 0

  int_a = float_a; // 2147483647
  std::cout << int_a << std::endl;

  return 0;
}
```


### 값을 비교 및 사칙연산을 할 때 부작용을 줄일 수 있는 방법

아래 코드는 애매하다. c의 값에 따라 true false가 변하니 프로그램을 예측 할 수가 없다. 이런 부작용을 줄이기 위해서는 오차 (엡실론)를 사용해야 한다.

```cpp
#include <iostream>
#include <limits>

int main() {
  float b = 0.2345;
  float c = 0.2345001;

  if (b == c) {
    std::cout << "b == c" << std::endl; // c가 0.23450001인 경우
  } else {
    std::cout << "b != c" << std::endl; // c가 0.2345001인 경우
  }
  
  return 0;
}
```

엡실론은 개발자가 정의 해도 되고 `limits`에 정의된 엡실론을 사용해도 된다. limits에 정의된 엡실론은 시스템에 맞는 적절한 엡실론 값이다. 일반적으로는 32비트 float의 경우 약 1.19209e-7 값을 가진다고 한다.

```cpp
#include <iostream>
#include <limits>

const float epsilon = 0.0000001;

int main() {
  float b = 0.2345;
  float c = 0.234501;

  if (std::fabs(b - c) < epsilon) {
    std::cout << "b == c" << std::endl;
  } else {
    std::cout << "b != c" << std::endl;
  }

  if (std::fabs(b - c) < std::numeric_limits<float>::epsilon()) {
    std::cout << "b == c" << std::endl;
  } else {
    std::cout << "b != c" << std::endl;
  }

  return 0;
}
```


### 부동소수점 오차

C++에서 부동 소수점을 사용할 때 플랫폼마다 오차가 발생할 수 있다. 대부분의 최신 플랫폼들은 IEEE 754라는 표준을 따르기 때문에 부동 소수점 자료형 (`float`, `double`)의 기본적인 표현 방식은 동일하다. 즉, 같은 값을 저장했을 때 메모리에 기록되는 비트 패턴은 같다.

차이가 발생하는 지점은 주로 컴파일러와 최적화 옵션, 각 OS에 내장된 수학 라이브러리의 구현방법이다. 

이러한 상황에서 오차를 줄이기 위한 방법은 아래와 같다.

1. 같은 컴파일러와 버전을 사용
2. 고정 소수점(Fixed-Point) 라이브러리 사용
3. 비교시 허용 오차 (엡실론) 허용

