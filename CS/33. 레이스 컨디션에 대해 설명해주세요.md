
레이스 컨디션은 여러 스레드가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 현상입니다.

가장 단순한 예는 카운터 증가입니다. `count++`는 실제로 읽기, 증가, 쓰기의 세 단계로 이루어집니다. 두 스레드가 동시에 실행하면, 둘 다 같은 값을 읽고 증가시켜 하나의 증가분이 손실될 수 있습니다. 예를 들어 count가 10일 때 두 스레드가 동시에 증가시키면 12가 아닌 11이 될 수 있죠.

**레이스 컨디션이 위험한 이유는 재현이 어렵다는 점입니다.** 스레드 스케줄링은 운영체제가 결정하므로, 같은 코드도 실행할 때마다 다른 결과가 나올 수 있습니다. 개발 환경에서는 문제없다가 운영 환경에서 갑자기 발생하기도 합니다. 이런 비결정적 특성 때문에 디버깅이 매우 어렵습니다.

**실제 프로젝트에서 자주 발생하는 패턴들이 있습니다.** Check-Then-Act 패턴이 대표적인데, 조건을 확인하고 행동하는 사이에 다른 스레드가 상태를 변경할 수 있습니다. 싱글톤 패턴의 이중 체크 잠금도 메모리 재정렬 때문에 문제가 될 수 있죠. 컨테이너를 순회하면서 수정하는 것도 반복자 무효화로 크래시를 일으킬 수 있습니다.

**해결 방법은 적절한 동기화입니다.** 가장 기본적으로는 뮤텍스를 사용하여 임계 영역을 보호합니다. 단순한 변수는 atomic 타입을 사용하면 락 없이도 안전합니다. 더 나아가 불변 객체나 thread-local storage를 활용하면 공유 자체를 피할 수 있습니다.

**디버깅 팁으로는,** ThreadSanitizer 같은 도구를 사용하면 레이스 컨디션을 자동으로 감지할 수 있습니다.