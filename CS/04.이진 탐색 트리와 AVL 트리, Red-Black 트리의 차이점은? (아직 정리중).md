

## 이진 탐색 트리

* 모든 노드에 대해서 왼쪽은 작고, 오른쪽은 큼
* 중위 순회시 정렬된 순서로 방문
* 시간복잡도: Best / Average: O(log n), 최악의 경우: O(n)
* 최악의 경우는 편향트리가 될 때임. 순차적으로 1,2,3,4,5... 넣으면 연결리스트 형태가 됨

## AVL 트리 

* Adelson - Velsky and Landis Tree
* 높이 군형(height -balanced) 이진 탐색 트리
* 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1
* 균형 팩터 (Balance factor) = 왼쪽 서브트리 높이 - 오른쪽 서브트리 높이
* 균형 팩터는 반드시 {-1, 0, 1} 중 하나여야 함
* 높이를 O(log n)으로 보장하여 모든 연산을 O(log n)으로 유지
* 삽입 / 삭제 시 균형이 깨지면 회전을 통해 복구
* 회전 연산
	* 4가지 회전 케이스 (LL, RR, LR, RL)
* 시간복잡도: O (log n)
* 어디에서 사용 돼?
* STL에서?


## Red Black 트리

* 색상 기반 균형 이진 탐색 트리
* 모든 노드는 RED 또는 BLACK
* 루트는 항상 BLACK
* 모든 리프는 BLACK
* RED 노드의 자식은 반드시 BLACK (연속된 RED 노드 금지)
* 임의의 노드에서 리프까지의 모든 경로는 동일한 수의 BLACK 노드를 포함
* 시간복잡도: O (log n) 보장
* 어디에서 사용돼?


### 특징 비교

**BST:**

- **장점:** 구현이 간단, 평균적으로 좋은 성능
- **단점:** 편향 트리 시 성능 저하
- **사용 사례:** 데이터가 무작위로 들어오는 경우

**AVL 트리:**

- **장점:** 엄격한 균형으로 **탐색 성능 최적화**
- **단점:** 빈번한 회전으로 **삽입/삭제 오버헤드 큼**
- **사용 사례:** 탐색이 많고 삽입/삭제가 적은 경우

**Red-Black 트리:**

- **장점:** **삽입/삭제 시 적은 회전** (최대 3회)
- **단점:** AVL보다 약간 느린 탐색
- **사용 사례:** 삽입/삭제가 빈번한 경우 (STL map, set)

---

**1단계: 기본 개념 정의** "먼저 이진 탐색 트리는 각 노드의 왼쪽 서브트리는 해당 노드보다 작은 값, 오른쪽 서브트리는 큰 값을 가지는 자료구조입니다. 하지만 일반 BST는 편향 트리가 될 경우 O(n)의 시간 복잡도를 가지는 문제가 있습니다."

**2단계: 균형 트리의 필요성** "이 문제를 해결하기 위해 등장한 것이 균형 트리들입니다. AVL 트리와 Red-Black 트리 모두 트리의 높이를 O(log n)으로 보장하여 모든 연산을 O(log n)으로 유지합니다."

**3단계: AVL 트리의 특징** "AVL 트리는 높이 균형을 사용합니다. 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하여야 하며, 이를 위해 4가지 회전 연산을 사용합니다. 매우 엄격한 균형을 유지하여 탐색 성능이 우수하지만, 삽입/삭제 시 많은 회전이 필요할 수 있습니다."

**4단계: Red-Black 트리의 특징**  
"Red-Black 트리는 색상 기반 균형을 사용합니다. 5가지 규칙을 통해 가장 긴 경로가 가장 짧은 경로의 2배를 넘지 않도록 보장합니다. AVL보다 느슨한 균형이지만 삽입/삭제 시 회전 횟수가 적어 실용적입니다."

**5단계: 선택 기준** "따라서 탐색이 많은 환경에서는 AVL 트리를, 삽입/삭제가 빈번한 환경에서는 Red-Black 트리를 선택합니다. 실제로 C++ STL의 map과 set은 Red-Black 트리로 구현되어 있습니다."


---

이 네 가지 트리는 모두 탐색을 효율적으로 하기 위한 자료구조인데, 균형을 유지하는 방법이 다릅니다.

기본 이진 탐색 트리는 왼쪽 서브트리는 루트보다 작고, 오른쪽은 크다는 규칙만 있습니다. 균형 보장이 없어서 최악의 경우 한쪽으로 치우친 선형 구조가 되어 O(n)이 됩니다. 실제로 정렬된 데이터를 순서대로 삽입하면 이런 일이 발생하죠.

AVL 트리는 이 문제를 해결하기 위해 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이를 최대 1로 제한합니다. 삽입이나 삭제 후 균형이 깨지면 회전 연산으로 복구합니다. 높이가 약 1.44 log n으로 보장되어 검색이 매우 빠르지만, 삽입 삭제 시 회전이 많이 발생할 수 있습니다.

Red-Black 트리는 좀 더 느슨한 균형을 유지합니다. 노드에 색깔을 부여하고, 루트는 검정, 빨강 노드의 자식은 검정, 모든 경로의 검정 노드 수는 같다는 규칙을 따릅니다. AVL보다 균형이 덜 엄격해서 높이가 최대 2 log n이지만, 삽입 삭제 시 회전이 적습니다. 그래서 STL의 map이 Red-Black 트리를 사용하죠.

B+ Tree는 완전히 다른 접근입니다. 다진 트리로 한 노드에 여러 키를 저장하고, 모든 데이터는 리프 노드에만 둡니다. 디스크 I/O를 최소화하기 위해 설계되어서 데이터베이스 인덱스에 사용됩니다. 한 번의 디스크 읽기로 수백 개의 키를 확인할 수 있고, 리프 노드가 연결되어 있어 범위 검색이 효율적입니다.