**이동 의미론은 C++11의 가장 중요한 개선사항 중 하나입니다.**

필요성은 불필요한 복사를 피하는 데 있습니다. 예를 들어 함수가 큰 vector를 반환할 때, 이전에는 전체 복사가 필요했지만, 이동 생성자를 사용하면 내부 포인터만 이동시킬 수 있습니다. 이는 O(n)에서 O(1)로 성능이 개선됩니다.

```cpp
#include <vector>
#include <iostream>

std::vector<int> make_big_vector() {
    // 100만 개 정수를 담는 큰 벡터 생성
    std::vector<int> v(1'000'000, 42);
    std::cout << "make_big_vector: vector constructed\n";
    return v;  // C++11 이후: move 생성자, C++17 이후: (N)RVO로 완전 생략
}

int main() {
    // 벡터를 복사 없이(또는 이동만으로) 받아옴 → O(1)
    std::vector<int> data = make_big_vector();
    std::cout << "main: vector size = " << data.size() << "\n";
    return 0;
}
```

**이동 생성자는 임시 객체로부터 리소스를 훔쳐옵니다.** 원본 객체의 포인터를 가져오고, 원본은 유효하지만 불확정 상태로 만듭니다. 일반적으로 nullptr로 설정하여 소멸자에서 안전하게 처리되도록 합니다.

```cpp
// 개념적 구현
MyClass(MyClass&& other) noexcept 
    : data(other.data) {
    other.data = nullptr;  // 원본을 안전한 상태로
}
```

**이동 대입 연산자는 자기 대입 검사와 기존 리소스 정리가 필요합니다.** swap을 사용한 구현이 일반적이며, 강한 예외 보장을 제공할 수 있습니다.

```
NonTrivial& operator=(NonTrivial&& other) noexcept {
        if (this != &other) {
            std::swap(data, other.data);
            std::swap(size, other.size);
            std::cout << "move assign called, size=" << size << "\n";
        }
        return *this;
    }
```

**주의할 점은** noexcept 지정입니다. 이동 연산이 예외를 던지지 않음을 보장하면, 컨테이너가 재할당 시 이동을 사용할 수 있습니다. noexcept가 없으면 예외안전성을 위해 복사를 사용합니다.


#### 참고) 이동은 '스택 영역에 할당된 데이터와 관련이 없고, 힙 영역에 할당된 데이터와 관련된 것'


