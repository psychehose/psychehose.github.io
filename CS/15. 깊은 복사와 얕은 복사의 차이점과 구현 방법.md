
1. 메모리 관점에서의 차이
2. 문제 발생 시나리오
3. 올바른 구현 방법
4. Rule of Three / Five

**깊은 복사와 얕은 복사의 차이는 포인터가 가리키는 메모리를 어떻게 처리하느냐에 있습니다.**

얕은 복사는 포인터 값 자체만 복사하여 두 객체가 같은 메모리를 가리키게 됩니다. 반면 깊은 복사는 포인터가 가리키는 메모리의 내용까지 새로 할당하여 복사합니다.

**얕은 복사의 문제는 이중 해제와 댕글링 포인터입니다.** 기본 복사 생성자는 포인터 타입은 얕은 복사를 수행하므로, 동적 메모리를 가진 객체를 복사하면 두 객체가 같은 메모리를 가리킵니다. 한 객체가 소멸되면서 메모리를 해제하면, 다른 객체는 해제된 메모리를 가리키는 댕글링 포인터가 됩니다.

**깊은 복사를 구현하려면 복사 생성자와 복사 대입 연산자를 명시적으로 정의해야 합니다.** 복사 생성자에서는 새 메모리를 할당하고 내용을 복사합니다. 복사 대입 연산자에서는 자기 대입 검사, 기존 메모리 해제, 새 메모리 할당 및 복사의 순서를 지켜야 합니다.


#### 참고) Rule of 3, Rule of 5, Rule of 0

Rule of 3
* 소멸자, 복사 생성자, 복사 대입 연산자 중 하나를 직접 정의하면, 나머지 둘도 반드시 정의하라.
* 필요한 이유
	* 클래스가 동적 메모리·파일·소켓 등 자원을 직접 관리할 때, 기본 제공 복사 연산자는 얕은 복사(shallow copy)만 수행하므로
		* 복사된 두 객체가 같은 자원을 공유 → 한 객체가 소멸될 때 자원을 해제하면 다른 객체는 댕글링 포인터를 가짐
		- 이중 해제(double free) 버그 발생

Rule of 5
* Rule of Three에 이동 연산자 둘을 추가


Rule of 0
* 가능하면 사용자 정의 특별 멤버 함수를 전혀 만들지 말라
*  스마트 포인터, STL, string 같은 RAII 타입을 사용해 자원을 관리

Rule of 3, 5는 컴파일러 자동 생성에 의존 하지 말고 의도를 드러내라라는 의미임.

#### 참고) 생성자 자동 생성 규칙

개발자가 생성자를 정의하지 않으면 컴파일러가 자동으로 생성해줌

1. 기본 생성자
2. 복사 생성자
3. 복사 대입 생성자
4. 이동 연산자
5. 이동 대입 연산자


| 함수 종류                                                 | 자동 생성 여부 조건                                                  |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| **기본 생성자**`ClassName()`                               | 사용자 선언 생성자가 **하나도 없을 때**                                     |
| **복사 생성자**`ClassName(const ClassName&)`               | **직접 선언된 복사 생성자가 없으면 언제나**(다른 멤버 선언과 무관하게)                   |
| **복사 대입 연산자**`ClassName& operator=(const ClassName&)` | **직접 선언된 복사 대입 연산자가 없으면 언제나**                                |
| **이동 생성자**`ClassName(ClassName&&)`                    | C++11 이상, **복사 생성자·복사 대입·이동 생성자·이동 대입·소멸자 중 하나도 선언되지 않았을 때** |
| **이동 대입 연산자**`ClassName& operator=(ClassName&&)`      | C++11 이상, **위 이동 생성자 조건과 동일**                                |

