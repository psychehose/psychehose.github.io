
1. 내부 구현 자료구조
2. 정렬 여부와 순회 순서
3. 시간복잡도 비교

**이 네 컨테이너는 내부 구현 방식에 따라 두 그룹으로 나뉩니다.**

map과 set은 Red-Black Tree로 구현되어 있습니다. 이는 자가 균형 이진 탐색 트리로, 모든 연산이 O(log n)을 보장합니다. 중요한 특징은 요소들이 항상 정렬된 상태를 유지한다는 것입니다. map은 키로, set은 값 자체로 정렬됩니다.

unordered_map과 unordered_set은 해시 테이블로 구현됩니다. 평균적으로 O(1)의 접근 시간을 제공하지만, 최악의 경우 해시 충돌로 인해 O(n)이 될 수 있습니다. 요소들의 순서는 보장되지 않으며, 해시 함수와 버킷 크기에 따라 달라집니다.

**메모리 사용량과 캐시 효율성 측면에서,** 트리 기반 컨테이너는 각 노드마다 좌우 포인터와 색상 정보를 저장해야 하므로 메모리 오버헤드가 큽니다. 해시 기반 컨테이너는 로드 팩터를 유지하기 위해 실제 요소 수보다 큰 버킷 배열을 할당하므로, 역시 메모리를 더 사용할 수 있습니다.

**선택 기준을 말씀드리면,** 정렬된 순서가 필요하거나 범위 기반 검색을 해야 한다면 map/set을 사용합니다. 예를 들어 구간 검색이나 lower_bound, upper_bound 연산이 필요한 경우입니다. 단순히 빠른 검색, 삽입, 삭제만 필요하다면 unordered 버전이 더 효율적입니다.

사용자 정의 타입을 키로 사용할 때 map,set은 Red Black Tree이므로 `operator<` 를 정의 해야하고 unordered_map, unordered_set은 해시 테이블 기반이기 때문에 `operator==`를 정의 해야한다.



