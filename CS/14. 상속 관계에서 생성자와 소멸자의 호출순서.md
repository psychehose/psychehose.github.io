
1. 상속 관계에서의 순서
2. 멤버 변수와의 관계
3. 가상 소멸자의 중요성


상속 관계에서 생성자는 기반 클래스로부터 파생 클래스 순으로 호출됩니다. 소멸자는 반대로 파생 클래스부터 기반 클래스 순으로 호출됩니다.

멤버 변수의 초기화 순서는 클래스 선언 순서를 따릅니다. 예를 들면


```cpp

class Base { 
 Base() {};
 ~Base() {};
}

class Member { 
	Member() {};
	~Member() {};
}

class Derived: Base { 

 Member _member;
 Derived() { }
 ~Derived() { };
 
}
```

생성 순서는 Base -> Member -> Derived 
소멸 순서는 Derived -> Member -> Base

입니다.

**가상 소멸자가 없으면 심각한 문제가 발생합니다.** Base 포인터로 Derived 객체를 삭제할 때, 가상 소멸자가 없으면 Derived 소멸자가 호출되지 않아 리소스 누수가 발생합니다. 따라서 다형성을 사용하는 기반 클래스는 반드시 가상 소멸자를 가져야 합니다.

상속관계에서 실무를 할 때 실수하기 좋은 지점은 생성자에서 가상함수를 호출하면 파생 클래스가 아닌 현재 클래스의 함수가 호출된다는 것입니다. 생성 중에는 객체가 아직 완전한 파생 클래스 타입이 아니기 때문입니다.

```cpp
#include <iostream>

class Base {
 public:
  Base() {
    std::cout << "Base constructor\n";
    virtualFunc();
  }

  virtual ~Base() {
    std::cout << "Base destructor\n";
    virtualFunc();
  }

  virtual void virtualFunc() {
    std::cout << "Base::virtualFunc()\n";
  }
};

class Derived : public Base {
 public:
  Derived() {
    std::cout << "Derived constructor\n";
  }

  ~Derived() override {
    std::cout << "Derived destructor\n";
  }

  void virtualFunc() override {
    std::cout << "Derived::virtualFunc()\n";
  }
};

int main() {
  Base* ptr = new Derived();

  ptr->virtualFunc();
  return 0;
}
```

```
Base constructor
Base::virtualFunc()
Derived constructor
Derived::virtualFunc()
```
