
**lvalue와 rvalue는 표현식의 카테고리를 나타내는 개념입니다.**

간단히 말하면, lvalue는 메모리 위치를 가지고 있어 주소를 취할 수 있는 표현식이고, rvalue는 임시 값으로 주소를 취할 수 없는 표현식입니다. 변수는 lvalue, 리터럴이나 임시 객체는 rvalue입니다.

**C++11에서 rvalue 참조가 도입되면서 이 구분이 더 중요해졌습니다.** lvalue 참조는 `&`로, rvalue 참조는 `&&`로 표현합니다. rvalue 참조는 임시 객체를 바인딩할 수 있어, 불필요한 복사를 피하고 이동 의미론을 구현할 수 있습니다.

예를 들어, `string s = "hello"` 에서 s는 lvalue, "hello"는 rvalue입니다. `string&& r = string("temp")`에서 rvalue 참조 r은 임시 string 객체를 바인딩합니다.

**실무에서 중요한 점은 완벽한 전달(perfect forwarding)입니다.** 템플릿에서 `T&&`는 유니버설 참조(forwarding reference)로, lvalue가 들어오면 lvalue 참조로, rvalue가 들어오면 rvalue 참조로 추론됩니다. `std::forward`를 사용해 원래 값 카테고리를 유지하며 전달할 수 있습니다.

**std::move의 역할을 정확히 이해해야 합니다.** move는 실제로 이동하지 않고, lvalue를 rvalue로 캐스팅만 합니다. 이를 통해 이동 생성자나 이동 대입 연산자가 호출되도록 합니다.

#### 참고) 포워딩 참조

포워딩 참조 (유니버셜 참조)의 핵심은 '템플릿에서 T&&가 lvalue, rvalue'를 모두 원래 카테고리를 보존해 전달할 수 있다는 것이다.

일반 함수에서 rvalue의 참조는 오직 ravlue만 바인딩할 수 있다.

```
void f(int&&); // f(3) 가능, f(x) 불가능
```

그런데 템플릿에서는 lvalue와 rvalue를 모두 바인딩할 수 있다. 이때 T&&를 포워딩 참조 또는 유니버셜 참조라고 한다.

```cpp
template<typename T>
void f(T&&); // f(3) 가능, f(x) 가능
```

이게 왜 가능할까?

rvalue 인자를 넘길 때 -> f(3)을 가정하면

```
f(3);
T를 int로 추론을 하고 매개변수 타입은 int&&로 추론함
```

```
int x = 0;
f(x);

T를 int&로 추론하고 타입은 int& &&로 추론함.
참조 결합 법칙에 따라 int&로 축소?
```


왜 완벽한 전달이 중요할까?

템플릿 관련 코드 std::make_shared, emplace_back 등은 내부에서 생성자나 다른 함수로 인자를 중계하는 경우가 많다. 이때 
* lvalue를 전달하면 복사 생성자를 호출하고, 
* rvalue를 전달하면 이동 생성자를 호출해야 한다.

그래서 원래의 카테고리를 보존해야하는데 유니버셜 참조와 std::forward가 그 역할을 해주기 때문

물론 &, && 를 둘 다 구현해서 lvalue와 rvalue를 각각 처리할 수 있는데 이렇게 한다면 코드가 중복 되고 가변 인자 조합 폭발 (매개변수가 2개라면 ll ,lr, rl, rr 4개 경우를 처리해야함)



#### 참고) 참조결합
C++ 표준은 참조의 참조를 허용하지 않기 때문에, 두 개의 참조 기호가 만나면 다음과 같은 방식으로 **하나의 참조**로 접는다.

|   조합    | 결과   |
| :-----: | :--- |
|  `& &`  | `&`  |
| `& &&`  | `&`  |
| `&& &`  | `&`  |
| `&& &&` | `&&` |
