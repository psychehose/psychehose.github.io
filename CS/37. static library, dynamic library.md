
### Static Library

컴파일 시점에 실행 파일에 직접 포함되는 라이브러리

특징
- 파일 확장자: `.lib` (Windows), `.a` (Linux/Unix)
- 링크 시점에 라이브러리 코드가 실행 파일에 복사됨
- 실행 파일이 독립적으로 동작 가능
- 라이브러리 의존성이 없어 배포가 간단함

장점:
- 실행 시 라이브러리 파일이 별도로 필요하지 않음
- 실행 속도가 빠름 (함수 호출 오버헤드 없음)

단점:
- 실행 파일 크기가 커짐
- 메모리 사용량 증가 (여러 프로그램이 같은 라이브러리를 사용할 때)
- 라이브러리 업데이트 시 전체 프로그램을 다시 컴파일해야 함

주로 성능이 중요한 앱이나 라이브러리 변경이 거의 없는 경우에 static lib를 선택한다. 실행 파일에 코드가 복사 되어 들어갔기 때문에 라이브러리 코드를 변경하지 않는 한 컴파일 속도가 dynamic lib보다 빠르다.


동작방식:
1. 컴파일: 함수 호출 위치에 임시 주소 생성
2. 링킹: 라이브러리의 함수 코드가 실행 파일에 직접 복사됨
3. 주소해결: 모든 함수 주소가 절대주소로 확정

```assembly
; 어셈블리 수준에서의 함수 호출
mov eax, 5        ; 첫 번째 인자
mov ebx, 3        ; 두 번째 인자
call 0x401020     ; 직접 주소로 점프 (add 함수)
```

컴파일 (링킹 포함)시에 함수 주소가 결정되고, 함수 주소가 실행 파일의 Text Section에 절대값으로 저장된다. 그래서 CPU는 오버헤드 없이 바로 함수를 호출할 수 있다.

### Dynamic Library

실행 시점에 필요할 때 로드되는 라이브러리

특징:
- 파일 확장자: `.dll` (Windows), `.so` (Linux), `.dylib` (macOS)
- 런타임에 라이브러리가 메모리에 로드됨
- 여러 프로그램이 하나의 라이브러리 인스턴스를 공유
- 실행파일에는 PLT 테이블과, GOT 테이블을 복사함

장점:
- 실행 파일 크기가 작음
- 메모리 효율성 (여러 프로그램 간 라이브러리 공유)
- 라이브러리 업데이트가 용이함 (실행 파일 재컴파일 불필요)

단점:
- 실행 시 라이브러리 파일이 필요함
- 초기 로딩 시간이 소요됨
- 배포 시 의존성 관리 필요

여러 어플리케이션이 공통적으로 사용하는 라이브러리인 경우나 라이브러리 업데이트가 빈번한 경우는 dynamic lib를 사용하는 것이 좋다. 여러 프로그램간에 라이브러리를 공유해서 메모리 효율성이 좋고 라이브러리 업데이트 시에 실행파일 재컴파일을 하지 않아도 되기 때문이다.


동작방식:
1. 컴파일: 함수 호출을 PLT 호출 변환 (주소 X)
2. 링킹: 실제 함수 주소 대신 PLT 엔트리 주소 연결
3. 첫번째 실행 시: PLT 테이블로 점프 (참조) -> GOT 테이블로 점프 -> dynamic linker가 실제 함수와 주소 연결-> GOT 테이블 업데이트 -> 함수 호출
4. n번째 실행 시: PLT 테이블 -> GOT 테이블 -> 함수 호출

실행 시점에 주소해결, 간접 함수 호출 (PLT/GOT 테이블 참조)로 인한 약간의 성능 오버헤드가 존재한다.


#### PLT / GOT와 PIC의 구분

PLT/GOT는 "누구의 것인가"가 기준이고, PIC는 '어디에 로드되어도 되는가'가 기준이다.

* PLT/GOT: 모든 외부 심볼 (다른 모듈의 심볼) 접근
- PIC: 다이나믹 라이브러리 내부의 위치 독립성, 어떤 주소에 로드되어도 동작하도록