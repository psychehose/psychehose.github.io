### TL;DR

결론적으로 C++17 이상의 컴파일러에서는 push_back을 기본적으로 사용하고 성능이 극도로 중요하고 객체의 이동 비용이 매우 비싸 이동조차 피하고 싶을 때 사용하면 된다.

---

C++에서 emplace_back()이 push_back()보다 권장되는 이유는 불필요한 임시 객체의 생성을 줄여 성능을 향상시키기 때문이다.

push_back은 이미 생성된 객체를 인자로 받아서 객체의 복사본 또는 이동본을 컨테이너에 추가한다. 이 과정에서 임시 객체가 생성되고 소멸되는 과정이 포함된다.

```cpp
std::vector<MyObject> vec;
vec.push_back(MyObject(10, 20)); 
```

1. 임시 MyObject 생성 
2. 이동 생성자로 벡터에 추가
3. 임시 객체 소멸

반면에 emplace_back은 객체를 직접 받는 대신에 객체를 생성하는 데 필요한 생성자의 인자들을 직접 받는다. 그런 다음에 컨테이너 내부의 메모리 공간에 해당 인자들로 객체를 바로 생성한다. 
이를 `in-place construction`라고 한다.

```cpp
std::vector<MyObject> vec;
vec.emplace_back(10,20); 
```

1. 인자 전달
2. 벡터의 메모리 공간에서 MyObject 생성

따라서 emplace_back()을 사용하면 임시 객체 생성 및 복사/이동 과정을 생략 할 수 있다.

emplace_back()을 사용해야 하는 경우는 아래와 같다.

1. 생성 비용이 비싼 객체를 컨테이너에 추가 해야하는 경우
2. 복사나 이동이 불가능한 객체를 컨테이너에 추가 해야하는 경우


## C++17 이후

과거에는 emplace_back이 좋다는 것이 정설처럼 받아들여졌지만, 일반적으로 C++17 이상인 환경에서는 push_back()을 권장한다.

C++17에 도입된 Guaranteed Copy의 도입으로 push_back()이 최적화가 되었기 때문이다.

```cpp
std::vector<MyObject> vec;
vec.push_back(MyObject(10, 20)); 
```

C++17 이상의 최신 컴파일러에서는 MyObject(10, 20)와 같은 순수 임시값(prvalue)를 push_back에 넘길 때 임시 객체를 만들지 않고 처음부터 벡터 내부에 직접 객체를 생성하도록 최적화한다.

따라서 최신 컴파일러는 emplace_back()과 push_back()은 동일한 기계어 코드를 생성할 가능성이 높다.

추가로 emplace_back()은 큰 문제점을 가지고 있다. 바로 어떤 생성자가 호출되었는지 명확하지 않다는 점이다.

```cpp
std::vector<std::vector<int>> vec;
vec.push_back(2000000);
```

이 코드는 오류를 발생시킨다. 왜냐하면 2000000을 `vector<int>`로 변환하지 못하기 때문이다.

```cpp
std::vector<std::vector<int>> vec;
vec.emplace_back(2000000);
```

이 코드는 오류를 발생시키지 않는다. 왜냐하면 길이가 2000000인 vector를 컨테이너에 넣기 때문이다.

정리하자면 C++17 이상의 컴파일러 환경에서 대부분의 경우에 emplace_back()와 push_back()의 성능 차이는 거의 없다. 그리고 emplace_back()은 어떤 생성자가 호출 되었는지 모호해서 혼란을 줄 수 있다.

그래서 C++17 이상의 컴파일러에서는 push_back을 기본적으로 사용하는 것이 권장된다. 그러면 emplace_back() 같은 경우는 언제 사용 되는가?

복사도 이동도 불가능한(Non-copyable/Non-movable) 객체를 다룰 때다. 예를 들면 std::mutex가 있다. 
mutex는 복사/이동 생성자가 모두 delete 되어 있어 복사/이동이 불가능한 객체다. 
그래서 emplace_back만을 사용할 수 있다.

```cpp
#include <vector>
#include <mutex>

std::vector<std::mutex> locks;

locks.push_back(std::mutex());      // 컴파일 에러: 이동 생성자가 delete 됨
std::mutex m;
locks.push_back(std::move(m)); // 컴파일 에러: 이동 생성자가 delete 됨

locks.emplace_back(); // 가능: 벡터 내부에 직접 mutex를 생성
```