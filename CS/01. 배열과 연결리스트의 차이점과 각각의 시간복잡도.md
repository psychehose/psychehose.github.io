
배열과 연결리스트는 둘 다 선형 자료구조지만, 메모리 저장 방식에 근본적인 차이가 있습니다.

배열은 연속된 메모리 공간에 동일한 타입의 데이터를 순서대로 저장하는 구조이고 연결리스트는 노드들이 포인터로 연결되어 있어 메모리 상에서 불연속적으로 저장되는 구조입니다.

```cpp
// 배열의 메모리 구조
int arr[5] = {10, 20, 30, 40, 50};
// 메모리: [10][20][30][40][50] (연속된 주소: 1000, 1004, 1008, 1012, 1016)

// 연결리스트의 메모리 구조  
struct Node {
    int data;
    Node* next;
};
// 메모리: 노드들이 힙의 임의 위치에 산재, 포인터로 연결
```


배열은 첫 번째 원소의 주소만 알면 인덱스를 통해 모든 원소에 직접 접근 가능하지만, 연결리스트는 헤드 노드부터 순차적으로 탐색해야 합니다.


### 시간 복잡도

| **연산** | **배열** | **연결리스트** | 이유                             |
| ------ | ------ | --------- | ------------------------------ |
| 접근     | O(1)   | O(n)      | 순차 탐색                          |
| 검색     | O(n)   | O(n)      | 선형구조                           |
| 삽입     | O(n)   | * O(1)    | 배열: 뒤 원소들 이동 필요, 연결리스트: 포인터 변경 |
| 삭제     | O(n)   | * O(1)    | 배열: 뒤 원소들 이동 필요, 연결리스트: 포인터 변경 |

`*`는 연결리스트는 삽입/삭제할 위치의 노드를 이미 알고 있을 때 

### 순차적 접근과 캐시 효율성

배열은 연속된 메모리에 저장되어 있어서, 한 원소에 접근할 때 주변 원소들도 함께 캐시로 로드됩니다. 따라서 순차 접근 시 캐시 히트율이 높아 성능이 우수합니다. 반면 연결리스트는 노드들이 메모리에 산재해 있어서, 다음 노드에 접근할 때마다 캐시 미스가 발생할 가능성이 높습니다.

### 메모리 할당 방식에서의 차이점 (메모리 외부 단편화)

메모리 할당에서도 차이가 있습니다.
* 배열은 실제 데이터만 저장하기 때문에 메모리 효율적이고
* 연결리스트는 데이터와 포인터를 저장하기 때문에 추가 메모리 오버헤드가 있습니다.

또한  연결리스트는 노드를 개별적으로 할당/해제하므로 메모리에 작은 빈 공간들이 산발적으로 생깁니다. 이는 외부 단편화를 야기해 메모리 효율성을 떨어뜨립니다. 배열은 큰 블록을 한 번에 할당하므로 이런 문제가 없습니다.
### STL에서

배열 기반: std::vector, std::array
연결리스트 기반: std::list


---
