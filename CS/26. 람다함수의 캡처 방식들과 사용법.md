
람다는 익명 함수 객체를 생성하는 간결한 방법입니다.

**캡처 방식은 크게 값 캡처와 참조 캡처로 나뉩니다.** `[=]`는 모든 변수를 값으로, `[&]`는 참조로 캡처합니다. 개별 변수는 `[x, &y]`처럼 선택적으로 캡처할 수 있습니다.

값 캡처는 람다 생성 시점의 값을 복사합니다. 원본이 변경되어도 람다 내부 값은 변하지 않으며, 람다가 원본보다 오래 살아도 안전합니다. 단, 기본적으로 const이므로 수정하려면 mutable 키워드가 필요합니다.

참조 캡처는 원본 변수를 직접 참조합니다. 원본 수정이 가능하지만, 원본이 소멸한 후 람다를 사용하면 댕글링 참조가 됩니다. 특히 비동기 작업이나 콜백에서 주의해야 합니다.

```cpp
#include <iostream>
#include <functional>

std::function<void()> makeCallback() {
    int x = 42;                  // 지역 변수
    return [&]() {               // x를 참조 캡처
        std::cout << x << "\n"; 
    };
} // 여기서 x가 소멸

int main() {
    auto cb = makeCallback();   // cb 안에는 x의 참조가 저장되어 있다
    cb();                       // 댕글링 참조를 사용 → UB
    return 0;
}

```

**C++14부터 초기화 캡처가 가능합니다.** `[ptr = make_unique<T>()]`처럼 캡처 시 새 변수를 만들 수 있어, 이동 캡처를 구현할 수 있습니다.

```cpp
#include <iostream>
#include <memory>
#include <functional>

int main() {
    auto ptr = std::make_unique<int>(100);

    // 이동 캡처: ptr은 람다 내부로 이동(move)되고, 외부 ptr은 빈 상태(nullptr)이 됨
    auto lambda = [p = std::move(ptr)]() {
        std::cout << *p << "\n";
    };

    // ptr이 nullptr이므로 더 이상 접근 불가
    // std::cout << *ptr; // 오류

    lambda();  // 안전하게 100 출력
    return 0;
}

```

자주 사용하는 패턴은 , STL 알고리즘과 함께 사용하는 것입니다. `std::sort`의 비교 함수, `std::find_if`의 조건 함수 등을 람다로 작성하면 코드가 간결해집니다.

멀티스레드 환경에서는 값 캡처를 선호합니다. 특히 `this` 캡처는 위험할 수 있으므로, C++17의 `[*this]`로 객체 전체를 값으로 캡처하는 것이 안전합니다.

흔한 함정은, 루프 안에서 람다를 생성할 때 참조 캡처한 루프 변수가 모두 마지막 값을 가리키는 문제입니다. 이런 경우 값 캡처나 초기화 캡처를 사용해야 합니다.

```cpp
#include <iostream>
#include <vector>
#include <functional>

int main() {
    std::vector<std::function<void()>> v;

    for (int i = 0; i < 3; ++i) {
        // [&i]로 참조 캡처 → 모든 람다가 동일한 i(=3)를 가리킴
        v.push_back([&]() { std::cout << i << " "; });
    }

    for (auto& f : v) f();  // 예상: 0 1 2 
                            // 실제: 3 3 3 
    std::cout << "\n";
    return 0;
}

```




#### 심화: 람다랑 std::function의 차이점?