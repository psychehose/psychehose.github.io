
1. 내부 메모리 구조
2. 각 연산의 시간복잡도
3. 메모리 재할당 전략
4. 선택 기준

**세 컨테이너의 가장 중요한 차이는 메모리 레이아웃입니다.**

vector는 연속된 메모리 블록을 사용합니다. 이는 동적 배열로, 모든 요소가 메모리상에 연속적으로 배치되어 있어 캐시 효율성이 뛰어납니다. 랜덤 액세스가 O(1)로 가능한 이유도 단순한 포인터 연산으로 주소를 계산할 수 있기 때문입니다.

list는 이중 연결 리스트로 구현됩니다. 각 노드가 데이터와 앞뒤 포인터를 가지고 있어, 메모리상에 분산되어 있습니다. 따라서 특정 위치 접근은 O(n)이지만, 위치를 알고 있다면 삽입과 삭제가 O(1)입니다.

deque는 청크 단위로 관리되는 이중 종단 큐입니다. 여러 개의 고정 크기 블록을 포인터 배열로 관리하여, 양 끝에서의 삽입/삭제가 O(1)이면서도 랜덤 액세스도 O(1)로 가능합니다.

메모리 재할당 측면에서 보면, vector는 용량이 부족하면 전체를 재할당하고 복사합니다. 보통 2배씩 늘립니다. deque는 새 청크만 추가하므로 기존 요소를 이동시킬 필요가 없고, 포인터는 유효하게 유지됩니다. list는 재할당 개념이 없고 각 노드를 개별 할당합니다.

실무에서 선택 기준은 이렇습니다. 대부분의 경우 vector를 기본으로 사용합니다. 캐시 효율성이 좋고 메모리 오버헤드가 적기 때문입니다. 중간 삽입/삭제가 빈번하고 요소 크기가 크면 list를 고려합니다. 양 끝 삽입/삭제가 많으면서 랜덤 액세스도 필요하면 deque를 선택합니다.


#### 참고

얼핏 보기에는 deque가 vector의 상위 호환 같아서 deque를 쓰는 게 나은 거 같지만 deque는 vector처럼 완전 연속 메모리가 아니라 캐시 지역성 관점에서 vector 만큼 효율이 나오지 않음.

vector는 랜덤 엑세스를 할 때 base_ptr + offset으로 접근 하는 반면 deque는 '어떤 청크에 있는 지' -> offset 계산으로 접근을 하기 때문에 참조와 분기를 수행해서 오버헤드가 있다.

그리고 deque는 내부적으로 청크 관리를 위해서 map table이라는 구조를 사용해 메모리 오버헤드가 있다.

즉 
- vector: 진정한 연속 메모리 → 최상의 캐시 지역성 → 가장 빠른 순차·임의 접근, 메모리 오버헤드 최소
- deque: 세그먼트된 연속 메모리 → 캐시 미스율 ↑, 연산 상수 계수 증가, 메모리 오버헤드 ↑, 대신 양끝 삽입·삭제가 아주 안정적으로 O(1)

