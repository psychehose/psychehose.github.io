### 다중 상속은 언제 사용해야 할까?


예를 들어서 여러분이 차량(Vehicle) 에 관련한 클래스를 생성한다고 해봅시다. 차량의 종류로는 땅에서 다니는 차, 물에서 다니는 차, 하늘에서 다니는 차, 우주에서 다니는 차들이 있다고 해봅시다. (차 라고 하기 보다는 운송 수단이 좀 더 적절한 표현이겠네요..)

또한, 이 차량들은 각기 다른 동력원들을 사용하는데, 휘발유를 사용할 수 도 있고, 풍력으로 갈 수 도 있고 원자력으로 갈 수도 있고, 페달을 밟아서 갈 수 도 있습니다.

이러한 차량들을 클래스로 나타내기 위해서, 다중 상속을 활용할 수 있지만 그 전에, 아래와 같은 질문들에 대한 대답을 생각해봅시다.

- `LandVehicle` 을 가리키는 `Vehicle&` 레퍼런스를 필요로 할까? 다시 말해, `Vehicle` 레퍼런스가 실제로는 `LandVehicle` 을 참조하고 있다면, `Vehicle` 의 멤버 함수를 호출하였을 때, LandVehicle 의 멤버 함수가 오버라이드 되서 호출되기를 바라나요?
    
- `GasPoweredVehicle` 의 경우도 마찬가지 입니다. 만일 `Vehicle` 레퍼런스가 실제로는 `GasPoweredVehicle` 을 참조하고 있을 때, `Vehicle` 레퍼런스의 멤버함수를 호출한다면, `GasPoweredVehicle` 의 멤버 함수가 오버라이드 되서 호출되기를 원하나요?
    

만일 두 개의 질문에 대한 대답이 모두 예 라면 다중 상속을 사용하는 것이 좋을 것입니다. 하지만 그 전에, 몇 가지 고려할 점이 더 있습니다. 만약에 이 차량이 작동하는 환경이 𝑁N 개가 있고 (땅, 물, 하늘, 우주 등등), 동력원의 종류가 𝑀M 개가 있다고 해봅시다.

이를 위해서, 크게 3 가지 방법으로 이러한 클래스를 디자인 할 수 있습니다. 바로 브리지 패턴 (bridge pattern), 중첩된 일반화 방식 (nested generalization), 다중 상속 입니다. 각각의 방식에는 모두 장단점이 있습니다.

- 브리지 패턴의 경우 차량을 나타내는 한 가지 카테고리를 아예 멤버 포인터로 만들어버립니다. 예를 들어서 `Vehicle` 클래스의 파생 클래스로 `LandVehicle`, `SpaceVehicle` 클래스들이 있고, `Vehicle` 클래스의 멤버 변수로 어떤 엔진을 사용하는지 가리키는 `Engine*` 멤버 변수가 있습니다. 이 `Engine` 은 `GasPowered`, `NuclearPowered` 와 같은 `Engine` 의 파생 클래스들의 객체들을 가리키게 됩니다. 그리고 런타임 시에 사용자가 `Engine` 을 적절히 설정해주면 됩니다. 이 경우 동력원 이나 환경을 하나 추가하더라도 클래스를 1 개만 더 만들면 됩니다. 즉, 총 𝑁+𝑀N+M 개의 클래스만 생성하면 된다는 뜻입니다. 
  
  하지만 오버라이딩 가지수가 𝑁+𝑀N+M 개 뿐이므로 최대 𝑁+𝑀N+M 개 알고리즘 밖에 사용할 수 없습니다. 만일 여러분이 𝑁×𝑀N×M 개의 모든 상황에 대한 섬세한 제어가 필요하다면 브리지 패턴을 사용하지 않는 것이 좋습니다. 또한, 컴파일 타임 타입 체크를 적절히 활용할 수 없다는 문제가 있습니다. 예를 들어서 `Engine` 이 페달이고 작동 환경이 우주라면, 애초에 해당 객체를 생성할 수 없어야 하지만 이를 컴파일 타임에서 강제할 방법이 없고 런타임에서나 확인할 수 있게 됩니다. 뿐만 아니라, 우주에서 작동하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 있지만 (`SpaceVehicle` 클래스), 작동 환경에 관계 없이 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 는 없습니다.


- 중첩된 일반화 방식을 사용하게 된다면, 한 가지 계층을 먼저 골라서 파생 클래스들을 생성합니다. 예를 들어서 `Vehicle` 클래스의 파생 클래스들로 `LandVehicle`, `WaterVehicle`, 등등이 있겠지요. 그 후에, 각각의 클래스들의 대해 다른 계층에 해당하는 파생 클래스들을 더 생성합니다. 예컨대 `LandVehicle` 의 경우 동력원으로 휘발유를 사용한다면 `GasPoweredLandVehicle`, 원자력을 사용한다면 `NuclearPoweredLandVehicle` 클래스를 생성할 수 있겠지요.
  
  따라서 최대 𝑁×𝑀N×M 가지의 파생 클래스들을 생성할 수 있게 됩니다. 따라서 브릿지 패턴에 비해서 좀 더 섬세한 제어를 할 수 있게 됩니다. 왜냐하면 오버라이딩 가지수가 𝑁+𝑀N+M 이 아닌 𝑁×𝑀N×M 이 되기 때문이지요. 하지만 동력원을 하나 더 추가하게 된다면 최대 𝑁N 개의 파생 클래스를 더 만들어야 합니다. 뿐만 아니라 앞서 브릿지 패턴에서 나왔던 문제 - 휘발유를 사용하는 모든 차량을 가리킬 수 있는 기반 클래스를 만들 수 없다가 여전히 있습니다. 따라서 만약에 휘발유를 사용하는 차량들에서 공통적으로 사용되는 코드가 있다면 매 번 새로 작성해줘야만 합니다.


- 다중 상속을 이용하게 된다면, 브리지 패턴 처럼 각 카테고리에 해당하는 파생 클래스들을 만들게 되지만, 그 대신 `Engine*` 멤버 변수를 없애고 동력원과 환경에 해당하는 클래스를 상속받는 파생 클래스들을 최대 𝑁×𝑀N×M 개 만들게 됩니다. 예를 들어서 휘발유를 사용하며 지상에서 다니는 차량을 나타내는 `GasPoweredLandVehicle` 클래스의 경우 `GasPoweredEngine` 과 `LandVehicle` 두 개의 클래스를 상속받겠지요.
  
  따라서 이 방식을 통해서 브리지 패턴에서 불가능 하였던 섬세한 제어를 수행할 수 있을 뿐더러, 말도 안되는 조합을 (예컨대 `PedalPoweredSpaceVehicle`) 컴파일 타입에서 확인할 수 있습니다 (애초에 정의 자체를 안하면 되니까요!). 또한 이전에 두 방식에서 발생하였던 휘발유를 사용하는 모든 차량을 가리킬 수 없다 문제를 해결할 수 있습니다. 왜냐하면 이제 `GasPoweredEngine` 을 통해서 휘발유를 사용하는 모든 차량을 가리킬 수 있기 때문이지요.

### Reference

1. https://modoocode.com/135
