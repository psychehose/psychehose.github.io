
PIC는 Position Independent Code의 준말로 실행파일이 메모리의 어느 위치에 상관 없이 올바르게 실행될 수 있도록 컴파일된 코드다.


리눅스에서 C++을 컴파일 했을 때 아래와 유사한 에러가 발생했다.

```
relocation R_X86_64_PC32 against symbol ... can not be used when making a shared object
```

`CMAKE_POSITION_INDEPENDENT_CODE ON` 를 이용해서 해결했다. 왜 이게 해결법일까?

#### PIC를 넣지 않으면 문제가 되는 이유

공유 라이브러리가 프로그램에 로드될 때 운영체제는 이 라이브러리를 메모리의 어느 위치에 로드할 지 실행 시점에 결정한다. 그래서 메모리 위치는 랜덤이다. 그리고 현대적인 운영체제는 보안 강화를 위해 ASLR(Address Space Layout Randomization)이라는 기술을 사용한다. 이 기술은 프로그램과 라이브러리의 메모리 로드 위치를 의도적으로 무작위화 한다.


PIC 옵션 켜지 않으면 위치 종속적 코드(Position Dependent Code)가 되어버려서 아래 유사하게 동작할 것이다.  만약 아래 코드가 메모리의 다른 위치 로드하게 되면 크래쉬가 발생할 것이다.

```
// 위치 종속적 코드의 예시 (가상의 어셈블리와 유사한 형태)
function_a:
    // 이 함수가 메모리 주소 0x10000에 있다고 가정
    ...
    CALL 0x10500  // function_b의 절대 주소를 하드코딩
    ...

function_b:
    // 이 함수는 항상 메모리 주소 0x10500에 있어야 함
    ...
```


PIC 옵션을 켜면

```
// 위치 독립적 코드의 예시
function_a:
    // 이 함수가 어디에 위치하든 상관없음
    ...
    CALL PC+500  // 현재 프로그램 카운터(PC)로부터의 상대적 오프셋
    ...

function_b:
    // function_a로부터 항상 500바이트 떨어진 위치에 있음
    ...
```

함수 호출을 상대적인 거리 (offset)으로 하기 때문에 코드가 메모리 위치에 상관 없이 제대로 동작할 수 있다.

즉 PIC 옵션은 메모리 매핑의 불확실성 속에서 코드가 올바르게 동작할 수 있게 된다. 운영체제가 라이브러리를 메모리의 어디에 배치하든 상관없이 코드는 자신의 위치와 다른 코드 조각들의 상대적 위치 관계를 이용하여 올바르게 실행된다.

Linux에서는 공유 라이브러리 (so)를 빌드할 때 명시적으로 PIC 설정이 필요하다. 
Mac에서는 기본적으로 공유 라이브러리(dylib)를 빌드할 때 -fPIC 옵션이 기본 적용된다.

크로스플랫폼 타겟으로 하는 CMake 프로젝트에서는 Root CMakeLists.txt에서 PIC 설정을 하는 것이 좋다.






