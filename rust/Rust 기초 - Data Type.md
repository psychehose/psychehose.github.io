####   boolean 타입

true와 false를 다루는 값입니다.

```
fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation
}
```

#### 문자 타입

 char는 string과 다르게 ‘ ‘ 를 사용합니다. 그리고 러스트에서는 Unicode 스칼라를 표현하는 값입니다. Unicode는 ASCII 보다 많은 표현이 가능합니다. 예를 들면 이모티콘, 한글을 표현할 수 있습니다.

```
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
```

### 컴파운드 타입

컴파운드 타입은 다른 타입의 다양한 값들을 하나의 타입으로 묶을 수 있습니다. Rust는 기본적으로 튜플과 배열이 있습니다.

#### 튜플

 튜플은 일반적으로 다양한 타입의 숫자를 집합시켜서 컴파운드 타입으로 만듭니다. 괄호 안에 콤마로 구분되는 값들의 목록을 작성하면 됩니다. 각 값의 타입이 동일한 필요가 없습니다. 저는 보통 좌표를 표현할 때 사용하는 것 같아요.

```
fn main() {
    let tup = (500, 6.4, 1);
		let five_hundred = tup.1
    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

위의 코드에서 let (x, y, z) = tup 처럼 값을 분리해서 할당할 수 있습니다. 이를 구조 해체 (destructurize)라고 합니다. 다른 언어들도 많이 가지고 있는 특징입니다. (Swift, JavaScript 등등)

또는 let five_hundred = tup.1처럼 tup에서 마침표(.)를 이용해서 튜플의 요소에 직접 접근할 수 있습니다.

#### 배열

튜플과 다르게 배열의 모든 요소는 같은 타입이여야 합니다.

다른 언어랑 구별되는 특징이 있습니다. Rust에서 배열은 고정된 길이를 가진다는 것입니다. 한번 선언되면 크기는 변할 수 없습니다. c처럼 동적 할당하는 것이 아니라, 아예 길이가 정해져야만 합니다.

```
fn main() {
    let a = [1, 2, 3, 4, 5];
		let index = 3
		// let index = 10;

    let element = a[index];
    println!("The value of element is: {}", element);
}
```

배열의 끝을 넘어선 요소에 접근하려고 하면 컴파일시에 에러를 발생시키진 않지만, 런타임 때 에러가 발생합니다. 이때 런타임에러가 발생하면서 프로그램이 종료될 때 패닉(panic) 한다고 합니다. 그렇기 때문에 배열은 heap 보다 stack에 할당될 때 즉, 고정된 길이를 보장해야 할 때 사용됩니다. 만약 길이가 가변적이라면 표준 라이브러리에서 제공하는 Vector 타입을 사용해야 한다고 합니다.

#### 정리

1. 스칼라 - 하나의 값으로 표현되는 타입  
    * 정수형  
      - u:  양수  
      - i: 음수, 양수  
      - isize, usize:  프로그램 동작하는 환경에 따라 64bit, 32bit  
      - 기본 타입: i32  
      
    * 부동소수점 - 기본타입 f64  
      
    * boolean  
      
    * 문자 - 유니코드, 작은 따옴표로 표현  
      
    
2. 컴파운드  
    * 튜플 - 집합, 구조 해체  
      
    * 배열 - 고정된 길이