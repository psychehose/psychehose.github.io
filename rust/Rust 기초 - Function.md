러스트에서 함수 선언은 fn 키워드를 이용합니다.

```
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```

 위처럼 같은 파일 내에서, 함수의 위치는 중요하지 않습니다. 역시 다른 언어와 마찬가지로 매개변수를 갖는 형식으로 상수를 전달 인자로 제공합니다. 이때 매개변수의 타입을 꼭 명시해줘야 합니다.

#### 함수 본문

 다른 함수와 다르게 함수 본문은 **구문**과 **표현식**으로 구성될 수 있어요. 구문은 어떤 명령들의 나열로 값을 반환하지 않는 어떤 동작을 수행을 합니다.

표현식은 결과 값을 산출해 냅니다. **표현식은 구문의 부분**일 수 있습니다. 함수를 호출하는 것은 표현식, 매크로를 호출하는 것도 표현식, 새로운 범위를 생성하는 데 사용하는 { } 도 표현식입니다. **쉽게 생각하면 값을 반환하면 ;을 안붙여야**합니다. 뭔가 좀 헷갈립니다. 예를 보고 한번 뜯어볼게요.

```
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

		// 표현식
		// { 
		//   let x = 3
		//   x+1
		//	}
        

    println!("The value of y is: {}", y);
		let y = five();
}

fn five() -> i32 {
    5
}
```

'let x = 5;' 이 부분이 **표현식은 구문의 부분이 될 수 있다**의 예입니다.  전체적으로 봤을 때 let x = 3은 어떠한 값을 리턴하지 않기 때문에 구문입니다. 그러나, '3'인 부분은 어떠한 값을 반환하기 때문에 표현식입니다. 그래서 전체적으로 봤을 때 ;이 붙어 있어야 합니다. 이제 같은 맥락에서 주석처리한 {  } 블록이 왜 표현식인지, 그리고 블록이 끝난 후에 세미콜론을 붙는지 이해할 수 있을 것 같아요.

반환값 설정은 five()와 같이 매개변수 오른쪽에 ‘ → i32 ‘ 처럼 작성하면 됩니다. '**→(반환타입)**'

five() 함수를 보면 조금 특징적인 것이 있습니다. 값을 반환할 때, return 키워드가 없습니다. return을 사용해서 함수로부터 값을 일찍 반환 할 수 있지만 대부분의 함수들은 암묵적으로 마지막 값을 반환합니다. 사실 Swift도 return을 생략할 수 있어요. 근데 가독성 때문에 잘 안 하는 것 같은데, 러스트에서는 return을 생략하나 봐요. 다음으로 함수의 반환 값에 ; 세미콜론이 붙지 않습니다. 위에서 언급한 것처럼 5라는 값을 반환하기 때문에 표현식이기 때문이에요. 따라서 ;이 없어야 합니다. 만약 반환값에 ;을 붙이면 아래와 같은 에러를 출력합니다.

> error[E0308]: mismatched types

함수 선언에서 i32 값을 반환한다고 했는데, 구문은 값을 반환하지 않기 때문에 ()라는 비어 있는 튜플을 반환하기 때문에 mismatched 에러가 발생하게 됩니다.

#### Ref.

[https://rinthel.github.io/rust-lang-book-ko/ch03-03-how-functions-work.html](https://rinthel.github.io/rust-lang-book-ko/ch03-03-how-functions-work.html)